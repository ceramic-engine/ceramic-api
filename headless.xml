<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Any.hx">
		<from><icast><d/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<meta><m n=":forward.variance"/></meta>
		<impl><class path="_Any.Any_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Any.hx" private="1" module="Any" final="1">
	<__promote params="T" get="inline" set="null" line="37" static="1">
		<f a="this">
			<d/>
			<c path="__promote.T"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":to"/>
		</meta>
	</__promote>
	<toString get="inline" set="null" line="40" static="1">
		<f a="this">
			<d/>
			<c path="String"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</toString>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="_Any.Any_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Any.hx" private="1" module="Any" final="1">
		<__promote params="T" get="inline" set="null" line="37" static="1">
			<f a="this">
				<d/>
				<c path="__promote.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":to"/>
			</meta>
		</__promote>
		<toString get="inline" set="null" line="40" static="1">
			<f a="this">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</toString>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Array" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<iterator public="1" get="inline" set="null" line="88">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/Date.hx" extern="1">
		<now public="1" get="inline" set="null" line="46" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" get="inline" set="null" line="50" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" get="inline" set="null" line="54" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the formatted string `s`. The following formats are
		accepted by the function:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats expressed a date in local time. The third is a time
		relative to the UTC epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of `this` date.
		On cpp and neko, this function only has a second resolution, so the
		result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
		To obtain the current timestamp with better precision on cpp and neko,
		see the `Sys.time` API.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in the local timezone.</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in the local timezone.</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in the local timezone.
		Note that the month number is zero-based.</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in the local timezone.</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in the local timezone.</haxe_doc>
		</getDay>
		<getUTCHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in UTC.</haxe_doc>
		</getUTCHours>
		<getUTCMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCMinutes>
		<getUTCSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCSeconds>
		<getUTCFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in UTC.</haxe_doc>
		</getUTCFullYear>
		<getUTCMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in UTC.
		Note that the month number is zero-based.</haxe_doc>
		</getUTCMonth>
		<getUTCDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in UTC.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in UTC.</haxe_doc>
		</getUTCDay>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the time zone difference of `this` Date in the current locale
		to UTC, in minutes.

		Assuming the function is executed on a machine in a UTC+2 timezone,
		`Date.now().getTimezoneOffset()` will return `-120`.</haxe_doc>
		</getTimezoneOffset>
		<toString public="1" get="inline" set="null" line="42">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="js.lib.RegExp" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/RegExp.hx" extern="1">
		<global public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates whether or not the "g" flag is used with the regular expression.</haxe_doc>
		</global>
		<ignoreCase public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates whether or not the "i" flag is used with the regular expression.</haxe_doc>
		</ignoreCase>
		<multiline public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates whether or not the "m" flag is used with the regular expression.</haxe_doc>
		</multiline>
		<source public="1" set="null">
			<c path="String"/>
			<haxe_doc>The source text of the regexp object, it doesn't contain the two forward slashes on both sides and any flags.</haxe_doc>
		</source>
		<lastIndex public="1">
			<x path="Int"/>
			<haxe_doc>The index at which to start the next match.</haxe_doc>
		</lastIndex>
		<exec public="1" set="method">
			<f a="str">
				<c path="String"/>
				<x path="Null"><c path="js.lib.RegExpMatch"/></x>
			</f>
			<haxe_doc>Execute a search for a match in a specified string.
		Returns a result array, or null.</haxe_doc>
		</exec>
		<test public="1" set="method">
			<f a="str">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Execute a search for a match between a regular expression and a specified string.
		Returns true or false.</haxe_doc>
		</test>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return a string representing the regular expression.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="pattern:?flags">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a regular expression object for matching text with a pattern.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Native JavaScript regular expressions.

	For cross-platform regular expressions, use Haxe `EReg` class or
	[regexp literals](https://haxe.org/manual/std-regex.html).

	@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp>]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"RegExp"</e></m>
		</meta>
	</class>
	<class path="EReg" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/EReg.hx">
		<escape public="1" get="inline" set="null" line="114" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape the string `s` for use as a part of regular expression.

		If `s` is null, the result is unspecified.</haxe_doc>
		</escape>
		<escapeRe expr="new js.lib.RegExp(&quot;[.*+?^${}()|[\\]\\\\]&quot;, &quot;g&quot;)" line="118" static="1">
			<c path="js.lib.RegExp"/>
			<meta><m n=":value"><e>new js.lib.RegExp("[.*+?^${}()|[\\]\\\\]", "g")</e></m></meta>
		</escapeRe>
		<r><c path="_EReg.HaxeRegExp"/></r>
		<match public="1" set="method" line="29">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="37">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedPos public="1" set="method" line="54">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchSub public="1" set="method" line="60">
			<f a="s:pos:?len" v="::-1">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ len : -1 }</e></m></meta>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.match(s.substr(pos,len))` can be used instead.

		This method modifies the internal state.

		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<replace public="1" get="inline" set="null" line="86">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<map public="1" set="method" line="90">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>Calls the function `f` for the substring of `s` which `this` EReg matches
		and replaces that substring with the result of `f` call.

		The `f` function takes `this` EReg object as its first argument and should
		return a replacement string for the substring matched.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `s` or `f` are null, the result is unspecified.</haxe_doc>
		</map>
		<new public="1" get="inline" set="null" line="25">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="_EReg.HaxeRegExp" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/EReg.hx" private="1" module="EReg" extern="1">
		<extends path="js.lib.RegExp"/>
		<m public="1"><c path="js.lib.RegExpMatch"/></m>
		<s public="1"><c path="String"/></s>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"RegExp"</e></m>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="js.Syntax" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/Syntax.hx" extern="1">
		<code public="1" set="method" static="1">
			<f a="code:args">
				<c path="String"/>
				<t path="haxe.extern.Rest"><d/></t>
				<d/>
			</f>
			<haxe_doc>Inject `code` directly into generated source.

		`code` must be a string constant.

		Additional `args` are supported to provide code interpolation, for example:
		```haxe
		Syntax.code("console.log({0}, {1})", "hi", 42);
		```
		will generate
		```haxe
		console.log("hi", 42);
		```

		Emits a compilation error if the count of `args` does not match the count of placeholders in `code`.</haxe_doc>
		</code>
		<plainCode public="1" set="method" static="1">
			<f a="code">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Inject `code` directly into generated source.
		The same as `js.Syntax.code` except this one does not provide code interpolation.</haxe_doc>
		</plainCode>
		<construct public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<x path="Class"><c path="construct.T"/></x>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="construct.T"/>
			</f>
			<haxe_doc>Generate `new cl(...args)` expression.</haxe_doc>
			<overloads><construct public="1" set="method">
	<f a="cl:args">
		<c path="String"/>
		<t path="haxe.extern.Rest"><d/></t>
		<d/>
	</f>
	<haxe_doc>Generate `new cl(...args)` expression.</haxe_doc>
</construct></overloads>
		</construct>
		<instanceof public="1" set="method" static="1">
			<f a="v:cl">
				<d/>
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>Generate `v instanceof cl` expression.</haxe_doc>
		</instanceof>
		<typeof public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Generate `typeof o` expression.</haxe_doc>
		</typeof>
		<strictEq public="1" set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Genearte `a === b` expression.</haxe_doc>
		</strictEq>
		<strictNeq public="1" set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Genearte `a !== b` expression.</haxe_doc>
		</strictNeq>
		<delete public="1" set="method" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Generate `delete o[f]` expression.</haxe_doc>
			<overloads><delete public="1" set="method">
	<f a="o:f">
		<d/>
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<haxe_doc>Generate `delete o[f]` expression.</haxe_doc>
</delete></overloads>
		</delete>
		<field public="1" set="method" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Generate `o.f` expression, if `f` is a constant string,
		or `o[f]` if it's any other expression.</haxe_doc>
		</field>
		<haxe_doc>Generate JavaScript syntax not directly supported by Haxe.
	Use only at low-level when specific target-specific code-generation is required.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noClosure"/>
		</meta>
	</class>
	<class path="js.lib.Date" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Date.hx" extern="1">
		<fromHaxeDate public="1" get="inline" set="null" line="40" static="1">
			<f a="date">
				<t path="_Date.HaxeDate"/>
				<c path="js.lib.Date"/>
			</f>
			<haxe_doc>Cast Haxe's Date to js.lib.Date.</haxe_doc>
		</fromHaxeDate>
		<toHaxeDate public="1" get="inline" set="null" line="47" static="1">
			<f a="date">
				<c path="js.lib.Date"/>
				<t path="_Date.HaxeDate"/>
			</f>
			<haxe_doc>Cast js.lib.Date to Haxe's Date.</haxe_doc>
		</toHaxeDate>
		<now public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the numeric value corresponding to the current time - the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC, with leap seconds ignored</haxe_doc>
		</now>
		<parse public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Parses a string representation of a date and returns the number of milliseconds since 1 January, 1970, 00:00:00, UTC, with leap seconds ignored.</haxe_doc>
		</parse>
		<UTC public="1" set="method" static="1">
			<f a="year:month:?day:?hours:?minutes:?seconds:?milliseconds">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the number of milliseconds since January 1, 1970, 00:00:00 UTC, with leap seconds ignored.</haxe_doc>
		</UTC>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the month (1-31) for the specified date according to local time.</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week (0-6) for the specified date according to local time.</haxe_doc>
		</getDay>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the year (4 digits for 4-digit years) of the specified date according to local time.</haxe_doc>
		</getFullYear>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hour (0-23) in the specified date according to local time.</haxe_doc>
		</getHours>
		<getMilliseconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the milliseconds (0-999) in the specified date according to local time.</haxe_doc>
		</getMilliseconds>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes (0-59) in the specified date according to local time.</haxe_doc>
		</getMinutes>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month (0-11) in the specified date according to local time.</haxe_doc>
		</getMonth>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds (0-59) in the specified date according to local time.</haxe_doc>
		</getSeconds>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970, 00:00:00 UTC (negative for prior times).</haxe_doc>
		</getTime>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the time-zone offset in minutes for the current locale.</haxe_doc>
		</getTimezoneOffset>
		<getUTCDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day (date) of the month (1-31) in the specified date according to universal time.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week (0-6) in the specified date according to universal time.</haxe_doc>
		</getUTCDay>
		<getUTCFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the year (4 digits for 4-digit years) in the specified date according to universal time.</haxe_doc>
		</getUTCFullYear>
		<getUTCHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours (0-23) in the specified date according to universal time.</haxe_doc>
		</getUTCHours>
		<getUTCMilliseconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the milliseconds (0-999) in the specified date according to universal time.</haxe_doc>
		</getUTCMilliseconds>
		<getUTCMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes (0-59) in the specified date according to universal time.</haxe_doc>
		</getUTCMinutes>
		<getUTCMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month (0-11) in the specified date according to universal time.</haxe_doc>
		</getUTCMonth>
		<getUTCSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds (0-59) in the specified date according to universal time.</haxe_doc>
		</getUTCSeconds>
		<setDate public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the day of the month for a specified date according to local time.</haxe_doc>
		</setDate>
		<setFullYear public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to local time.</haxe_doc>
		</setFullYear>
		<setHours public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the hours for a specified date according to local time.</haxe_doc>
		</setHours>
		<setMilliseconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the milliseconds for a specified date according to local time.</haxe_doc>
		</setMilliseconds>
		<setMinutes public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the minutes for a specified date according to local time.</haxe_doc>
		</setMinutes>
		<setMonth public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the month for a specified date according to local time.</haxe_doc>
		</setMonth>
		<setSeconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the seconds for a specified date according to local time.</haxe_doc>
		</setSeconds>
		<setTime public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the Date object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC, allowing for negative numbers for times prior.</haxe_doc>
		</setTime>
		<setUTCDate public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the day of the month for a specified date according to universal time.</haxe_doc>
		</setUTCDate>
		<setUTCFullYear public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to universal time.</haxe_doc>
		</setUTCFullYear>
		<setUTCHours public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the hour for a specified date according to universal time.</haxe_doc>
		</setUTCHours>
		<setUTCMilliseconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the milliseconds for a specified date according to universal time.</haxe_doc>
		</setUTCMilliseconds>
		<setUTCMinutes public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the minutes for a specified date according to universal time.</haxe_doc>
		</setUTCMinutes>
		<setUTCMonth public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the month for a specified date according to universal time.</haxe_doc>
		</setUTCMonth>
		<setUTCSeconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the seconds for a specified date according to universal time.</haxe_doc>
		</setUTCSeconds>
		<toDateString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the "date" portion of the Date as a human-readable string.</haxe_doc>
		</toDateString>
		<toISOString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Converts a date to a string following the ISO 8601 Extended Format.</haxe_doc>
		</toISOString>
		<toJSON public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the Date using toISOString(). Intended for use by JSON.stringify().</haxe_doc>
		</toJSON>
		<toLocaleDateString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<d><d/></d>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a locality sensitive representation of the date portion of this date based on system settings.</haxe_doc>
			<overloads><toLocaleDateString public="1" set="method">
	<f a="?locales:?options">
		<c path="Array"><c path="String"/></c>
		<d><d/></d>
		<c path="String"/>
	</f>
	<haxe_doc>Returns a string with a locality sensitive representation of the date portion of this date based on system settings.</haxe_doc>
</toLocaleDateString></overloads>
		</toLocaleDateString>
		<toLocaleFormat public="1" set="method">
			<f a="format">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts a date to a string, using a format string.</haxe_doc>
		</toLocaleFormat>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<d><d/></d>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a locality sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.</haxe_doc>
			<overloads><toLocaleString public="1" set="method">
	<f a="?locales:?options">
		<c path="Array"><c path="String"/></c>
		<d><d/></d>
		<c path="String"/>
	</f>
	<haxe_doc>Returns a string with a locality sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.</haxe_doc>
</toLocaleString></overloads>
		</toLocaleString>
		<toLocaleTimeString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<d><d/></d>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a locality sensitive representation of the time portion of this date based on system settings.</haxe_doc>
			<overloads><toLocaleTimeString public="1" set="method">
	<f a="?locales:?options">
		<c path="Array"><c path="String"/></c>
		<d><d/></d>
		<c path="String"/>
	</f>
	<haxe_doc>Returns a string with a locality sensitive representation of the time portion of this date based on system settings.</haxe_doc>
</toLocaleTimeString></overloads>
		</toLocaleTimeString>
		<toSource public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the source for an equivalent Date object; you can use this value to create a new object. Overrides the Object.prototype.toSource() method.</haxe_doc>
		</toSource>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the specified Date object. Overrides the Object.prototype.toString() method.</haxe_doc>
		</toString>
		<toTimeString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the "time" portion of the Date as a human-readable string.</haxe_doc>
		</toTimeString>
		<toUTCString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Converts a date to a string using the UTC timezone.</haxe_doc>
		</toUTCString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
				<new public="1" set="method"><f a="dateString">
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new public="1" set="method"><f a="year:month:?day:?hours:?minutes:?seconds:?milliseconds">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<haxe_doc>Creates a JavaScript Date instance that represents a single moment in time. Date objects are based on a time value that is the number of milliseconds since 1 January 1970 UTC.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Date"</e></m>
		</meta>
	</class>
	<class path="IntIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/IntIterator.hx">
		<min>
			<x path="Int"/>
			<meta><m n=":keep"/></meta>
		</min>
		<max>
			<x path="Int"/>
			<meta><m n=":keep"/></meta>
		</max>
		<hasNext public="1" get="inline" set="null" line="53">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="62">
			<f a=""><x path="Int"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Moves to the next item of the iterator.

		If this is called while hasNext() is false, the result is unspecified.</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="45">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc><![CDATA[Iterates from `min` (inclusive) to `max` (exclusive).

		If `max <= min`, the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>IntIterator is used for implementing interval iterations.

	It is usually not used explicitly, but through its special syntax:
	`min...max`

	While it is possible to assign an instance of IntIterator to a variable or
	field, it is worth noting that IntIterator does not reset after being used
	in a for-loop. Subsequent uses of the same instance will then have no
	effect.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="Main" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/Main.hx">
		<project public="1" expr="null" line="7" static="1">
			<c path="Project"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</project>
		<_lastUpdateTime expr="-1" line="9" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</_lastUpdateTime>
		<main public="1" set="method" line="11" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<update set="method" line="29" static="1"><f a=""><x path="Void"/></f></update>
	</class>
	<typedef path="Map" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<abs public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></abs>
		<asin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<ceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></ceil>
		<cos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></cos>
		<exp public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></exp>
		<floor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></floor>
		<max public="1" set="method" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></max>
		<min public="1" set="method" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></min>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><x path="Float"/></f></random>
		<round public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></round>
		<sin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></sin>
		<sqrt public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
		</meta>
	</class>
	<class path="ceramic.Lazy" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Lazy.hx" interface="1"><haxe_doc>* Lazy allows to mark any property as lazy.
 * Lazy properties are initialized only at first access.</haxe_doc></class>
	<class path="tracker.Events" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Events.hx" interface="1">
		<haxe_doc>Events allows to add strictly typed events to classes.
    Generates related methods: on|once|off|emit{EventName}()</haxe_doc>
		<meta><m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m></meta>
	</class>
	<class path="ceramic.Entity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Entity.hx">
		<implements path="ceramic.Lazy"/>
		<implements path="tracker.Events"/>
		<_data expr="null">
			<d/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_data>
		<hasData public="1" get="accessor" set="null"><x path="Bool"/></hasData>
		<get_hasData get="inline" set="null" line="48"><f a=""><x path="Bool"/></f></get_hasData>
		<data public="1" get="accessor" set="accessor"><d/></data>
		<get_data set="method" line="53"><f a=""><d/></f></get_data>
		<set_data set="method" line="57"><f a="data">
	<d/>
	<d/>
</f></set_data>
		<id public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</id>
		<_lifecycleState expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Internal flag to keep track of current entity state:
     *  - 0: Entity is not destroyed, can be used normally
     *  - -1: Entity is marked destroyed still allowing calls to super.destroy()
     *  - -2: Entity is marked destroyed and additional calls to destroy() are ignored
     *  - -3: Entity root is destroyed (Entity.destroy() was called). Additional calls to destroy() are ignored</haxe_doc>
		</_lifecycleState>
		<destroyed public="1" get="accessor" set="null"><x path="Bool"/></destroyed>
		<get_destroyed get="inline" set="null" line="128"><f a=""><x path="Bool"/></f></get_destroyed>
		<disposed public="1" get="accessor" set="null"><x path="Bool"/></disposed>
		<get_disposed get="inline" set="null" line="133"><f a=""><x path="Bool"/></f></get_disposed>
		<_dox_event_dispose public="1" set="method" line="637">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_dispose>
		<emitDispose set="method" line="1095">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>dispose event</haxe_doc>
		</emitDispose>
		<onDispose public="1" set="method" line="1199">
			<f a="owner:handleEntity">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="entity">
					<c path="ceramic.Entity"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dispose event</haxe_doc>
		</onDispose>
		<onceDispose public="1" set="method" line="1298">
			<f a="owner:handleEntity">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="entity">
					<c path="ceramic.Entity"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dispose event</haxe_doc>
		</onceDispose>
		<offDispose public="1" set="method" line="1368">
			<f a="?handleEntity">
				<f a="entity">
					<c path="ceramic.Entity"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dispose event</haxe_doc>
		</offDispose>
		<listensDispose public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to dispose event</haxe_doc>
		</listensDispose>
		<_dox_event_destroy public="1" set="method" line="637">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_destroy>
		<emitDestroy set="method" line="1095">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>destroy event</haxe_doc>
		</emitDestroy>
		<onDestroy public="1" set="method" line="1199">
			<f a="owner:handleEntity">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="entity">
					<c path="ceramic.Entity"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>destroy event</haxe_doc>
		</onDestroy>
		<onceDestroy public="1" set="method" line="1298">
			<f a="owner:handleEntity">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="entity">
					<c path="ceramic.Entity"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>destroy event</haxe_doc>
		</onceDestroy>
		<offDestroy public="1" set="method" line="1368">
			<f a="?handleEntity">
				<f a="entity">
					<c path="ceramic.Entity"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>destroy event</haxe_doc>
		</offDestroy>
		<listensDestroy public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to destroy event</haxe_doc>
		</listensDestroy>
		<destroy public="1" set="method" line="320">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroy this entity. This method is automatically protected from duplicate calls. That means
     * calling multiple times an entity's `destroy()` method will run the destroy code only one time.
     * As soon as `destroy()` is called, the entity is marked `destroyed=true`, even when calling `destroy()`
     * method on a subclass (a macro is inserting a code to mark the object
     * as destroyed at the beginning of every `destroy()` override function.</haxe_doc>
		</destroy>
		<dispose public="1" set="method" line="370">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Schedules destroy, at the end of the current frame.</haxe_doc>
		</dispose>
		<unbindEvents public="1" set="method" line="384">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Remove all events handlers from this entity.</haxe_doc>
		</unbindEvents>
		<autoruns public="1" set="null" expr="null">
			<c path="Array"><c path="tracker.Autorun"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</autoruns>
		<autorun public="1" set="method" line="400">
			<f a="run:?afterRun">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<c path="tracker.Autorun"/>
			</f>
			<haxe_doc>* Creates a new `Autorun` instance with the given callback associated with the current entity.
     * @param run The run callback
     * @return The autorun instance</haxe_doc>
		</autorun>
		<checkAutoruns set="method" line="469"><f a="_">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></checkAutoruns>
		<tween public="1" set="method" line="482"><f a="?easing:duration:fromValue:toValue:update">
	<e path="ceramic.Easing"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<f a=":">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<c path="ceramic.Tween"/>
</f></tween>
		<className public="1" set="method" line="490"><f a=""><c path="String"/></f></className>
		<toString set="method" line="499"><f a=""><c path="String"/></f></toString>
		<clearComponents public="1" get="inline" set="null" line="513"><f a=""><x path="Void"/></f></clearComponents>
		<components public="1" get="accessor" set="accessor">
			<x path="ceramic.ReadOnlyMap">
				<c path="String"/>
				<c path="ceramic.Component"/>
			</x>
			<meta><m n="editable"/></meta>
			<haxe_doc>* Public components mapping. Contain components
     * created separately with `component()` or macro-based components as well.</haxe_doc>
		</components>
		<get_components get="inline" set="null" line="537"><f a=""><x path="ceramic.ReadOnlyMap">
	<c path="String"/>
	<c path="ceramic.Component"/>
</x></f></get_components>
		<set_components set="method" line="540"><f a="components">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</x>
</f></set_components>
		<_components expr="null">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.Component"/>
			</t>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Internal components representation.</haxe_doc>
		</_components>
		<component public="1" params="C" set="method" line="583"><f a="?name:?component">
	<c path="String"/>
	<x path="Null"><c path="component.C"/></x>
	<c path="component.C"/>
</f></component>
		<hasComponent public="1" set="method" line="643"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasComponent>
		<removeComponent public="1" set="method" line="649"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeComponent>
		<new public="1" set="method" line="161">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Create a new entity</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n="editable"/>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<class path="Project" params="" file="/home/runner/work/api-docs/api-docs/src/Project.hx">
		<extends path="ceramic.Entity"/>
		<ready set="method" line="25"><f a=""><x path="Void"/></f></ready>
		<new set="method" line="10"><f a="settings">
	<c path="ceramic.InitSettings"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="Reflect" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/Reflect.hx">
		<hasField public="1" get="inline" set="null" line="24" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="29" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="36" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" line="41" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="48" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" get="inline" set="null" line="56" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method `func` with the given arguments `args`.

		The object `o` is ignored in most cases. It serves as the `this`-context in the following
		situations:

		* (neko) Allows switching the context to `o` in all cases.
		* (macro) Same as neko for Haxe 3. No context switching in Haxe 4.
		* (js, lua) Require the `o` argument if `func` does not, but should have a context.
			This can occur by accessing a function field natively, e.g. through `Reflect.field`
			or by using `(object : Dynamic).field`. However, if `func` has a context, `o` is
			ignored like on other targets.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="60" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="74" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>js.Boot</e></m></meta>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="78" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<isObject public="1" set="method" line="87" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>js.Boot</e></m></meta>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="95" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" line="99" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<makeVarArgs public="1" set="method" line="116" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method"><f a="f">
	<f a="">
		<c path="Array"><d/></c>
		<x path="Void"/>
	</f>
	<d/>
</f></makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="String" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/String.hx" extern="1">
		<fromCharCode public="1" get="inline" set="null" line="43" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<charCodeAt public="1" get="inline" set="null" line="35">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substr public="1" get="inline" set="null" line="39">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/Std.hx">
		<isOfType public="1" get="inline" set="null" line="33" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</isOfType>
		<string public="1" set="method" line="47" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="51" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="56" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		`x` may optionally start with a + or - to denote a postive or negative value respectively.

		If the optional sign is followed 0x or 0X, hexadecimal notation is recognized where the following
		digits may contain 0-9 and A-F. Both the prefix and digits are case insensitive.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. Octal and binary
		notations are not supported.

		Parsing continues until an invalid character is detected, in which case the result up to
		that point is returned. Scientific notation is not supported. That is `Std.parseInt('10e2')` produces `10`.

		If `x` is `null`, the result is `null`.
		If `x` cannot be parsed as integer or is empty, the result is `null`.

		If `x` starts with a hexadecimal prefix which is not followed by at least one valid hexadecimal
		digit, the result is unspecified.</haxe_doc>
		</parseInt>
		<parseFloat public="1" get="inline" set="null" line="77" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of `null`. Also, hexadecimal support is **not** specified.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.

		It may also end with `e` or `E` followed by optional minus or plus sign and a sequence of
		digits (defines exponent to base 10).</haxe_doc>
		</parseFloat>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="StringBuf" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StringBuf.hx">
		<b><c path="String"/></b>
		<add public="1" params="T" get="inline" set="null" line="61">
			<f a="x">
				<c path="add.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of `x` to `this` StringBuf.

		The exact representation of `x` may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).

		If `x` is null, the String "null" is appended.</haxe_doc>
		</add>
		<addChar public="1" get="inline" set="null" line="71">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the character identified by `c` to `this` StringBuf.

		If `c` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</addChar>
		<addSub public="1" get="inline" set="null" line="87">
			<f a="s:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends a substring of `s` to `this` StringBuf.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.add(s.substr(pos,len))` can be used instead.

		If `s` or `pos` are null, the result is unspecified.

		If `len` is omitted or null, the substring ranges from `pos` to the end
		of `s`.</haxe_doc>
		</addSub>
		<toString public="1" get="inline" set="null" line="96">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of `this` StringBuf as String.

		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<new public="1" get="inline" set="null" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.SysTools" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/SysTools.hx">
		<quoteUnixArg public="1" set="method" line="18" static="1">
			<f a="argument">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Unix.
		The input will be quoted, or escaped if necessary.</haxe_doc>
		</quoteUnixArg>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StringTools.hx">
		<urlEncode public="1" get="inline" set="null" line="42" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" get="inline" set="null" line="110" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="158" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:

		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;

		If `quotes` is true, the following characters are also replaced:

		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<startsWith public="1" set="method" line="226" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is `null`, the result is unspecified.

		If `start` is the empty String `""`, the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="251" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is `null`, the result is unspecified.

		If `end` is the empty String `""`, the result is true.</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="282" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="300" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="325" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="347" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for `ltrim(rtrim(s))`.</haxe_doc>
		</trim>
		<replace public="1" set="method" line="416" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s` except the last one. If `by` is also the empty String `""`, `s`
		remains unchanged.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="438" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its `length` equals `digits`.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="480" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the character code at position `index` of String `s`, or an
		end-of-file indicator at if `position` equals `s.length`.

		This method is faster than `String.charCodeAt()` on some platforms, but
		the result is unspecified if `index` is negative or greater than
		`s.length`.

		End of file status can be checked by calling `StringTools.isEof()` with
		the returned value as argument.

		This operation is not guaranteed to work if `s` contains the `\0`
		character.</haxe_doc>
		</fastCodeAt>
		<unsafeCodeAt public="1" get="inline" set="null" line="519" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the character code at position `index` of String `s`, or an
		end-of-file indicator at if `position` equals `s.length`.

		This method is faster than `String.charCodeAt()` on some platforms, but
		the result is unspecified if `index` is negative or greater than
		`s.length`.

		This operation is not guaranteed to work if `s` contains the `\0`
		character.</haxe_doc>
		</unsafeCodeAt>
		<isEof public="1" get="inline" set="null" line="572" static="1">
			<f a="c">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>Tells if `c` represents the end-of-file (EOF) character.</haxe_doc>
		</isEof>
		<utf16CodePointAt get="inline" set="null" line="636" static="1"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></utf16CodePointAt>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Sys" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/Sys.hx">
		<args public="1" get="inline" set="null" line="22" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed in the command line.
		This does not include the interpreter or the name of the program file.

		(java)(eval) On Windows, non-ASCII Unicode arguments will not work correctly.

		(cs) Non-ASCII Unicode arguments will not work correctly.</haxe_doc>
		</args>
		<getCwd public="1" get="inline" set="null" line="48" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Gets the current working directory (usually the one in which the program was started).</haxe_doc>
		</getCwd>
		<setCwd public="1" get="inline" set="null" line="52" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the current working directory.

		(java) This functionality is not available on Java; calling this function will throw.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="56" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the type of the current system. Possible values are:
		 - `"Windows"`
		 - `"Linux"`
		 - `"BSD"`
		 - `"Mac"`</haxe_doc>
		</systemName>
		<exit public="1" get="inline" set="null" line="73" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exits the current process with the given exit code.

		(macro)(eval) Being invoked in a macro or eval context (e.g. with `-x` or `--run`) immediately terminates
		the compilation process, which also prevents the execution of any `--next` sections of compilation arguments.</haxe_doc>
		</exit>
		<haxe_doc>This class provides access to various base functions of system platforms.
	Look in the `sys` package for more system APIs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dce"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.io.Output" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Output.hx">
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the `writeByte` and maybe the `write`, `flush` and `close`
	methods. See `File.write` and `String.write` for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="_Sys.FileOutput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/Sys.hx" private="1" module="Sys">
		<extends path="haxe.io.Output"/>
		<fd><x path="Int"/></fd>
		<writeByte public="1" set="method" line="127"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="131"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<writeString public="1" set="method" line="135"><f a="s:?encoding">
	<c path="String"/>
	<e path="haxe.io.Encoding"/>
	<x path="Void"/>
</f></writeString>
		<flush public="1" set="method" line="139"><f a=""><x path="Void"/></f></flush>
		<close public="1" set="method" line="143"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="123"><f a="fd">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Input" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Input.hx">
		<readByte public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="64">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<readAll public="1" set="method" line="106">
			<f a="?bufsize">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return all available data.

		The `bufsize` optional argument specifies the size of chunks by
		which data is read. Its default value is target-specific.</haxe_doc>
		</readAll>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="_Sys.FileInput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/Sys.hx" private="1" module="Sys">
		<extends path="haxe.io.Input"/>
		<fd><x path="Int"/></fd>
		<readByte public="1" set="method" line="155" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="168" override="1"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="180"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="151"><f a="fd">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="ValueType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="Type" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/Type.hx">
		<getClass public="1" params="T" get="inline" set="null" line="35" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getSuperClass public="1" get="inline" set="null" line="50" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" get="inline" set="null" line="54" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" get="inline" set="null" line="58" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" get="inline" set="null" line="81" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" get="inline" set="null" line="85" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="136" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" get="inline" set="null" line="141" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="146" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<getInstanceFields public="1" set="method" line="209" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`, including
		inherited fields.

		This only includes fields which are known at compile-time. In
		particular, using `getInstanceFields(getClass(obj))` will not include
		any fields which were added to `obj` at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getInstanceFields>
		<getEnumConstructs public="1" get="inline" set="null" line="229" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="238" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":access"><e>js.Boot</e></m>
			</meta>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="276" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" get="inline" set="null" line="306" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="320" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="327" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" get="inline" set="null" line="335" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="_UInt.UInt_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/UInt.hx" private="1" module="UInt" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="XmlType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Xml.hx" module="Xml">
		<this><x path="Int"/></this>
		<haxe_doc>Xml node types.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="_Xml.XmlType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Xml.hx" private="1" module="Xml" final="1">
	<toString public="1" set="method" line="64" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="_Xml.XmlType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Xml.hx" private="1" module="Xml" final="1">
		<toString public="1" set="method" line="64" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="Xml" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Xml.hx">
		<Element public="1" set="null" expr="XmlType.Element" line="86" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Element</e></m></meta>
			<haxe_doc>XML element type.</haxe_doc>
		</Element>
		<PCData public="1" set="null" expr="XmlType.PCData" line="91" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.PCData</e></m></meta>
			<haxe_doc>XML parsed character data type.</haxe_doc>
		</PCData>
		<CData public="1" set="null" expr="XmlType.CData" line="96" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.CData</e></m></meta>
			<haxe_doc>XML character data type.</haxe_doc>
		</CData>
		<Comment public="1" set="null" expr="XmlType.Comment" line="101" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Comment</e></m></meta>
			<haxe_doc>XML comment type.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" expr="XmlType.DocType" line="106" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.DocType</e></m></meta>
			<haxe_doc>XML doctype element type.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" expr="XmlType.ProcessingInstruction" line="111" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.ProcessingInstruction</e></m></meta>
			<haxe_doc>XML processing instruction type.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" expr="XmlType.Document" line="116" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Document</e></m></meta>
			<haxe_doc>XML document type.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="121" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parses the String into an Xml document.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="182" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="191" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="200" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="209" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="218" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="227" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="236" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<x path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<nodeName public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<parent public="1" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be `null`, an Element or a Document.</haxe_doc>
		</parent>
		<children><c path="Array"><c path="Xml"/></c></children>
		<attributeMap><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></attributeMap>
		<get_nodeName get="inline" set="null" line="151"><f a=""><c path="String"/></f></get_nodeName>
		<set_nodeName get="inline" set="null" line="158"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeName>
		<get_nodeValue get="inline" set="null" line="165"><f a=""><c path="String"/></f></get_nodeValue>
		<set_nodeValue get="inline" set="null" line="172"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeValue>
		<get public="1" set="method" line="244">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns `null` if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<set public="1" set="method" line="255">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<exists public="1" set="method" line="277">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="287">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an `Iterator` on all the attribute names.</haxe_doc>
		</attributes>
		<iterator public="1" get="inline" set="null" line="298">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</iterator>
		<elements public="1" set="method" line="307">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="317">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<firstElement public="1" set="method" line="337">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="353">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		A child node can only be inside one given parent node, which is indicated by the `parent` property.
		If the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.
		If the child node was previously inside a different node, it will be moved to this Document or Element.</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="366">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<toString public="1" get="inline" set="null" line="393">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<ensureElementType get="inline" set="null" line="403"><f a=""><x path="Void"/></f></ensureElementType>
		<new set="method" line="397"><f a="nodeType">
	<x path="XmlType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Cross-platform Xml API.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds._Map.Map_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
		<_new public="1" set="method" static="1">
			<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
		</_new>
		<set public="1" get="inline" set="null" line="74" static="1">
			<f a="this:key:value">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Maps `key` to `value`.

		If `key` already has a mapping, the previous value disappears.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="92" static="1">
			<f a="this:key">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<x path="Null"><c path="haxe.ds.Map.V"/></x>
			</f>
			<meta><m n=":arrayAccess"/></meta>
			<haxe_doc>Returns the current mapping of `key`.

		If no such mapping exists, `null` is returned.

		Note that a check like `map.get(key) == null` can hold for two reasons:

		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`

		If it is important to distinguish these cases, `exists()` should be
		used.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="100" static="1">
			<f a="this:key">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `key` has a mapping, false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</exists>
		<remove public="1" get="inline" set="null" line="109" static="1">
			<f a="this:key">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="116" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<t path="Iterator"><c path="haxe.ds.Map.K"/></t>
			</f>
			<haxe_doc>Returns an Iterator over the keys of `this` Map.

		The order of keys is undefined.</haxe_doc>
		</keys>
		<iterator public="1" get="inline" set="null" line="125" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<t path="Iterator"><c path="haxe.ds.Map.V"/></t>
			</f>
			<haxe_doc>Returns an Iterator over the values of `this` Map.

		The order of values is undefined.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="134" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<t path="KeyValueIterator">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</t>
			</f>
			<haxe_doc>Returns an Iterator over the keys and values of `this` Map.

		The order of values is undefined.</haxe_doc>
		</keyValueIterator>
		<copy public="1" get="inline" set="null" line="143" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<x path="haxe.ds.Map">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</x>
			</f>
			<haxe_doc>Returns a shallow copy of `this` map.

		The order of values is undefined.</haxe_doc>
		</copy>
		<clear public="1" get="inline" set="null" line="159" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes all keys from `this` Map.</haxe_doc>
		</clear>
		<toStringMap params="K:V" get="inline" set="null" line="168" static="1">
			<f a="t">
				<c path="haxe.IMap">
					<c path="toStringMap.K"/>
					<c path="toStringMap.V"/>
				</c>
				<c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c>
			</f>
			<meta>
				<m n=":multiType"/>
				<m n=":to"/>
			</meta>
		</toStringMap>
		<toIntMap params="K:V" get="inline" set="null" line="172" static="1">
			<f a="t">
				<c path="haxe.IMap">
					<c path="toIntMap.K"/>
					<c path="toIntMap.V"/>
				</c>
				<c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c>
			</f>
			<meta>
				<m n=":multiType"/>
				<m n=":to"/>
			</meta>
		</toIntMap>
		<fromStringMap params="V" get="inline" set="null" line="184" static="1">
			<f a="map">
				<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
				<x path="haxe.ds.Map">
					<c path="String"/>
					<c path="fromStringMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromStringMap>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="ceramic.Assets" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Assets.hx">
		<extends path="ceramic.Entity"/>
		<instances public="1" expr="[]" line="14" static="1">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.Assets"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
		</instances>
		<all public="1" expr="[]" line="16" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</all>
		<allDirs public="1" expr="[]" line="18" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</allDirs>
		<allByName public="1" expr="new Map()" line="20" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</allByName>
		<allDirsByName public="1" expr="new Map()" line="22" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</allDirsByName>
		<customAssetKinds expr="new Map()" line="73" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.CustomAssetKind"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</customAssetKinds>
		<reloadCountByRealAssetPath expr="null" line="75" static="1">
			<t path="Map">
				<c path="String"/>
				<x path="Int"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</reloadCountByRealAssetPath>
		<lastModifiedByRealAssetPath expr="null" line="77" static="1">
			<t path="Map">
				<c path="String"/>
				<x path="Float"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastModifiedByRealAssetPath>
		<_instances expr="[]" line="89" static="1">
			<c path="Array"><c path="ceramic.Assets"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_instances>
		<flushAllInstancesImmediate public="1" set="method" line="91" static="1"><f a=""><x path="Void"/></f></flushAllInstancesImmediate>
		<decodePath public="1" set="method" line="1119" static="1"><f a="path">
	<c path="String"/>
	<c path="ceramic.AssetPathInfo"/>
</f></decodePath>
		<addAssetKind public="1" set="method" line="1125" static="1"><f a="kind:add:extensions:dir:types">
	<c path="String"/>
	<f a="assets:name:variant:options">
		<c path="ceramic.Assets"/>
		<c path="String"/>
		<c path="String"/>
		<t path="ceramic.AssetOptions"/>
		<x path="Void"/>
	</f>
	<c path="Array"><c path="String"/></c>
	<x path="Bool"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></addAssetKind>
		<getAssetsPath public="1" get="inline" set="null" line="1137" static="1"><f a=""><c path="String"/></f></getAssetsPath>
		<assetNameFromPath public="1" set="method" line="1143" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></assetNameFromPath>
		<realAssetPath public="1" set="method" line="1158" static="1"><f a="path:?runtimeAssets">
	<c path="String"/>
	<c path="ceramic.RuntimeAssets"/>
	<c path="String"/>
</f></realAssetPath>
		<incrementReloadCount set="method" line="1182" static="1"><f a="realAssetPath">
	<c path="String"/>
	<x path="Void"/>
</f></incrementReloadCount>
		<getReloadCount public="1" set="method" line="1196" static="1"><f a="realAssetPath">
	<c path="String"/>
	<x path="Int"/>
</f></getReloadCount>
		<_dox_event_complete public="1" set="method" line="637">
			<f a="success">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_complete>
		<emitComplete set="method" line="1095">
			<f a="success">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>complete event</haxe_doc>
		</emitComplete>
		<onComplete public="1" set="method" line="1199">
			<f a="owner:handleSuccess">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="success">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</onComplete>
		<onceComplete public="1" set="method" line="1298">
			<f a="owner:handleSuccess">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="success">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</onceComplete>
		<offComplete public="1" set="method" line="1368">
			<f a="?handleSuccess">
				<f a="success">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</offComplete>
		<listensComplete public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to complete event</haxe_doc>
		</listensComplete>
		<_dox_event_update public="1" set="method" line="637">
			<f a="asset">
				<c path="ceramic.Asset"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_update>
		<emitUpdate set="method" line="1095">
			<f a="asset">
				<c path="ceramic.Asset"/>
				<x path="Void"/>
			</f>
			<haxe_doc>update event</haxe_doc>
		</emitUpdate>
		<onUpdate public="1" set="method" line="1199">
			<f a="owner:handleAsset">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="asset">
					<c path="ceramic.Asset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onUpdate>
		<onceUpdate public="1" set="method" line="1298">
			<f a="owner:handleAsset">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="asset">
					<c path="ceramic.Asset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onceUpdate>
		<offUpdate public="1" set="method" line="1368">
			<f a="?handleAsset">
				<f a="asset">
					<c path="ceramic.Asset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</offUpdate>
		<listensUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to update event</haxe_doc>
		</listensUpdate>
		<_dox_event_progress public="1" set="method" line="637">
			<f a="loaded:total:success">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_progress>
		<emitProgress set="method" line="1095">
			<f a="loaded:total:success">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>progress event</haxe_doc>
		</emitProgress>
		<onProgress public="1" set="method" line="1199">
			<f a="owner:handleLoadedTotalSuccess">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="loaded:total:success">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>progress event</haxe_doc>
		</onProgress>
		<onceProgress public="1" set="method" line="1298">
			<f a="owner:handleLoadedTotalSuccess">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="loaded:total:success">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>progress event</haxe_doc>
		</onceProgress>
		<offProgress public="1" set="method" line="1368">
			<f a="?handleLoadedTotalSuccess">
				<f a="loaded:total:success">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>progress event</haxe_doc>
		</offProgress>
		<listensProgress public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to progress event</haxe_doc>
		</listensProgress>
		<_dox_event_assetFilesChange public="1" set="method" line="637">
			<f a="newFiles:previousFiles">
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_assetFilesChange>
		<emitAssetFilesChange set="method" line="1095">
			<f a="newFiles:previousFiles">
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>assetFilesChange event</haxe_doc>
		</emitAssetFilesChange>
		<onAssetFilesChange public="1" set="method" line="1199">
			<f a="owner:handleNewFilesPreviousFiles">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newFiles:previousFiles">
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>assetFilesChange event</haxe_doc>
		</onAssetFilesChange>
		<onceAssetFilesChange public="1" set="method" line="1298">
			<f a="owner:handleNewFilesPreviousFiles">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newFiles:previousFiles">
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>assetFilesChange event</haxe_doc>
		</onceAssetFilesChange>
		<offAssetFilesChange public="1" set="method" line="1368">
			<f a="?handleNewFilesPreviousFiles">
				<f a="newFiles:previousFiles">
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>assetFilesChange event</haxe_doc>
		</offAssetFilesChange>
		<listensAssetFilesChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to assetFilesChange event</haxe_doc>
		</listensAssetFilesChange>
		<addedAssets expr="[]">
			<c path="Array"><c path="ceramic.Asset"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</addedAssets>
		<assetsByKindAndName expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<c path="ceramic.Asset"/>
				</t>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</assetsByKindAndName>
		<immediate public="1" set="null" expr="new Immediate()">
			<c path="ceramic.Immediate"/>
			<meta><m n=":value"><e>new Immediate()</e></m></meta>
		</immediate>
		<runtimeAssets public="1" expr="null">
			<c path="ceramic.RuntimeAssets"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If set, will be provided to each added asset in this `Assets` instance.</haxe_doc>
		</runtimeAssets>
		<defaultImageOptions public="1" expr="null">
			<t path="ceramic.AssetOptions"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</defaultImageOptions>
		<loadMethod public="1" expr="SYNC">
			<x path="ceramic.AssetsLoadMethod"/>
			<meta><m n=":value"><e>SYNC</e></m></meta>
		</loadMethod>
		<scheduleMethod public="1" expr="PARALLEL">
			<x path="ceramic.AssetsScheduleMethod"/>
			<meta><m n=":value"><e>PARALLEL</e></m></meta>
		</scheduleMethod>
		<delayBetweenXAssets public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</delayBetweenXAssets>
		<reloadOnTextureDensityChange public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</reloadOnTextureDensityChange>
		<parent public="1" expr="null">
			<c path="ceramic.Assets"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If provided, when requesting an asset, it will also check if the parent `Assets`
     * instance has it and return it if that's the case.</haxe_doc>
		</parent>
		<atlasPacker public="1" expr="null">
			<c path="ceramic.TextureAtlasPacker"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* A shared texture atlas packer that can be used to merge smaller textures together.
     * Also required when loading some kind of assets, like `.ase`/`.aseprite` files.</haxe_doc>
		</atlasPacker>
		<pendingAtlasPackers expr="null">
			<c path="Array"><c path="ceramic.TextureAtlasPacker"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</pendingAtlasPackers>
		<destroy public="1" set="method" line="107" override="1"><f a=""><x path="Void"/></f></destroy>
		<flush public="1" set="method" line="139">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroy assets that have their refCount at `0`.</haxe_doc>
		</flush>
		<add public="1" set="method" line="157"><f a="id:?variant:?options">
	<x path="ceramic.AssetId"><d/></x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></add>
		<addAll public="1" set="method" line="193">
			<f a="?pathPattern">
				<c path="EReg"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add all assets matching given path pattern (if provided)
     * @param pathPattern</haxe_doc>
		</addAll>
		<addImage public="1" set="method" line="335"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addImage>
		<addFont public="1" set="method" line="342"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addFont>
		<addAtlas public="1" set="method" line="349"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addAtlas>
		<addText public="1" set="method" line="356"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addText>
		<addBinary public="1" set="method" line="363"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addBinary>
		<addSound public="1" set="method" line="370"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addSound>
		<addDatabase public="1" set="method" line="377"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addDatabase>
		<addFragments public="1" set="method" line="384"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addFragments>
		<addShader public="1" set="method" line="391"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addShader>
		<addAsset public="1" set="method" line="401">
			<f a="asset">
				<c path="ceramic.Asset"/>
				<c path="ceramic.Asset"/>
			</f>
			<haxe_doc>* Add the given asset. If a previous asset was replaced, return it.</haxe_doc>
		</addAsset>
		<assetDestroyed set="method" line="441"><f a="_">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></assetDestroyed>
		<imageAsset public="1" set="method" line="458"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.ImageAsset"/>
</f></imageAsset>
		<fontAsset public="1" set="method" line="462"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.FontAsset"/>
</f></fontAsset>
		<atlasAsset public="1" set="method" line="466"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.AtlasAsset"/>
</f></atlasAsset>
		<textAsset public="1" set="method" line="470"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.TextAsset"/>
</f></textAsset>
		<soundAsset public="1" set="method" line="474"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.SoundAsset"/>
</f></soundAsset>
		<databaseAsset public="1" set="method" line="478"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.DatabaseAsset"/>
</f></databaseAsset>
		<fragmentsAsset public="1" set="method" line="482"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.FragmentsAsset"/>
</f></fragmentsAsset>
		<shaderAsset public="1" set="method" line="486"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.ShaderAsset"/>
</f></shaderAsset>
		<asset public="1" set="method" line="490"><f a="idOrName:?kind:?variant">
	<d/>
	<c path="String"/>
	<c path="String"/>
	<c path="ceramic.Asset"/>
</f></asset>
		<removeAsset public="1" set="method" line="513"><f a="asset">
	<c path="ceramic.Asset"/>
	<x path="Void"/>
</f></removeAsset>
		<hasAnythingToLoad public="1" set="method" line="536">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if there are assets that should be loaded
     * @return Bool</haxe_doc>
		</hasAnythingToLoad>
		<countAssetsWithStatus public="1" set="method" line="549"><f a="status">
	<e path="ceramic.AssetStatus"/>
	<x path="Int"/>
</f></countAssetsWithStatus>
		<load public="1" set="method" line="562">
			<f a="?warnIfNothingToLoad:?pos" v="true:">
				<x path="Bool"/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ warnIfNothingToLoad : true }</e></m></meta>
		</load>
		<_prepareComplete set="method" line="652"><f a="allSuccess">
	<x path="Bool"/>
	<x path="Void"/>
</f></_prepareComplete>
		<_packNextAtlasPacker set="method" line="663"><f a="done">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></_packNextAtlasPacker>
		<addPendingAtlasPacker set="method" line="670"><f a="atlasPacker">
	<c path="ceramic.TextureAtlasPacker"/>
	<x path="Void"/>
</f></addPendingAtlasPacker>
		<_loadNextSerial set="method" line="680"><f a="toLoad:numComplete">
	<c path="Array"><c path="ceramic.Asset"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></_loadNextSerial>
		<_assetCompleteSerial set="method" line="697"><f a="success:toLoad:numComplete">
	<x path="Bool"/>
	<c path="Array"><c path="ceramic.Asset"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></_assetCompleteSerial>
		<_loadNextParallel set="method" line="713"><f a="toLoad:numStarted">
	<c path="Array"><c path="ceramic.Asset"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></_loadNextParallel>
		<ensure public="1" set="method" line="740">
			<f a="id:?variant:?options:done">
				<x path="ceramic.AssetId"><d/></x>
				<c path="String"/>
				<x path="Null"><t path="ceramic.AssetOptions"/></x>
				<f a="">
					<c path="ceramic.Asset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Ensures and asset is loaded and return it on the callback.
     * This will check if the requested asset is currently being loaded,
     * already loaded or should be added and loaded. In all cases, it will try
     * its best to deliver the requested asset or `null` if something went wrong.</haxe_doc>
		</ensure>
		<ensureImage public="1" set="method" line="789"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.ImageAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureImage>
		<ensureFont public="1" set="method" line="799"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.FontAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureFont>
		<ensureAtlas public="1" set="method" line="809"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.AtlasAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureAtlas>
		<ensureText public="1" set="method" line="819"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.TextAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureText>
		<ensureSound public="1" set="method" line="829"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.SoundAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureSound>
		<ensureDatabase public="1" set="method" line="839"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.DatabaseAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureDatabase>
		<ensureShader public="1" set="method" line="849"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.ShaderAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureShader>
		<texture public="1" set="method" line="861"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.Texture"/>
</f></texture>
		<font public="1" set="method" line="875"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.BitmapFont"/>
</f></font>
		<atlas public="1" set="method" line="889"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.TextureAtlas"/>
</f></atlas>
		<sound public="1" set="method" line="903"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.Sound"/>
</f></sound>
		<text public="1" set="method" line="917"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="String"/>
</f></text>
		<bytes public="1" set="method" line="931"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></bytes>
		<shader public="1" set="method" line="945"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.Shader"/>
</f></shader>
		<database public="1" set="method" line="959"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
</f></database>
		<fragments public="1" set="method" line="973"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
</f></fragments>
		<iterator public="1" set="method" line="989"><f a=""><t path="Iterator"><c path="ceramic.Asset"/></t></f></iterator>
		<hotReload public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Set to `true` to enable hot reload.
     * Note: this won't do anything unless used in pair with `watchDirectory(path)`</haxe_doc>
		</hotReload>
		<set_hotReload set="method" line="1011"><f a="hotReload">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_hotReload>
		<watchDirectory public="1" set="method" line="1033">
			<f a="?path:?hotReload" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="ceramic.WatchDirectory"/>
			</f>
			<meta><m n=":value"><e>{ hotReload : true }</e></m></meta>
			<haxe_doc>* Watch the given asset directory. Any change will fire `assetFilesChange` event.
     * If `hotReload` is set to `true` (its default), related assets will be hot reloaded
     * when their file changes on disk.
     * Behavior may differ depending on the platfom.
     * When using web target via electron, be sure to add `ceramic_use_electron` define.
     * @param path
     *     The assets path to watch. You could use `ceramic.macros.DefinesMacro.getDefine('assets_path')`
     *     to watch default asset path in project. It's the path that will be used if none is provided
     * @param hotReload
     *     `true` by default. Will enable hot reload of assets when related file changes on disk
     * @return WatchDirectory instance used internally</haxe_doc>
		</watchDirectory>
		<inheritRuntimeAssetsFromAssets public="1" set="method" line="1110">
			<f a="assets">
				<c path="ceramic.Assets"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Inherit runtime asset settings from parent assets instance.
     * Used internally to make sure sub-instances of `Assets` take owner live reload settings and related
     * @param assets</haxe_doc>
		</inheritRuntimeAssetsFromAssets>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="81"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.Asset</e></m>
		</meta>
	</class>
	<class path="assets.AllAssets" params="" file="/home/runner/work/api-docs/api-docs/gen/assets/AllAssets.hx">
		<bind public="1" set="method" line="16" static="1"><f a=""><x path="Void"/></f></bind>
		<all public="1" set="null" expr="[&quot;ceramic@2x.png&quot;, &quot;ceramic.png&quot;, &quot;fxaa.frag&quot;, &quot;blur.vert&quot;, &quot;fxaa.vert&quot;, &quot;tintBlack.frag&quot;, &quot;outline.vert&quot;, &quot;bloom.frag&quot;, &quot;tintBlack.vert&quot;, &quot;msdf.frag&quot;, &quot;glow.frag&quot;, &quot;pixelArt.frag&quot;, &quot;bloom.vert&quot;, &quot;innerLight.frag&quot;, &quot;textured.vert&quot;, &quot;blur.frag&quot;, &quot;pixelArt.vert&quot;, &quot;gaussianBlur.frag&quot;, &quot;glow.vert&quot;, &quot;outline.frag&quot;, &quot;textured.frag&quot;, &quot;msdf.vert&quot;, &quot;RobotoMedium.png&quot;, &quot;RobotoMedium.fnt&quot;, &quot;white.png&quot;]" line="6" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["ceramic@2x.png", "ceramic.png", "fxaa.frag", "blur.vert", "fxaa.vert", "tintBlack.frag", "outline.vert", "bloom.frag", "tintBlack.vert", "msdf.frag", "glow.frag", "pixelArt.frag", "bloom.vert", "innerLight.frag", "textured.vert", "blur.frag", "pixelArt.vert", "gaussianBlur.frag", "glow.vert", "outline.frag", "textured.frag", "msdf.vert", "RobotoMedium.png", "RobotoMedium.fnt", "white.png"]</e></m></meta>
			<haxe_doc>All asset file paths array</haxe_doc>
		</all>
		<allDirs public="1" set="null" expr="[]" line="6" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>All asset directory paths array</haxe_doc>
		</allDirs>
		<allByName public="1" set="null" expr="[&quot;white&quot; =&gt; [&quot;white.png&quot;], &quot;tintBlack&quot; =&gt; [&quot;tintBlack.frag&quot;, &quot;tintBlack.vert&quot;], &quot;textured&quot; =&gt; [&quot;textured.vert&quot;, &quot;textured.frag&quot;], &quot;pixelArt&quot; =&gt; [&quot;pixelArt.frag&quot;, &quot;pixelArt.vert&quot;], &quot;outline&quot; =&gt; [&quot;outline.vert&quot;, &quot;outline.frag&quot;], &quot;msdf&quot; =&gt; [&quot;msdf.frag&quot;, &quot;msdf.vert&quot;], &quot;innerLight&quot; =&gt; [&quot;innerLight.frag&quot;], &quot;glow&quot; =&gt; [&quot;glow.frag&quot;, &quot;glow.vert&quot;], &quot;gaussianBlur&quot; =&gt; [&quot;gaussianBlur.frag&quot;], &quot;fxaa&quot; =&gt; [&quot;fxaa.frag&quot;, &quot;fxaa.vert&quot;], &quot;ceramic&quot; =&gt; [&quot;ceramic@2x.png&quot;, &quot;ceramic.png&quot;], &quot;blur&quot; =&gt; [&quot;blur.vert&quot;, &quot;blur.frag&quot;], &quot;bloom&quot; =&gt; [&quot;bloom.frag&quot;, &quot;bloom.vert&quot;], &quot;RobotoMedium&quot; =&gt; [&quot;RobotoMedium.png&quot;, &quot;RobotoMedium.fnt&quot;]]" line="6" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</t>
			<meta><m n=":value"><e><![CDATA[["white" => ["white.png"], "tintBlack" => ["tintBlack.frag", "tintBlack.vert"], "textured" => ["textured.vert", "textured.frag"], "pixelArt" => ["pixelArt.frag", "pixelArt.vert"], "outline" => ["outline.vert", "outline.frag"], "msdf" => ["msdf.frag", "msdf.vert"], "innerLight" => ["innerLight.frag"], "glow" => ["glow.frag", "glow.vert"], "gaussianBlur" => ["gaussianBlur.frag"], "fxaa" => ["fxaa.frag", "fxaa.vert"], "ceramic" => ["ceramic@2x.png", "ceramic.png"], "blur" => ["blur.vert", "blur.frag"], "bloom" => ["bloom.frag", "bloom.vert"], "RobotoMedium" => ["RobotoMedium.png", "RobotoMedium.fnt"]]]]></e></m></meta>
			<haxe_doc>Assets by base name</haxe_doc>
		</allByName>
		<allDirsByName public="1" set="null" expr="new Map()" line="231" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
			<haxe_doc>Asset directories by base name</haxe_doc>
		</allDirsByName>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.AssetsMacro.buildLists()</e></m>
		</meta>
	</class>
	<class path="spec.Audio" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Audio.hx" interface="1">
		<load public="1" set="method"><f a="path:?options:done">
	<c path="String"/>
	<x path="Null"><t path="backend.LoadAudioOptions"/></x>
	<f a="">
		<t path="backend.AudioResource"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<supportsHotReloadPath public="1" set="method"><f a=""><x path="Bool"/></f></supportsHotReloadPath>
		<getDuration public="1" set="method"><f a="audio">
	<t path="backend.AudioResource"/>
	<x path="Float"/>
</f></getDuration>
		<resumeAudioContext public="1" set="method"><f a="done">
	<f a="">
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></resumeAudioContext>
		<destroy public="1" set="method"><f a="audio">
	<t path="backend.AudioResource"/>
	<x path="Void"/>
</f></destroy>
		<mute public="1" set="method"><f a="audio">
	<t path="backend.AudioResource"/>
	<t path="backend.AudioHandle"/>
</f></mute>
		<play public="1" set="method">
			<f a="audio:?volume:?pan:?pitch:?position:?loop" v=":0.5:0:1:0:false">
				<t path="backend.AudioResource"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="backend.AudioHandle"/>
			</f>
			<meta><m n=":value"><e>{ loop : false, position : 0, pitch : 1, pan : 0, volume : 0.5 }</e></m></meta>
		</play>
		<pause public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Void"/>
</f></pause>
		<resume public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Void"/>
</f></resume>
		<stop public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Void"/>
</f></stop>
		<getVolume public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getVolume>
		<setVolume public="1" set="method"><f a="handle:volume">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVolume>
		<getPan public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getPan>
		<setPan public="1" set="method"><f a="handle:pan">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPan>
		<getPitch public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getPitch>
		<setPitch public="1" set="method"><f a="handle:pitch">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPitch>
		<getPosition public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getPosition>
		<setPosition public="1" set="method"><f a="handle:position">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
	</class>
	<class path="backend.Audio" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Audio.hx">
		<implements path="spec.Audio"/>
		<load public="1" set="method" line="15"><f a="path:?options:_done">
	<c path="String"/>
	<x path="Null"><t path="backend.LoadAudioOptions"/></x>
	<f a="">
		<t path="backend.AudioResource"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<supportsHotReloadPath public="1" get="inline" set="null" line="28"><f a=""><x path="Bool"/></f></supportsHotReloadPath>
		<getDuration public="1" get="inline" set="null" line="34"><f a="audio">
	<t path="backend.AudioResource"/>
	<x path="Float"/>
</f></getDuration>
		<resumeAudioContext public="1" get="inline" set="null" line="40"><f a="done">
	<f a="">
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></resumeAudioContext>
		<destroy public="1" get="inline" set="null" line="46"><f a="audio">
	<t path="backend.AudioResource"/>
	<x path="Void"/>
</f></destroy>
		<mute public="1" get="inline" set="null" line="52"><f a="audio">
	<t path="backend.AudioResource"/>
	<t path="backend.AudioHandle"/>
</f></mute>
		<play public="1" set="method" line="58">
			<f a="audio:?volume:?pan:?pitch:?position:?loop" v=":0.5:0:1:0:false">
				<t path="backend.AudioResource"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="backend.AudioHandle"/>
			</f>
			<meta><m n=":value"><e>{ loop : false, position : 0, pitch : 1, pan : 0, volume : 0.5 }</e></m></meta>
		</play>
		<pause public="1" set="method" line="70"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Void"/>
</f></pause>
		<resume public="1" set="method" line="76"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Void"/>
</f></resume>
		<stop public="1" set="method" line="82"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Void"/>
</f></stop>
		<getVolume public="1" set="method" line="88"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getVolume>
		<setVolume public="1" set="method" line="94"><f a="handle:volume">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVolume>
		<getPan public="1" set="method" line="100"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getPan>
		<setPan public="1" set="method" line="106"><f a="handle:pan">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPan>
		<getPitch public="1" set="method" line="112"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getPitch>
		<setPitch public="1" set="method" line="118"><f a="handle:pitch">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPitch>
		<getPosition public="1" set="method" line="124"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getPosition>
		<setPosition public="1" set="method" line="130"><f a="handle:position">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="backend.AudioHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/AudioHandle.hx"><c path="backend.AudioHandleImpl"/></typedef>
	<class path="backend.AudioHandleImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/AudioHandleImpl.hx">
		<volume public="1" expr="0.5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</volume>
		<pan public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pan>
		<pitch public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</pitch>
		<position public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</position>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="backend.AudioResource" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/AudioResource.hx"><c path="backend.AudioResourceImpl"/></typedef>
	<class path="backend.AudioResourceImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/AudioResourceImpl.hx">
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spec.Backend" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Backend.hx" interface="1">
		<init public="1" set="method"><f a="app">
	<c path="ceramic.App"/>
	<x path="Void"/>
</f></init>
		<setTargetFps public="1" set="method"><f a="fps">
	<x path="Int"/>
	<x path="Void"/>
</f></setTargetFps>
		<io public="1" set="null"><c path="backend.IO"/></io>
		<info public="1" set="null"><c path="backend.Info"/></info>
		<audio public="1" set="null"><c path="backend.Audio"/></audio>
		<draw public="1" set="null"><c path="backend.Draw"/></draw>
		<texts public="1" set="null"><c path="backend.Texts"/></texts>
		<binaries public="1" set="null"><c path="backend.Binaries"/></binaries>
		<textures public="1" set="null"><c path="backend.Textures"/></textures>
		<screen public="1" set="null"><c path="backend.Screen"/></screen>
		<textInput public="1" set="null"><c path="backend.TextInput"/></textInput>
		<clipboard public="1" set="null"><c path="backend.Clipboard"/></clipboard>
	</class>
	<class path="backend.Backend" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Backend.hx">
		<implements path="spec.Backend"/>
		<implements path="tracker.Events"/>
		<io public="1" set="null" expr="new backend.IO()">
			<c path="backend.IO"/>
			<meta><m n=":value"><e>new backend.IO()</e></m></meta>
		</io>
		<info public="1" set="null" expr="new backend.Info()">
			<c path="backend.Info"/>
			<meta><m n=":value"><e>new backend.Info()</e></m></meta>
		</info>
		<audio public="1" set="null" expr="new backend.Audio()">
			<c path="backend.Audio"/>
			<meta><m n=":value"><e>new backend.Audio()</e></m></meta>
		</audio>
		<draw public="1" set="null" expr="new backend.Draw()">
			<c path="backend.Draw"/>
			<meta><m n=":value"><e>new backend.Draw()</e></m></meta>
		</draw>
		<texts public="1" set="null" expr="new backend.Texts()">
			<c path="backend.Texts"/>
			<meta><m n=":value"><e>new backend.Texts()</e></m></meta>
		</texts>
		<binaries public="1" set="null" expr="new backend.Binaries()">
			<c path="backend.Binaries"/>
			<meta><m n=":value"><e>new backend.Binaries()</e></m></meta>
		</binaries>
		<textures public="1" set="null" expr="new backend.Textures()">
			<c path="backend.Textures"/>
			<meta><m n=":value"><e>new backend.Textures()</e></m></meta>
		</textures>
		<shaders public="1" set="null" expr="new backend.Shaders()">
			<c path="backend.Shaders"/>
			<meta><m n=":value"><e>new backend.Shaders()</e></m></meta>
		</shaders>
		<screen public="1" set="null" expr="new backend.Screen()">
			<c path="backend.Screen"/>
			<meta><m n=":value"><e>new backend.Screen()</e></m></meta>
		</screen>
		<input public="1" set="null" expr="new backend.Input()">
			<c path="backend.Input"/>
			<meta><m n=":value"><e>new backend.Input()</e></m></meta>
		</input>
		<textInput public="1" set="null" expr="new backend.TextInput()">
			<c path="backend.TextInput"/>
			<meta><m n=":value"><e>new backend.TextInput()</e></m></meta>
		</textInput>
		<clipboard public="1" set="null" expr="new backend.Clipboard()">
			<c path="backend.Clipboard"/>
			<meta><m n=":value"><e>new backend.Clipboard()</e></m></meta>
		</clipboard>
		<init public="1" set="method" line="39"><f a="app">
	<c path="ceramic.App"/>
	<x path="Void"/>
</f></init>
		<setTargetFps public="1" set="method" line="43"><f a="fps">
	<x path="Int"/>
	<x path="Void"/>
</f></setTargetFps>
		<_dox_event_ready public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_ready>
		<emitReady set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>ready event</haxe_doc>
		</emitReady>
		<onReady public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>ready event</haxe_doc>
		</onReady>
		<onceReady public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>ready event</haxe_doc>
		</onceReady>
		<offReady public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>ready event</haxe_doc>
		</offReady>
		<listensReady public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to ready event</haxe_doc>
		</listensReady>
		<_dox_event_update public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_update>
		<emitUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>update event</haxe_doc>
		</emitUpdate>
		<onUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onUpdate>
		<onceUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onceUpdate>
		<offUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</offUpdate>
		<listensUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to update event</haxe_doc>
		</listensUpdate>
		<_dox_event_render public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_render>
		<emitRender set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>render event</haxe_doc>
		</emitRender>
		<onRender public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>render event</haxe_doc>
		</onRender>
		<onceRender public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>render event</haxe_doc>
		</onceRender>
		<offRender public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>render event</haxe_doc>
		</offRender>
		<listensRender public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to render event</haxe_doc>
		</listensRender>
		<willEmitUpdate get="inline" set="null" line="59"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitUpdate>
		<didEmitUpdate get="inline" set="null" line="65"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></didEmitUpdate>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="37"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>Main</e></m>
			<m n=":allow"><e>backend.Textures</e></m>
		</meta>
	</class>
	<class path="spec.Binaries" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Binaries.hx" interface="1">
		<load public="1" set="method"><f a="path:?options:done">
	<c path="String"/>
	<x path="Null"><t path="backend.LoadBinaryOptions"/></x>
	<f a="">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<supportsHotReloadPath public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if paths with `?hot=...` are supported on this backend
     * @return Bool</haxe_doc>
		</supportsHotReloadPath>
	</class>
	<class path="backend.Binaries" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Binaries.hx">
		<implements path="spec.Binaries"/>
		<load public="1" set="method" line="17"><f a="path:?options:_done">
	<c path="String"/>
	<x path="Null"><t path="backend.LoadBinaryOptions"/></x>
	<f a="">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<supportsHotReloadPath public="1" get="inline" set="null" line="61"><f a=""><x path="Bool"/></f></supportsHotReloadPath>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="backend.BlendMode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/BlendMode.hx"><x path="backend.BlendModeImpl"/></typedef>
	<abstract path="backend.BlendModeImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/BlendMode.hx" module="backend.BlendMode">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="backend._BlendMode.BlendModeImpl_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/BlendMode.hx" private="1" module="backend.BlendMode" extern="1" final="1">
	<ZERO public="1" get="inline" set="null" expr="cast 0" line="9" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ZERO>
	<ONE public="1" get="inline" set="null" expr="cast 1" line="10" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ONE>
	<SRC_COLOR public="1" get="inline" set="null" expr="cast 2" line="11" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SRC_COLOR>
	<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" expr="cast 3" line="12" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ONE_MINUS_SRC_COLOR>
	<SRC_ALPHA public="1" get="inline" set="null" expr="cast 4" line="13" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SRC_ALPHA>
	<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" expr="cast 5" line="14" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ONE_MINUS_SRC_ALPHA>
	<DST_ALPHA public="1" get="inline" set="null" expr="cast 6" line="15" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DST_ALPHA>
	<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" expr="cast 7" line="16" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ONE_MINUS_DST_ALPHA>
	<DST_COLOR public="1" get="inline" set="null" expr="cast 8" line="17" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DST_COLOR>
	<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" expr="cast 9" line="18" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ONE_MINUS_DST_COLOR>
	<SRC_ALPHA_SATURATE public="1" get="inline" set="null" expr="cast 10" line="19" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SRC_ALPHA_SATURATE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="backend._BlendMode.BlendModeImpl_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/BlendMode.hx" private="1" module="backend.BlendMode" extern="1" final="1">
		<ZERO public="1" get="inline" set="null" expr="cast 0" line="9" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ZERO>
		<ONE public="1" get="inline" set="null" expr="cast 1" line="10" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ONE>
		<SRC_COLOR public="1" get="inline" set="null" expr="cast 2" line="11" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" expr="cast 3" line="12" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1" get="inline" set="null" expr="cast 4" line="13" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" expr="cast 5" line="14" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1" get="inline" set="null" expr="cast 6" line="15" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" expr="cast 7" line="16" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1" get="inline" set="null" expr="cast 8" line="17" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" expr="cast 9" line="18" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1" get="inline" set="null" expr="cast 10" line="19" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SRC_ALPHA_SATURATE>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="spec.Clipboard" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Clipboard.hx" interface="1">
		<getText public="1" set="method"><f a=""><c path="String"/></f></getText>
		<setText public="1" set="method"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></setText>
	</class>
	<class path="backend.Clipboard" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Clipboard.hx">
		<implements path="spec.Clipboard"/>
		<clipboardText expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</clipboardText>
		<getText public="1" set="method" line="9"><f a=""><c path="String"/></f></getText>
		<setText public="1" set="method" line="15"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></setText>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="backend.Draw" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Draw.hx">
		<MAX_VERTS_SIZE get="inline" set="null" expr="65536" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65536</e></m></meta>
		</MAX_VERTS_SIZE>
		<MAX_INDICES get="inline" set="null" expr="16384" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16384</e></m></meta>
		</MAX_INDICES>
		<_vertexSize expr="0" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_vertexSize>
		<_numIndices expr="0" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numIndices>
		<_numPos expr="0" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numPos>
		<_posIndex expr="0" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_posIndex>
		<_numUVs expr="0" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numUVs>
		<_uvIndex expr="0" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_uvIndex>
		<_numColors expr="0" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numColors>
		<_colorIndex expr="0" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_colorIndex>
		<_floatAttributesIndex expr="0" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_floatAttributesIndex>
		<_currentShader static="1"><c path="backend.ShaderImpl"/></_currentShader>
		<_maxVerts expr="0" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_maxVerts>
		<_activeTextureSlot expr="0" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_activeTextureSlot>
		<getItem public="1" get="inline" set="null" line="35"><f a="visual">
	<c path="ceramic.Visual"/>
	<e path="backend.VisualItem"/>
</f></getItem>
		<draw public="1" set="method" line="55"><f a="visuals">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Void"/>
</f></draw>
		<swap public="1" set="method" line="61"><f a=""><x path="Void"/></f></swap>
		<initBuffers public="1" get="inline" set="null" line="69"><f a=""><x path="Void"/></f></initBuffers>
		<beginRender public="1" get="inline" set="null" line="75"><f a=""><x path="Void"/></f></beginRender>
		<setRenderTarget public="1" get="inline" set="null" line="81">
			<f a="renderTarget:?force" v=":false">
				<c path="ceramic.RenderTexture"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</setRenderTarget>
		<useShader public="1" get="inline" set="null" line="87"><f a="shader">
	<c path="backend.ShaderImpl"/>
	<x path="Void"/>
</f></useShader>
		<clear public="1" get="inline" set="null" line="104"><f a=""><x path="Void"/></f></clear>
		<enableBlending public="1" get="inline" set="null" line="110"><f a=""><x path="Void"/></f></enableBlending>
		<disableBlending public="1" get="inline" set="null" line="116"><f a=""><x path="Void"/></f></disableBlending>
		<setBlendFuncSeparate public="1" get="inline" set="null" line="122"><f a="srcRgb:dstRgb:srcAlpha:dstAlpha">
	<t path="backend.BlendMode"/>
	<t path="backend.BlendMode"/>
	<t path="backend.BlendMode"/>
	<t path="backend.BlendMode"/>
	<x path="Void"/>
</f></setBlendFuncSeparate>
		<getActiveTexture public="1" get="inline" set="null" line="128"><f a=""><x path="Int"/></f></getActiveTexture>
		<setActiveTexture public="1" get="inline" set="null" line="134"><f a="slot">
	<x path="Int"/>
	<x path="Void"/>
</f></setActiveTexture>
		<textureBackendItemMatchesId public="1" get="inline" set="null" line="140"><f a="backendItem:textureId">
	<t path="backend.Texture"/>
	<t path="backend.TextureId"/>
	<x path="Bool"/>
</f></textureBackendItemMatchesId>
		<getTextureId public="1" get="inline" set="null" line="146"><f a="backendItem">
	<t path="backend.Texture"/>
	<t path="backend.TextureId"/>
</f></getTextureId>
		<getTextureWidth public="1" get="inline" set="null" line="152"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureWidth>
		<getTextureHeight public="1" get="inline" set="null" line="158"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureHeight>
		<getTextureWidthActual public="1" get="inline" set="null" line="164"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureWidthActual>
		<getTextureHeightActual public="1" get="inline" set="null" line="170"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureHeightActual>
		<bindTexture public="1" get="inline" set="null" line="176"><f a="backendItem">
	<t path="backend.Texture"/>
	<x path="Void"/>
</f></bindTexture>
		<bindNoTexture public="1" get="inline" set="null" line="182"><f a=""><x path="Void"/></f></bindNoTexture>
		<setPrimitiveType public="1" get="inline" set="null" line="188"><f a="primitiveType">
	<x path="ceramic.RenderPrimitiveType"/>
	<x path="Void"/>
</f></setPrimitiveType>
		<beginDrawQuad public="1" get="inline" set="null" line="194"><f a="quad">
	<c path="ceramic.Quad"/>
	<x path="Void"/>
</f></beginDrawQuad>
		<endDrawQuad public="1" get="inline" set="null" line="200"><f a=""><x path="Void"/></f></endDrawQuad>
		<beginDrawMesh public="1" get="inline" set="null" line="206"><f a="mesh">
	<c path="ceramic.Mesh"/>
	<x path="Void"/>
</f></beginDrawMesh>
		<endDrawMesh public="1" get="inline" set="null" line="212"><f a=""><x path="Void"/></f></endDrawMesh>
		<enableScissor public="1" get="inline" set="null" line="218"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></enableScissor>
		<disableScissor public="1" get="inline" set="null" line="224"><f a=""><x path="Void"/></f></disableScissor>
		<beginDrawingInStencilBuffer public="1" get="inline" set="null" line="230"><f a=""><x path="Void"/></f></beginDrawingInStencilBuffer>
		<endDrawingInStencilBuffer public="1" get="inline" set="null" line="236"><f a=""><x path="Void"/></f></endDrawingInStencilBuffer>
		<drawWithStencilTest public="1" get="inline" set="null" line="242"><f a=""><x path="Void"/></f></drawWithStencilTest>
		<drawWithoutStencilTest public="1" get="inline" set="null" line="248"><f a=""><x path="Void"/></f></drawWithoutStencilTest>
		<getNumPos public="1" get="inline" set="null" line="254"><f a=""><x path="Int"/></f></getNumPos>
		<putPos public="1" get="inline" set="null" line="260"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putPos>
		<putPosAndTextureSlot public="1" get="inline" set="null" line="267"><f a="x:y:z:textureSlot">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putPosAndTextureSlot>
		<putIndice public="1" get="inline" set="null" line="274"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></putIndice>
		<putUVs public="1" get="inline" set="null" line="280"><f a="uvX:uvY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putUVs>
		<putColor public="1" get="inline" set="null" line="287"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putColor>
		<beginFloatAttributes public="1" get="inline" set="null" line="294"><f a=""><x path="Void"/></f></beginFloatAttributes>
		<putFloatAttribute public="1" get="inline" set="null" line="300"><f a="index:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putFloatAttribute>
		<endFloatAttributes public="1" get="inline" set="null" line="306"><f a=""><x path="Void"/></f></endFloatAttributes>
		<clearAndApplyBackground public="1" get="inline" set="null" line="312"><f a=""><x path="Void"/></f></clearAndApplyBackground>
		<shouldFlush public="1" get="inline" set="null" line="318"><f a="numVerticesAfter:numIndicesAfter:customFloatAttributesSize">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></shouldFlush>
		<remainingVertices public="1" get="inline" set="null" line="324"><f a=""><x path="Int"/></f></remainingVertices>
		<remainingIndices public="1" get="inline" set="null" line="330"><f a=""><x path="Int"/></f></remainingIndices>
		<hasAnythingToFlush public="1" get="inline" set="null" line="336"><f a=""><x path="Bool"/></f></hasAnythingToFlush>
		<flush public="1" get="inline" set="null" line="342"><f a=""><x path="Void"/></f></flush>
		<resetIndexes get="inline" set="null" line="348"><f a=""><x path="Void"/></f></resetIndexes>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>backend.Backend</e></m>
		</meta>
	</class>
	<typedef path="backend.Float32Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Float32Array.hx"><x path="backend.Float32ArrayImplHeadless"/></typedef>
	<abstract path="backend.Float32ArrayImplHeadless" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Float32Array.hx" module="backend.Float32Array">
		<from><icast><c path="Array"><x path="Float"/></c></icast></from>
		<this><c path="Array"><x path="Float"/></c></this>
		<to><icast><c path="Array"><x path="Float"/></c></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="backend._Float32Array.Float32ArrayImplHeadless_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Float32Array.hx" private="1" module="backend.Float32Array" final="1"><_new public="1" set="method" line="8" static="1">
	<f a="size">
		<x path="Int"/>
		<x path="backend.Float32ArrayImplHeadless"/>
	</f>
	<meta><m n=":noCompletion"/></meta>
</_new></class></impl>
	</abstract>
	<class path="backend._Float32Array.Float32ArrayImplHeadless_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Float32Array.hx" private="1" module="backend.Float32Array" final="1"><_new public="1" set="method" line="8" static="1">
	<f a="size">
		<x path="Int"/>
		<x path="backend.Float32ArrayImplHeadless"/>
	</f>
	<meta><m n=":noCompletion"/></meta>
</_new></class>
	<class path="spec.IO" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/IO.hx" interface="1">
		<saveString public="1" set="method"><f a="key:str">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></saveString>
		<appendString public="1" set="method"><f a="key:str">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></appendString>
		<readString public="1" set="method"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></readString>
	</class>
	<class path="backend.IO" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/IO.hx">
		<implements path="spec.IO"/>
		<saveString public="1" set="method" line="9"><f a="key:str">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></saveString>
		<appendString public="1" set="method" line="15"><f a="key:str">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></appendString>
		<readString public="1" set="method" line="21"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></readString>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="backend.Info" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Info.hx">
		<storageDirectory public="1" get="inline" set="null" line="9"><f a=""><c path="String"/></f></storageDirectory>
		<imageExtensions public="1" get="inline" set="null" line="15"><f a=""><c path="Array"><c path="String"/></c></f></imageExtensions>
		<textExtensions public="1" get="inline" set="null" line="19"><f a=""><c path="Array"><c path="String"/></c></f></textExtensions>
		<soundExtensions public="1" get="inline" set="null" line="23"><f a=""><c path="Array"><c path="String"/></c></f></soundExtensions>
		<shaderExtensions public="1" get="inline" set="null" line="27"><f a=""><c path="Array"><c path="String"/></c></f></shaderExtensions>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spec.Input" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Input.hx" interface="1"/>
	<class path="backend.Input" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Input.hx">
		<implements path="spec.Input"/>
		<implements path="tracker.Events"/>
		<_dox_event_keyDown public="1" set="method" line="637">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_keyDown>
		<emitKeyDown set="method" line="1095">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<haxe_doc>keyDown event</haxe_doc>
		</emitKeyDown>
		<onKeyDown public="1" set="method" line="1199">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>keyDown event</haxe_doc>
		</onKeyDown>
		<onceKeyDown public="1" set="method" line="1298">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>keyDown event</haxe_doc>
		</onceKeyDown>
		<offKeyDown public="1" set="method" line="1368">
			<f a="?handleKey">
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>keyDown event</haxe_doc>
		</offKeyDown>
		<listensKeyDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to keyDown event</haxe_doc>
		</listensKeyDown>
		<_dox_event_keyUp public="1" set="method" line="637">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_keyUp>
		<emitKeyUp set="method" line="1095">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<haxe_doc>keyUp event</haxe_doc>
		</emitKeyUp>
		<onKeyUp public="1" set="method" line="1199">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>keyUp event</haxe_doc>
		</onKeyUp>
		<onceKeyUp public="1" set="method" line="1298">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>keyUp event</haxe_doc>
		</onceKeyUp>
		<offKeyUp public="1" set="method" line="1368">
			<f a="?handleKey">
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>keyUp event</haxe_doc>
		</offKeyUp>
		<listensKeyUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to keyUp event</haxe_doc>
		</listensKeyUp>
		<_dox_event_gamepadAxis public="1" set="method" line="637">
			<f a="gamepadId:axisId:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadAxis>
		<emitGamepadAxis set="method" line="1095">
			<f a="gamepadId:axisId:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</emitGamepadAxis>
		<onGamepadAxis public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdAxisIdValue">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:axisId:value">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</onGamepadAxis>
		<onceGamepadAxis public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdAxisIdValue">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:axisId:value">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</onceGamepadAxis>
		<offGamepadAxis public="1" set="method" line="1368">
			<f a="?handleGamepadIdAxisIdValue">
				<f a="gamepadId:axisId:value">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</offGamepadAxis>
		<listensGamepadAxis public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadAxis event</haxe_doc>
		</listensGamepadAxis>
		<_dox_event_gamepadDown public="1" set="method" line="637">
			<f a="gamepadId:buttonId">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadDown>
		<emitGamepadDown set="method" line="1095">
			<f a="gamepadId:buttonId">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadDown event</haxe_doc>
		</emitGamepadDown>
		<onGamepadDown public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdButtonId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:buttonId">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDown event</haxe_doc>
		</onGamepadDown>
		<onceGamepadDown public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdButtonId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:buttonId">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDown event</haxe_doc>
		</onceGamepadDown>
		<offGamepadDown public="1" set="method" line="1368">
			<f a="?handleGamepadIdButtonId">
				<f a="gamepadId:buttonId">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDown event</haxe_doc>
		</offGamepadDown>
		<listensGamepadDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadDown event</haxe_doc>
		</listensGamepadDown>
		<_dox_event_gamepadUp public="1" set="method" line="637">
			<f a="gamepadId:buttonId">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadUp>
		<emitGamepadUp set="method" line="1095">
			<f a="gamepadId:buttonId">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadUp event</haxe_doc>
		</emitGamepadUp>
		<onGamepadUp public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdButtonId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:buttonId">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadUp event</haxe_doc>
		</onGamepadUp>
		<onceGamepadUp public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdButtonId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:buttonId">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadUp event</haxe_doc>
		</onceGamepadUp>
		<offGamepadUp public="1" set="method" line="1368">
			<f a="?handleGamepadIdButtonId">
				<f a="gamepadId:buttonId">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadUp event</haxe_doc>
		</offGamepadUp>
		<listensGamepadUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadUp event</haxe_doc>
		</listensGamepadUp>
		<_dox_event_gamepadGyro public="1" set="method" line="637">
			<f a="gamepadId:dx:dy:dz">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadGyro>
		<emitGamepadGyro set="method" line="1095">
			<f a="gamepadId:dx:dy:dz">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</emitGamepadGyro>
		<onGamepadGyro public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdDxDyDz">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:dx:dy:dz">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</onGamepadGyro>
		<onceGamepadGyro public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdDxDyDz">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:dx:dy:dz">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</onceGamepadGyro>
		<offGamepadGyro public="1" set="method" line="1368">
			<f a="?handleGamepadIdDxDyDz">
				<f a="gamepadId:dx:dy:dz">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</offGamepadGyro>
		<listensGamepadGyro public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadGyro event</haxe_doc>
		</listensGamepadGyro>
		<_dox_event_gamepadEnable public="1" set="method" line="637">
			<f a="gamepadId:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadEnable>
		<emitGamepadEnable set="method" line="1095">
			<f a="gamepadId:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</emitGamepadEnable>
		<onGamepadEnable public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</onGamepadEnable>
		<onceGamepadEnable public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</onceGamepadEnable>
		<offGamepadEnable public="1" set="method" line="1368">
			<f a="?handleGamepadIdName">
				<f a="gamepadId:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</offGamepadEnable>
		<listensGamepadEnable public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadEnable event</haxe_doc>
		</listensGamepadEnable>
		<_dox_event_gamepadDisable public="1" set="method" line="637">
			<f a="gamepadId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadDisable>
		<emitGamepadDisable set="method" line="1095">
			<f a="gamepadId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</emitGamepadDisable>
		<onGamepadDisable public="1" set="method" line="1199">
			<f a="owner:handleGamepadId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</onGamepadDisable>
		<onceGamepadDisable public="1" set="method" line="1298">
			<f a="owner:handleGamepadId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</onceGamepadDisable>
		<offGamepadDisable public="1" set="method" line="1368">
			<f a="?handleGamepadId">
				<f a="gamepadId">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</offGamepadDisable>
		<listensGamepadDisable public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadDisable event</haxe_doc>
		</listensGamepadDisable>
		<startGamepadRumble public="1" set="method" line="16"><f a="gamepadId:lowFrequency:highFrequency:duration">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></startGamepadRumble>
		<stopGamepadRumble public="1" set="method" line="20"><f a="gamepadId">
	<x path="Int"/>
	<x path="Void"/>
</f></stopGamepadRumble>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<typedef path="backend.LoadAudioOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/LoadAudioOptions.hx"><a><stream>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
</stream></a></typedef>
	<typedef path="backend.LoadBinaryOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/LoadBinaryOptions.hx"><a/></typedef>
	<typedef path="backend.LoadTextOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/LoadTextOptions.hx"><a/></typedef>
	<typedef path="backend.LoadTextureOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/LoadTextureOptions.hx"><a/></typedef>
	<class path="backend.Screen" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Screen.hx">
		<implements path="tracker.Events"/>
		<_dox_event_resize public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_resize>
		<emitResize set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>resize event</haxe_doc>
		</emitResize>
		<onResize public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>resize event</haxe_doc>
		</onResize>
		<onceResize public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>resize event</haxe_doc>
		</onceResize>
		<offResize public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>resize event</haxe_doc>
		</offResize>
		<listensResize public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to resize event</haxe_doc>
		</listensResize>
		<_dox_event_mouseDown public="1" set="method" line="637">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseDown>
		<emitMouseDown set="method" line="1095">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseDown event</haxe_doc>
		</emitMouseDown>
		<onMouseDown public="1" set="method" line="1199">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseDown event</haxe_doc>
		</onMouseDown>
		<onceMouseDown public="1" set="method" line="1298">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseDown event</haxe_doc>
		</onceMouseDown>
		<offMouseDown public="1" set="method" line="1368">
			<f a="?handleButtonIdXY">
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseDown event</haxe_doc>
		</offMouseDown>
		<listensMouseDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseDown event</haxe_doc>
		</listensMouseDown>
		<_dox_event_mouseUp public="1" set="method" line="637">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseUp>
		<emitMouseUp set="method" line="1095">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseUp event</haxe_doc>
		</emitMouseUp>
		<onMouseUp public="1" set="method" line="1199">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseUp event</haxe_doc>
		</onMouseUp>
		<onceMouseUp public="1" set="method" line="1298">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseUp event</haxe_doc>
		</onceMouseUp>
		<offMouseUp public="1" set="method" line="1368">
			<f a="?handleButtonIdXY">
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseUp event</haxe_doc>
		</offMouseUp>
		<listensMouseUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseUp event</haxe_doc>
		</listensMouseUp>
		<_dox_event_mouseWheel public="1" set="method" line="637">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseWheel>
		<emitMouseWheel set="method" line="1095">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseWheel event</haxe_doc>
		</emitMouseWheel>
		<onMouseWheel public="1" set="method" line="1199">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseWheel event</haxe_doc>
		</onMouseWheel>
		<onceMouseWheel public="1" set="method" line="1298">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseWheel event</haxe_doc>
		</onceMouseWheel>
		<offMouseWheel public="1" set="method" line="1368">
			<f a="?handleXY">
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseWheel event</haxe_doc>
		</offMouseWheel>
		<listensMouseWheel public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseWheel event</haxe_doc>
		</listensMouseWheel>
		<_dox_event_mouseMove public="1" set="method" line="637">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseMove>
		<emitMouseMove set="method" line="1095">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseMove event</haxe_doc>
		</emitMouseMove>
		<onMouseMove public="1" set="method" line="1199">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseMove event</haxe_doc>
		</onMouseMove>
		<onceMouseMove public="1" set="method" line="1298">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseMove event</haxe_doc>
		</onceMouseMove>
		<offMouseMove public="1" set="method" line="1368">
			<f a="?handleXY">
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseMove event</haxe_doc>
		</offMouseMove>
		<listensMouseMove public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseMove event</haxe_doc>
		</listensMouseMove>
		<_dox_event_touchDown public="1" set="method" line="637">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_touchDown>
		<emitTouchDown set="method" line="1095">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>touchDown event</haxe_doc>
		</emitTouchDown>
		<onTouchDown public="1" set="method" line="1199">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchDown event</haxe_doc>
		</onTouchDown>
		<onceTouchDown public="1" set="method" line="1298">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchDown event</haxe_doc>
		</onceTouchDown>
		<offTouchDown public="1" set="method" line="1368">
			<f a="?handleTouchIndexXY">
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchDown event</haxe_doc>
		</offTouchDown>
		<listensTouchDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to touchDown event</haxe_doc>
		</listensTouchDown>
		<_dox_event_touchUp public="1" set="method" line="637">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_touchUp>
		<emitTouchUp set="method" line="1095">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>touchUp event</haxe_doc>
		</emitTouchUp>
		<onTouchUp public="1" set="method" line="1199">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchUp event</haxe_doc>
		</onTouchUp>
		<onceTouchUp public="1" set="method" line="1298">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchUp event</haxe_doc>
		</onceTouchUp>
		<offTouchUp public="1" set="method" line="1368">
			<f a="?handleTouchIndexXY">
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchUp event</haxe_doc>
		</offTouchUp>
		<listensTouchUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to touchUp event</haxe_doc>
		</listensTouchUp>
		<_dox_event_touchMove public="1" set="method" line="637">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_touchMove>
		<emitTouchMove set="method" line="1095">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>touchMove event</haxe_doc>
		</emitTouchMove>
		<onTouchMove public="1" set="method" line="1199">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchMove event</haxe_doc>
		</onTouchMove>
		<onceTouchMove public="1" set="method" line="1298">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchMove event</haxe_doc>
		</onceTouchMove>
		<offTouchMove public="1" set="method" line="1368">
			<f a="?handleTouchIndexXY">
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchMove event</haxe_doc>
		</offTouchMove>
		<listensTouchMove public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to touchMove event</haxe_doc>
		</listensTouchMove>
		<getWidth public="1" get="inline" set="null" line="24"><f a=""><x path="Int"/></f></getWidth>
		<getHeight public="1" get="inline" set="null" line="30"><f a=""><x path="Int"/></f></getHeight>
		<getDensity public="1" get="inline" set="null" line="36"><f a=""><x path="Float"/></f></getDensity>
		<setBackground public="1" set="method" line="42"><f a="background">
	<x path="Int"/>
	<x path="Void"/>
</f></setBackground>
		<setWindowTitle public="1" set="method" line="48"><f a="title">
	<c path="String"/>
	<x path="Void"/>
</f></setWindowTitle>
		<setWindowFullscreen public="1" set="method" line="54"><f a="fullscreen">
	<x path="Bool"/>
	<x path="Void"/>
</f></setWindowFullscreen>
		<screenshotToTexture public="1" set="method" line="60"><f a="done">
	<f a="texture">
		<t path="backend.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></screenshotToTexture>
		<screenshotToPng public="1" set="method" line="66"><f a="?path:done">
	<c path="String"/>
	<f a="?data">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></screenshotToPng>
		<screenshotToPixels public="1" set="method" line="72"><f a="done">
	<f a="pixels:width:height">
		<t path="ceramic.UInt8Array"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></screenshotToPixels>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="backend.Shader" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Shader.hx">
		<from><icast><c path="backend.ShaderImpl"/></icast></from>
		<this><c path="backend.ShaderImpl"/></this>
		<to><icast><c path="backend.ShaderImpl"/></icast></to>
		<impl><class path="backend._Shader.Shader_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Shader.hx" private="1" module="backend.Shader" extern="1" final="1"/></impl>
	</abstract>
	<class path="backend._Shader.Shader_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Shader.hx" private="1" module="backend.Shader" extern="1" final="1"/>
	<class path="backend.ShaderImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/ShaderImpl.hx">
		<customAttributes public="1" expr="null">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</customAttributes>
		<new public="1" set="method" line="5"><f a="?customAttributes">
	<x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spec.Shaders" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Shaders.hx" interface="1">
		<destroy public="1" set="method"><f a="shader">
	<x path="backend.Shader"/>
	<x path="Void"/>
</f></destroy>
		<fromSource public="1" set="method"><f a="vertSource:fragSource:?customAttributes">
	<c path="String"/>
	<c path="String"/>
	<x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x>
	<x path="backend.Shader"/>
</f></fromSource>
		<clone public="1" set="method"><f a="shader">
	<x path="backend.Shader"/>
	<x path="backend.Shader"/>
</f></clone>
		<setInt public="1" set="method"><f a="shader:name:value">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setFloat public="1" set="method"><f a="shader:name:value">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setColor public="1" set="method"><f a="shader:name:r:g:b:a">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setColor>
		<setVec2 public="1" set="method"><f a="shader:name:x:y">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec2>
		<setVec3 public="1" set="method"><f a="shader:name:x:y:z">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec3>
		<setVec4 public="1" set="method"><f a="shader:name:x:y:z:w">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec4>
		<setFloatArray public="1" set="method"><f a="shader:name:array">
	<x path="backend.Shader"/>
	<c path="String"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setFloatArray>
		<setTexture public="1" set="method"><f a="shader:name:slot:texture">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Int"/>
	<t path="backend.Texture"/>
	<x path="Void"/>
</f></setTexture>
		<customFloatAttributesSize public="1" set="method"><f a="shader">
	<x path="backend.Shader"/>
	<x path="Int"/>
</f></customFloatAttributesSize>
		<maxIfStatementsByFragmentShader public="1" set="method"><f a=""><x path="Int"/></f></maxIfStatementsByFragmentShader>
		<canBatchWithMultipleTextures public="1" set="method"><f a="shader">
	<x path="backend.Shader"/>
	<x path="Bool"/>
</f></canBatchWithMultipleTextures>
		<supportsHotReloadPath public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if paths with `?hot=...` are supported on this backend
     * @return Bool</haxe_doc>
		</supportsHotReloadPath>
	</class>
	<class path="backend.Shaders" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Shaders.hx">
		<implements path="spec.Shaders"/>
		<fromSource public="1" get="inline" set="null" line="11"><f a="vertSource:fragSource:?customAttributes">
	<c path="String"/>
	<c path="String"/>
	<x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x>
	<x path="backend.Shader"/>
</f></fromSource>
		<destroy public="1" get="inline" set="null" line="17"><f a="shader">
	<x path="backend.Shader"/>
	<x path="Void"/>
</f></destroy>
		<clone public="1" get="inline" set="null" line="23"><f a="shader">
	<x path="backend.Shader"/>
	<x path="backend.Shader"/>
</f></clone>
		<setInt public="1" get="inline" set="null" line="31"><f a="shader:name:value">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setFloat public="1" get="inline" set="null" line="37"><f a="shader:name:value">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setColor public="1" get="inline" set="null" line="43"><f a="shader:name:r:g:b:a">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setColor>
		<setVec2 public="1" get="inline" set="null" line="49"><f a="shader:name:x:y">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec2>
		<setVec3 public="1" get="inline" set="null" line="55"><f a="shader:name:x:y:z">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec3>
		<setVec4 public="1" get="inline" set="null" line="61"><f a="shader:name:x:y:z:w">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec4>
		<setFloatArray public="1" get="inline" set="null" line="67"><f a="shader:name:array">
	<x path="backend.Shader"/>
	<c path="String"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setFloatArray>
		<setTexture public="1" get="inline" set="null" line="73"><f a="shader:name:slot:texture">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Int"/>
	<t path="backend.Texture"/>
	<x path="Void"/>
</f></setTexture>
		<setMat4FromTransform public="1" get="inline" set="null" line="79"><f a="shader:name:transform">
	<x path="backend.Shader"/>
	<c path="String"/>
	<c path="ceramic.Transform"/>
	<x path="Void"/>
</f></setMat4FromTransform>
		<customFloatAttributesSize public="1" get="inline" set="null" line="85"><f a="shader">
	<c path="backend.ShaderImpl"/>
	<x path="Int"/>
</f></customFloatAttributesSize>
		<maxIfStatementsByFragmentShader public="1" set="method" line="101"><f a=""><x path="Int"/></f></maxIfStatementsByFragmentShader>
		<canBatchWithMultipleTextures public="1" set="method" line="107"><f a="shader">
	<x path="backend.Shader"/>
	<x path="Bool"/>
</f></canBatchWithMultipleTextures>
		<supportsHotReloadPath public="1" get="inline" set="null" line="113"><f a=""><x path="Bool"/></f></supportsHotReloadPath>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spec.TextInput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/TextInput.hx" interface="1">
		<start public="1" set="method"><f a="initialText:x:y:w:h">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></start>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
	</class>
	<class path="backend.TextInput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/TextInput.hx">
		<implements path="spec.TextInput"/>
		<start public="1" set="method" line="7"><f a="initialText:x:y:w:h">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></start>
		<stop public="1" set="method" line="9"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spec.Texts" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Texts.hx" interface="1">
		<load public="1" set="method"><f a="path:?options:done">
	<c path="String"/>
	<x path="Null"><t path="backend.LoadTextOptions"/></x>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<supportsHotReloadPath public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if paths with `?hot=...` are supported on this backend
     * @return Bool</haxe_doc>
		</supportsHotReloadPath>
	</class>
	<class path="backend.Texts" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Texts.hx">
		<implements path="spec.Texts"/>
		<load public="1" set="method" line="16"><f a="path:?options:_done">
	<c path="String"/>
	<x path="Null"><t path="backend.LoadTextOptions"/></x>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<supportsHotReloadPath public="1" get="inline" set="null" line="60"><f a=""><x path="Bool"/></f></supportsHotReloadPath>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="backend.Texture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Texture.hx"><c path="backend.TextureImpl"/></typedef>
	<typedef path="backend.TextureId" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/TextureId.hx"><x path="backend.TextureIdImpl"/></typedef>
	<abstract path="backend.TextureIdImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/TextureId.hx" module="backend.TextureId">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<impl><class path="backend._TextureId.TextureIdImpl_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/TextureId.hx" private="1" module="backend.TextureId" final="1"><DEFAULT public="1" get="inline" set="null" expr="0" line="7" static="1">
	<t path="backend.TextureId"/>
	<meta><m n=":value"><e>0</e></m></meta>
</DEFAULT></class></impl>
	</abstract>
	<class path="backend._TextureId.TextureIdImpl_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/TextureId.hx" private="1" module="backend.TextureId" final="1"><DEFAULT public="1" get="inline" set="null" expr="0" line="7" static="1">
	<t path="backend.TextureId"/>
	<meta><m n=":value"><e>0</e></m></meta>
</DEFAULT></class>
	<class path="backend.TextureImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/TextureImpl.hx">
		<_nextTextureId expr="1" line="4" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</_nextTextureId>
		<width public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</width>
		<height public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</height>
		<depth public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</depth>
		<stencil public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</stencil>
		<antialiasing public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</antialiasing>
		<textureId public="1" expr="0">
			<t path="backend.TextureId"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</textureId>
		<new public="1" set="method" line="11">
			<f a="?width:?height:?depth:?stencil:?antialiasing" v="0:0:true:true:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ antialiasing : 0, stencil : true, depth : true, height : 0, width : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spec.Textures" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Textures.hx" interface="1">
		<load public="1" set="method"><f a="path:?options:done">
	<c path="String"/>
	<x path="Null"><t path="backend.LoadTextureOptions"/></x>
	<f a="">
		<t path="backend.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<loadFromBytes public="1" set="method"><f a="bytes:type:?options:done">
	<c path="haxe.io.Bytes"/>
	<x path="ceramic.ImageType"/>
	<x path="Null"><t path="backend.LoadTextureOptions"/></x>
	<f a="">
		<t path="backend.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadFromBytes>
		<supportsHotReloadPath public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if paths with `?hot=...` are supported on this backend
     * @return Bool</haxe_doc>
		</supportsHotReloadPath>
		<createTexture public="1" set="method"><f a="width:height:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<t path="ceramic.UInt8Array"/>
	<t path="backend.Texture"/>
</f></createTexture>
		<destroyTexture public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Void"/>
</f></destroyTexture>
		<getTextureId public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<t path="backend.TextureId"/>
</f></getTextureId>
		<getTextureWidth public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureWidth>
		<getTextureHeight public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureHeight>
		<getTextureWidthActual public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureWidthActual>
		<getTextureHeightActual public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureHeightActual>
		<fetchTexturePixels public="1" set="method"><f a="texture:?result">
	<t path="backend.Texture"/>
	<x path="Null"><t path="ceramic.UInt8Array"/></x>
	<t path="ceramic.UInt8Array"/>
</f></fetchTexturePixels>
		<submitTexturePixels public="1" set="method"><f a="texture:pixels">
	<t path="backend.Texture"/>
	<t path="ceramic.UInt8Array"/>
	<x path="Void"/>
</f></submitTexturePixels>
		<setTextureFilter public="1" set="method"><f a="texture:filter">
	<t path="backend.Texture"/>
	<e path="ceramic.TextureFilter"/>
	<x path="Void"/>
</f></setTextureFilter>
		<setTextureWrapS public="1" set="method"><f a="texture:wrap">
	<t path="backend.Texture"/>
	<x path="ceramic.TextureWrap"/>
	<x path="Void"/>
</f></setTextureWrapS>
		<setTextureWrapT public="1" set="method"><f a="texture:wrap">
	<t path="backend.Texture"/>
	<x path="ceramic.TextureWrap"/>
	<x path="Void"/>
</f></setTextureWrapT>
		<createRenderTarget public="1" set="method"><f a="width:height:depth:stencil:antialiasing">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<t path="backend.Texture"/>
</f></createRenderTarget>
		<maxTexturesByBatch public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* If this returns a value above 1, that means this backend supports multi-texture batching.</haxe_doc>
		</maxTexturesByBatch>
		<getTextureIndex public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureIndex>
		<textureToPng public="1" set="method">
			<f a="texture:?reversePremultiplyAlpha:?path:done" v=":true::">
				<t path="backend.Texture"/>
				<x path="Bool"/>
				<c path="String"/>
				<f a="?data">
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ reversePremultiplyAlpha : true }</e></m></meta>
		</textureToPng>
		<pixelsToPng public="1" set="method"><f a="width:height:pixels:?path:done">
	<x path="Int"/>
	<x path="Int"/>
	<t path="ceramic.UInt8Array"/>
	<c path="String"/>
	<f a="?data">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></pixelsToPng>
	</class>
	<class path="backend.Textures" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/Textures.hx">
		<implements path="spec.Textures"/>
		<load public="1" set="method" line="10"><f a="path:?options:_done">
	<c path="String"/>
	<x path="Null"><t path="backend.LoadTextureOptions"/></x>
	<f a="">
		<t path="backend.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<loadFromBytes public="1" set="method" line="23"><f a="bytes:type:?options:_done">
	<c path="haxe.io.Bytes"/>
	<x path="ceramic.ImageType"/>
	<x path="Null"><t path="backend.LoadTextureOptions"/></x>
	<f a="">
		<t path="backend.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadFromBytes>
		<supportsHotReloadPath public="1" get="inline" set="null" line="36"><f a=""><x path="Bool"/></f></supportsHotReloadPath>
		<createTexture public="1" set="method" line="42"><f a="width:height:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<t path="ceramic.UInt8Array"/>
	<t path="backend.Texture"/>
</f></createTexture>
		<destroyTexture public="1" set="method" line="48"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Void"/>
</f></destroyTexture>
		<createRenderTarget public="1" get="inline" set="null" line="52"><f a="width:height:depth:stencil:antialiasing">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<t path="backend.Texture"/>
</f></createRenderTarget>
		<destroy public="1" set="method" line="58"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Void"/>
</f></destroy>
		<getTextureId public="1" get="inline" set="null" line="64"><f a="texture">
	<t path="backend.Texture"/>
	<t path="backend.TextureId"/>
</f></getTextureId>
		<getTextureWidth public="1" get="inline" set="null" line="70"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureWidth>
		<getTextureHeight public="1" get="inline" set="null" line="76"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureHeight>
		<getTextureWidthActual public="1" get="inline" set="null" line="82"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureWidthActual>
		<getTextureHeightActual public="1" get="inline" set="null" line="88"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureHeightActual>
		<fetchTexturePixels public="1" get="inline" set="null" line="94"><f a="texture:?result">
	<t path="backend.Texture"/>
	<x path="Null"><t path="ceramic.UInt8Array"/></x>
	<t path="ceramic.UInt8Array"/>
</f></fetchTexturePixels>
		<submitTexturePixels public="1" get="inline" set="null" line="100"><f a="texture:pixels">
	<t path="backend.Texture"/>
	<t path="ceramic.UInt8Array"/>
	<x path="Void"/>
</f></submitTexturePixels>
		<setTextureFilter public="1" get="inline" set="null" line="104"><f a="texture:filter">
	<t path="backend.Texture"/>
	<e path="ceramic.TextureFilter"/>
	<x path="Void"/>
</f></setTextureFilter>
		<setTextureWrapS public="1" get="inline" set="null" line="110"><f a="texture:wrap">
	<t path="backend.Texture"/>
	<x path="ceramic.TextureWrap"/>
	<x path="Void"/>
</f></setTextureWrapS>
		<setTextureWrapT public="1" get="inline" set="null" line="116"><f a="texture:wrap">
	<t path="backend.Texture"/>
	<x path="ceramic.TextureWrap"/>
	<x path="Void"/>
</f></setTextureWrapT>
		<maxTexturesByBatch public="1" set="method" line="122"><f a=""><x path="Int"/></f></maxTexturesByBatch>
		<getTextureIndex public="1" get="inline" set="null" line="128"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureIndex>
		<textureToPng public="1" set="method" line="134">
			<f a="texture:?reversePremultiplyAlpha:?path:done" v=":true::">
				<t path="backend.Texture"/>
				<x path="Bool"/>
				<c path="String"/>
				<f a="?data">
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ reversePremultiplyAlpha : true }</e></m></meta>
		</textureToPng>
		<pixelsToPng public="1" set="method" line="140"><f a="width:height:pixels:?path:done">
	<x path="Int"/>
	<x path="Int"/>
	<t path="ceramic.UInt8Array"/>
	<c path="String"/>
	<f a="?data">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></pixelsToPng>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="backend.UInt8Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/UInt8Array.hx"><x path="backend.UInt8ArrayImplHeadlessJS"/></typedef>
	<abstract path="backend.UInt8ArrayImplHeadlessJS" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/UInt8Array.hx" module="backend.UInt8Array">
		<from><icast><c path="js.lib.Uint8Array"/></icast></from>
		<this><c path="js.lib.Uint8Array"/></this>
		<to><icast><c path="js.lib.Uint8Array"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="backend._UInt8Array.UInt8ArrayImplHeadlessJS_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/UInt8Array.hx" private="1" module="backend.UInt8Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="12" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<_new public="1" get="inline" set="null" line="14" static="1">
		<f a="_elements">
			<x path="Int"/>
			<x path="backend.UInt8ArrayImplHeadlessJS"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<fromArray public="1" params="T" get="inline" set="null" line="18" static="1">
		<f a="_array">
			<c path="Array"><c path="fromArray.T"/></c>
			<t path="backend.UInt8Array"/>
		</f>
		<meta><m n=":has_untyped"/></meta>
	</fromArray>
	<fromView public="1" get="inline" set="null" line="22" static="1">
		<f a="_view">
			<c path="js.lib.ArrayBufferView"/>
			<t path="backend.UInt8Array"/>
		</f>
		<meta><m n=":has_untyped"/></meta>
	</fromView>
	<fromBuffer public="1" get="inline" set="null" line="26" static="1"><f a="_buffer:_byteOffset:_byteLength">
	<c path="js.lib.ArrayBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="backend.UInt8Array"/>
</f></fromBuffer>
	<__set get="inline" set="null" line="30" static="1">
		<f a="this:idx:val">
			<c path="js.lib.Uint8Array"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<__get get="inline" set="null" line="31" static="1">
		<f a="this:idx">
			<c path="js.lib.Uint8Array"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<fromBytes public="1" get="inline" set="null" line="35" static="1"><f a="bytes:?byteOffset:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="backend.UInt8Array"/>
</f></fromBytes>
	<toBytes public="1" get="inline" set="null" line="41" static="1"><f a="this">
	<c path="js.lib.Uint8Array"/>
	<c path="haxe.io.Bytes"/>
</f></toBytes>
	<toString get="inline" set="null" line="49" static="1"><f a="this">
	<c path="js.lib.Uint8Array"/>
	<c path="String"/>
</f></toString>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="backend._UInt8Array.UInt8ArrayImplHeadlessJS_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/UInt8Array.hx" private="1" module="backend.UInt8Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<_new public="1" get="inline" set="null" line="14" static="1">
			<f a="_elements">
				<x path="Int"/>
				<x path="backend.UInt8ArrayImplHeadlessJS"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<fromArray public="1" params="T" get="inline" set="null" line="18" static="1">
			<f a="_array">
				<c path="Array"><c path="fromArray.T"/></c>
				<t path="backend.UInt8Array"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromArray>
		<fromView public="1" get="inline" set="null" line="22" static="1">
			<f a="_view">
				<c path="js.lib.ArrayBufferView"/>
				<t path="backend.UInt8Array"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromView>
		<fromBuffer public="1" get="inline" set="null" line="26" static="1"><f a="_buffer:_byteOffset:_byteLength">
	<c path="js.lib.ArrayBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="backend.UInt8Array"/>
</f></fromBuffer>
		<__set get="inline" set="null" line="30" static="1">
			<f a="this:idx:val">
				<c path="js.lib.Uint8Array"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<__get get="inline" set="null" line="31" static="1">
			<f a="this:idx">
				<c path="js.lib.Uint8Array"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<fromBytes public="1" get="inline" set="null" line="35" static="1"><f a="bytes:?byteOffset:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="backend.UInt8Array"/>
</f></fromBytes>
		<toBytes public="1" get="inline" set="null" line="41" static="1"><f a="this">
	<c path="js.lib.Uint8Array"/>
	<c path="haxe.io.Bytes"/>
</f></toBytes>
		<toString get="inline" set="null" line="49" static="1"><f a="this">
	<c path="js.lib.Uint8Array"/>
	<c path="String"/>
</f></toString>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="backend.VisualItem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/headless/runtime/src/backend/VisualItem.hx">
		<NONE/>
		<QUAD/>
		<MESH/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="binpacking.IOccupancy" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/IOccupancy.hx" interface="1"><occupancy public="1" set="method"><f a=""><x path="Float"/></f></occupancy></class>
	<abstract path="binpacking.FreeRectChoiceHeuristic" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/MaxRectsPacker.hx" module="binpacking.MaxRectsPacker">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="binpacking._MaxRectsPacker.FreeRectChoiceHeuristic_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/MaxRectsPacker.hx" private="1" module="binpacking.MaxRectsPacker" extern="1" final="1">
	<BestShortSideFit public="1" get="inline" set="null" expr="cast 1" line="4" static="1">
		<x path="binpacking.FreeRectChoiceHeuristic"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BestShortSideFit>
	<BestLongSideFit public="1" get="inline" set="null" expr="cast 2" line="5" static="1">
		<x path="binpacking.FreeRectChoiceHeuristic"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BestLongSideFit>
	<BestAreaFit public="1" get="inline" set="null" expr="cast 3" line="6" static="1">
		<x path="binpacking.FreeRectChoiceHeuristic"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BestAreaFit>
	<BottomLeftRule public="1" get="inline" set="null" expr="cast 4" line="7" static="1">
		<x path="binpacking.FreeRectChoiceHeuristic"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BottomLeftRule>
	<ContactPointRule public="1" get="inline" set="null" expr="cast 5" line="8" static="1">
		<x path="binpacking.FreeRectChoiceHeuristic"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ContactPointRule>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="binpacking._MaxRectsPacker.FreeRectChoiceHeuristic_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/MaxRectsPacker.hx" private="1" module="binpacking.MaxRectsPacker" extern="1" final="1">
		<BestShortSideFit public="1" get="inline" set="null" expr="cast 1" line="4" static="1">
			<x path="binpacking.FreeRectChoiceHeuristic"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BestShortSideFit>
		<BestLongSideFit public="1" get="inline" set="null" expr="cast 2" line="5" static="1">
			<x path="binpacking.FreeRectChoiceHeuristic"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BestLongSideFit>
		<BestAreaFit public="1" get="inline" set="null" expr="cast 3" line="6" static="1">
			<x path="binpacking.FreeRectChoiceHeuristic"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BestAreaFit>
		<BottomLeftRule public="1" get="inline" set="null" expr="cast 4" line="7" static="1">
			<x path="binpacking.FreeRectChoiceHeuristic"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BottomLeftRule>
		<ContactPointRule public="1" get="inline" set="null" expr="cast 5" line="8" static="1">
			<x path="binpacking.FreeRectChoiceHeuristic"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ContactPointRule>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="binpacking.MaxRectsPackerBestFitPosition" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/MaxRectsPacker.hx" module="binpacking.MaxRectsPacker">
		<bestNode public="1" expr="null">
			<c path="binpacking.Rect"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</bestNode>
		<bestAreaFit public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bestAreaFit>
		<bestShortSideFit public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bestShortSideFit>
		<bestLongSideFit public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bestLongSideFit>
		<bestContactScore public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bestContactScore>
		<bestX public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bestX>
		<bestY public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bestY>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="binpacking.MaxRectsPackerRectScore" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/MaxRectsPacker.hx" module="binpacking.MaxRectsPacker">
		<rect public="1"><c path="binpacking.Rect"/></rect>
		<primaryScore public="1"><x path="Int"/></primaryScore>
		<secondaryScore public="1"><x path="Int"/></secondaryScore>
		<new public="1" set="method" line="23">
			<f a="rect:primaryScore:secondaryScore">
				<c path="binpacking.Rect"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="binpacking.MaxRectsPacker" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/MaxRectsPacker.hx">
		<implements path="binpacking.IOccupancy"/>
		<binWidth public="1" set="null"><x path="Int"/></binWidth>
		<binHeight public="1" set="null"><x path="Int"/></binHeight>
		<binAllowFlip public="1" set="null"><x path="Bool"/></binAllowFlip>
		<usedRectangles public="1" set="null" expr="new Array&lt;Rect&gt;()">
			<c path="Array"><c path="binpacking.Rect"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Rect>()]]></e></m></meta>
		</usedRectangles>
		<freeRectangles public="1" set="null" expr="new Array&lt;Rect&gt;()">
			<c path="Array"><c path="binpacking.Rect"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Rect>()]]></e></m></meta>
		</freeRectangles>
		<_bestFitPosition expr="new MaxRectsPackerBestFitPosition()">
			<c path="binpacking.MaxRectsPackerBestFitPosition"/>
			<meta><m n=":value"><e>new MaxRectsPackerBestFitPosition()</e></m></meta>
		</_bestFitPosition>
		<insert public="1" set="method" line="48"><f a="width:height:method">
	<x path="Int"/>
	<x path="Int"/>
	<x path="binpacking.FreeRectChoiceHeuristic"/>
	<c path="binpacking.Rect"/>
</f></insert>
		<occupancy public="1" set="method" line="84"><f a=""><x path="Float"/></f></occupancy>
		<scoreRect set="method" line="98"><f a="width:height:method">
	<x path="Int"/>
	<x path="Int"/>
	<x path="binpacking.FreeRectChoiceHeuristic"/>
	<c path="binpacking.MaxRectsPackerRectScore"/>
</f></scoreRect>
		<contactPointScoreNode set="method" line="138"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></contactPointScoreNode>
		<findPositionForNewNodeBottomLeft set="method" line="160"><f a="width:height:result">
	<x path="Int"/>
	<x path="Int"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
</f></findPositionForNewNodeBottomLeft>
		<findPositionForNewNodeBestShortSideFit set="method" line="196"><f a="width:height:result">
	<x path="Int"/>
	<x path="Int"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
</f></findPositionForNewNodeBestShortSideFit>
		<findPositionForNewNodeBestLongSideFit set="method" line="243"><f a="width:height:result">
	<x path="Int"/>
	<x path="Int"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
</f></findPositionForNewNodeBestLongSideFit>
		<findPositionForNewNodeBestAreaFit set="method" line="290"><f a="width:height:result">
	<x path="Int"/>
	<x path="Int"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
</f></findPositionForNewNodeBestAreaFit>
		<findPositionForNewNodeContactPoint set="method" line="337"><f a="width:height:result">
	<x path="Int"/>
	<x path="Int"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
</f></findPositionForNewNodeContactPoint>
		<splitFreeNode set="method" line="372"><f a="freeNode:usedNode">
	<c path="binpacking.Rect"/>
	<c path="binpacking.Rect"/>
	<x path="Bool"/>
</f></splitFreeNode>
		<pruneFreeList set="method" line="411"><f a=""><x path="Void"/></f></pruneFreeList>
		<commonIntervalLength set="method" line="433"><f a="i1start:i1end:i2start:i2end">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></commonIntervalLength>
		<new public="1" set="method" line="38">
			<f a="?width:?height:?allowFlip" v="0:0:true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ allowFlip : true, height : 0, width : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="binpacking.RectSize" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/Rect.hx" module="binpacking.Rect">
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<new public="1" get="inline" set="null" line="7"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="binpacking.Rect" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/Rect.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<flipped public="1"><x path="Bool"/></flipped>
		<clone public="1" get="inline" set="null" line="28"><f a=""><c path="binpacking.Rect"/></f></clone>
		<isContainedIn public="1" get="inline" set="null" line="32"><f a="other">
	<c path="binpacking.Rect"/>
	<x path="Bool"/>
</f></isContainedIn>
		<new public="1" get="inline" set="null" line="20">
			<f a="?x:?y:?width:?height:?flipped" v="0:0:0:0:false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ flipped : false, height : 0, width : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="binpacking.DisjointRectCollection" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/Rect.hx" module="binpacking.Rect">
		<rectsDisjoint public="1" set="method" line="76" static="1"><f a="a:b">
	<c path="binpacking.Rect"/>
	<c path="binpacking.Rect"/>
	<x path="Bool"/>
</f></rectsDisjoint>
		<rects public="1" expr="new Array&lt;Rect&gt;()">
			<c path="Array"><c path="binpacking.Rect"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Rect>()]]></e></m></meta>
		</rects>
		<add public="1" set="method" line="44"><f a="r">
	<c path="binpacking.Rect"/>
	<x path="Bool"/>
</f></add>
		<clear public="1" set="method" line="58"><f a=""><x path="Void"/></f></clear>
		<disjoint public="1" set="method" line="62"><f a="r">
	<c path="binpacking.Rect"/>
	<x path="Bool"/>
</f></disjoint>
		<new public="1" set="method" line="41"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="ceramic.AllApi" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AllApi.hx">
		<apiCallCache public="1" set="method" line="403" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</apiCallCache>
		<configureHscript public="1" set="method" line="410" static="1"><f a="interp">
	<c path="hscript.Interp"/>
	<x path="Void"/>
</f></configureHscript>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<abstract path="ceramic.AlphaColor" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AlphaColor.hx">
		<from>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
			<icast field="toColor"><x path="ceramic.Color"/></icast>
		</to>
		<haxe_doc>* Color (alpha included) stored as integer.
 * Can be decomposed to Color/Int (RGB) + Float (A) and
 * constructed from Color/Int (RGB) + Float (A).</haxe_doc>
		<impl><class path="ceramic._AlphaColor.AlphaColor_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AlphaColor.hx" private="1" module="ceramic.AlphaColor" final="1">
	<NONE public="1" get="inline" set="null" expr="-1" line="19" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>-1</e></m></meta>
	</NONE>
	<TRANSPARENT public="1" get="inline" set="null" expr="0x00000000" line="21" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0x00000000</e></m></meta>
	</TRANSPARENT>
	<WHITE public="1" get="inline" set="null" expr="0xFFFFFFFF" line="23" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFFFFF</e></m></meta>
	</WHITE>
	<GRAY public="1" get="inline" set="null" expr="0xFF808080" line="24" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF808080</e></m></meta>
	</GRAY>
	<BLACK public="1" get="inline" set="null" expr="0xFF000000" line="25" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF000000</e></m></meta>
	</BLACK>
	<GREEN public="1" get="inline" set="null" expr="0xFF008000" line="27" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF008000</e></m></meta>
	</GREEN>
	<LIME public="1" get="inline" set="null" expr="0xFF00FF00" line="28" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF00FF00</e></m></meta>
	</LIME>
	<YELLOW public="1" get="inline" set="null" expr="0xFFFFFF00" line="29" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFFF00</e></m></meta>
	</YELLOW>
	<ORANGE public="1" get="inline" set="null" expr="0xFFFFA500" line="30" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFA500</e></m></meta>
	</ORANGE>
	<RED public="1" get="inline" set="null" expr="0xFFFF0000" line="31" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF0000</e></m></meta>
	</RED>
	<PURPLE public="1" get="inline" set="null" expr="0xFF800080" line="32" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF800080</e></m></meta>
	</PURPLE>
	<BLUE public="1" get="inline" set="null" expr="0xFF0000FF" line="33" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF0000FF</e></m></meta>
	</BLUE>
	<BROWN public="1" get="inline" set="null" expr="0xFF8B4513" line="34" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF8B4513</e></m></meta>
	</BROWN>
	<PINK public="1" get="inline" set="null" expr="0xFFFFC0CB" line="35" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFC0CB</e></m></meta>
	</PINK>
	<MAGENTA public="1" get="inline" set="null" expr="0xFFFF00FF" line="36" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
	</MAGENTA>
	<CYAN public="1" get="inline" set="null" expr="0xFF00FFFF" line="37" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
	</CYAN>
	<CORNFLOWERBLUE public="1" get="inline" set="null" expr="0xFF6495ED" line="39" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF6495ED</e></m></meta>
	</CORNFLOWERBLUE>
	<MEDIUMVIOLETRED public="1" get="inline" set="null" expr="0xFFC71585" line="40" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFC71585</e></m></meta>
	</MEDIUMVIOLETRED>
	<DEEPPINK public="1" get="inline" set="null" expr="0xFFFF1493" line="41" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF1493</e></m></meta>
	</DEEPPINK>
	<PALEVIOLETRED public="1" get="inline" set="null" expr="0xFFDB7093" line="42" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFDB7093</e></m></meta>
	</PALEVIOLETRED>
	<HOTPINK public="1" get="inline" set="null" expr="0xFFFF69B4" line="43" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF69B4</e></m></meta>
	</HOTPINK>
	<LIGHTPINK public="1" get="inline" set="null" expr="0xFFFFB6C1" line="44" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFB6C1</e></m></meta>
	</LIGHTPINK>
	<DARKRED public="1" get="inline" set="null" expr="0xFF8B0000" line="45" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF8B0000</e></m></meta>
	</DARKRED>
	<FIREBRICK public="1" get="inline" set="null" expr="0xFFB22222" line="46" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFB22222</e></m></meta>
	</FIREBRICK>
	<CRIMSON public="1" get="inline" set="null" expr="0xFFDC143C" line="47" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFDC143C</e></m></meta>
	</CRIMSON>
	<INDIANRED public="1" get="inline" set="null" expr="0xFFCD5C5C" line="48" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFCD5C5C</e></m></meta>
	</INDIANRED>
	<LIGHTCORAL public="1" get="inline" set="null" expr="0xFFF08080" line="49" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFF08080</e></m></meta>
	</LIGHTCORAL>
	<SALMON public="1" get="inline" set="null" expr="0xFFFA8072" line="50" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFA8072</e></m></meta>
	</SALMON>
	<DARKSALMON public="1" get="inline" set="null" expr="0xFFE9967A" line="51" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFE9967A</e></m></meta>
	</DARKSALMON>
	<LIGHTSALMON public="1" get="inline" set="null" expr="0xFFFFA07A" line="52" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFA07A</e></m></meta>
	</LIGHTSALMON>
	<ORANGERED public="1" get="inline" set="null" expr="0xFFFF4500" line="53" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF4500</e></m></meta>
	</ORANGERED>
	<TOMATO public="1" get="inline" set="null" expr="0xFFFF6347" line="54" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF6347</e></m></meta>
	</TOMATO>
	<DARKORANGE public="1" get="inline" set="null" expr="0xFFFF8C00" line="55" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF8C00</e></m></meta>
	</DARKORANGE>
	<CORAL public="1" get="inline" set="null" expr="0xFFFF7F50" line="56" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF7F50</e></m></meta>
	</CORAL>
	<DARKKHAKI public="1" get="inline" set="null" expr="0xFFBDB76B" line="57" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFBDB76B</e></m></meta>
	</DARKKHAKI>
	<GOLD public="1" get="inline" set="null" expr="0xFFFFD700" line="58" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFD700</e></m></meta>
	</GOLD>
	<KHAKI public="1" get="inline" set="null" expr="0xFFF0E68C" line="59" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFF0E68C</e></m></meta>
	</KHAKI>
	<PEACHPUFF public="1" get="inline" set="null" expr="0xFFFFDAB9" line="60" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFDAB9</e></m></meta>
	</PEACHPUFF>
	<PALEGOLDENROD public="1" get="inline" set="null" expr="0xFFEEE8AA" line="61" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFEEE8AA</e></m></meta>
	</PALEGOLDENROD>
	<MOCCASIN public="1" get="inline" set="null" expr="0xFFFFE4B5" line="62" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFE4B5</e></m></meta>
	</MOCCASIN>
	<PAPAYAWHIP public="1" get="inline" set="null" expr="0xFFFFEFD5" line="63" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFEFD5</e></m></meta>
	</PAPAYAWHIP>
	<LEMONCHIFFON public="1" get="inline" set="null" expr="0xFFFFFACD" line="64" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFFACD</e></m></meta>
	</LEMONCHIFFON>
	<LIGHTYELLOW public="1" get="inline" set="null" expr="0xFFFFFFE0" line="65" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFFFE0</e></m></meta>
	</LIGHTYELLOW>
	<SIENNA public="1" get="inline" set="null" expr="0xFFA0522D" line="66" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFA0522D</e></m></meta>
	</SIENNA>
	<CHOCOLATE public="1" get="inline" set="null" expr="0xFFD2691E" line="67" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFD2691E</e></m></meta>
	</CHOCOLATE>
	<PERU public="1" get="inline" set="null" expr="0xFFCD853F" line="68" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFCD853F</e></m></meta>
	</PERU>
	<TAN public="1" get="inline" set="null" expr="0xFFD2B48C" line="69" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFD2B48C</e></m></meta>
	</TAN>
	<DARKOLIVEGREEN public="1" get="inline" set="null" expr="0xFF556B2F" line="70" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF556B2F</e></m></meta>
	</DARKOLIVEGREEN>
	<OLIVE public="1" get="inline" set="null" expr="0xFF808000" line="71" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF808000</e></m></meta>
	</OLIVE>
	<TEAL public="1" get="inline" set="null" expr="0xFF008080" line="72" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF008080</e></m></meta>
	</TEAL>
	<TURQUOISE public="1" get="inline" set="null" expr="0xFF40E0D0" line="73" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF40E0D0</e></m></meta>
	</TURQUOISE>
	<NAVY public="1" get="inline" set="null" expr="0xFF000080" line="74" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF000080</e></m></meta>
	</NAVY>
	<INDIGO public="1" get="inline" set="null" expr="0xFF4B0082" line="75" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF4B0082</e></m></meta>
	</INDIGO>
	<ORCHID public="1" get="inline" set="null" expr="0xFFDA70D6" line="76" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFDA70D6</e></m></meta>
	</ORCHID>
	<LAVENDER public="1" get="inline" set="null" expr="0xFFE6E6FA" line="77" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFE6E6FA</e></m></meta>
	</LAVENDER>
	<AZURE public="1" get="inline" set="null" expr="0xFFF0FFFF" line="78" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFF0FFFF</e></m></meta>
	</AZURE>
	<IVORY public="1" get="inline" set="null" expr="0xFFFFFFF0" line="79" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFFFF0</e></m></meta>
	</IVORY>
	<DIMGREY public="1" get="inline" set="null" expr="0xFF696969" line="80" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF696969</e></m></meta>
	</DIMGREY>
	<SLATEGREY public="1" get="inline" set="null" expr="0xFF708090" line="81" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF708090</e></m></meta>
	</SLATEGREY>
	<SNOW public="1" get="inline" set="null" expr="0xFFFFFAFA" line="82" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFFAFA</e></m></meta>
	</SNOW>
	<red public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Red color component as `Int` between `0` and `255`</haxe_doc>
	</red>
	<green public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Green color component as `Int` between `0` and `255`</haxe_doc>
	</green>
	<blue public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Blue color component as `Int` between `0` and `255`</haxe_doc>
	</blue>
	<alpha public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Alpha component as `Int` between `0` and `255`</haxe_doc>
	</alpha>
	<redFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Red color component as `Float` between `0.0` and `1.0`</haxe_doc>
	</redFloat>
	<greenFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Green color component as `Float` between `0.0` and `1.0`</haxe_doc>
	</greenFloat>
	<blueFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Blue color component as `Float` between `0.0` and `1.0`</haxe_doc>
	</blueFloat>
	<alphaFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Alpha component as `Float` between `0.0` and `1.0`</haxe_doc>
	</alphaFloat>
	<cyan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></cyan>
	<magenta public="1" get="accessor" set="accessor" static="1"><x path="Float"/></magenta>
	<yellow public="1" get="accessor" set="accessor" static="1"><x path="Float"/></yellow>
	<black public="1" get="accessor" set="accessor" static="1"><x path="Float"/></black>
	<hue public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hue>
	<saturation public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
	</saturation>
	<brightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
	</brightness>
	<lightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
	</lightness>
	<color public="1" get="accessor" set="accessor" static="1">
		<x path="ceramic.Color"/>
		<haxe_doc>* RGB color component typed as `ceramic.Color`</haxe_doc>
	</color>
	<rgb public="1" get="accessor" set="accessor" static="1">
		<x path="ceramic.Color"/>
		<haxe_doc>* RGB color component typed as `ceramic.Color` (alias of `color`)</haxe_doc>
	</rgb>
	<toColor public="1" get="inline" set="null" line="150" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":to"/></meta>
	</toColor>
	<random public="1" get="inline" set="null" line="159" static="1">
		<f a="?minSatutation:?minBrightness" v="0.5:0.5">
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":value"><e>{ minBrightness : 0.5, minSatutation : 0.5 }</e></m></meta>
		<haxe_doc>* Generate a random color (away from white or black)
     * @return The color as an AlphaColor</haxe_doc>
	</random>
	<fromInt public="1" get="inline" set="null" line="170" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Create a color from the least significant four bytes of an Int
     *
     * @param    value And Int with bytes in the format 0xAARRGGBB
     * @return    The color as an AlphaColor</haxe_doc>
	</fromInt>
	<fromRGB public="1" get="inline" set="null" line="183" static="1">
		<f a="red:green:blue">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from integer RGB values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return The color as a AlphaColor</haxe_doc>
	</fromRGB>
	<fromRGBFloat public="1" get="inline" set="null" line="196" static="1">
		<f a="red:green:blue">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from float RGB values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return The color as a AlphaColor</haxe_doc>
	</fromRGBFloat>
	<fromRGBA public="1" get="inline" set="null" line="211" static="1">
		<f a="red:green:blue:alpha">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from integer RGBA values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @param alpha    The alpha value of the color from 0 to 255
     * @return The color as a AlphaColor</haxe_doc>
	</fromRGBA>
	<fromRGBAFloat public="1" get="inline" set="null" line="225" static="1">
		<f a="red:green:blue:alpha">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from float RGBA values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @param alpha    The green value of the color from 0 to 1
     * @return The color as a AlphaColor</haxe_doc>
	</fromRGBAFloat>
	<fromCMYK public="1" get="inline" set="null" line="240" static="1">
		<f a="cyan:magenta:yellow:black">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from CMYK values (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return The color as a AlphaColor</haxe_doc>
	</fromCMYK>
	<fromHSB public="1" set="method" line="254" static="1">
		<f a="hue:saturation:brightness">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from HSB (aka HSV) components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    The color as a AlphaColor</haxe_doc>
	</fromHSB>
	<fromHSL public="1" get="inline" set="null" line="268" static="1">
		<f a="hue:saturation:lightness">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a AlphaColor</haxe_doc>
	</fromHSL>
	<fromString public="1" set="method" line="287" static="1">
		<f a="str">
			<c path="String"/>
			<x path="Null"><x path="ceramic.AlphaColor"/></x>
		</f>
		<haxe_doc><![CDATA[* Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.
     *
     * Examples (input -> output in hex):
     *
     * - `0xFF00FF00`    -> `0xFF00FF00`
     * - `#FF0000FF`     -> `0xFF0000FF`
     * - `GRAY`        -> `0xFF808080`
     * - `blue`        -> `0xFF0000FF`
     *
     * @param    str     The string to be parsed
     * @return    A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
	</fromString>
	<getHSBColorWheel public="1" set="method" line="329" static="1">
		<f a=""><c path="Array"><x path="ceramic.AlphaColor"/></c></f>
		<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
     *
     * @return    HSB color wheel as Array of AlphaColors</haxe_doc>
	</getHSBColorWheel>
	<interpolate public="1" get="inline" set="null" line="342" static="1">
		<f a="color1:color2:?factor" v="::0.5">
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":value"><e>{ factor : 0.5 }</e></m></meta>
		<haxe_doc>* Get an interpolated color based on two different colors.
     *
     * @param     color1 The first color
     * @param     color2 The second color
     * @param     factor value from 0 to 1 representing how much to shift color1 toward color2
     * @return    The interpolated color</haxe_doc>
	</interpolate>
	<gradient public="1" set="method" line="361" static="1">
		<f a="color1:color2:steps:?ease">
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
			<x path="Int"/>
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<c path="Array"><x path="ceramic.AlphaColor"/></c>
		</f>
		<haxe_doc>* Create a gradient from one color to another
     *
     * @param color1 The color to shift from
     * @param color2 The color to shift to
     * @param steps How many colors the gradient should have
     * @param ease An optional easing function, such as those provided in FlxEase
     * @return An array of colors of length steps, shifting from color1 to color2</haxe_doc>
	</gradient>
	<multiply public="1" get="inline" set="null" line="385" static="1">
		<f a="lhs:rhs">
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":op"><e>A * B</e></m></meta>
		<haxe_doc>* Multiply the RGB channels of two AlphaColors</haxe_doc>
	</multiply>
	<add public="1" get="inline" set="null" line="394" static="1">
		<f a="lhs:rhs">
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
		<haxe_doc>* Add the RGB channels of two AlphaColors</haxe_doc>
	</add>
	<subtract public="1" get="inline" set="null" line="403" static="1">
		<f a="lhs:rhs">
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
		<haxe_doc>* Subtract the RGB channels of one Color from another</haxe_doc>
	</subtract>
	<toHexString public="1" get="inline" set="null" line="414" static="1">
		<f a="this:?prefix" v=":true">
			<x path="Int"/>
			<x path="Bool"/>
			<c path="String"/>
		</f>
		<meta><m n=":value"><e>{ prefix : true }</e></m></meta>
		<haxe_doc>* Return a String representation of the color in the format
     *
     * @param prefix Whether to include "0x" prefix at start of string
     * @return    A string of length 10 in the format 0xAARRGGBB</haxe_doc>
	</toHexString>
	<toWebString public="1" get="inline" set="null" line="425" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Return a String representation of the color in the format #RRGGBB
     *
     * @return    A string of length 7 in the format #RRGGBB</haxe_doc>
	</toWebString>
	<getColorInfo public="1" set="method" line="435" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Get a string of color information about this color
     *
     * @return A string containing information about this color</haxe_doc>
	</getColorInfo>
	<getDarkened public="1" set="method" line="454" static="1">
		<f a="this:?factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
		<haxe_doc>* Get a darkened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward black.
     * @return     A darkened version of this color</haxe_doc>
	</getDarkened>
	<getLightened public="1" get="inline" set="null" line="468" static="1">
		<f a="this:?factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
		<haxe_doc>* Get a lightened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward white.
     * @return     A lightened version of this color</haxe_doc>
	</getLightened>
	<getInverted public="1" get="inline" set="null" line="481" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Get the inversion of this color
     *
     * @return The inversion of this color</haxe_doc>
	</getInverted>
	<setRGB public="1" get="inline" set="null" line="497" static="1">
		<f a="this:red:green:blue">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set RGB values as integers (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return This color</haxe_doc>
	</setRGB>
	<setRGBA public="1" get="inline" set="null" line="514" static="1">
		<f a="this:red:green:blue:alpha">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set RGB values as integers (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @param alpha    The alpha value of the color from 0 to 255
     * @return This color</haxe_doc>
	</setRGBA>
	<setRGBFloat public="1" get="inline" set="null" line="531" static="1">
		<f a="this:red:green:blue">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set RGB values as floats (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return This color</haxe_doc>
	</setRGBFloat>
	<setRGBAFloat public="1" get="inline" set="null" line="548" static="1">
		<f a="this:red:green:blue:alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set RGB values as floats (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @param alpha    The alpha value of the color from 0 to 1
     * @return This color</haxe_doc>
	</setRGBAFloat>
	<setCMYK public="1" get="inline" set="null" line="566" static="1">
		<f a="this:cyan:magenta:yellow:black">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set CMYK values as floats (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return This color</haxe_doc>
	</setCMYK>
	<setHSB public="1" get="inline" set="null" line="582" static="1">
		<f a="this:hue:saturation:brightness">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set HSB (aka HSV) components
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    This color</haxe_doc>
	</setHSB>
	<setHSL public="1" get="inline" set="null" line="597" static="1">
		<f a="this:hue:saturation:lightness">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
	</setHSL>
	<setHSChromaMatch get="inline" set="null" line="607" static="1">
		<f a="this:hue:saturation:chroma:match">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
	</setHSChromaMatch>
	<_new public="1" get="inline" set="null" line="631" static="1">
		<f a="color:?alpha" v=":255">
			<x path="ceramic.Color"/>
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta>
			<m n=":value"><e>{ alpha : 255 }</e></m>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>* Create a new `AlphaColor` (ARGB) object from a `ceramic.Color` object and the given `alpha`
     * @param color RGB color object (`ceramic.Color`)
     * @param alpha alpha component between `0` and `255`</haxe_doc>
	</_new>
	<get_color get="inline" set="null" line="637" static="1"><f a="this">
	<x path="Int"/>
	<x path="ceramic.Color"/>
</f></get_color>
	<set_color get="inline" set="null" line="640" static="1"><f a="this:color">
	<x path="Int"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
	<get_rgb get="inline" set="null" line="647" static="1"><f a="this">
	<x path="Int"/>
	<x path="ceramic.Color"/>
</f></get_rgb>
	<set_rgb get="inline" set="null" line="650" static="1"><f a="this:color">
	<x path="Int"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_rgb>
	<get_red get="inline" set="null" line="657" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_red>
	<get_green get="inline" set="null" line="661" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_green>
	<get_blue get="inline" set="null" line="665" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_blue>
	<get_alpha get="inline" set="null" line="669" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_alpha>
	<get_redFloat get="inline" set="null" line="673" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_redFloat>
	<get_greenFloat get="inline" set="null" line="677" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_greenFloat>
	<get_blueFloat get="inline" set="null" line="681" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_blueFloat>
	<get_alphaFloat get="inline" set="null" line="685" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_alphaFloat>
	<set_red get="inline" set="null" line="689" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_red>
	<set_green get="inline" set="null" line="695" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_green>
	<set_blue get="inline" set="null" line="701" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_blue>
	<set_alpha get="inline" set="null" line="707" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_alpha>
	<set_redFloat get="inline" set="null" line="713" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_redFloat>
	<set_greenFloat get="inline" set="null" line="718" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_greenFloat>
	<set_blueFloat get="inline" set="null" line="723" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_blueFloat>
	<set_alphaFloat get="inline" set="null" line="728" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_alphaFloat>
	<get_cyan get="inline" set="null" line="734" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_cyan>
	<get_magenta get="inline" set="null" line="739" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_magenta>
	<get_yellow get="inline" set="null" line="744" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_yellow>
	<get_black get="inline" set="null" line="749" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_black>
	<set_cyan get="inline" set="null" line="754" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_cyan>
	<set_magenta get="inline" set="null" line="760" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_magenta>
	<set_yellow get="inline" set="null" line="766" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_yellow>
	<set_black get="inline" set="null" line="772" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_black>
	<get_hue set="method" line="778" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hue>
	<get_brightness get="inline" set="null" line="790" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_brightness>
	<get_saturation get="inline" set="null" line="795" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturation>
	<get_lightness get="inline" set="null" line="800" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightness>
	<set_hue get="inline" set="null" line="805" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hue>
	<set_saturation get="inline" set="null" line="811" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturation>
	<set_brightness get="inline" set="null" line="817" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_brightness>
	<set_lightness get="inline" set="null" line="823" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightness>
	<maxColor get="inline" set="null" line="829" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></maxColor>
	<minColor get="inline" set="null" line="834" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></minColor>
	<boundChannel get="inline" set="null" line="839" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></boundChannel>
	<roundDecimal set="method" line="846" static="1"><f a="value:precision">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></roundDecimal>
	<bound get="inline" set="null" line="856" static="1"><f a="value:?min:?max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></bound>
	<toString public="1" get="inline" set="null" line="867" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Get this RGBA color as `String`.
     * Format: `0xAARRGGBB`</haxe_doc>
	</toString>
	<_hsluvTuple expr="[0, 0, 0]" line="877" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
	</_hsluvTuple>
	<_hsluvResult expr="[0, 0, 0]" line="879" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
	</_hsluvResult>
	<hueHSLuv public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The HSLuv hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hueHSLuv>
	<saturationHSLuv public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The HSLuv saturation of the color (from 0 to 1)</haxe_doc>
	</saturationHSLuv>
	<lightnessHSLuv public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The HSLuv lightness of the color (from 0 to 1)</haxe_doc>
	</lightnessHSLuv>
	<get_hueHSLuv set="method" line="895" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hueHSLuv>
	<set_hueHSLuv get="inline" set="null" line="900" static="1"><f a="this:hueHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hueHSLuv>
	<get_saturationHSLuv set="method" line="906" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturationHSLuv>
	<set_saturationHSLuv get="inline" set="null" line="911" static="1"><f a="this:saturationHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturationHSLuv>
	<get_lightnessHSLuv set="method" line="917" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightnessHSLuv>
	<set_lightnessHSLuv get="inline" set="null" line="922" static="1"><f a="this:lightnessHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightnessHSLuv>
	<_getOrCreateCachedHSLuvComponent get="inline" set="null" line="928" static="1"><f a="this:index">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></_getOrCreateCachedHSLuvComponent>
	<fromHSLuv public="1" get="inline" set="null" line="951" static="1">
		<f a="hue:saturation:lightness">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a AlphaColor</haxe_doc>
	</fromHSLuv>
	<setHSLuv public="1" get="inline" set="null" line="965" static="1">
		<f a="this:hue:saturation:lightness">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
	</setHSLuv>
	<getHSLuv public="1" get="inline" set="null" line="997" static="1">
		<f a="this:?result">
			<x path="Int"/>
			<c path="Array"><x path="Float"/></c>
			<c path="Array"><x path="Float"/></c>
		</f>
		<haxe_doc>* Get HSLuv components from the color instance.
     *
     * @param result A pre-allocated array to store the result into.
     * @return    The HSLuv components as a float array</haxe_doc>
	</getHSLuv>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._AlphaColor.AlphaColor_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AlphaColor.hx" private="1" module="ceramic.AlphaColor" final="1">
		<NONE public="1" get="inline" set="null" expr="-1" line="19" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</NONE>
		<TRANSPARENT public="1" get="inline" set="null" expr="0x00000000" line="21" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
		</TRANSPARENT>
		<WHITE public="1" get="inline" set="null" expr="0xFFFFFFFF" line="23" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFFFFF</e></m></meta>
		</WHITE>
		<GRAY public="1" get="inline" set="null" expr="0xFF808080" line="24" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF808080</e></m></meta>
		</GRAY>
		<BLACK public="1" get="inline" set="null" expr="0xFF000000" line="25" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF000000</e></m></meta>
		</BLACK>
		<GREEN public="1" get="inline" set="null" expr="0xFF008000" line="27" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF008000</e></m></meta>
		</GREEN>
		<LIME public="1" get="inline" set="null" expr="0xFF00FF00" line="28" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF00FF00</e></m></meta>
		</LIME>
		<YELLOW public="1" get="inline" set="null" expr="0xFFFFFF00" line="29" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFFF00</e></m></meta>
		</YELLOW>
		<ORANGE public="1" get="inline" set="null" expr="0xFFFFA500" line="30" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFA500</e></m></meta>
		</ORANGE>
		<RED public="1" get="inline" set="null" expr="0xFFFF0000" line="31" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF0000</e></m></meta>
		</RED>
		<PURPLE public="1" get="inline" set="null" expr="0xFF800080" line="32" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF800080</e></m></meta>
		</PURPLE>
		<BLUE public="1" get="inline" set="null" expr="0xFF0000FF" line="33" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF0000FF</e></m></meta>
		</BLUE>
		<BROWN public="1" get="inline" set="null" expr="0xFF8B4513" line="34" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF8B4513</e></m></meta>
		</BROWN>
		<PINK public="1" get="inline" set="null" expr="0xFFFFC0CB" line="35" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFC0CB</e></m></meta>
		</PINK>
		<MAGENTA public="1" get="inline" set="null" expr="0xFFFF00FF" line="36" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
		</MAGENTA>
		<CYAN public="1" get="inline" set="null" expr="0xFF00FFFF" line="37" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
		</CYAN>
		<CORNFLOWERBLUE public="1" get="inline" set="null" expr="0xFF6495ED" line="39" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF6495ED</e></m></meta>
		</CORNFLOWERBLUE>
		<MEDIUMVIOLETRED public="1" get="inline" set="null" expr="0xFFC71585" line="40" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFC71585</e></m></meta>
		</MEDIUMVIOLETRED>
		<DEEPPINK public="1" get="inline" set="null" expr="0xFFFF1493" line="41" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF1493</e></m></meta>
		</DEEPPINK>
		<PALEVIOLETRED public="1" get="inline" set="null" expr="0xFFDB7093" line="42" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFDB7093</e></m></meta>
		</PALEVIOLETRED>
		<HOTPINK public="1" get="inline" set="null" expr="0xFFFF69B4" line="43" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF69B4</e></m></meta>
		</HOTPINK>
		<LIGHTPINK public="1" get="inline" set="null" expr="0xFFFFB6C1" line="44" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFB6C1</e></m></meta>
		</LIGHTPINK>
		<DARKRED public="1" get="inline" set="null" expr="0xFF8B0000" line="45" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF8B0000</e></m></meta>
		</DARKRED>
		<FIREBRICK public="1" get="inline" set="null" expr="0xFFB22222" line="46" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFB22222</e></m></meta>
		</FIREBRICK>
		<CRIMSON public="1" get="inline" set="null" expr="0xFFDC143C" line="47" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFDC143C</e></m></meta>
		</CRIMSON>
		<INDIANRED public="1" get="inline" set="null" expr="0xFFCD5C5C" line="48" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFCD5C5C</e></m></meta>
		</INDIANRED>
		<LIGHTCORAL public="1" get="inline" set="null" expr="0xFFF08080" line="49" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFF08080</e></m></meta>
		</LIGHTCORAL>
		<SALMON public="1" get="inline" set="null" expr="0xFFFA8072" line="50" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFA8072</e></m></meta>
		</SALMON>
		<DARKSALMON public="1" get="inline" set="null" expr="0xFFE9967A" line="51" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFE9967A</e></m></meta>
		</DARKSALMON>
		<LIGHTSALMON public="1" get="inline" set="null" expr="0xFFFFA07A" line="52" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFA07A</e></m></meta>
		</LIGHTSALMON>
		<ORANGERED public="1" get="inline" set="null" expr="0xFFFF4500" line="53" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF4500</e></m></meta>
		</ORANGERED>
		<TOMATO public="1" get="inline" set="null" expr="0xFFFF6347" line="54" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF6347</e></m></meta>
		</TOMATO>
		<DARKORANGE public="1" get="inline" set="null" expr="0xFFFF8C00" line="55" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF8C00</e></m></meta>
		</DARKORANGE>
		<CORAL public="1" get="inline" set="null" expr="0xFFFF7F50" line="56" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF7F50</e></m></meta>
		</CORAL>
		<DARKKHAKI public="1" get="inline" set="null" expr="0xFFBDB76B" line="57" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFBDB76B</e></m></meta>
		</DARKKHAKI>
		<GOLD public="1" get="inline" set="null" expr="0xFFFFD700" line="58" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFD700</e></m></meta>
		</GOLD>
		<KHAKI public="1" get="inline" set="null" expr="0xFFF0E68C" line="59" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFF0E68C</e></m></meta>
		</KHAKI>
		<PEACHPUFF public="1" get="inline" set="null" expr="0xFFFFDAB9" line="60" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFDAB9</e></m></meta>
		</PEACHPUFF>
		<PALEGOLDENROD public="1" get="inline" set="null" expr="0xFFEEE8AA" line="61" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFEEE8AA</e></m></meta>
		</PALEGOLDENROD>
		<MOCCASIN public="1" get="inline" set="null" expr="0xFFFFE4B5" line="62" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFE4B5</e></m></meta>
		</MOCCASIN>
		<PAPAYAWHIP public="1" get="inline" set="null" expr="0xFFFFEFD5" line="63" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFEFD5</e></m></meta>
		</PAPAYAWHIP>
		<LEMONCHIFFON public="1" get="inline" set="null" expr="0xFFFFFACD" line="64" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFFACD</e></m></meta>
		</LEMONCHIFFON>
		<LIGHTYELLOW public="1" get="inline" set="null" expr="0xFFFFFFE0" line="65" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFFFE0</e></m></meta>
		</LIGHTYELLOW>
		<SIENNA public="1" get="inline" set="null" expr="0xFFA0522D" line="66" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFA0522D</e></m></meta>
		</SIENNA>
		<CHOCOLATE public="1" get="inline" set="null" expr="0xFFD2691E" line="67" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFD2691E</e></m></meta>
		</CHOCOLATE>
		<PERU public="1" get="inline" set="null" expr="0xFFCD853F" line="68" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFCD853F</e></m></meta>
		</PERU>
		<TAN public="1" get="inline" set="null" expr="0xFFD2B48C" line="69" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFD2B48C</e></m></meta>
		</TAN>
		<DARKOLIVEGREEN public="1" get="inline" set="null" expr="0xFF556B2F" line="70" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF556B2F</e></m></meta>
		</DARKOLIVEGREEN>
		<OLIVE public="1" get="inline" set="null" expr="0xFF808000" line="71" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF808000</e></m></meta>
		</OLIVE>
		<TEAL public="1" get="inline" set="null" expr="0xFF008080" line="72" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF008080</e></m></meta>
		</TEAL>
		<TURQUOISE public="1" get="inline" set="null" expr="0xFF40E0D0" line="73" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF40E0D0</e></m></meta>
		</TURQUOISE>
		<NAVY public="1" get="inline" set="null" expr="0xFF000080" line="74" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF000080</e></m></meta>
		</NAVY>
		<INDIGO public="1" get="inline" set="null" expr="0xFF4B0082" line="75" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF4B0082</e></m></meta>
		</INDIGO>
		<ORCHID public="1" get="inline" set="null" expr="0xFFDA70D6" line="76" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFDA70D6</e></m></meta>
		</ORCHID>
		<LAVENDER public="1" get="inline" set="null" expr="0xFFE6E6FA" line="77" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFE6E6FA</e></m></meta>
		</LAVENDER>
		<AZURE public="1" get="inline" set="null" expr="0xFFF0FFFF" line="78" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFF0FFFF</e></m></meta>
		</AZURE>
		<IVORY public="1" get="inline" set="null" expr="0xFFFFFFF0" line="79" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFFFF0</e></m></meta>
		</IVORY>
		<DIMGREY public="1" get="inline" set="null" expr="0xFF696969" line="80" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF696969</e></m></meta>
		</DIMGREY>
		<SLATEGREY public="1" get="inline" set="null" expr="0xFF708090" line="81" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF708090</e></m></meta>
		</SLATEGREY>
		<SNOW public="1" get="inline" set="null" expr="0xFFFFFAFA" line="82" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFFAFA</e></m></meta>
		</SNOW>
		<red public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Red color component as `Int` between `0` and `255`</haxe_doc>
		</red>
		<green public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Green color component as `Int` between `0` and `255`</haxe_doc>
		</green>
		<blue public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Blue color component as `Int` between `0` and `255`</haxe_doc>
		</blue>
		<alpha public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Alpha component as `Int` between `0` and `255`</haxe_doc>
		</alpha>
		<redFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Red color component as `Float` between `0.0` and `1.0`</haxe_doc>
		</redFloat>
		<greenFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Green color component as `Float` between `0.0` and `1.0`</haxe_doc>
		</greenFloat>
		<blueFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Blue color component as `Float` between `0.0` and `1.0`</haxe_doc>
		</blueFloat>
		<alphaFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Alpha component as `Float` between `0.0` and `1.0`</haxe_doc>
		</alphaFloat>
		<cyan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></cyan>
		<magenta public="1" get="accessor" set="accessor" static="1"><x path="Float"/></magenta>
		<yellow public="1" get="accessor" set="accessor" static="1"><x path="Float"/></yellow>
		<black public="1" get="accessor" set="accessor" static="1"><x path="Float"/></black>
		<hue public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hue>
		<saturation public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
		</saturation>
		<brightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
		</brightness>
		<lightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
		</lightness>
		<color public="1" get="accessor" set="accessor" static="1">
			<x path="ceramic.Color"/>
			<haxe_doc>* RGB color component typed as `ceramic.Color`</haxe_doc>
		</color>
		<rgb public="1" get="accessor" set="accessor" static="1">
			<x path="ceramic.Color"/>
			<haxe_doc>* RGB color component typed as `ceramic.Color` (alias of `color`)</haxe_doc>
		</rgb>
		<toColor public="1" get="inline" set="null" line="150" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":to"/></meta>
		</toColor>
		<random public="1" get="inline" set="null" line="159" static="1">
			<f a="?minSatutation:?minBrightness" v="0.5:0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":value"><e>{ minBrightness : 0.5, minSatutation : 0.5 }</e></m></meta>
			<haxe_doc>* Generate a random color (away from white or black)
     * @return The color as an AlphaColor</haxe_doc>
		</random>
		<fromInt public="1" get="inline" set="null" line="170" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Create a color from the least significant four bytes of an Int
     *
     * @param    value And Int with bytes in the format 0xAARRGGBB
     * @return    The color as an AlphaColor</haxe_doc>
		</fromInt>
		<fromRGB public="1" get="inline" set="null" line="183" static="1">
			<f a="red:green:blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from integer RGB values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return The color as a AlphaColor</haxe_doc>
		</fromRGB>
		<fromRGBFloat public="1" get="inline" set="null" line="196" static="1">
			<f a="red:green:blue">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from float RGB values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return The color as a AlphaColor</haxe_doc>
		</fromRGBFloat>
		<fromRGBA public="1" get="inline" set="null" line="211" static="1">
			<f a="red:green:blue:alpha">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from integer RGBA values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @param alpha    The alpha value of the color from 0 to 255
     * @return The color as a AlphaColor</haxe_doc>
		</fromRGBA>
		<fromRGBAFloat public="1" get="inline" set="null" line="225" static="1">
			<f a="red:green:blue:alpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from float RGBA values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @param alpha    The green value of the color from 0 to 1
     * @return The color as a AlphaColor</haxe_doc>
		</fromRGBAFloat>
		<fromCMYK public="1" get="inline" set="null" line="240" static="1">
			<f a="cyan:magenta:yellow:black">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from CMYK values (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return The color as a AlphaColor</haxe_doc>
		</fromCMYK>
		<fromHSB public="1" set="method" line="254" static="1">
			<f a="hue:saturation:brightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from HSB (aka HSV) components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    The color as a AlphaColor</haxe_doc>
		</fromHSB>
		<fromHSL public="1" get="inline" set="null" line="268" static="1">
			<f a="hue:saturation:lightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a AlphaColor</haxe_doc>
		</fromHSL>
		<fromString public="1" set="method" line="287" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Null"><x path="ceramic.AlphaColor"/></x>
			</f>
			<haxe_doc><![CDATA[* Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.
     *
     * Examples (input -> output in hex):
     *
     * - `0xFF00FF00`    -> `0xFF00FF00`
     * - `#FF0000FF`     -> `0xFF0000FF`
     * - `GRAY`        -> `0xFF808080`
     * - `blue`        -> `0xFF0000FF`
     *
     * @param    str     The string to be parsed
     * @return    A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
		</fromString>
		<getHSBColorWheel public="1" set="method" line="329" static="1">
			<f a=""><c path="Array"><x path="ceramic.AlphaColor"/></c></f>
			<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
     *
     * @return    HSB color wheel as Array of AlphaColors</haxe_doc>
		</getHSBColorWheel>
		<interpolate public="1" get="inline" set="null" line="342" static="1">
			<f a="color1:color2:?factor" v="::0.5">
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.5 }</e></m></meta>
			<haxe_doc>* Get an interpolated color based on two different colors.
     *
     * @param     color1 The first color
     * @param     color2 The second color
     * @param     factor value from 0 to 1 representing how much to shift color1 toward color2
     * @return    The interpolated color</haxe_doc>
		</interpolate>
		<gradient public="1" set="method" line="361" static="1">
			<f a="color1:color2:steps:?ease">
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
				<x path="Int"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<c path="Array"><x path="ceramic.AlphaColor"/></c>
			</f>
			<haxe_doc>* Create a gradient from one color to another
     *
     * @param color1 The color to shift from
     * @param color2 The color to shift to
     * @param steps How many colors the gradient should have
     * @param ease An optional easing function, such as those provided in FlxEase
     * @return An array of colors of length steps, shifting from color1 to color2</haxe_doc>
		</gradient>
		<multiply public="1" get="inline" set="null" line="385" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":op"><e>A * B</e></m></meta>
			<haxe_doc>* Multiply the RGB channels of two AlphaColors</haxe_doc>
		</multiply>
		<add public="1" get="inline" set="null" line="394" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
			<haxe_doc>* Add the RGB channels of two AlphaColors</haxe_doc>
		</add>
		<subtract public="1" get="inline" set="null" line="403" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
			<haxe_doc>* Subtract the RGB channels of one Color from another</haxe_doc>
		</subtract>
		<toHexString public="1" get="inline" set="null" line="414" static="1">
			<f a="this:?prefix" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ prefix : true }</e></m></meta>
			<haxe_doc>* Return a String representation of the color in the format
     *
     * @param prefix Whether to include "0x" prefix at start of string
     * @return    A string of length 10 in the format 0xAARRGGBB</haxe_doc>
		</toHexString>
		<toWebString public="1" get="inline" set="null" line="425" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a String representation of the color in the format #RRGGBB
     *
     * @return    A string of length 7 in the format #RRGGBB</haxe_doc>
		</toWebString>
		<getColorInfo public="1" set="method" line="435" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Get a string of color information about this color
     *
     * @return A string containing information about this color</haxe_doc>
		</getColorInfo>
		<getDarkened public="1" set="method" line="454" static="1">
			<f a="this:?factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
			<haxe_doc>* Get a darkened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward black.
     * @return     A darkened version of this color</haxe_doc>
		</getDarkened>
		<getLightened public="1" get="inline" set="null" line="468" static="1">
			<f a="this:?factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
			<haxe_doc>* Get a lightened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward white.
     * @return     A lightened version of this color</haxe_doc>
		</getLightened>
		<getInverted public="1" get="inline" set="null" line="481" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Get the inversion of this color
     *
     * @return The inversion of this color</haxe_doc>
		</getInverted>
		<setRGB public="1" get="inline" set="null" line="497" static="1">
			<f a="this:red:green:blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set RGB values as integers (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return This color</haxe_doc>
		</setRGB>
		<setRGBA public="1" get="inline" set="null" line="514" static="1">
			<f a="this:red:green:blue:alpha">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set RGB values as integers (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @param alpha    The alpha value of the color from 0 to 255
     * @return This color</haxe_doc>
		</setRGBA>
		<setRGBFloat public="1" get="inline" set="null" line="531" static="1">
			<f a="this:red:green:blue">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set RGB values as floats (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return This color</haxe_doc>
		</setRGBFloat>
		<setRGBAFloat public="1" get="inline" set="null" line="548" static="1">
			<f a="this:red:green:blue:alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set RGB values as floats (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @param alpha    The alpha value of the color from 0 to 1
     * @return This color</haxe_doc>
		</setRGBAFloat>
		<setCMYK public="1" get="inline" set="null" line="566" static="1">
			<f a="this:cyan:magenta:yellow:black">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set CMYK values as floats (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return This color</haxe_doc>
		</setCMYK>
		<setHSB public="1" get="inline" set="null" line="582" static="1">
			<f a="this:hue:saturation:brightness">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set HSB (aka HSV) components
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    This color</haxe_doc>
		</setHSB>
		<setHSL public="1" get="inline" set="null" line="597" static="1">
			<f a="this:hue:saturation:lightness">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
		</setHSL>
		<setHSChromaMatch get="inline" set="null" line="607" static="1">
			<f a="this:hue:saturation:chroma:match">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
		</setHSChromaMatch>
		<_new public="1" get="inline" set="null" line="631" static="1">
			<f a="color:?alpha" v=":255">
				<x path="ceramic.Color"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta>
				<m n=":value"><e>{ alpha : 255 }</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Create a new `AlphaColor` (ARGB) object from a `ceramic.Color` object and the given `alpha`
     * @param color RGB color object (`ceramic.Color`)
     * @param alpha alpha component between `0` and `255`</haxe_doc>
		</_new>
		<get_color get="inline" set="null" line="637" static="1"><f a="this">
	<x path="Int"/>
	<x path="ceramic.Color"/>
</f></get_color>
		<set_color get="inline" set="null" line="640" static="1"><f a="this:color">
	<x path="Int"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
		<get_rgb get="inline" set="null" line="647" static="1"><f a="this">
	<x path="Int"/>
	<x path="ceramic.Color"/>
</f></get_rgb>
		<set_rgb get="inline" set="null" line="650" static="1"><f a="this:color">
	<x path="Int"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_rgb>
		<get_red get="inline" set="null" line="657" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_red>
		<get_green get="inline" set="null" line="661" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_green>
		<get_blue get="inline" set="null" line="665" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_blue>
		<get_alpha get="inline" set="null" line="669" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_alpha>
		<get_redFloat get="inline" set="null" line="673" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_redFloat>
		<get_greenFloat get="inline" set="null" line="677" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_greenFloat>
		<get_blueFloat get="inline" set="null" line="681" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_blueFloat>
		<get_alphaFloat get="inline" set="null" line="685" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_alphaFloat>
		<set_red get="inline" set="null" line="689" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_red>
		<set_green get="inline" set="null" line="695" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_green>
		<set_blue get="inline" set="null" line="701" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_blue>
		<set_alpha get="inline" set="null" line="707" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_alpha>
		<set_redFloat get="inline" set="null" line="713" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_redFloat>
		<set_greenFloat get="inline" set="null" line="718" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_greenFloat>
		<set_blueFloat get="inline" set="null" line="723" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_blueFloat>
		<set_alphaFloat get="inline" set="null" line="728" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_alphaFloat>
		<get_cyan get="inline" set="null" line="734" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_cyan>
		<get_magenta get="inline" set="null" line="739" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_magenta>
		<get_yellow get="inline" set="null" line="744" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_yellow>
		<get_black get="inline" set="null" line="749" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_black>
		<set_cyan get="inline" set="null" line="754" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_cyan>
		<set_magenta get="inline" set="null" line="760" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_magenta>
		<set_yellow get="inline" set="null" line="766" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_yellow>
		<set_black get="inline" set="null" line="772" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_black>
		<get_hue set="method" line="778" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hue>
		<get_brightness get="inline" set="null" line="790" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_brightness>
		<get_saturation get="inline" set="null" line="795" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturation>
		<get_lightness get="inline" set="null" line="800" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightness>
		<set_hue get="inline" set="null" line="805" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hue>
		<set_saturation get="inline" set="null" line="811" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturation>
		<set_brightness get="inline" set="null" line="817" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_brightness>
		<set_lightness get="inline" set="null" line="823" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightness>
		<maxColor get="inline" set="null" line="829" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></maxColor>
		<minColor get="inline" set="null" line="834" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></minColor>
		<boundChannel get="inline" set="null" line="839" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></boundChannel>
		<roundDecimal set="method" line="846" static="1"><f a="value:precision">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></roundDecimal>
		<bound get="inline" set="null" line="856" static="1"><f a="value:?min:?max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></bound>
		<toString public="1" get="inline" set="null" line="867" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Get this RGBA color as `String`.
     * Format: `0xAARRGGBB`</haxe_doc>
		</toString>
		<_hsluvTuple expr="[0, 0, 0]" line="877" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
		</_hsluvTuple>
		<_hsluvResult expr="[0, 0, 0]" line="879" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
		</_hsluvResult>
		<hueHSLuv public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The HSLuv hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hueHSLuv>
		<saturationHSLuv public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The HSLuv saturation of the color (from 0 to 1)</haxe_doc>
		</saturationHSLuv>
		<lightnessHSLuv public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The HSLuv lightness of the color (from 0 to 1)</haxe_doc>
		</lightnessHSLuv>
		<get_hueHSLuv set="method" line="895" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hueHSLuv>
		<set_hueHSLuv get="inline" set="null" line="900" static="1"><f a="this:hueHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hueHSLuv>
		<get_saturationHSLuv set="method" line="906" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturationHSLuv>
		<set_saturationHSLuv get="inline" set="null" line="911" static="1"><f a="this:saturationHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturationHSLuv>
		<get_lightnessHSLuv set="method" line="917" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightnessHSLuv>
		<set_lightnessHSLuv get="inline" set="null" line="922" static="1"><f a="this:lightnessHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightnessHSLuv>
		<_getOrCreateCachedHSLuvComponent get="inline" set="null" line="928" static="1"><f a="this:index">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></_getOrCreateCachedHSLuvComponent>
		<fromHSLuv public="1" get="inline" set="null" line="951" static="1">
			<f a="hue:saturation:lightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a AlphaColor</haxe_doc>
		</fromHSLuv>
		<setHSLuv public="1" get="inline" set="null" line="965" static="1">
			<f a="this:hue:saturation:lightness">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
		</setHSLuv>
		<getHSLuv public="1" get="inline" set="null" line="997" static="1">
			<f a="this:?result">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Get HSLuv components from the color instance.
     *
     * @param result A pre-allocated array to store the result into.
     * @return    The HSLuv components as a float array</haxe_doc>
		</getHSLuv>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.App" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/App.hx">
		<extends path="ceramic.Entity"/>
		<app public="1" get="accessor" set="null" static="1">
			<c path="ceramic.App"/>
			<haxe_doc>* Shared `App` instance singleton.</haxe_doc>
		</app>
		<get_app get="inline" set="null" line="51" static="1"><f a=""><c path="ceramic.App"/></f></get_app>
		<preInitCallbacks static="1"><c path="Array"><f a=""><x path="Void"/></f></c></preInitCallbacks>
		<oncePreInit set="method" line="484" static="1"><f a="handle">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></oncePreInit>
		<init public="1" set="method" line="687" static="1">
			<f a=""><c path="ceramic.InitSettings"/></f>
			<meta><m n=":noCompletion"/></meta>
		</init>
		<_dox_event_ready public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app is ready
     * and the game logic can be started.</haxe_doc>
		</_dox_event_ready>
		<emitReady set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when the app is ready
     * and the game logic can be started.</haxe_doc>
		</emitReady>
		<onReady public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app is ready
     * and the game logic can be started.</haxe_doc>
		</onReady>
		<onceReady public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app is ready
     * and the game logic can be started.</haxe_doc>
		</onceReady>
		<offReady public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app is ready
     * and the game logic can be started.</haxe_doc>
		</offReady>
		<listensReady public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app is ready
     * and the game logic can be started.</haxe_doc>
		</listensReady>
		<_dox_event_update public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired as many times as there are frames per seconds.
     * It is in sync with screen FPS but used for everything that needs
     * to get updated depending on time (ceramic.Timer relies on it).
     * Use this event to update your contents before they get drawn again.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</_dox_event_update>
		<emitUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired as many times as there are frames per seconds.
     * It is in sync with screen FPS but used for everything that needs
     * to get updated depending on time (ceramic.Timer relies on it).
     * Use this event to update your contents before they get drawn again.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</emitUpdate>
		<onUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired as many times as there are frames per seconds.
     * It is in sync with screen FPS but used for everything that needs
     * to get updated depending on time (ceramic.Timer relies on it).
     * Use this event to update your contents before they get drawn again.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</onUpdate>
		<onceUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired as many times as there are frames per seconds.
     * It is in sync with screen FPS but used for everything that needs
     * to get updated depending on time (ceramic.Timer relies on it).
     * Use this event to update your contents before they get drawn again.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</onceUpdate>
		<offUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired as many times as there are frames per seconds.
     * It is in sync with screen FPS but used for everything that needs
     * to get updated depending on time (ceramic.Timer relies on it).
     * Use this event to update your contents before they get drawn again.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</offUpdate>
		<listensUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired as many times as there are frames per seconds.
     * It is in sync with screen FPS but used for everything that needs
     * to get updated depending on time (ceramic.Timer relies on it).
     * Use this event to update your contents before they get drawn again.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</listensUpdate>
		<_dox_event_preUpdate public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right before update event and
     * can be used when you want to run garantee your code
     * will be run before regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</_dox_event_preUpdate>
		<emitPreUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired right before update event and
     * can be used when you want to run garantee your code
     * will be run before regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</emitPreUpdate>
		<onPreUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before update event and
     * can be used when you want to run garantee your code
     * will be run before regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</onPreUpdate>
		<oncePreUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before update event and
     * can be used when you want to run garantee your code
     * will be run before regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</oncePreUpdate>
		<offPreUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before update event and
     * can be used when you want to run garantee your code
     * will be run before regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</offPreUpdate>
		<listensPreUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before update event and
     * can be used when you want to run garantee your code
     * will be run before regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</listensPreUpdate>
		<_dox_event_postUpdate public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right after update event and
     * can be used when you want to run garantee your code
     * will be run after regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</_dox_event_postUpdate>
		<emitPostUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired right after update event and
     * can be used when you want to run garantee your code
     * will be run after regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</emitPostUpdate>
		<onPostUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after update event and
     * can be used when you want to run garantee your code
     * will be run after regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</onPostUpdate>
		<oncePostUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after update event and
     * can be used when you want to run garantee your code
     * will be run after regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</oncePostUpdate>
		<offPostUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after update event and
     * can be used when you want to run garantee your code
     * will be run after regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</offPostUpdate>
		<listensPostUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after update event and
     * can be used when you want to run garantee your code
     * will be run after regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</listensPostUpdate>
		<_dox_event_defaultAssetsLoad public="1" set="method" line="637">
			<f a="assets">
				<c path="ceramic.Assets"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right before default assets are being loaded.
     * @param assets
     *      The `Assets` instance used to load default assets.
     *      If you add custom assets to this instance, they will be loaded as well.</haxe_doc>
		</_dox_event_defaultAssetsLoad>
		<emitDefaultAssetsLoad set="method" line="1095">
			<f a="assets">
				<c path="ceramic.Assets"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired right before default assets are being loaded.
     * @param assets
     *      The `Assets` instance used to load default assets.
     *      If you add custom assets to this instance, they will be loaded as well.</haxe_doc>
		</emitDefaultAssetsLoad>
		<onDefaultAssetsLoad public="1" set="method" line="1199">
			<f a="owner:handleAssets">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="assets">
					<c path="ceramic.Assets"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before default assets are being loaded.
     * @param assets
     *      The `Assets` instance used to load default assets.
     *      If you add custom assets to this instance, they will be loaded as well.</haxe_doc>
		</onDefaultAssetsLoad>
		<onceDefaultAssetsLoad public="1" set="method" line="1298">
			<f a="owner:handleAssets">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="assets">
					<c path="ceramic.Assets"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before default assets are being loaded.
     * @param assets
     *      The `Assets` instance used to load default assets.
     *      If you add custom assets to this instance, they will be loaded as well.</haxe_doc>
		</onceDefaultAssetsLoad>
		<offDefaultAssetsLoad public="1" set="method" line="1368">
			<f a="?handleAssets">
				<f a="assets">
					<c path="ceramic.Assets"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before default assets are being loaded.
     * @param assets
     *      The `Assets` instance used to load default assets.
     *      If you add custom assets to this instance, they will be loaded as well.</haxe_doc>
		</offDefaultAssetsLoad>
		<listensDefaultAssetsLoad public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before default assets are being loaded.
     * @param assets
     *      The `Assets` instance used to load default assets.
     *      If you add custom assets to this instance, they will be loaded as well.</haxe_doc>
		</listensDefaultAssetsLoad>
		<_dox_event_criticalError public="1" set="method" line="637">
			<f a="error:stack">
				<d/>
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app hits an critical (uncaught) error.
     * Can be used to perform custom crash reporting.
     * If this even is handled, app exit should be performed by the event handler.
     * @param error The error
     * @param stack The stack trace of the error</haxe_doc>
		</_dox_event_criticalError>
		<emitCriticalError set="method" line="1095">
			<f a="error:stack">
				<d/>
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired when the app hits an critical (uncaught) error.
     * Can be used to perform custom crash reporting.
     * If this even is handled, app exit should be performed by the event handler.
     * @param error The error
     * @param stack The stack trace of the error</haxe_doc>
		</emitCriticalError>
		<onCriticalError public="1" set="method" line="1199">
			<f a="owner:handleErrorStack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="error:stack">
					<d/>
					<c path="Array"><e path="haxe.StackItem"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app hits an critical (uncaught) error.
     * Can be used to perform custom crash reporting.
     * If this even is handled, app exit should be performed by the event handler.
     * @param error The error
     * @param stack The stack trace of the error</haxe_doc>
		</onCriticalError>
		<onceCriticalError public="1" set="method" line="1298">
			<f a="owner:handleErrorStack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="error:stack">
					<d/>
					<c path="Array"><e path="haxe.StackItem"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app hits an critical (uncaught) error.
     * Can be used to perform custom crash reporting.
     * If this even is handled, app exit should be performed by the event handler.
     * @param error The error
     * @param stack The stack trace of the error</haxe_doc>
		</onceCriticalError>
		<offCriticalError public="1" set="method" line="1368">
			<f a="?handleErrorStack">
				<f a="error:stack">
					<d/>
					<c path="Array"><e path="haxe.StackItem"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app hits an critical (uncaught) error.
     * Can be used to perform custom crash reporting.
     * If this even is handled, app exit should be performed by the event handler.
     * @param error The error
     * @param stack The stack trace of the error</haxe_doc>
		</offCriticalError>
		<listensCriticalError public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app hits an critical (uncaught) error.
     * Can be used to perform custom crash reporting.
     * If this even is handled, app exit should be performed by the event handler.
     * @param error The error
     * @param stack The stack trace of the error</haxe_doc>
		</listensCriticalError>
		<_dox_event_beginEnterBackground public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app will enter background state.</haxe_doc>
		</_dox_event_beginEnterBackground>
		<emitBeginEnterBackground set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when the app will enter background state.</haxe_doc>
		</emitBeginEnterBackground>
		<onBeginEnterBackground public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter background state.</haxe_doc>
		</onBeginEnterBackground>
		<onceBeginEnterBackground public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter background state.</haxe_doc>
		</onceBeginEnterBackground>
		<offBeginEnterBackground public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter background state.</haxe_doc>
		</offBeginEnterBackground>
		<listensBeginEnterBackground public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter background state.</haxe_doc>
		</listensBeginEnterBackground>
		<_dox_event_finishEnterBackground public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering background state.</haxe_doc>
		</_dox_event_finishEnterBackground>
		<emitFinishEnterBackground set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when the app did finish entering background state.</haxe_doc>
		</emitFinishEnterBackground>
		<onFinishEnterBackground public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering background state.</haxe_doc>
		</onFinishEnterBackground>
		<onceFinishEnterBackground public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering background state.</haxe_doc>
		</onceFinishEnterBackground>
		<offFinishEnterBackground public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering background state.</haxe_doc>
		</offFinishEnterBackground>
		<listensFinishEnterBackground public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering background state.</haxe_doc>
		</listensFinishEnterBackground>
		<_dox_event_beginEnterForeground public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app will enter foreground state.</haxe_doc>
		</_dox_event_beginEnterForeground>
		<emitBeginEnterForeground set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when the app will enter foreground state.</haxe_doc>
		</emitBeginEnterForeground>
		<onBeginEnterForeground public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter foreground state.</haxe_doc>
		</onBeginEnterForeground>
		<onceBeginEnterForeground public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter foreground state.</haxe_doc>
		</onceBeginEnterForeground>
		<offBeginEnterForeground public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter foreground state.</haxe_doc>
		</offBeginEnterForeground>
		<listensBeginEnterForeground public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter foreground state.</haxe_doc>
		</listensBeginEnterForeground>
		<_dox_event_finishEnterForeground public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering foreground state.</haxe_doc>
		</_dox_event_finishEnterForeground>
		<emitFinishEnterForeground set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when the app did finish entering foreground state.</haxe_doc>
		</emitFinishEnterForeground>
		<onFinishEnterForeground public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering foreground state.</haxe_doc>
		</onFinishEnterForeground>
		<onceFinishEnterForeground public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering foreground state.</haxe_doc>
		</onceFinishEnterForeground>
		<offFinishEnterForeground public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering foreground state.</haxe_doc>
		</offFinishEnterForeground>
		<listensFinishEnterForeground public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering foreground state.</haxe_doc>
		</listensFinishEnterForeground>
		<_dox_event_beginSortVisuals public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right before sorting all visuals.
     * Visual are sorted at each frame depending on their properties:
     * depth, texture, blending, shader...</haxe_doc>
		</_dox_event_beginSortVisuals>
		<emitBeginSortVisuals set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired right before sorting all visuals.
     * Visual are sorted at each frame depending on their properties:
     * depth, texture, blending, shader...</haxe_doc>
		</emitBeginSortVisuals>
		<onBeginSortVisuals public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before sorting all visuals.
     * Visual are sorted at each frame depending on their properties:
     * depth, texture, blending, shader...</haxe_doc>
		</onBeginSortVisuals>
		<onceBeginSortVisuals public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before sorting all visuals.
     * Visual are sorted at each frame depending on their properties:
     * depth, texture, blending, shader...</haxe_doc>
		</onceBeginSortVisuals>
		<offBeginSortVisuals public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before sorting all visuals.
     * Visual are sorted at each frame depending on their properties:
     * depth, texture, blending, shader...</haxe_doc>
		</offBeginSortVisuals>
		<listensBeginSortVisuals public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before sorting all visuals.
     * Visual are sorted at each frame depending on their properties:
     * depth, texture, blending, shader...</haxe_doc>
		</listensBeginSortVisuals>
		<_dox_event_finishSortVisuals public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right after all visuals have been sort.</haxe_doc>
		</_dox_event_finishSortVisuals>
		<emitFinishSortVisuals set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired right after all visuals have been sort.</haxe_doc>
		</emitFinishSortVisuals>
		<onFinishSortVisuals public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after all visuals have been sort.</haxe_doc>
		</onFinishSortVisuals>
		<onceFinishSortVisuals public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after all visuals have been sort.</haxe_doc>
		</onceFinishSortVisuals>
		<offFinishSortVisuals public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after all visuals have been sort.</haxe_doc>
		</offFinishSortVisuals>
		<listensFinishSortVisuals public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after all visuals have been sort.</haxe_doc>
		</listensFinishSortVisuals>
		<_dox_event_beginDraw public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right before drawing phase of visuals.</haxe_doc>
		</_dox_event_beginDraw>
		<emitBeginDraw set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired right before drawing phase of visuals.</haxe_doc>
		</emitBeginDraw>
		<onBeginDraw public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before drawing phase of visuals.</haxe_doc>
		</onBeginDraw>
		<onceBeginDraw public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before drawing phase of visuals.</haxe_doc>
		</onceBeginDraw>
		<offBeginDraw public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before drawing phase of visuals.</haxe_doc>
		</offBeginDraw>
		<listensBeginDraw public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before drawing phase of visuals.</haxe_doc>
		</listensBeginDraw>
		<_dox_event_finishDraw public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right after drawing phase of visuals.</haxe_doc>
		</_dox_event_finishDraw>
		<emitFinishDraw set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired right after drawing phase of visuals.</haxe_doc>
		</emitFinishDraw>
		<onFinishDraw public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after drawing phase of visuals.</haxe_doc>
		</onFinishDraw>
		<onceFinishDraw public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after drawing phase of visuals.</haxe_doc>
		</onceFinishDraw>
		<offFinishDraw public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after drawing phase of visuals.</haxe_doc>
		</offFinishDraw>
		<listensFinishDraw public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after drawing phase of visuals.</haxe_doc>
		</listensFinishDraw>
		<_dox_event_lowMemory public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired if the app is running low on memory.
     * (not be implemented by all platforms/targets).</haxe_doc>
		</_dox_event_lowMemory>
		<emitLowMemory set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired if the app is running low on memory.
     * (not be implemented by all platforms/targets).</haxe_doc>
		</emitLowMemory>
		<onLowMemory public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired if the app is running low on memory.
     * (not be implemented by all platforms/targets).</haxe_doc>
		</onLowMemory>
		<onceLowMemory public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired if the app is running low on memory.
     * (not be implemented by all platforms/targets).</haxe_doc>
		</onceLowMemory>
		<offLowMemory public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired if the app is running low on memory.
     * (not be implemented by all platforms/targets).</haxe_doc>
		</offLowMemory>
		<listensLowMemory public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired if the app is running low on memory.
     * (not be implemented by all platforms/targets).</haxe_doc>
		</listensLowMemory>
		<_dox_event_terminate public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app terminates.</haxe_doc>
		</_dox_event_terminate>
		<emitTerminate set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when the app terminates.</haxe_doc>
		</emitTerminate>
		<onTerminate public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app terminates.</haxe_doc>
		</onTerminate>
		<onceTerminate public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app terminates.</haxe_doc>
		</onceTerminate>
		<offTerminate public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app terminates.</haxe_doc>
		</offTerminate>
		<listensTerminate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app terminates.</haxe_doc>
		</listensTerminate>
		<immediateCallbacks expr="[]">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</immediateCallbacks>
		<immediateCallbacksCapacity expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</immediateCallbacksCapacity>
		<immediateCallbacksLen expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</immediateCallbacksLen>
		<postFlushImmediateCallbacks expr="[]">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</postFlushImmediateCallbacks>
		<postFlushImmediateCallbacksCapacity expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</postFlushImmediateCallbacksCapacity>
		<postFlushImmediateCallbacksLen expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</postFlushImmediateCallbacksLen>
		<loaders public="1" expr="[]">
			<c path="Array"><f a="done">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":noCompletion"/>
			</meta>
		</loaders>
		<onceImmediate public="1" get="inline" set="null" line="186">
			<f a="owner:handleImmediate">
				<c path="ceramic.Entity"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Schedule immediate callback that is garanteed to be executed before the next time frame
     * (before elements are drawn onto screen)
     * @param owner Owner of this callback, allowing to cancel callback if owner is destroyed
     * @param handleImmediate The callback to execute</haxe_doc>
			<overloads><onceImmediate public="1" get="inline" set="null" line="197">
	<f a="handleImmediate">
		<f a=""><x path="Void"/></f>
		<x path="Void"/>
	</f>
	<haxe_doc>* Schedule immediate callback that is garanteed to be executed before the next time frame
     * (before elements are drawn onto screen)
     * @param handleImmediate The callback to execute</haxe_doc>
</onceImmediate></overloads>
		</onceImmediate>
		<_onceImmediateWithOwner set="method" line="203"><f a="owner:handleImmediate">
	<c path="ceramic.Entity"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></_onceImmediateWithOwner>
		<_onceImmediate set="method" line="213"><f a="handleImmediate">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></_onceImmediate>
		<oncePostFlushImmediate public="1" get="inline" set="null" line="243">
			<f a="owner:handlePostFlushImmediate:?defer" v="::true">
				<c path="ceramic.Entity"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ defer : true }</e></m></meta>
			<haxe_doc>* Schedule callback that is garanteed to be executed when no immediate callback are pending anymore.
     * @param owner Owner of this callback, allowing to cancel callback if owner is destroyed
     * @param handlePostFlushImmediate The callback to execute
     * @param defer if `true` (default), will box this call into an immediate callback</haxe_doc>
			<overloads><oncePostFlushImmediate public="1" get="inline" set="null" line="254">
	<f a="handlePostFlushImmediate:?defer" v=":true">
		<f a=""><x path="Void"/></f>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{ defer : true }</e></m></meta>
	<haxe_doc>* Schedule callback that is garanteed to be executed when no immediate callback are pending anymore.
     * @param handlePostFlushImmediate The callback to execute
     * @param defer if `true` (default), will box this call into an immediate callback</haxe_doc>
</oncePostFlushImmediate></overloads>
		</oncePostFlushImmediate>
		<_oncePostFlushImmediateWithOwner set="method" line="260"><f a="owner:handlePostFlushImmediate:defer">
	<c path="ceramic.Entity"/>
	<f a=""><x path="Void"/></f>
	<x path="Bool"/>
	<x path="Void"/>
</f></_oncePostFlushImmediateWithOwner>
		<_oncePostFlushImmediate set="method" line="275">
			<f a="handlePostFlushImmediate:defer">
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Schedule callback that is garanteed to be executed when no immediate callback are pending anymore.
     * @param handlePostFlushImmediate The callback to execute
     * @param defer if `true` (default), will box this call into an immediate callback</haxe_doc>
		</_oncePostFlushImmediate>
		<flushImmediate public="1" set="method" line="306">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Execute and flush every awaiting immediate callback, including the ones that
     * could have been added with `onceImmediate()` after executing the existing callbacks.
     * @return `true` if anything was flushed</haxe_doc>
		</flushImmediate>
		<_xUpdatesHandlersPool expr="new Pool&lt;AppXUpdatesHandler&gt;()">
			<c path="ceramic.Pool"><c path="ceramic.AppXUpdatesHandler"/></c>
			<meta><m n=":value"><e><![CDATA[new Pool<AppXUpdatesHandler>()]]></e></m></meta>
		</_xUpdatesHandlersPool>
		<_xUpdatesHandlers expr="[]">
			<c path="Array"><c path="ceramic.AppXUpdatesHandler"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_xUpdatesHandlers>
		<_xUpdatesToCallNow expr="[]">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_xUpdatesToCallNow>
		<onceXUpdates public="1" set="method" line="366"><f a="owner:numUpdates:callback">
	<c path="ceramic.Entity"/>
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></onceXUpdates>
		<offXUpdates public="1" set="method" line="389"><f a="callback">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></offXUpdates>
		<tickOnceXUpdates set="method" line="408"><f a=""><x path="Void"/></f></tickOnceXUpdates>
		<cleanXUpdatesNullValues set="method" line="442"><f a=""><x path="Void"/></f></cleanXUpdatesNullValues>
		<inUpdate public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* `true` if the app is currently running its update phase.</haxe_doc>
		</inUpdate>
		<computedFps public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Computed fps of the app. Read only.
     * Value is automatically computed from last second of frame updates.</haxe_doc>
		</computedFps>
		<get_computedFps get="inline" set="null" line="496"><f a=""><x path="Int"/></f></get_computedFps>
		<_computeFps expr="new ComputeFps()">
			<c path="ceramic.ComputeFps"/>
			<meta><m n=":value"><e>new ComputeFps()</e></m></meta>
		</_computeFps>
		<frame public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current frame number</haxe_doc>
		</frame>
		<delta public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Current frame delta time (never above `settings.maxDelta`)</haxe_doc>
		</delta>
		<realDelta public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Current frame real delta time (the actual elapsed time since last frame update)</haxe_doc>
		</realDelta>
		<backend public="1" set="null">
			<c path="backend.Backend"/>
			<haxe_doc>* Backend instance</haxe_doc>
		</backend>
		<screen public="1" set="null">
			<c path="ceramic.Screen"/>
			<haxe_doc>* Screen instance</haxe_doc>
		</screen>
		<audio public="1" set="null">
			<c path="ceramic.Audio"/>
			<haxe_doc>* Audio instance</haxe_doc>
		</audio>
		<settings public="1" set="null">
			<c path="ceramic.Settings"/>
			<haxe_doc>* App settings</haxe_doc>
		</settings>
		<systems public="1" set="null">
			<c path="ceramic.Systems"/>
			<haxe_doc>* Systems are objects to structure app work/phases and update cycle</haxe_doc>
		</systems>
		<logger public="1" set="null" expr="new Logger()">
			<c path="ceramic.Logger"/>
			<meta><m n=":value"><e>new Logger()</e></m></meta>
			<haxe_doc>* Logger. Used by log shortcut</haxe_doc>
		</logger>
		<visuals public="1" set="null" expr="[]">
			<c path="Array"><c path="ceramic.Visual"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Visuals (ordered)
     * Active list of visuals being managed by ceramic.
     * This list is ordered and updated at every frame.
     * In between, it could contain destroyed visuals as they
     * are removed only at the end of the frame for performance reasons.</haxe_doc>
		</visuals>
		<pendingVisuals public="1" set="null" expr="[]">
			<c path="Array"><c path="ceramic.Visual"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Pending visuals: visuals that have been created this frame
     * but were not added to the `visual` list yet</haxe_doc>
		</pendingVisuals>
		<destroyedVisuals public="1" set="null" expr="[]">
			<c path="Array"><c path="ceramic.Visual"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Pending destroyed visuals: visuals that have been destroyed this frame
     * but were not removed to the `visual` list yet</haxe_doc>
		</destroyedVisuals>
		<groups public="1" set="null" expr="[]">
			<c path="Array"><c path="ceramic.Group"><c path="ceramic.Entity"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* All groups of entities in this app</haxe_doc>
		</groups>
		<input public="1" set="null">
			<c path="ceramic.Input"/>
			<haxe_doc>* Shared instance of `Input`</haxe_doc>
		</input>
		<renderTextures public="1" set="null" expr="[]">
			<c path="Array"><c path="ceramic.RenderTexture"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* All active render textures in this app</haxe_doc>
		</renderTextures>
		<assets public="1" set="null">
			<c path="ceramic.Assets"/>
			<haxe_doc>* App level assets. Used to load default assets (font, texture, shader)
     * required to make ceramic work properly.</haxe_doc>
		</assets>
		<defaultTexturedShader public="1" set="null" expr="null">
			<c path="ceramic.Shader"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Default textured shader.
     * This is the shader used for any visual (quad or mesh) that don't have a custom shader assigned.</haxe_doc>
		</defaultTexturedShader>
		<defaultWhiteTexture public="1" set="null" expr="null">
			<c path="ceramic.Texture"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc><![CDATA[* Default white texture.
     * When a quad or mesh doesn't have a texture assigned, it will use the default white texture
     * instead to render as plain flat coloured object. This means that the same default shader
     * is used and everything can be batched together (textured & non-textured in the same batch).]]></haxe_doc>
		</defaultWhiteTexture>
		<defaultFont public="1" set="null" expr="null">
			<c path="ceramic.BitmapFont"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Default font used by `Text` instances.</haxe_doc>
		</defaultFont>
		<projectDir public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Project directory. May be null depending on the platform.</haxe_doc>
		</projectDir>
		<persistent public="1" set="null" expr="null">
			<c path="ceramic.PersistentData"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* App level persistent data.
     * This is a simple key-value store ready to be used.
     * Don't forget to call `persistent.save()` to apply changes permanently.</haxe_doc>
		</persistent>
		<textInput public="1" set="null" expr="null">
			<c path="ceramic.TextInput"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Shared text input manager. Usually not used directly as is.
     * You might want to use `EditText` component instead.</haxe_doc>
		</textInput>
		<converters public="1" expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.ConvertField">
					<d/>
					<d/>
				</c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
			<haxe_doc><![CDATA[* Converters are used to transform field data in `Fragment` instances.
     * This map is matching a type (as string, like `"Array<Float>"`) with an instance
     * of a `ConvertField` subclass.]]></haxe_doc>
		</converters>
		<timelines public="1" expr="new Timelines()">
			<c path="ceramic.Timelines"/>
			<meta><m n=":value"><e>new Timelines()</e></m></meta>
			<haxe_doc>* All active timelines in this app.</haxe_doc>
		</timelines>
		<scenes public="1" expr="SceneSystem.shared">
			<c path="ceramic.SceneSystem"/>
			<meta>
				<m n=":value"><e>SceneSystem.shared</e></m>
				<m n="lazy"/>
			</meta>
			<haxe_doc>* Shared scene system.</haxe_doc>
		</scenes>
		<hierarchyDirty expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hierarchyDirty>
		<visualsContentDirty expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</visualsContentDirty>
		<beginUpdateCallbacks expr="[]">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* List of functions that will be called and purged when update iteration begins.
     * Useful to run some specific code once exactly before update event is sent.</haxe_doc>
		</beginUpdateCallbacks>
		<disposedEntities expr="[]">
			<c path="Array"><c path="ceramic.Entity"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</disposedEntities>
		<numBlockingDefaultScroll public="1" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</numBlockingDefaultScroll>
		<quit public="1" set="method" line="752">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Quit the application.
     * Works on desktop (windows, mac, linux), unity.
     * Can also work on web by closing the window if **electron** plugin is enabled
     * and the app is running via electron instead of a regular browser.</haxe_doc>
		</quit>
		<backendReady set="method" line="758"><f a=""><x path="Void"/></f></backendReady>
		<bindSettings set="method" line="857"><f a=""><x path="Void"/></f></bindSettings>
		<initFieldConverters set="method" line="868"><f a=""><x path="Void"/></f></initFieldConverters>
		<initCollections set="method" line="889"><f a="collections:?info">
	<c path="ceramic.AutoCollections"/>
	<d/>
	<x path="Void"/>
</f></initCollections>
		<assetsLoaded set="method" line="952"><f a=""><x path="Void"/></f></assetsLoaded>
		<runNextLoader set="method" line="958"><f a=""><x path="Void"/></f></runNextLoader>
		<runReady set="method" line="975"><f a=""><x path="Void"/></f></runReady>
		<updatePreReady set="method" line="1089"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></updatePreReady>
		<update set="method" line="1100"><f a="realDelta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<render set="method" line="1235"><f a=""><x path="Void"/></f></render>
		<addVisual public="1" get="inline" set="null" line="1256">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</addVisual>
		<removeVisual public="1" get="inline" set="null" line="1263">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</removeVisual>
		<syncPendingVisuals set="method" line="1269"><f a=""><x path="Bool"/></f></syncPendingVisuals>
		<syncDestroyedVisuals set="method" line="1288"><f a=""><x path="Void"/></f></syncDestroyedVisuals>
		<updateVisuals public="1" get="inline" set="null" line="1331">
			<f a="visuals">
				<c path="Array"><c path="ceramic.Visual"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</updateVisuals>
		<computeHierarchy public="1" set="method" line="1457">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</computeHierarchy>
		<computeRenderTexturesPriority public="1" get="inline" set="null" line="1483">
			<f a="renderTextures">
				<c path="Array"><c path="ceramic.RenderTexture"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</computeRenderTexturesPriority>
		<sortVisuals public="1" get="inline" set="null" line="1510">
			<f a="visuals">
				<c path="Array"><c path="ceramic.Visual"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</sortVisuals>
		<group public="1" set="method" line="1531">
			<f a="id:?createIfNeeded" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="ceramic.Group"><c path="ceramic.Entity"/></c>
			</f>
			<meta><m n=":value"><e>{ createIfNeeded : true }</e></m></meta>
			<haxe_doc>* Get a group with the given id.
     * @param id The id of the group
     * @param createIfNeeded `true` (default) to create a group if not created already for this id
     * @return the group or null if no group was found and none created.</haxe_doc>
		</group>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<info public="1" expr="{ editable : { item11 : &quot;ceramic.Particles&quot;, item3 : &quot;ceramic.Fragment&quot;, item10 : &quot;ceramic.Line&quot;, item5 : &quot;ceramic.Text&quot;, item7 : &quot;ceramic.Shape&quot;, item2 : &quot;ceramic.Layer&quot;, item6 : &quot;ceramic.Mesh&quot;, item9 : &quot;ceramic.Arc&quot;, item1 : &quot;ceramic.Visual&quot;, item4 : &quot;ceramic.Quad&quot;, item8 : &quot;ceramic.Ngon&quot;, item0 : &quot;ceramic.Entity&quot; }, name : &quot;ceramic-docs&quot;, collections : {  }, version : &quot;1.0&quot;, author : &quot;My Company&quot;, displayName : &quot;ceramic-docs&quot; }">
			<a>
				<version><c path="String"/></version>
				<name><c path="String"/></name>
				<editable><a>
	<item9><c path="String"/></item9>
	<item8><c path="String"/></item8>
	<item7><c path="String"/></item7>
	<item6><c path="String"/></item6>
	<item5><c path="String"/></item5>
	<item4><c path="String"/></item4>
	<item3><c path="String"/></item3>
	<item2><c path="String"/></item2>
	<item11><c path="String"/></item11>
	<item10><c path="String"/></item10>
	<item1><c path="String"/></item1>
	<item0><c path="String"/></item0>
</a></editable>
				<displayName><c path="String"/></displayName>
				<collections><a/></collections>
				<author><c path="String"/></author>
			</a>
			<meta>
				<m n=":value"><e>{ editable : { item11 : "ceramic.Particles", item3 : "ceramic.Fragment", item10 : "ceramic.Line", item5 : "ceramic.Text", item7 : "ceramic.Shape", item2 : "ceramic.Layer", item6 : "ceramic.Mesh", item9 : "ceramic.Arc", item1 : "ceramic.Visual", item4 : "ceramic.Quad", item8 : "ceramic.Ngon", item0 : "ceramic.Entity" }, name : "ceramic-docs", collections : {  }, version : "1.0", author : "My Company", displayName : "ceramic-docs" }</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>App info extracted from `ceramic.yml`</haxe_doc>
		</info>
		<new set="method" line="712"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* `App` class is the root instance of any ceramic app.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.AppMacro.build()</e></m>
			<m n=":allow"><e>ceramic.Visual</e></m>
			<m n=":allow"><e>ceramic.Screen</e></m>
			<m n=":allow"><e>ceramic.Entity</e></m>
			<m n=":allow"><e>ceramic.Timer</e></m>
		</meta>
	</class>
	<class path="ceramic.AppXUpdatesHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AppXUpdatesHandler.hx">
		<owner public="1" expr="null">
			<c path="ceramic.Entity"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</owner>
		<numUpdates public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</numUpdates>
		<callback public="1" expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</callback>
		<reset set="method" line="14"><f a=""><x path="Void"/></f></reset>
		<new set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<class path="ceramic.DecomposedTransform" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/DecomposedTransform.hx">
		<pivotX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pivotX>
		<pivotY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pivotY>
		<x public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<rotation public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</rotation>
		<scaleX public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</scaleX>
		<scaleY public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</scaleY>
		<skewX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewX>
		<skewY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewY>
		<toString set="method" line="30"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Decomposed transform holds rotation, translation, scale, skew and pivot informations.
 * Provided by Transform.decompose() method.
 * Angles are in radians.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Transform" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Transform.hx">
		<implements path="tracker.Events"/>
		<_decomposed1 expr="new DecomposedTransform()" line="18" static="1">
			<c path="ceramic.DecomposedTransform"/>
			<meta><m n=":value"><e>new DecomposedTransform()</e></m></meta>
		</_decomposed1>
		<_decomposed2 expr="new DecomposedTransform()" line="20" static="1">
			<c path="ceramic.DecomposedTransform"/>
			<meta><m n=":value"><e>new DecomposedTransform()</e></m></meta>
		</_decomposed2>
		<_tmp expr="new Transform()" line="58" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</_tmp>
		<_dox_event_change public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_change>
		<emitChange public="1" set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>change event</haxe_doc>
		</emitChange>
		<onChange public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onChange>
		<onceChange public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onceChange>
		<offChange public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</offChange>
		<listensChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to change event</haxe_doc>
		</listensChange>
		<_aPrev><x path="Float"/></_aPrev>
		<_bPrev><x path="Float"/></_bPrev>
		<_cPrev><x path="Float"/></_cPrev>
		<_dPrev><x path="Float"/></_dPrev>
		<_txPrev><x path="Float"/></_txPrev>
		<_tyPrev><x path="Float"/></_tyPrev>
		<changedDirty public="1"><x path="Bool"/></changedDirty>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<changed public="1" set="null"><x path="Bool"/></changed>
		<computeChanged public="1" get="inline" set="null" line="82"><f a=""><x path="Void"/></f></computeChanged>
		<didEmitChange get="inline" set="null" line="99"><f a=""><x path="Void"/></f></didEmitChange>
		<cleanChangedState public="1" get="inline" set="null" line="105"><f a=""><x path="Void"/></f></cleanChangedState>
		<clone public="1" get="inline" set="null" line="118"><f a=""><c path="ceramic.Transform"/></f></clone>
		<concat public="1" get="inline" set="null" line="124"><f a="m">
	<c path="ceramic.Transform"/>
	<x path="Void"/>
</f></concat>
		<decompose public="1" get="inline" set="null" line="143"><f a="?output">
	<c path="ceramic.DecomposedTransform"/>
	<c path="ceramic.DecomposedTransform"/>
</f></decompose>
		<setFromDecomposed public="1" get="inline" set="null" line="178"><f a="decomposed">
	<c path="ceramic.DecomposedTransform"/>
	<x path="Void"/>
</f></setFromDecomposed>
		<setFromValues public="1" get="inline" set="null" line="184">
			<f a="?x:?y:?scaleX:?scaleY:?rotation:?skewX:?skewY:?pivotX:?pivotY" v="0:0:1:1:0:0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pivotY : 0, pivotX : 0, skewY : 0, skewX : 0, rotation : 0, scaleY : 1, scaleX : 1, y : 0, x : 0 }</e></m></meta>
		</setFromValues>
		<setFromInterpolated public="1" get="inline" set="null" line="200"><f a="transform1:transform2:ratio">
	<c path="ceramic.Transform"/>
	<c path="ceramic.Transform"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFromInterpolated>
		<deltaTransformX public="1" get="inline" set="null" line="225"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></deltaTransformX>
		<deltaTransformY public="1" get="inline" set="null" line="231"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></deltaTransformY>
		<equals public="1" get="inline" set="null" line="237"><f a="transform">
	<c path="ceramic.Transform"/>
	<x path="Bool"/>
</f></equals>
		<identity public="1" get="inline" set="null" line="243"><f a=""><x path="Void"/></f></identity>
		<invert public="1" get="inline" set="null" line="256"><f a=""><x path="Void"/></f></invert>
		<rotate public="1" get="inline" set="null" line="288">
			<f a="angle">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Rotate by angle (in radians)</haxe_doc>
		</rotate>
		<scale public="1" get="inline" set="null" line="309"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<translate public="1" get="inline" set="null" line="324"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<skew public="1" get="inline" set="null" line="333"><f a="skewX:skewY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></skew>
		<setRotation public="1" get="inline" set="null" line="358">
			<f a="angle:?scale" v=":1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1 }</e></m></meta>
		</setRotation>
		<setTo public="1" get="inline" set="null" line="369"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<setToTransform public="1" get="inline" set="null" line="382"><f a="transform">
	<c path="ceramic.Transform"/>
	<x path="Void"/>
</f></setToTransform>
		<toString public="1" set="method" line="395"><f a=""><c path="String"/></f></toString>
		<transformX public="1" get="inline" set="null" line="403"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></transformX>
		<transformY public="1" get="inline" set="null" line="410"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></transformY>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="62">
			<f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, d : 1, c : 0, b : 0, a : 1 }</e></m></meta>
		</new>
		<haxe_doc>* Transform holds matrix data to make 2d rotate, translate, scale and skew transformations.
 * Angles are in degrees.
 * Representation:
 * | a | c | tx |
 * | b | d | ty |
 * | 0 | 0 | 1  |</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.TransformPool</e></m>
		</meta>
	</class>
	<class path="ceramic.Pool" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Pool.hx">
		<availableItems expr="[]">
			<c path="Array"><c path="ceramic.Pool.T"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</availableItems>
		<get public="1" get="inline" set="null" line="17">
			<f a=""><c path="ceramic.Pool.T"/></f>
			<haxe_doc>* Get an available item if any is ready to be used or `null` if none is available.</haxe_doc>
		</get>
		<recycle public="1" set="method" line="26">
			<f a="item">
				<c path="ceramic.Pool.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Recycle an existing item so that it can be reused later</haxe_doc>
		</recycle>
		<clear public="1" set="method" line="32"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A generic object pool utility.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Point" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Point.hx">
		<get public="1" get="inline" set="null" line="35" static="1">
			<f a="?x:?y:?z" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.Point"/>
			</f>
			<meta><m n=":value"><e>{ z : 0, y : 0, x : 0 }</e></m></meta>
		</get>
		<pool expr="new Pool&lt;Point&gt;()" line="52" static="1">
			<c path="ceramic.Pool"><c path="ceramic.Point"/></c>
			<meta><m n=":value"><e><![CDATA[new Pool<Point>()]]></e></m></meta>
		</pool>
		<x public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<z public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</z>
		<toString set="method" line="12"><f a=""><c path="String"/></f></toString>
		<recycle public="1" set="method" line="26"><f a=""><x path="Void"/></f></recycle>
		<new public="1" set="method" line="18">
			<f a="?x:?y:?z" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.Visual" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Visual.hx">
		<extends path="ceramic.Entity"/>
		<DEPTH_FACTOR final="1" get="inline" set="null" expr="1000" line="48" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1000</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* A factor applied to every computed depth. This factor is used to avoid having
     * all computed depth values being too small and risking to create precision issues.
     * It is expected to work best with use of `depthRange = 1` on visuals (default)</haxe_doc>
		</DEPTH_FACTOR>
		<DEPTH_MARGIN final="1" get="inline" set="null" expr="0.01" line="55" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.01</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* A garanteed margin between max inner computed depth and container depth range,
     * and min inner depth and container's computed depth.</haxe_doc>
		</DEPTH_MARGIN>
		<FLAG_NOT_ACTIVE final="1" get="inline" set="null" expr="1" line="1553" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</FLAG_NOT_ACTIVE>
		<FLAG_VISIBLE_WHEN_ACTIVE final="1" get="inline" set="null" expr="2" line="1554" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</FLAG_VISIBLE_WHEN_ACTIVE>
		<FLAG_TOUCHABLE_WHEN_ACTIVE final="1" get="inline" set="null" expr="4" line="1555" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</FLAG_TOUCHABLE_WHEN_ACTIVE>
		<FLAG_IS_HIT_VISUAL final="1" get="inline" set="null" expr="8" line="1556" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</FLAG_IS_HIT_VISUAL>
		<_degToRad get="inline" set="null" expr="0.017453292519943295" line="1699" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.017453292519943295</e></m></meta>
		</_degToRad>
		<_matrix expr="new Transform()" line="1701" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</_matrix>
		<_point expr="new Point()" line="1703" static="1">
			<c path="ceramic.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
		</_point>
		<_minDepth expr="0" line="2522" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_minDepth>
		<_maxDepth expr="0" line="2524" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_maxDepth>
		<computeChildrenDepth set="method" line="2581" static="1">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Compute children depth. The result depends on whether
     * a parent defines a custom `depthRange` value or not.</haxe_doc>
		</computeChildrenDepth>
		<_computeChildrenDepth0 get="inline" set="null" line="2587" static="1"><f a="visual:step">
	<c path="ceramic.Visual"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_computeChildrenDepth0>
		<_computeChildrenDepth1 get="inline" set="null" line="2615" static="1"><f a="visual:step">
	<c path="ceramic.Visual"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_computeChildrenDepth1>
		<_computeChildrenDepthApplyDepthRange get="inline" set="null" line="2641" static="1"><f a="visual:children">
	<c path="ceramic.Visual"/>
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Void"/>
</f></_computeChildrenDepthApplyDepthRange>
		<computeMinMaxDepths set="method" line="2665" static="1"><f a="visual">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></computeMinMaxDepths>
		<_computeMinMaxDepths0 get="inline" set="null" line="2671" static="1"><f a="visual:step">
	<c path="ceramic.Visual"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_computeMinMaxDepths0>
		<_computeMinMaxDepths1 get="inline" set="null" line="2699" static="1"><f a="visual:step">
	<c path="ceramic.Visual"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_computeMinMaxDepths1>
		<multiplyDepths set="method" line="2725" static="1"><f a="visual:startDepth:targetRange">
	<c path="ceramic.Visual"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></multiplyDepths>
		<_multiplyDepths0 get="inline" set="null" line="2731" static="1"><f a="visual:startDepth:targetRange:step">
	<c path="ceramic.Visual"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_multiplyDepths0>
		<_multiplyDepths1 get="inline" set="null" line="2762" static="1"><f a="visual:startDepth:targetRange:step">
	<c path="ceramic.Visual"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_multiplyDepths1>
		<_dox_event_pointerDown public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is down on the visual
     * @param info The info related to this pointer event</haxe_doc>
		</_dox_event_pointerDown>
		<emitPointerDown set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired when a pointer (touch or mouse) is down on the visual
     * @param info The info related to this pointer event</haxe_doc>
		</emitPointerDown>
		<onPointerDown public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is down on the visual
     * @param info The info related to this pointer event</haxe_doc>
		</onPointerDown>
		<oncePointerDown public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is down on the visual
     * @param info The info related to this pointer event</haxe_doc>
		</oncePointerDown>
		<offPointerDown public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is down on the visual
     * @param info The info related to this pointer event</haxe_doc>
		</offPointerDown>
		<listensPointerDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is down on the visual
     * @param info The info related to this pointer event</haxe_doc>
		</listensPointerDown>
		<_dox_event_pointerUp public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was down on the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</_dox_event_pointerUp>
		<emitPointerUp set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired when a pointer (touch or mouse) was down on the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</emitPointerUp>
		<onPointerUp public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was down on the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</onPointerUp>
		<oncePointerUp public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was down on the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</oncePointerUp>
		<offPointerUp public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was down on the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</offPointerUp>
		<listensPointerUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was down on the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</listensPointerUp>
		<_dox_event_pointerOver public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is over the visual
     * @param info The info related to this pointer event</haxe_doc>
		</_dox_event_pointerOver>
		<emitPointerOver set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired when a pointer (touch or mouse) is over the visual
     * @param info The info related to this pointer event</haxe_doc>
		</emitPointerOver>
		<onPointerOver public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is over the visual
     * @param info The info related to this pointer event</haxe_doc>
		</onPointerOver>
		<oncePointerOver public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is over the visual
     * @param info The info related to this pointer event</haxe_doc>
		</oncePointerOver>
		<offPointerOver public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is over the visual
     * @param info The info related to this pointer event</haxe_doc>
		</offPointerOver>
		<listensPointerOver public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is over the visual
     * @param info The info related to this pointer event</haxe_doc>
		</listensPointerOver>
		<_dox_event_pointerOut public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was over the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</_dox_event_pointerOut>
		<emitPointerOut set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired when a pointer (touch or mouse) was over the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</emitPointerOut>
		<onPointerOut public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was over the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</onPointerOut>
		<oncePointerOut public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was over the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</oncePointerOut>
		<offPointerOut public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was over the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</offPointerOut>
		<listensPointerOut public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was over the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</listensPointerOut>
		<_dox_event_focus public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when this visual gains focus (after handling a pointer event)</haxe_doc>
		</_dox_event_focus>
		<emitFocus set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when this visual gains focus (after handling a pointer event)</haxe_doc>
		</emitFocus>
		<onFocus public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual gains focus (after handling a pointer event)</haxe_doc>
		</onFocus>
		<onceFocus public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual gains focus (after handling a pointer event)</haxe_doc>
		</onceFocus>
		<offFocus public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual gains focus (after handling a pointer event)</haxe_doc>
		</offFocus>
		<listensFocus public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual gains focus (after handling a pointer event)</haxe_doc>
		</listensFocus>
		<_dox_event_blur public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when this visual loses focus</haxe_doc>
		</_dox_event_blur>
		<emitBlur set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when this visual loses focus</haxe_doc>
		</emitBlur>
		<onBlur public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual loses focus</haxe_doc>
		</onBlur>
		<onceBlur public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual loses focus</haxe_doc>
		</onceBlur>
		<offBlur public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual loses focus</haxe_doc>
		</offBlur>
		<listensBlur public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual loses focus</haxe_doc>
		</listensBlur>
		<willListenPointerOver get="inline" set="null" line="94"><f a=""><x path="Void"/></f></willListenPointerOver>
		<asQuad public="1" expr="null">
			<c path="ceramic.Quad"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Get this visual typed as `Quad` or null if it isn't a `Quad`</haxe_doc>
		</asQuad>
		<asMesh public="1" expr="null">
			<c path="ceramic.Mesh"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Get this visual typed as `Mesh` or null if it isn't a `Mesh`</haxe_doc>
		</asMesh>
		<multiTouch public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* When enabled, this visual will receive as many up/down/click/over/out events as
     * there are fingers or mouse pointer interacting with it.
     * Default is `false`, ensuring there is never multiple up/down/click/over/out that
     * overlap each other. In that case, it triggers `pointer down` when the first finger/pointer hits
     * the visual and trigger `pointer up` when the last finger/pointer stops touching it. Behavior is
     * similar for `pointer over` and `pointer out` events.</haxe_doc>
		</multiTouch>
		<isPointerDown public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether this visual is between a `pointer down` and an `pointer up` event or not.</haxe_doc>
		</isPointerDown>
		<_numPointerDown expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numPointerDown>
		<get_isPointerDown get="inline" set="null" line="963"><f a=""><x path="Bool"/></f></get_isPointerDown>
		<isPointerOver public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether this visual is between a `pointer over` and an `pointer out` event or not.</haxe_doc>
		</isPointerOver>
		<_numPointerOver expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numPointerOver>
		<get_isPointerOver get="inline" set="null" line="970"><f a=""><x path="Bool"/></f></get_isPointerOver>
		<clip public="1" set="accessor" expr="null">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Use the given visual's bounds as clipping area for itself and **every children**.
     * Clipping areas cannot be combined. That means if `clip` is not null and current
     * visual instance is already clipped by a parent visual, its children's won't be clipped
     * by it anymore as they are instead clipped by this `clip` property instead.</haxe_doc>
		</clip>
		<set_clip get="inline" set="null" line="979"><f a="clip">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
</f></set_clip>
		<inheritAlpha public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this visual should inherit its parent alpha value or not.
     * If it inherits, parent alpha value will be multiplied with current visual's own `alpha` property.</haxe_doc>
		</inheritAlpha>
		<set_inheritAlpha get="inline" set="null" line="991"><f a="inheritAlpha">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_inheritAlpha>
		<stop public="1" set="method" line="1002">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stop this visual, whatever that means (override in subclasses).
     * When arcade physics are enabled, visual's body is stopped from this call.</haxe_doc>
		</stop>
		<translatesOnly public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Computed flag that tells whether this visual is only translated,
     * thus not rotated, skewed nor scaled.
     * When this is `true`, matrix computation may be a bit faster as it
     * will skip some unneeded matrix computation.</haxe_doc>
		</translatesOnly>
		<translatesOnlyDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether we should re-check if this visual is only translating or having a more complex transform</haxe_doc>
		</translatesOnlyDirty>
		<contentDirty public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Setting this to true will force the visual to recompute its displayed content</haxe_doc>
		</contentDirty>
		<set_contentDirty get="inline" set="null" line="1049"><f a="contentDirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_contentDirty>
		<matrixDirty public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Setting this to true will force the visual's matrix to be re-computed</haxe_doc>
		</matrixDirty>
		<set_matrixDirty get="inline" set="null" line="1061"><f a="matrixDirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_matrixDirty>
		<renderTargetDirty public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Setting this to true will force the visual's computed render target to be re-computed</haxe_doc>
		</renderTargetDirty>
		<set_renderTargetDirty get="inline" set="null" line="1078"><f a="renderTargetDirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_renderTargetDirty>
		<visibilityDirty public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Setting this to true will force the visual to compute it's visility in hierarchy</haxe_doc>
		</visibilityDirty>
		<set_visibilityDirty get="inline" set="null" line="1096"><f a="visibilityDirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visibilityDirty>
		<touchableDirty public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Setting this to true will force the visual to compute it's touchability in hierarchy</haxe_doc>
		</touchableDirty>
		<set_touchableDirty get="inline" set="null" line="1113"><f a="touchableDirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_touchableDirty>
		<clipDirty public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Setting this to true will force the visual to compute it's clipping state in hierarchy</haxe_doc>
		</clipDirty>
		<set_clipDirty get="inline" set="null" line="1130"><f a="clipDirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clipDirty>
		<renderTarget public="1" set="accessor" expr="null">
			<c path="ceramic.RenderTexture"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If set, the visual will be rendered into this target RenderTexture instance
     * instead of being drawn onto screen directly.</haxe_doc>
		</renderTarget>
		<set_renderTarget set="method" line="1147"><f a="renderTarget">
	<c path="ceramic.RenderTexture"/>
	<c path="ceramic.RenderTexture"/>
</f></set_renderTarget>
		<blending public="1" set="accessor" expr="Blending.AUTO">
			<x path="ceramic.Blending"/>
			<meta><m n=":value"><e>Blending.AUTO</e></m></meta>
		</blending>
		<set_blending set="method" line="1156"><f a="blending">
	<x path="ceramic.Blending"/>
	<x path="ceramic.Blending"/>
</f></set_blending>
		<visible public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="editable"><e>{ group : "active" }</e></m>
			</meta>
			<haxe_doc>* Set to `false` to make this visual (and all of its children) invisible and not rendered.</haxe_doc>
		</visible>
		<set_visible set="method" line="1165"><f a="visible">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<touchable public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="editable"><e>{ group : "active" }</e></m>
			</meta>
			<haxe_doc>* Set to `false` to make this visual (and all of its children) not touchable</haxe_doc>
		</touchable>
		<set_touchable set="method" line="1177"><f a="touchable">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_touchable>
		<depth public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "depth" }</e></m>
			</meta>
			<haxe_doc>* Set this visual's depth.
     * Visuals are rendered from back to front of the screen.
     * Given two visuals, a visual with higher depth will be rendered **above** a visual with lower depth.
     * In practice, it is advised to use integer values like `1`, `2`, `3`... to order your visuals,
     * like you would do with z-index on CSS elements.</haxe_doc>
		</depth>
		<set_depth set="method" line="1193"><f a="depth">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depth>
		<depthRange public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n="editable"><e>{ group : "depth", label : "Range" }</e></m>
			</meta>
			<haxe_doc>* If set to `1` (default), children will be sort by depth and their computed depth
     * will be within range [parent.depth, parent.depth + depthRange].
     * You'll usually won't need to change this value,
     * unless you want to do advanced drawing where different
     * hierarchies of visuals are blending with each other.
     *
     * ```haxe
     * // Children computed depths will be relative to their parent visual depth.
     * // This is the default value and recommended approach in most situations as
     * // its behaviour is similar to display trees, z-index etc...
     * visual.depthRange = 1;
     *
     * // More advanced, two visuals: visual2 above visual1 because of higher depth, but
     * // visual1's depth range is `8`, so its children computed depths will be distributed
     * // between `1` and `1 + 8` (9 excluded). That means some of visual1's children
     * // can be above visual2's children. Can be useful on some specific edge cases,
     * // but not recommended in general.
     * visual1.depthRange = 8;
     * visual1.depth = 1;
     * visual2.depth = 2;
     *
     * // Another case: two visuals with the same depth and depthRange.
     * // There children will share the same computed depth space, so a child of visual1 at `depth = 6`
     * // will be above a child of visual2 at `depth = 4`.
     * // Resulting computed depths will be between `1` and `1 + 16` (17 excluded).
     * visual1.depthRange = 16
     * visual2.depthRange = 16
     * visual1.depth = 1;
     * visual2.depth = 1;
     *
     * // Children computed depths won't be relative to their parent visual depth.
     * // Instead, it will be relative to the higher parent (of the parent) in hierarchy that has a positive `depthRange` value,
     * visual.depthRange = -1;
     * ```</haxe_doc>
		</depthRange>
		<set_depthRange set="method" line="1242"><f a="depthRange">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depthRange>
		<x public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "position" }</e></m>
			</meta>
			<haxe_doc>* The **x** position of this visual.
     * Relative to its parent, or screen if this visual has no parent.</haxe_doc>
		</x>
		<set_x set="method" line="1255"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<y public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "position" }</e></m>
			</meta>
			<haxe_doc>* The **y** position of this visual.
     * Relative to its parent, or screen if this visual has no parent.</haxe_doc>
		</y>
		<set_y set="method" line="1268"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<scaleX public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n="editable"><e>{ group : "scale" }</e></m>
			</meta>
			<haxe_doc>* The **scaleX** value of this visual.</haxe_doc>
		</scaleX>
		<set_scaleX set="method" line="1280"><f a="scaleX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<scaleY public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n="editable"><e>{ group : "scale" }</e></m>
			</meta>
			<haxe_doc>* The **scaleY** value of this visual.</haxe_doc>
		</scaleY>
		<set_scaleY set="method" line="1293"><f a="scaleY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<skewX public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "skew" }</e></m>
			</meta>
			<haxe_doc>* The **skewX** value of this visual.</haxe_doc>
		</skewX>
		<set_skewX set="method" line="1306"><f a="skewX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_skewX>
		<skewY public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "skew" }</e></m>
			</meta>
			<haxe_doc>* The **skewY** value of this visual.</haxe_doc>
		</skewY>
		<set_skewY set="method" line="1319"><f a="skewY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_skewY>
		<anchorX public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "anchor" }</e></m>
			</meta>
			<haxe_doc>* The **anchorX** value of this visual.
     * Affects how position, scale, rotation and skew of the visual are rendered.
     * Default is `0`, which means: anchor relative to the **left** of the visual.
     * Use `1` to make it relative to the **right** of the visual, or `0.5` to make it
     * relative to the **horizontal center** of the visual.</haxe_doc>
		</anchorX>
		<set_anchorX set="method" line="1336"><f a="anchorX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_anchorX>
		<anchorY public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "anchor" }</e></m>
			</meta>
			<haxe_doc>* The **anchorY** value of this visual.
     * Affects how position, scale, rotation and skew of the visual are rendered.
     * Default is `0`, which means: anchor relative to the **top** of the visual.
     * Use `1` to make it relative to the **bottom** of the visual, or `0.5` to make it
     * relative to the **vertical center** of the visual.</haxe_doc>
		</anchorY>
		<set_anchorY set="method" line="1352"><f a="anchorY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_anchorY>
		<width public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ min : 0, group : "size" }</e></m></meta>
			<haxe_doc>* The **width** of the visual.
     * Default is `0`. Can be set to an explicit value.
     * Some subclasses of `Visual` are computing it automatically
     * like `Text` from its textual content or `Quad` when a texture is assigned to it.</haxe_doc>
		</width>
		<_width expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_width>
		<get_width set="method" line="1368"><f a=""><x path="Float"/></f></get_width>
		<set_width set="method" line="1371"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<height public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ min : 0, group : "size" }</e></m></meta>
			<haxe_doc>* The **height** of the visual.
     * Default is `0`. Can be set to an explicit value.
     * Some subclasses of `Visual` are computing it automatically
     * like `Text` from its textual content or `Quad` when a texture is assigned to it.</haxe_doc>
		</height>
		<_height expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_height>
		<get_height set="method" line="1387"><f a=""><x path="Float"/></f></get_height>
		<set_height set="method" line="1390"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<roundTranslation public="1" set="accessor" expr="-1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc><![CDATA[* If set to a value above zero, matrix translation (tx & ty) will be rounded.
     *
     * ```haxe
     * roundTranslation = 0; // No rounding (default)
     * roundTranslation = 1; // Pixel perfect rounding
     * roundTranslation = 2; // Half-pixel rounding
     * ```
     *
     * May be useful to render pixel perfect scenes onto `ceramic.Filter`.]]></haxe_doc>
		</roundTranslation>
		<set_roundTranslation set="method" line="1410"><f a="roundTranslation">
	<x path="Int"/>
	<x path="Int"/>
</f></set_roundTranslation>
		<rotation public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ slider : [0, 360], degrees : true }</e></m>
			</meta>
			<haxe_doc>* Rotation of the visual in degrees.
     * The center of the rotation depends on `anchorX` and `anchorY`.</haxe_doc>
		</rotation>
		<set_rotation set="method" line="1423"><f a="rotation">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<alpha public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n="editable"><e>{ slider : [0, 1] }</e></m>
			</meta>
			<haxe_doc>* Alpha of the visual. Must be a value between `0` (transparent) and `1` (fully opaque)</haxe_doc>
		</alpha>
		<set_alpha set="method" line="1436"><f a="alpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<translateX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ group : "translate" }</e></m></meta>
			<haxe_doc>* Visual X translation.
     * This is a shorthand equivalent to assigning a `Transform` object to
     * the visual with a `tx` value of `translateX`.
     * Only recommended for advanced usage as `x` property should be used in general instead.</haxe_doc>
		</translateX>
		<get_translateX get="inline" set="null" line="1451"><f a=""><x path="Float"/></f></get_translateX>
		<set_translateX get="inline" set="null" line="1454"><f a="translateX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_translateX>
		<translateY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ group : "translate" }</e></m></meta>
			<haxe_doc>* Visual Y translation.
     * This is a shorthand equivalent to assigning a `Transform` object to
     * the visual with a `ty` value of `translateY`.
     * Only recommended for advanced usage as `y` property should be used in general instead.</haxe_doc>
		</translateY>
		<get_translateY get="inline" set="null" line="1481"><f a=""><x path="Float"/></f></get_translateY>
		<set_translateY get="inline" set="null" line="1484"><f a="translateY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_translateY>
		<transform public="1" set="accessor" expr="null">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Set additional matrix-based transform to this visual. Default is `null`.
     * A `Transform` object will affect of the visual is rendered.
     * The transform is applied after visual's properties (position, rotation, scale, skew).</haxe_doc>
		</transform>
		<set_transform set="method" line="1509"><f a="transform">
	<c path="ceramic.Transform"/>
	<c path="ceramic.Transform"/>
</f></set_transform>
		<shader public="1" set="accessor" expr="null">
			<c path="ceramic.Shader"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* Assign a shader to this visual.
     * When none is assigned, default shader will be used.</haxe_doc>
		</shader>
		<set_shader set="method" line="1533"><f a="shader">
	<c path="ceramic.Shader"/>
	<c path="ceramic.Shader"/>
</f></set_shader>
		<flag public="1" get="inline" set="null" line="1546">
			<f a="index:?value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Read and write arbitrary boolean flags on this visual.
     * Index should be between 0 (included) and 16 (excluded) or result is undefined.
     * @param index The index of the flag to change, between 0 (included) and 16 (excluded)
     * @param value (optional) The boolean value to set, or no value to simply read current value
     * @return The existing value if just reading, or the new value if writing</haxe_doc>
		</flag>
		<internalFlag get="inline" set="null" line="1571">
			<f a="index:?value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Read and write arbitrary boolean flags on this visual.
     * Index should be between 0 (included) and 16 (excluded) or result is undefined.
     * /!\ Reserved for internal use</haxe_doc>
		</internalFlag>
		<flags expr="new Flags()">
			<x path="ceramic.Flags"/>
			<meta><m n=":value"><e>new Flags()</e></m></meta>
			<haxe_doc>* Just a way to store some flags.
     * 32 boolean values stored inside an `Int`.</haxe_doc>
		</flags>
		<active public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether this visual is `active`. Default is **true**. When setting it to **false**,
     * the visual won't be `visible` nor `touchable` anymore (these get set to **false**).
     * When restoring `active` to **true**, `visible` and `touchable` will also get back
     * their previous state.
     * If you want to keep a visual around without it being displayed or interactive, simply
     * set its `active` property to `false`. It will be almost like it doesn't exist and its
     * impact on rendering will be minimal.</haxe_doc>
		</active>
		<get_active get="inline" set="null" line="1593"><f a=""><x path="Bool"/></f></get_active>
		<set_active set="method" line="1596"><f a="active">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_active>
		<matA public="1" expr="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matA>
		<matB public="1" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matB>
		<matC public="1" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matC>
		<matD public="1" expr="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matD>
		<matTX public="1" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matTX>
		<matTY public="1" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matTY>
		<computedVisible public="1" set="null" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Computed visible value. This is `true` if this visual is `visible` and all
     * of its parents are `visible`. If you want to know if a visual is visible on screen,
     * you should check with this property and not `visible` property, which doesn't account
     * for parent visibility.</haxe_doc>
		</computedVisible>
		<computedAlpha public="1" set="null" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Computed alpha value. This is the combination of this visual's alpha and its parent alpha
     * if `inheritAlpha` is `true`</haxe_doc>
		</computedAlpha>
		<computedDepth public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Computed depth value. This is the final depth used by rendering, computed from this visual's `depth`
     * and `depthRange` properties and its hierarchy of parent visuals.</haxe_doc>
		</computedDepth>
		<computedRenderTarget public="1" set="null" expr="null">
			<c path="ceramic.RenderTexture"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Computed render target. When a visual has a `renderTarget` assigned, its `computedRenderTarget` will
     * be assigned with the same instance, and its children's `computedRenderTarget` property as well.</haxe_doc>
		</computedRenderTarget>
		<computedTouchable public="1" set="null" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Computed touchable value. This is `true` if this visual is `touchable` and all
     * of its parents are `touchable`.</haxe_doc>
		</computedTouchable>
		<computedClip public="1" set="null" expr="null">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If any parent of this visual has a `clip` visual assigned, this will be the computed/resolved visual.</haxe_doc>
		</computedClip>
		<children public="1" set="null" expr="null">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.Visual"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* A visual can have **children**.
     * Children positions and transformations are relative to their parent.
     * This property is read only. Use `add()` to add children to this visual
     * and `remove()` to remove them.
     * The order on the visuals in `children` should not be used to predict the order in which visuals are rendered.
     * If you want to control the order of rendering of visuals, use `depth` property on the children instead.</haxe_doc>
		</children>
		<parent public="1" set="null" expr="null">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The **parent visual** if there is any, or `null` if this visual doesn't have any parent.</haxe_doc>
		</parent>
		<size public="1" get="inline" set="null" line="1712">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand to set `width` and `height` in a single call.
     * @param width The width to set to the visual
     * @param height The height to set to the visual</haxe_doc>
		</size>
		<anchor public="1" get="inline" set="null" line="1724">
			<f a="anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand to set `anchorX` and `anchorY` in a single call.
     * @param anchorX The anchor to set to the visual on **x** axis
     * @param anchorY The anchor to set to the visual on **y** axis</haxe_doc>
		</anchor>
		<pos public="1" get="inline" set="null" line="1736">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand to set `x` and `y` in a single call.
     * @param x The x position to set to the visual
     * @param y The y position to set to the visual</haxe_doc>
		</pos>
		<scale public="1" get="inline" set="null" line="1748">
			<f a="scaleX">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand to set `scaleX` and `scaleY` in a single call.
     * @param scaleX The scale to set to the visual on **x** axis
     * @param scaleY (optional) The scale to set to the visual on **y** axis. If not provided, will use scaleX value.</haxe_doc>
			<overloads><scale public="1" get="inline" set="null" line="1759">
	<f a="scaleX:scaleY">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* Shorthand to set `scaleX` and `scaleY` in a single call.
     * @param scaleX The scale to set to the visual on **x** axis
     * @param scaleY (optional) The scale to set to the visual on **y** axis. If not provided, will use scaleX value.</haxe_doc>
</scale></overloads>
		</scale>
		<_scale get="inline" set="null" line="1765"><f a="scaleX:scaleY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></_scale>
		<skew public="1" get="inline" set="null" line="1777">
			<f a="skewX:skewY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand to set `skewX` and `skewY` in a single call.
     * @param skewX The skew to set to the visual on **x** axis
     * @param skewY The skew to set to the visual on **y** axis</haxe_doc>
		</skew>
		<translate public="1" get="inline" set="null" line="1789">
			<f a="translateX:translateY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand to set `translateX` and `translateY` in a single call.
     * @param translateX The translation to set to the visual on **x** axis
     * @param translateY The translation to set to the visual on **y** axis</haxe_doc>
		</translate>
		<anchorKeepPosition public="1" set="method" line="1805">
			<f a="anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the visual's anchor but ensure the visual keeps its current position.
     * This is similar to `anchor(anchorX, anchorY)` but visual with have its `x` and `y` properties
     * updated to ensure it stays at the same position as before changing anchor.
     * @param anchorX The anchor to set to the visual on **x** axis
     * @param anchorY The anchor to set to the visual on **y** axis</haxe_doc>
		</anchorKeepPosition>
		<childWithId public="1" set="method" line="1838">
			<f a="id:?recursive" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="ceramic.Visual"/>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
			<haxe_doc>* Returns the first child matching the requested `id` or `null` otherwise.
     * @param id The requested id
     * @param recursive (optional) Recursive search in children
     * @return A matching visual or `null`</haxe_doc>
		</childWithId>
		<destroy public="1" set="method" line="1884" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroy the visual.
     * When a visual is destroyed, `clear()` is called,
     * which means all children are removed and destroyed.
     * Events owned by this visual and events on this visual are
     * unbound so they don't need to be unbound explicitly.
     * As soon as `destroy()` is called, the `destroyed` property
     * becomes `true`.</haxe_doc>
		</destroy>
		<clear public="1" set="method" line="1922">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Remove and destroy all children.</haxe_doc>
		</clear>
		<transformDidChange set="method" line="1946">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when this visual's transform has changed</haxe_doc>
		</transformDidChange>
		<computeMatrix set="method" line="1955">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when this visual's matrix needs to be recomputed</haxe_doc>
		</computeMatrix>
		<computeTranslatesOnly get="inline" set="null" line="1967"><f a=""><x path="Void"/></f></computeTranslatesOnly>
		<doComputeMatrix get="inline" set="null" line="1974"><f a=""><x path="Void"/></f></doComputeMatrix>
		<hits public="1" get="inline" set="null" line="2123">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if screen (x, y) screen coordinates hit/intersect this visual visible bounds
     * @param x Screen **x** coordinate
     * @param y Screen **y** coordinate
     * @return `true` if it hits</haxe_doc>
			<overloads><hits public="1" get="inline" set="null" line="2136">
	<f a="x:y:ignoreRenderTarget">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Bool"/>
		<x path="Bool"/>
	</f>
	<haxe_doc>* Returns true if screen (x, y) screen coordinates hit/intersect this visual visible bounds
     * @param x Screen **x** coordinate
     * @param y Screen **y** coordinate
     * @param ignoreRenderTarget
     *      If `true`, hit test will be performed like the visual
     *      doesn't have a render target even if it has in reality
     * @return `true` if it hits</haxe_doc>
</hits></overloads>
		</hits>
		<_hits set="method" line="2140"><f a="x:y:ignoreRenderTarget">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></_hits>
		<hitTest set="method" line="2190">
			<f a="x:y:matrix">
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.Transform"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* The actual hit test performed on the visual.
     * If needed to change how hit test is performed
     * on a visual subclass, this is the method to override.
     * @param x Screen **x** coordinate
     * @param y Screen **y** coordinate
     * @param matrix The matrix being applied to visual, relative to screen space
     * @return `true` if it hits</haxe_doc>
		</hitTest>
		<isHitVisual get="accessor" set="accessor"><x path="Bool"/></isHitVisual>
		<get_isHitVisual get="inline" set="null" line="2203"><f a=""><x path="Bool"/></f></get_isHitVisual>
		<set_isHitVisual get="inline" set="null" line="2207"><f a="isHitVisual">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isHitVisual>
		<interceptPointerDown set="method" line="2224">
			<f a="hittingVisual:x:y:touchIndex:buttonId">
				<c path="ceramic.Visual"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Override this method in subclasses to intercept hitting pointer down events on this visual's children (any level in sub-hierarchy).
     * Return `true` to stop an event from being triggered on the hitting child, `false` (default) otherwise.
     * @param hittingVisual The hitting visual, meaning the visual on which the event applies
     * @param x The **x** coordinate of the event
     * @param y The **y** coordinate of the event
     * @param touchIndex The **touch index** of the event (or `-1` if it is not a touch event)
     * @param buttonId The **button id** of the event (or `-1` if it is not a mouse event)
     * @return `true` if the event is intercepted</haxe_doc>
		</interceptPointerDown>
		<interceptPointerOver set="method" line="2239">
			<f a="hittingVisual:x:y">
				<c path="ceramic.Visual"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Override this method in subclasses to intercept hitting pointer over events on this visual's children (any level in sub-hierarchy).
     * Return `true` to stop an event from being triggered on the hitting child, `false` (default) otherwise.
     * @param hittingVisual The hitting visual, meaning the visual on which the event applies
     * @param x The **x** coordinate of the event
     * @param y The **y** coordinate of the event
     * @return `true` if the event is intercepted</haxe_doc>
		</interceptPointerOver>
		<screenToVisual public="1" set="method" line="2254">
			<f a="x:y:point:?handleFilters" v=":::true">
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.Point"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ handleFilters : true }</e></m></meta>
			<haxe_doc>* Assign **x** and **y** to given point after converting them from screen coordinates to current visual coordinates.
     * @param x The **x** coordinate
     * @param y The **y** coordinate
     * @param point The point in which resulting x and y coordinate are stored
     * @param handleFilters (optional) Make it `false` if you want to skip nested filter transformations</haxe_doc>
		</screenToVisual>
		<visualToScreen public="1" set="method" line="2304">
			<f a="x:y:point:?handleFilters" v=":::true">
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.Point"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ handleFilters : true }</e></m></meta>
			<haxe_doc>* Assign **x** and **y** to given point after converting them from current visual coordinates to screen coordinates.
     * @param x The **x** coordinate
     * @param y The **y** coordinate
     * @param point The point in which resulting x and y coordinate are stored
     * @param handleFilters (optional) Make it `false` if you want to skip nested filter transformations</haxe_doc>
		</visualToScreen>
		<visualToTransform public="1" set="method" line="2350">
			<f a="transform">
				<c path="ceramic.Transform"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Extract current visual transformation and write it into the given `transform`
     * @param transform The transform object to write data into</haxe_doc>
		</visualToTransform>
		<computeVisibility set="method" line="2362"><f a=""><x path="Void"/></f></computeVisibility>
		<computeClip set="method" line="2400"><f a=""><x path="Void"/></f></computeClip>
		<computeTouchable set="method" line="2436"><f a=""><x path="Void"/></f></computeTouchable>
		<computeRenderTarget set="method" line="2460"><f a=""><x path="Void"/></f></computeRenderTarget>
		<computeContent public="1" set="method" line="2514">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Compute content on this visual.
     * This method is expected to be overrided in `Visual` subclasses
     * to compute actual content (raw `Visual` class doesn't do anything).</haxe_doc>
		</computeContent>
		<autoChildrenDepth public="1" set="method" line="2532">
			<f a="?start:?step" v="1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ step : 1, start : 1 }</e></m></meta>
			<haxe_doc>* Will walk on every children and set their depths starting from
     * `start` and incrementing depth by `step`.
     * @param start The depth starting value (default 1). First child will have this depth, next child `depthStart + depthStep` etc...
     * @param step The depth step to use when increment depth for each child</haxe_doc>
		</autoChildrenDepth>
		<sortChildrenByDepth public="1" set="method" line="2551">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sort children by depth in ascending order.
     * This will simply reorder children in `children` array.
     * No depth value will be changed on any child.</haxe_doc>
		</sortChildrenByDepth>
		<normalizeChildrenDepth public="1" set="method" line="2566">
			<f a="?start:?step" v="1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ step : 1, start : 1 }</e></m></meta>
			<haxe_doc>* This is the equivalent of calling `sortChildrenByDepth()` followed with `autoChildrenDepth()`
     * @param start The depth starting value (default 1). First child will have this depth, next child `depthStart + depthStep` etc...
     * @param step The depth step to use when increment depth for each child</haxe_doc>
		</normalizeChildrenDepth>
		<hasIndirectParent public="1" set="method" line="2797">
			<f a="targetParent">
				<c path="ceramic.Visual"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if current visual has `targetParent` as parent visual. The parent can possibly
     * be indirect, meaning it can be the parent of the parent of the visual etc...
     * @param targetParent The target parent to check
     * @return `true` if the visual has the given target parent as indirect parent</haxe_doc>
		</hasIndirectParent>
		<firstParentWithClass public="1" params="T" set="method" line="2815">
			<f a="clazz">
				<x path="Class"><c path="firstParentWithClass.T"/></x>
				<c path="firstParentWithClass.T"/>
			</f>
			<haxe_doc>* Returns the first parent (can be indirect) of this visual that matches
     * the given class or `null` if none is matching
     * @param clazz The requested class
     * @return A matching parent or `null`</haxe_doc>
		</firstParentWithClass>
		<add public="1" set="method" line="2833">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add the given visual as a child.
     * When a visual is added as a child, it's `parent` property is updated
     * and it will follow parent transformation in addition to its own.
     * @param visual The visual to add</haxe_doc>
		</add>
		<remove public="1" set="method" line="2864">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove the child from current visual.
     * @param visual The child to remove</haxe_doc>
		</remove>
		<contains public="1" set="method" line="2894">
			<f a="child:?recursive" v=":false">
				<c path="ceramic.Visual"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ recursive : false }</e></m></meta>
			<haxe_doc>* Returns `true` if the current visual contains this child.
     * When `recursive` option is `true`, will return `true` if
     * the current visual contains this child or one of
     * its direct or indirect children does.
     * @param child The child to check in hierarchy
     * @param recursive (optional) Set to `true` to search recursively on indirect children
     * @return `true` if the current visual contains this child</haxe_doc>
		</contains>
		<computeBounds public="1" set="method" line="2917">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Compute bounds from children this visual contains.
     * This overwrites width, height, anchorX and anchorY properties accordingly.
     * Warning: this may be an expensive operation.</haxe_doc>
		</computeBounds>
		<bindToNativeScreenSize public="1" set="method" line="3037">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Will set this visual size to native screen size.
     * This is different than `bindToScreenSize()` because it will ignore
     * logical screen scaling. Use that if you want to provide visuals
     * that should keep the same pixel size when the window changes size and scales its content.
     * If needed, a `Transform` instance will be created and assigned to `transform` property.</haxe_doc>
		</bindToNativeScreenSize>
		<_bindToNativeScreenSizeCallback set="method" line="3045"><f a=""><x path="Void"/></f></_bindToNativeScreenSizeCallback>
		<bindToScreenSize public="1" set="method" line="3064">
			<f a="?factor" v="1.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ factor : 1.0 }</e></m></meta>
			<haxe_doc>* Will set this visual size to screen size</haxe_doc>
		</bindToScreenSize>
		<_bindToScreenSizeCallback set="method" line="3072"><f a="factor">
	<x path="Float"/>
	<x path="Void"/>
</f></_bindToScreenSizeCallback>
		<bindToTargetSize public="1" set="method" line="3081">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Will set this visual size to target size (`settings.targetWidth` and `settings.targetHeight`)</haxe_doc>
		</bindToTargetSize>
		<_bindToTargetSizeCallback set="method" line="3089"><f a=""><x path="Void"/></f></_bindToTargetSizeCallback>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="1863">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Create a new `Visual`</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Visuals are the building blocks to display things on screen.
 * A raw visual doesn't display anything but can have children
 * that can be more specialized visuals like `Quad`, `Mesh` or `Text` etc...
 *
 * ```haxe
 * var visual = new Visual();
 * visual.pos(x, y);
 * visual.size(someWidth, someHeight);
 * visual.onPointerDown(this, info -> {
 *     trace('clicked');
 * });
 * ```]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
			<m n=":allow"><e>ceramic.Screen</e></m>
			<m n=":allow"><e>ceramic.MeshPool</e></m>
			<m n="editable"/>
		</meta>
	</class>
	<class path="ceramic.Mesh" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Mesh.hx">
		<extends path="ceramic.Visual"/>
		<_matrix expr="Visual._matrix" line="50" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>Visual._matrix</e></m></meta>
		</_matrix>
		<colorMapping public="1" expr="MeshColorMapping.MESH">
			<x path="ceramic.MeshColorMapping"/>
			<meta><m n=":value"><e>MeshColorMapping.MESH</e></m></meta>
		</colorMapping>
		<customFloatAttributesSize public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The number of floats to add to fill float attributes in vertices array.
     * Default is zero: no custom attributes. Update this value when using shaders with custom attributes.</haxe_doc>
		</customFloatAttributesSize>
		<complexHit public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* When set to `true` hit test on this mesh will be performed at vertices level instead
     * of simply using bounds. This make the test substancially more expensive however.
     * Use only when needed.</haxe_doc>
		</complexHit>
		<destroy public="1" set="method" line="80" override="1"><f a=""><x path="Void"/></f></destroy>
		<color public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<meta><m n="editable"/></meta>
			<haxe_doc>* On `Mesh` instances, can be used instead of colors array when the mesh is only composed of a single color.</haxe_doc>
		</color>
		<get_color set="method" line="96"><f a=""><x path="ceramic.Color"/></f></get_color>
		<set_color set="method" line="108"><f a="color">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
		<vertices public="1" expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* An array of floats where each pair of numbers is treated as a coordinate location (x,y)</haxe_doc>
		</vertices>
		<indices public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* An array of integers or indexes, where every three indexes define a triangle.</haxe_doc>
		</indices>
		<colors public="1" expr="[]">
			<c path="Array"><x path="ceramic.AlphaColor"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* An array of colors for each vertex.
     * Each color is stored in a single `AlphaColor`(`Int`) value.</haxe_doc>
		</colors>
		<floatColors public="1" expr="null">
			<t path="ceramic.Float32Array"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* An array of colors for each vertex stored are four float32 values for each color.
     * Generally not needed unless you need extra precision for each color value.
     * If provided (not `null`), it will be used instead of `colors`.
     * When using `floatColors` instead of `colors`, no additional operation
     * related to premultiplied alpha will be done on the CPU.</haxe_doc>
		</floatColors>
		<texture public="1" set="accessor" expr="null">
			<c path="ceramic.Texture"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* The texture used on the mesh (optional)</haxe_doc>
		</texture>
		<set_texture get="inline" set="null" line="158"><f a="texture">
	<c path="ceramic.Texture"/>
	<c path="ceramic.Texture"/>
</f></set_texture>
		<uvs public="1" expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* An array of normalized coordinates used to apply texture mapping.
     * Required if the texture is set.</haxe_doc>
		</uvs>
		<textureDestroyed set="method" line="216"><f a="_">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></textureDestroyed>
		<hitTest set="method" line="225" override="1"><f a="x:y:matrix">
	<x path="Float"/>
	<x path="Float"/>
	<c path="ceramic.Transform"/>
	<x path="Bool"/>
</f></hitTest>
		<set_shader set="method" line="290" override="1"><f a="shader">
	<c path="ceramic.Shader"/>
	<c path="ceramic.Shader"/>
</f></set_shader>
		<computeSize public="1" set="method" line="303">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Compute width and height from vertices</haxe_doc>
		</computeSize>
		<grid public="1" set="method" line="353">
			<f a="cols:rows:?width:?height" v="::-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : -1, width : -1 }</e></m></meta>
			<haxe_doc>* Compute vertices and indices to obtain a grid with `cols` columns
     * and `rows` rows at the requested `width` and `height`.
     * @param cols The number of columnns in the grid
     * @param rows The number of rows in the grid
     * @param width The width of the grid
     * @param height The height of the grid</haxe_doc>
		</grid>
		<gridFromTexture public="1" set="method" line="418">
			<f a="cols:rows:?texture">
				<x path="Int"/>
				<x path="Int"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Compute vertices, indices and uvs to obtain a grid with `cols` columns
     * and `rows` rows to fit the given texture or mesh's current texture.
     * @param cols The number of columnns in the grid
     * @param rows The number of rows in the grid
     * @param texture The texture used to generate the grid. If not provided, will use mesh's current texture</haxe_doc>
		</gridFromTexture>
		<new public="1" set="method" line="72"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Draw anything composed of triangles/vertices.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n="editable"><e>{ highlight : { points : "vertices" }, helpers : [{ name : "Grid", method : "grid", params : [{ name : "Columns", type : "Int", value : 1, slider : [1, 64] }, { name : "Rows", type : "Int", value : 1, slider : [1, 64] }] }, { name : "Grid From Texture", method : "gridFromTexture", params : [{ name : "Columns", type : "Int", value : 1, slider : [1, 64] }, { name : "Rows", type : "Int", value : 1, slider : [1, 64] }] }] }</e></m>
			<m n=":allow"><e>ceramic.MeshPool</e></m>
		</meta>
	</class>
	<class path="ceramic.Arc" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Arc.hx">
		<extends path="ceramic.Mesh"/>
		<sides public="1" set="accessor" expr="32">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>32</e></m>
				<m n="editable"><e>{ slider : [3, 100] }</e></m>
			</meta>
			<haxe_doc>* Number of sides. Higher is smoother but needs more vertices</haxe_doc>
		</sides>
		<set_sides get="inline" set="null" line="16"><f a="sides">
	<x path="Int"/>
	<x path="Int"/>
</f></set_sides>
		<radius public="1" set="accessor" expr="64">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>64</e></m>
				<m n="editable"><e>{ slider : [0, 999] }</e></m>
			</meta>
			<haxe_doc>* Radius of the arc</haxe_doc>
		</radius>
		<set_radius set="method" line="28"><f a="radius">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius>
		<angle public="1" set="accessor" expr="270">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>270</e></m>
				<m n="editable"><e>{ slider : [0, 360] }</e></m>
			</meta>
			<haxe_doc>* Angle (from 0 to 360). 360 will make it draw a full circle/ring</haxe_doc>
		</angle>
		<set_angle set="method" line="40"><f a="angle">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<borderPosition public="1" set="accessor" expr="MIDDLE">
			<e path="ceramic.BorderPosition"/>
			<meta>
				<m n=":value"><e>MIDDLE</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* Position of the drawn border</haxe_doc>
		</borderPosition>
		<set_borderPosition get="inline" set="null" line="52"><f a="borderPosition">
	<e path="ceramic.BorderPosition"/>
	<e path="ceramic.BorderPosition"/>
</f></set_borderPosition>
		<thickness public="1" set="accessor" expr="16">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>16</e></m>
				<m n="editable"><e>{ slider : [1, 120] }</e></m>
			</meta>
			<haxe_doc>* Thickness of the arc. If same value as radius and borderPosition is `INSIDE`, will draw a pie.</haxe_doc>
		</thickness>
		<set_thickness set="method" line="64"><f a="thickness">
	<x path="Float"/>
	<x path="Float"/>
</f></set_thickness>
		<computeContent public="1" set="method" line="79" override="1"><f a=""><x path="Void"/></f></computeContent>
		<new public="1" set="method" line="71"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Convenience mesh subclass to draw arc, pie, ring or disc geometry</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n="editable"><e>{ implicitSize : true }</e></m>
		</meta>
	</class>
	<class path="ceramic.ArrayPool" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ArrayPool.hx">
		<ALLOC_STEP expr="10" line="5" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</ALLOC_STEP>
		<dynPool10 expr="new ArrayPool(10)" line="9" static="1">
			<c path="ceramic.ArrayPool"/>
			<meta><m n=":value"><e>new ArrayPool(10)</e></m></meta>
		</dynPool10>
		<dynPool100 expr="new ArrayPool(100)" line="11" static="1">
			<c path="ceramic.ArrayPool"/>
			<meta><m n=":value"><e>new ArrayPool(100)</e></m></meta>
		</dynPool100>
		<dynPool1000 expr="new ArrayPool(1000)" line="13" static="1">
			<c path="ceramic.ArrayPool"/>
			<meta><m n=":value"><e>new ArrayPool(1000)</e></m></meta>
		</dynPool1000>
		<dynPool10000 expr="new ArrayPool(10000)" line="15" static="1">
			<c path="ceramic.ArrayPool"/>
			<meta><m n=":value"><e>new ArrayPool(10000)</e></m></meta>
		</dynPool10000>
		<dynPool100000 expr="new ArrayPool(100000)" line="17" static="1">
			<c path="ceramic.ArrayPool"/>
			<meta><m n=":value"><e>new ArrayPool(100000)</e></m></meta>
		</dynPool100000>
		<didNotifyLargePool expr="false" line="19" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</didNotifyLargePool>
		<pool public="1" set="method" line="21" static="1"><f a="size">
	<x path="Int"/>
	<c path="ceramic.ArrayPool"/>
</f></pool>
		<arrays expr="null">
			<c path="ceramic.ReusableArray"><x path="Any"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</arrays>
		<nextFree expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextFree>
		<arrayLengths><x path="Int"/></arrayLengths>
		<get public="1" set="method" line="70"><f a=""><c path="ceramic.ReusableArray"><x path="Any"/></c></f></get>
		<release public="1" set="method" line="99"><f a="array">
	<c path="ceramic.ReusableArray"><x path="Any"/></c>
	<x path="Void"/>
</f></release>
		<new public="1" set="method" line="62"><f a="arrayLengths">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Assert" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Assert.hx"><assert public="1" set="method" static="1">
	<f a="expr:?reason">
		<d/>
		<c path="String"/>
		<d/>
	</f>
	<haxe_doc>* Assert the expression evaluates to `true`.
     * This check is only done in `debug` builds and doesn't affect `release` builds.</haxe_doc>
</assert></class>
	<class path="tracker.Observable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Observable.hx" interface="1">
		<haxe_doc>Observable allows to observe properties of an object.</haxe_doc>
		<meta><m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m></meta>
	</class>
	<class path="ceramic.Asset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Asset.hx">
		<extends path="ceramic.Entity"/>
		<implements path="tracker.Observable"/>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Asset"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Asset"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Asset"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Asset"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.Asset"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<_dox_event_complete public="1" set="method" line="637">
			<f a="success">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_complete>
		<emitComplete set="method" line="1095">
			<f a="success">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>complete event</haxe_doc>
		</emitComplete>
		<onComplete public="1" set="method" line="1199">
			<f a="owner:handleSuccess">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="success">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</onComplete>
		<onceComplete public="1" set="method" line="1298">
			<f a="owner:handleSuccess">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="success">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</onceComplete>
		<offComplete public="1" set="method" line="1368">
			<f a="?handleSuccess">
				<f a="success">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</offComplete>
		<listensComplete public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to complete event</haxe_doc>
		</listensComplete>
		<kind public="1" set="null">
			<c path="String"/>
			<haxe_doc>* Asset kind</haxe_doc>
		</kind>
		<name public="1" set="accessor">
			<c path="String"/>
			<haxe_doc>* Asset name</haxe_doc>
		</name>
		<variant public="1" set="accessor">
			<c path="String"/>
			<haxe_doc>* Asset variant</haxe_doc>
		</variant>
		<fullName public="1" set="null">
			<c path="String"/>
			<haxe_doc>* Asset full name (including variant, if provided)</haxe_doc>
		</fullName>
		<path public="1" set="accessor">
			<c path="String"/>
			<haxe_doc>* Asset path</haxe_doc>
		</path>
		<allPaths public="1" set="null">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* All paths related to this asset</haxe_doc>
		</allPaths>
		<density public="1" set="null" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Asset target density. Some assets depend on current screen density,
     * like bitmap fonts, textures. Default is 1.0</haxe_doc>
		</density>
		<owner public="1" set="null">
			<c path="ceramic.Assets"/>
			<haxe_doc>* Asset owner. The owner is a group of assets (Assets instance). When the owner gets
     * destroyed, every asset it owns get destroyed as well.</haxe_doc>
		</owner>
		<runtimeAssets public="1" set="accessor">
			<c path="ceramic.RuntimeAssets"/>
			<haxe_doc>* Optional runtime assets, used to compute path.</haxe_doc>
		</runtimeAssets>
		<options public="1" set="null">
			<t path="ceramic.AssetOptions"/>
			<haxe_doc>* Asset options. Depends on asset kind and even backend in some cases.</haxe_doc>
		</options>
		<assets public="1" set="null" expr="null">
			<c path="ceramic.Assets"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Sub assets-list. Defaults to null but some kind of assets (like bitmap fonts) instanciate it to load sub-assets it depends on.</haxe_doc>
		</assets>
		<refCount public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Manage asset retain count. Increase it by calling `retain()` and decrease it by calling `release()`.
     * This can be used when mutliple objects are using the same assets
     * without knowing in advance when they will be needed.</haxe_doc>
		</refCount>
		<invalidateStatus public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateStatus>
		<status public="1" expr="NONE">
			<e path="ceramic.AssetStatus"/>
			<meta>
				<m n=":value"><e>NONE</e></m>
				<m n="observe"/>
			</meta>
		</status>
		<unobservedStatus>
			<e path="ceramic.AssetStatus"/>
			<haxe_doc></haxe_doc>
		</unobservedStatus>
		<_dox_event_statusChange public="1" set="method" line="637">
			<f a="current:previous">
				<e path="ceramic.AssetStatus"/>
				<e path="ceramic.AssetStatus"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</_dox_event_statusChange>
		<emitStatusChange set="method" line="1095">
			<f a="current:previous">
				<e path="ceramic.AssetStatus"/>
				<e path="ceramic.AssetStatus"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</emitStatusChange>
		<onStatusChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.AssetStatus"/>
					<e path="ceramic.AssetStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</onStatusChange>
		<onceStatusChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.AssetStatus"/>
					<e path="ceramic.AssetStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</onceStatusChange>
		<offStatusChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<e path="ceramic.AssetStatus"/>
					<e path="ceramic.AssetStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</offStatusChange>
		<listensStatusChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</listensStatusChange>
		<handleTexturesDensityChange set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</handleTexturesDensityChange>
		<hotReload set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hotReload>
		<customExtensions set="null" expr="null">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</customExtensions>
		<load public="1" set="method" line="105"><f a=""><x path="Void"/></f></load>
		<destroy public="1" set="method" line="113" override="1"><f a=""><x path="Void"/></f></destroy>
		<computePath public="1" set="method" line="129"><f a="?extensions:?dir:?runtimeAssets">
	<c path="Array"><c path="String"/></c>
	<x path="Bool"/>
	<c path="ceramic.RuntimeAssets"/>
	<x path="Void"/>
</f></computePath>
		<set_path set="method" line="257"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></set_path>
		<set_name set="method" line="276"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></set_name>
		<set_variant set="method" line="289"><f a="variant">
	<c path="String"/>
	<c path="String"/>
</f></set_variant>
		<set_runtimeAssets set="method" line="302"><f a="runtimeAssets">
	<c path="ceramic.RuntimeAssets"/>
	<c path="ceramic.RuntimeAssets"/>
</f></set_runtimeAssets>
		<set_handleTexturesDensityChange set="method" line="313"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_handleTexturesDensityChange>
		<texturesDensityDidChange set="method" line="329"><f a="newDensity:prevDensity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texturesDensityDidChange>
		<set_hotReload set="method" line="335"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_hotReload>
		<assetFilesDidChange set="method" line="351"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<toString set="method" line="359" override="1"><f a=""><c path="String"/></f></toString>
		<willEmitComplete get="inline" set="null" line="373"><f a="success">
	<x path="Bool"/>
	<x path="Void"/>
</f></willEmitComplete>
		<retain public="1" set="method" line="383"><f a=""><x path="Void"/></f></retain>
		<release public="1" set="method" line="393"><f a=""><x path="Void"/></f></release>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="92"><f a="kind:name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.Assets</e></m>
		</meta>
	</class>
	<abstract path="ceramic.AssetId" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetId.hx">
		<from><icast><c path="ceramic.AssetId.T"/></icast></from>
		<this><c path="ceramic.AssetId.T"/></this>
		<to><icast><c path="ceramic.AssetId.T"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="ceramic._AssetId.AssetId_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetId.hx" private="1" module="ceramic.AssetId" final="1"><_new public="1" get="inline" set="null" line="6" static="1">
	<f a="value">
		<c path="ceramic.AssetId.T"/>
		<x path="ceramic.AssetId"><c path="ceramic.AssetId.T"/></x>
	</f>
	<meta><m n=":noCompletion"/></meta>
</_new></class></impl>
	</abstract>
	<class path="ceramic._AssetId.AssetId_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetId.hx" private="1" module="ceramic.AssetId" final="1"><_new public="1" get="inline" set="null" line="6" static="1">
	<f a="value">
		<c path="ceramic.AssetId.T"/>
		<x path="ceramic.AssetId"><c path="ceramic.AssetId.T"/></x>
	</f>
	<meta><m n=":noCompletion"/></meta>
</_new></class>
	<typedef path="ceramic.AssetOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetOptions.hx"><d/></typedef>
	<class path="ceramic.AssetPathInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetPathInfo.hx">
		<density public="1">
			<x path="Float"/>
			<haxe_doc>* Density value resolved from file name.
     * Example: If file is named `someImage@2x.png`, density will be `2`.
     * Default density is `1`</haxe_doc>
		</density>
		<extension public="1">
			<c path="String"/>
			<haxe_doc>* File extension (always converted to lowercase for convenience)</haxe_doc>
		</extension>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* Normalized asset name (includes subdirectories relative to asset root).
     * Example: both `someImage.png` and `someImage@2x.png` will resolve to a same asset name `someImage`</haxe_doc>
		</name>
		<path public="1">
			<c path="String"/>
			<haxe_doc>* Original path used to generated path info</haxe_doc>
		</path>
		<flags public="1">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<haxe_doc>* Flags are extracted from file path.
     * Example: file `someFile+myTag.txt` will generate `myTag` flag.</haxe_doc>
		</flags>
		<toString set="method" line="86"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="43"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Information extracted from a raw asset path</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="ceramic.AssetStatus" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetStatus.hx">
		<NONE/>
		<LOADING/>
		<READY/>
		<BROKEN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="ceramic.AssetsLoadMethod" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetsLoadMethod.hx">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._AssetsLoadMethod.AssetsLoadMethod_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetsLoadMethod.hx" private="1" module="ceramic.AssetsLoadMethod" extern="1" final="1">
	<ASYNC public="1" get="inline" set="null" expr="cast 1" line="10" static="1">
		<x path="ceramic.AssetsLoadMethod"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Ensure asset loading is non blocking, at least between each asset.
     * This is useful when we need to update screen during asset loading.
     * Backends may adapt how they load assets from this setting as well</haxe_doc>
	</ASYNC>
	<SYNC public="1" get="inline" set="null" expr="cast 2" line="16" static="1">
		<x path="ceramic.AssetsLoadMethod"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Try to load assets synchronously (if supported on the current backend).
     * This means calling `assets.load()` will trigger `complete` event synchronously if possible.</haxe_doc>
	</SYNC>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._AssetsLoadMethod.AssetsLoadMethod_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetsLoadMethod.hx" private="1" module="ceramic.AssetsLoadMethod" extern="1" final="1">
		<ASYNC public="1" get="inline" set="null" expr="cast 1" line="10" static="1">
			<x path="ceramic.AssetsLoadMethod"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Ensure asset loading is non blocking, at least between each asset.
     * This is useful when we need to update screen during asset loading.
     * Backends may adapt how they load assets from this setting as well</haxe_doc>
		</ASYNC>
		<SYNC public="1" get="inline" set="null" expr="cast 2" line="16" static="1">
			<x path="ceramic.AssetsLoadMethod"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Try to load assets synchronously (if supported on the current backend).
     * This means calling `assets.load()` will trigger `complete` event synchronously if possible.</haxe_doc>
		</SYNC>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="ceramic.AssetsScheduleMethod" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetsScheduleMethod.hx">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._AssetsScheduleMethod.AssetsScheduleMethod_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetsScheduleMethod.hx" private="1" module="ceramic.AssetsScheduleMethod" extern="1" final="1">
	<PARALLEL public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
		<x path="ceramic.AssetsScheduleMethod"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Assets are all loaded in parallel (if not blocked by their thread)</haxe_doc>
	</PARALLEL>
	<SERIAL public="1" get="inline" set="null" expr="cast 2" line="13" static="1">
		<x path="ceramic.AssetsScheduleMethod"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Assets are loaded one after another</haxe_doc>
	</SERIAL>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._AssetsScheduleMethod.AssetsScheduleMethod_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetsScheduleMethod.hx" private="1" module="ceramic.AssetsScheduleMethod" extern="1" final="1">
		<PARALLEL public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
			<x path="ceramic.AssetsScheduleMethod"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Assets are all loaded in parallel (if not blocked by their thread)</haxe_doc>
		</PARALLEL>
		<SERIAL public="1" get="inline" set="null" expr="cast 2" line="13" static="1">
			<x path="ceramic.AssetsScheduleMethod"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Assets are loaded one after another</haxe_doc>
		</SERIAL>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="ceramic.AtlasAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AtlasAsset.hx">
		<extends path="ceramic.Asset"/>
		<_dox_event_replaceAtlas public="1" set="method" line="637">
			<f a="newAtlas:prevAtlas">
				<c path="ceramic.TextureAtlas"/>
				<c path="ceramic.TextureAtlas"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_replaceAtlas>
		<emitReplaceAtlas set="method" line="1095">
			<f a="newAtlas:prevAtlas">
				<c path="ceramic.TextureAtlas"/>
				<c path="ceramic.TextureAtlas"/>
				<x path="Void"/>
			</f>
			<haxe_doc>replaceAtlas event</haxe_doc>
		</emitReplaceAtlas>
		<onReplaceAtlas public="1" set="method" line="1199">
			<f a="owner:handleNewAtlasPrevAtlas">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newAtlas:prevAtlas">
					<c path="ceramic.TextureAtlas"/>
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceAtlas event</haxe_doc>
		</onReplaceAtlas>
		<onceReplaceAtlas public="1" set="method" line="1298">
			<f a="owner:handleNewAtlasPrevAtlas">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newAtlas:prevAtlas">
					<c path="ceramic.TextureAtlas"/>
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceAtlas event</haxe_doc>
		</onceReplaceAtlas>
		<offReplaceAtlas public="1" set="method" line="1368">
			<f a="?handleNewAtlasPrevAtlas">
				<f a="newAtlas:prevAtlas">
					<c path="ceramic.TextureAtlas"/>
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceAtlas event</haxe_doc>
		</offReplaceAtlas>
		<listensReplaceAtlas public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to replaceAtlas event</haxe_doc>
		</listensReplaceAtlas>
		<invalidateAtlas public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateAtlas>
		<atlas public="1" expr="null">
			<c path="ceramic.TextureAtlas"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</atlas>
		<unobservedAtlas>
			<c path="ceramic.TextureAtlas"/>
			<haxe_doc></haxe_doc>
		</unobservedAtlas>
		<_dox_event_atlasChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.TextureAtlas"/>
				<c path="ceramic.TextureAtlas"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when atlas field changes.</haxe_doc>
		</_dox_event_atlasChange>
		<emitAtlasChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.TextureAtlas"/>
				<c path="ceramic.TextureAtlas"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when atlas field changes.</haxe_doc>
		</emitAtlasChange>
		<onAtlasChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.TextureAtlas"/>
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when atlas field changes.</haxe_doc>
		</onAtlasChange>
		<onceAtlasChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.TextureAtlas"/>
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when atlas field changes.</haxe_doc>
		</onceAtlasChange>
		<offAtlasChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.TextureAtlas"/>
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when atlas field changes.</haxe_doc>
		</offAtlasChange>
		<listensAtlasChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when atlas field changes.</haxe_doc>
		</listensAtlasChange>
		<invalidateText public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateText>
		<text public="1" expr="null">
			<c path="String"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</text>
		<unobservedText>
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</unobservedText>
		<_dox_event_textChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</_dox_event_textChange>
		<emitTextChange set="method" line="1095">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</emitTextChange>
		<onTextChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</onTextChange>
		<onceTextChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</onceTextChange>
		<offTextChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</offTextChange>
		<listensTextChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</listensTextChange>
		<parseAtlas expr="null">
			<f a="text">
				<c path="String"/>
				<c path="ceramic.TextureAtlas"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* A custom atlas parsing method. Will be used over the default parsing if not null</haxe_doc>
		</parseAtlas>
		<load public="1" set="method" line="36" override="1"><f a=""><x path="Void"/></f></load>
		<texturesDensityDidChange set="method" line="214" override="1"><f a="newDensity:prevDensity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texturesDensityDidChange>
		<checkTexturesDensity set="method" line="225"><f a=""><x path="Void"/></f></checkTexturesDensity>
		<assetFilesDidChange set="method" line="240" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="261" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="27"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Audio" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Audio.hx">
		<extends path="ceramic.Entity"/>
		<mixers>
			<c path="ceramic.IntMap"><c path="ceramic.AudioMixer"/></c>
			<meta><m n=":allow"><e>ceramic.Sound</e></m></meta>
		</mixers>
		<initMixerIfNeeded get="inline" set="null" line="19">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>ceramic.Sound</e></m></meta>
		</initMixerIfNeeded>
		<mixer public="1" set="method" line="27"><f a="index">
	<x path="Int"/>
	<c path="ceramic.AudioMixer"/>
</f></mixer>
		<new set="method" line="9">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>ceramic.App</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.AudioMixer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AudioMixer.hx">
		<extends path="ceramic.Entity"/>
		<volume public="1" expr="0.5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</volume>
		<pan public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pan>
		<pitch public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</pitch>
		<mute public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</mute>
		<index public="1"><x path="Int"/></index>
		<new set="method" line="16">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>ceramic.Audio</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.AutoCollections" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AutoCollections.hx" interface="1"><meta>
	<m n=":keep"/>
	<m n=":keepSub"/>
	<m n=":autoBuild"><e>ceramic.macros.CollectionsMacro.build()</e></m>
</meta></class>
	<class path="ceramic.BackgroundQueue" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BackgroundQueue.hx">
		<extends path="ceramic.Entity"/>
		<checkInterval public="1" expr="0.1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.1</e></m></meta>
			<haxe_doc>* Time interval between each checks to see if there is something to run.</haxe_doc>
		</checkInterval>
		<runsInBackground expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</runsInBackground>
		<stop expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</stop>
		<pending expr="[]">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pending>
		<schedule public="1" set="method" line="47"><f a="fn">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></schedule>
		<destroy public="1" set="method" line="103" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="33">
			<f a="?checkInterval" v="0.1">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkInterval : 0.1 }</e></m></meta>
		</new>
		<haxe_doc>* An utility to enqueue functions and execute them in bbackground, in a serialized way,
 * meaning it is garanteed that no function in this queue will be run in parallel. An enqueued
 * function will always be started after every previous function has finished executing.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.BezierEasing" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BezierEasing.hx">
		<SPLINE_TABLE_SIZE expr="11" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</SPLINE_TABLE_SIZE>
		<SAMPLE_STEP_SIZE expr="1.0 / (SPLINE_TABLE_SIZE - 1.0)" line="14" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0 / (SPLINE_TABLE_SIZE - 1.0)</e></m></meta>
		</SAMPLE_STEP_SIZE>
		<NEWTON_ITERATIONS expr="4" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</NEWTON_ITERATIONS>
		<NEWTON_MIN_SLOPE expr="0.001" line="16" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.001</e></m></meta>
		</NEWTON_MIN_SLOPE>
		<SUBDIVISION_PRECISION expr="0.0000001" line="17" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0000001</e></m></meta>
		</SUBDIVISION_PRECISION>
		<SUBDIVISION_MAX_ITERATIONS expr="10" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</SUBDIVISION_MAX_ITERATIONS>
		<TWO_THIRD expr="2.0 / 3.0" line="19" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2.0 / 3.0</e></m></meta>
		</TWO_THIRD>
		<CACHE_SIZE expr="10000" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10000</e></m></meta>
		</CACHE_SIZE>
		<quadraticToCubicCP1 get="inline" set="null" line="195" static="1"><f a="p">
	<x path="Float"/>
	<x path="Float"/>
</f></quadraticToCubicCP1>
		<quadraticToCubicCP2 get="inline" set="null" line="201" static="1"><f a="p">
	<x path="Float"/>
	<x path="Float"/>
</f></quadraticToCubicCP2>
		<cachedInstances expr="null" line="209" static="1">
			<c path="ceramic.IntMap"><c path="Array"><c path="ceramic.BezierEasing"/></c></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</cachedInstances>
		<numCachedInstances expr="0" line="211" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numCachedInstances>
		<cacheKey get="inline" set="null" line="232" static="1"><f a="x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></cacheKey>
		<clearCache public="1" set="method" line="239" static="1"><f a=""><x path="Void"/></f></clearCache>
		<get public="1" set="method" line="250" static="1">
			<f a="x1:y1:?x2:?y2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.BezierEasing"/>
			</f>
			<haxe_doc>* Get or create a `BezierEasing` instance with the given parameters.
     * Created instances are cached and reused.</haxe_doc>
		</get>
		<linearEasing expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</linearEasing>
		<sampleValues><c path="Array"><x path="Float"/></c></sampleValues>
		<cached expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</cached>
		<quadratic expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</quadratic>
		<mQuadraticX1><x path="Float"/></mQuadraticX1>
		<mQuadraticX2><x path="Float"/></mQuadraticX2>
		<mX1><x path="Float"/></mX1>
		<mY1><x path="Float"/></mY1>
		<mX2><x path="Float"/></mX2>
		<mY2><x path="Float"/></mY2>
		<configure public="1" set="method" line="61">
			<f a="x1:y1:?x2:?y2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Configure the instance with the given arguments.
     * If only `x1` and `y1` are provided, the curve is treated as quadratic.
     * If all four values `x1`, `y1`, `x2`, `y2` are provided,
     * the curve is treated as cubic.</haxe_doc>
		</configure>
		<ease public="1" set="method" line="102"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<getTForX get="inline" set="null" line="111"><f a="aX">
	<x path="Float"/>
	<x path="Float"/>
</f></getTForX>
		<calcBezier get="inline" set="null" line="141">
			<f a="aT:aA1:aA2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2</haxe_doc>
		</calcBezier>
		<getSlope get="inline" set="null" line="150">
			<f a="aT:aA1:aA2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2</haxe_doc>
		</getSlope>
		<binarySubdivide get="inline" set="null" line="156"><f a="aX:aA:aB:mX1:mX2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></binarySubdivide>
		<newtonRaphsonIterate set="method" line="176"><f a="aX:aGuessT:mX1:mX2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></newtonRaphsonIterate>
		<A get="inline" set="null" line="191"><f a="aA1:aA2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></A>
		<B get="inline" set="null" line="192"><f a="aA1:aA2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></B>
		<C get="inline" set="null" line="193"><f a="aA1">
	<x path="Float"/>
	<x path="Float"/>
</f></C>
		<removeFromCache set="method" line="213"><f a="x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></removeFromCache>
		<new public="1" set="method" line="49">
			<f a="x1:y1:?x2:?y2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new instance with the given arguments.
     * If only `x1` and `y1` are provided, the curve is treated as quadratic.
     * If all four values `x1`, `y1`, `x2`, `y2` are provided,
     * the curve is treated as cubic.</haxe_doc>
		</new>
		<haxe_doc>* Bezier curve easing, ported from https://github.com/gre/bezier-easing
 * then extended to work with both cubic and quadratic settings</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.BinaryAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BinaryAsset.hx">
		<extends path="ceramic.Asset"/>
		<invalidateBytes public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateBytes>
		<bytes public="1" expr="null">
			<c path="haxe.io.Bytes"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</bytes>
		<unobservedBytes>
			<c path="haxe.io.Bytes"/>
			<haxe_doc></haxe_doc>
		</unobservedBytes>
		<_dox_event_bytesChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when bytes field changes.</haxe_doc>
		</_dox_event_bytesChange>
		<emitBytesChange set="method" line="1095">
			<f a="current:previous">
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when bytes field changes.</haxe_doc>
		</emitBytesChange>
		<onBytesChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="haxe.io.Bytes"/>
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when bytes field changes.</haxe_doc>
		</onBytesChange>
		<onceBytesChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="haxe.io.Bytes"/>
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when bytes field changes.</haxe_doc>
		</onceBytesChange>
		<offBytesChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="haxe.io.Bytes"/>
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when bytes field changes.</haxe_doc>
		</offBytesChange>
		<listensBytesChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when bytes field changes.</haxe_doc>
		</listensBytesChange>
		<load public="1" set="method" line="16" override="1"><f a=""><x path="Void"/></f></load>
		<assetFilesDidChange set="method" line="65" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="86" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="10"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.BitmapFont" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BitmapFont.hx">
		<extends path="ceramic.Entity"/>
		<pages public="1" expr="new IntMap(16, 0.5, true)">
			<c path="ceramic.IntMap"><c path="ceramic.Texture"/></c>
			<meta><m n=":value"><e>new IntMap(16, 0.5, true)</e></m></meta>
			<haxe_doc>* The map of font texture pages to their id.</haxe_doc>
		</pages>
		<fontData set="accessor">
			<c path="ceramic.BitmapFontData"/>
			<haxe_doc>* The bitmap font fontData.</haxe_doc>
		</fontData>
		<set_fontData set="method" line="20"><f a="fontData">
	<c path="ceramic.BitmapFontData"/>
	<c path="ceramic.BitmapFontData"/>
</f></set_fontData>
		<face public="1" get="accessor" set="accessor"><c path="String"/></face>
		<get_face get="inline" set="null" line="39"><f a=""><c path="String"/></f></get_face>
		<set_face get="inline" set="null" line="40"><f a="face">
	<c path="String"/>
	<c path="String"/>
</f></set_face>
		<pointSize public="1" get="accessor" set="accessor"><x path="Float"/></pointSize>
		<get_pointSize get="inline" set="null" line="43"><f a=""><x path="Float"/></f></get_pointSize>
		<set_pointSize get="inline" set="null" line="44"><f a="pointSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pointSize>
		<baseSize public="1" get="accessor" set="accessor"><x path="Float"/></baseSize>
		<get_baseSize get="inline" set="null" line="47"><f a=""><x path="Float"/></f></get_baseSize>
		<set_baseSize get="inline" set="null" line="48"><f a="baseSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_baseSize>
		<chars public="1" get="accessor" set="accessor"><c path="ceramic.IntMap"><c path="ceramic.BitmapFontCharacter"/></c></chars>
		<get_chars get="inline" set="null" line="51"><f a=""><c path="ceramic.IntMap"><c path="ceramic.BitmapFontCharacter"/></c></f></get_chars>
		<set_chars get="inline" set="null" line="52"><f a="chars">
	<c path="ceramic.IntMap"><c path="ceramic.BitmapFontCharacter"/></c>
	<c path="ceramic.IntMap"><c path="ceramic.BitmapFontCharacter"/></c>
</f></set_chars>
		<charCount public="1" get="accessor" set="accessor"><x path="Int"/></charCount>
		<get_charCount get="inline" set="null" line="55"><f a=""><x path="Int"/></f></get_charCount>
		<set_charCount get="inline" set="null" line="56"><f a="charCount">
	<x path="Int"/>
	<x path="Int"/>
</f></set_charCount>
		<lineHeight public="1" get="accessor" set="accessor"><x path="Float"/></lineHeight>
		<get_lineHeight get="inline" set="null" line="59"><f a=""><x path="Float"/></f></get_lineHeight>
		<set_lineHeight get="inline" set="null" line="60"><f a="lineHeight">
	<x path="Float"/>
	<x path="Float"/>
</f></set_lineHeight>
		<kernings public="1" get="accessor" set="accessor"><c path="ceramic.IntMap"><c path="ceramic.IntFloatMap"/></c></kernings>
		<get_kernings get="inline" set="null" line="63"><f a=""><c path="ceramic.IntMap"><c path="ceramic.IntFloatMap"/></c></f></get_kernings>
		<set_kernings get="inline" set="null" line="64"><f a="kernings">
	<c path="ceramic.IntMap"><c path="ceramic.IntFloatMap"/></c>
	<c path="ceramic.IntMap"><c path="ceramic.IntFloatMap"/></c>
</f></set_kernings>
		<msdf public="1" get="accessor" set="null"><x path="Bool"/></msdf>
		<get_msdf get="inline" set="null" line="67"><f a=""><x path="Bool"/></f></get_msdf>
		<spaceChar public="1">
			<c path="ceramic.BitmapFontCharacter"/>
			<haxe_doc>* Cached reference of the ' '(32) character, for sizing on tabs/spaces</haxe_doc>
		</spaceChar>
		<pageShaders public="1" expr="null">
			<t path="Map">
				<x path="Int"/>
				<c path="ceramic.Shader"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Shaders used to render the characters. If null, uses default shader.
     * When loading MSDF fonts, ceramic's MSDF shader will be assigned here.
     * Stored per page</haxe_doc>
		</pageShaders>
		<preRenderedPages public="1" expr="null">
			<t path="Map">
				<x path="Int"/>
				<t path="Map">
					<x path="Int"/>
					<c path="ceramic.Texture"/>
				</t>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* When using MSDF fonts, or fonts with custom shaders, it is possible to pre-render characters
     * onto a RenderTexture to use it like a regular texture later with default shader.
     * Useful in some situations to reduce draw calls.</haxe_doc>
		</preRenderedPages>
		<_preRenderingPages expr="null">
			<t path="Map">
				<x path="Int"/>
				<t path="Map">
					<x path="Int"/>
					<c path="Array"><f a=""><x path="Void"/></f></c>
				</t>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* When a page is being pre-rendered, it will be referenced here, until the rendering is finished.
     * This is needed to prevent parallel renders of the same requested texture, giving us unexpected duplicate textures</haxe_doc>
		</_preRenderingPages>
		<asset public="1"><c path="ceramic.Asset"/></asset>
		<destroy public="1" set="method" line="138" override="1"><f a=""><x path="Void"/></f></destroy>
		<needsToPreRenderAtSize public="1" set="method" line="174"><f a="pixelSize">
	<x path="Int"/>
	<x path="Bool"/>
</f></needsToPreRenderAtSize>
		<preRenderAtSize public="1" set="method" line="189"><f a="pixelSize:done">
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></preRenderAtSize>
		<preRenderPage set="method" line="207"><f a="id:pixelsSize:done">
	<x path="Int"/>
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></preRenderPage>
		<kerning public="1" get="inline" set="null" line="302">
			<f a="first:second">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the kerning between two glyphs, or 0 if none.
     * A glyph int id is the value from 'c'.charCodeAt(0)</haxe_doc>
		</kerning>
		<new public="1" set="method" line="98"><f a="fontData:pages">
	<c path="ceramic.BitmapFontData"/>
	<t path="Map">
		<c path="String"/>
		<c path="ceramic.Texture"/>
	</t>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.BitmapFontCharacter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BitmapFontCharacter.hx">
		<id public="1"><x path="Int"/></id>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<xOffset public="1"><x path="Float"/></xOffset>
		<yOffset public="1"><x path="Float"/></yOffset>
		<xAdvance public="1"><x path="Float"/></xAdvance>
		<page public="1"><x path="Int"/></page>
		<new public="1" set="method" line="4">
			<f a="id:x:y:width:height:xOffset:yOffset:xAdvance:page">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.BitmapFontData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BitmapFontData.hx">
		<face public="1"><c path="String"/></face>
		<path public="1"><c path="String"/></path>
		<pointSize public="1"><x path="Float"/></pointSize>
		<baseSize public="1"><x path="Float"/></baseSize>
		<chars public="1"><c path="ceramic.IntMap"><c path="ceramic.BitmapFontCharacter"/></c></chars>
		<charCount public="1"><x path="Int"/></charCount>
		<distanceField public="1"><x path="Null"><c path="ceramic.BitmapFontDistanceFieldData"/></x></distanceField>
		<pages public="1"><c path="Array"><c path="ceramic.BitmapFontDataPage"/></c></pages>
		<lineHeight public="1"><x path="Float"/></lineHeight>
		<kernings public="1"><c path="ceramic.IntMap"><c path="ceramic.IntFloatMap"/></c></kernings>
		<new public="1" set="method" line="4">
			<f a="face:path:pointSize:baseSize:chars:charCount:distanceField:pages:lineHeight:kernings">
				<c path="String"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.IntMap"><c path="ceramic.BitmapFontCharacter"/></c>
				<x path="Int"/>
				<x path="Null"><c path="ceramic.BitmapFontDistanceFieldData"/></x>
				<c path="Array"><c path="ceramic.BitmapFontDataPage"/></c>
				<x path="Float"/>
				<c path="ceramic.IntMap"><c path="ceramic.IntFloatMap"/></c>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.BitmapFontDataPage" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BitmapFontData.hx" module="ceramic.BitmapFontData">
		<id public="1"><x path="Int"/></id>
		<file public="1"><c path="String"/></file>
		<new public="1" set="method" line="18">
			<f a="id:file">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.BitmapFontDistanceFieldData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BitmapFontDistanceFieldData.hx">
		<fieldType public="1"><c path="String"/></fieldType>
		<distanceRange public="1"><x path="Int"/></distanceRange>
		<new public="1" set="method" line="4">
			<f a="fieldType:distanceRange">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.BitmapFontParser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BitmapFontParser.hx">
		<parse public="1" set="method" line="11" static="1"><f a="rawFontData">
	<c path="String"/>
	<c path="ceramic.BitmapFontData"/>
</f></parse>
		<convertXmlFontData set="method" line="62" static="1"><f a="rawFontData">
	<c path="String"/>
	<c path="String"/>
</f></convertXmlFontData>
		<parseLine set="method" line="111" static="1"><f a="line:info">
	<c path="String"/>
	<c path="ceramic.BitmapFontData"/>
	<x path="Void"/>
</f></parseLine>
		<extractLineTokens set="method" line="190" static="1"><f a="line:map">
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
	<c path="String"/>
</f></extractLineTokens>
		<unquote get="inline" set="null" line="272" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></unquote>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="ceramic.Blending" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Blending.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._Blending.Blending_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Blending.hx" private="1" module="ceramic.Blending" extern="1" final="1">
	<AUTO public="1" get="inline" set="null" expr="cast 0" line="10" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Automatic/default blending in ceramic. Internally, this translates to premultiplied alpha blending as textures
     * are already transformed for this blending at asset copy phase, except in some situations (render to texture) where
     * ceramic may use some more specific blendings as needed.</haxe_doc>
	</AUTO>
	<PREMULTIPLIED_ALPHA public="1" get="inline" set="null" expr="cast 1" line="15" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Explicit premultiplied alpha blending</haxe_doc>
	</PREMULTIPLIED_ALPHA>
	<ADD public="1" get="inline" set="null" expr="cast 2" line="20" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Additive blending</haxe_doc>
	</ADD>
	<SET public="1" get="inline" set="null" expr="cast 4" line="25" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Set blending</haxe_doc>
	</SET>
	<RENDER_TO_TEXTURE public="1" get="inline" set="null" expr="cast 5" line="30" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Blending used by ceramic when rendering to texture.</haxe_doc>
	</RENDER_TO_TEXTURE>
	<RENDER_TO_TEXTURE_ALPHA public="1" get="inline" set="null" expr="cast 6" line="35" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Blending used by ceramic when rendering to texture.</haxe_doc>
	</RENDER_TO_TEXTURE_ALPHA>
	<ALPHA public="1" get="inline" set="null" expr="cast 3" line="41" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Traditional alpha blending. This should only be used on very specific cases. Used instead of `NORMAL` blending
     * when the visual is drawing a RenderTexture.</haxe_doc>
	</ALPHA>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._Blending.Blending_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Blending.hx" private="1" module="ceramic.Blending" extern="1" final="1">
		<AUTO public="1" get="inline" set="null" expr="cast 0" line="10" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Automatic/default blending in ceramic. Internally, this translates to premultiplied alpha blending as textures
     * are already transformed for this blending at asset copy phase, except in some situations (render to texture) where
     * ceramic may use some more specific blendings as needed.</haxe_doc>
		</AUTO>
		<PREMULTIPLIED_ALPHA public="1" get="inline" set="null" expr="cast 1" line="15" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Explicit premultiplied alpha blending</haxe_doc>
		</PREMULTIPLIED_ALPHA>
		<ADD public="1" get="inline" set="null" expr="cast 2" line="20" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Additive blending</haxe_doc>
		</ADD>
		<SET public="1" get="inline" set="null" expr="cast 4" line="25" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Set blending</haxe_doc>
		</SET>
		<RENDER_TO_TEXTURE public="1" get="inline" set="null" expr="cast 5" line="30" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Blending used by ceramic when rendering to texture.</haxe_doc>
		</RENDER_TO_TEXTURE>
		<RENDER_TO_TEXTURE_ALPHA public="1" get="inline" set="null" expr="cast 6" line="35" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Blending used by ceramic when rendering to texture.</haxe_doc>
		</RENDER_TO_TEXTURE_ALPHA>
		<ALPHA public="1" get="inline" set="null" expr="cast 3" line="41" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Traditional alpha blending. This should only be used on very specific cases. Used instead of `NORMAL` blending
     * when the visual is drawing a RenderTexture.</haxe_doc>
		</ALPHA>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="ceramic.Border" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Border.hx">
		<extends path="ceramic.Mesh"/>
		<autoComputeVertices public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</autoComputeVertices>
		<set_autoComputeVertices get="inline" set="null" line="11"><f a="autoComputeVertices">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoComputeVertices>
		<autoComputeColors public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</autoComputeColors>
		<set_autoComputeColors get="inline" set="null" line="21"><f a="autoComputeColors">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoComputeColors>
		<set_width set="method" line="30" override="1"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="36" override="1"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<borderPosition public="1" set="accessor" expr="INSIDE">
			<e path="ceramic.BorderPosition"/>
			<meta><m n=":value"><e>INSIDE</e></m></meta>
		</borderPosition>
		<set_borderPosition get="inline" set="null" line="43"><f a="borderPosition">
	<e path="ceramic.BorderPosition"/>
	<e path="ceramic.BorderPosition"/>
</f></set_borderPosition>
		<borderSize public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</borderSize>
		<set_borderSize get="inline" set="null" line="51"><f a="borderSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderSize>
		<borderTopSize public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</borderTopSize>
		<set_borderTopSize get="inline" set="null" line="59"><f a="borderTopSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderTopSize>
		<borderBottomSize public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</borderBottomSize>
		<set_borderBottomSize get="inline" set="null" line="67"><f a="borderBottomSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderBottomSize>
		<borderLeftSize public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</borderLeftSize>
		<set_borderLeftSize get="inline" set="null" line="75"><f a="borderLeftSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderLeftSize>
		<borderRightSize public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</borderRightSize>
		<set_borderRightSize get="inline" set="null" line="83"><f a="borderRightSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderRightSize>
		<borderColor public="1" set="accessor" expr="Color.GRAY">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.GRAY</e></m></meta>
		</borderColor>
		<set_borderColor get="inline" set="null" line="91"><f a="borderColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_borderColor>
		<borderTopColor public="1" set="accessor" expr="Color.NONE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</borderTopColor>
		<set_borderTopColor get="inline" set="null" line="99"><f a="borderTopColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_borderTopColor>
		<borderBottomColor public="1" set="accessor" expr="Color.NONE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</borderBottomColor>
		<set_borderBottomColor get="inline" set="null" line="107"><f a="borderBottomColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_borderBottomColor>
		<borderLeftColor public="1" set="accessor" expr="Color.NONE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</borderLeftColor>
		<set_borderLeftColor get="inline" set="null" line="115"><f a="borderLeftColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_borderLeftColor>
		<borderRightColor public="1" set="accessor" expr="Color.NONE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</borderRightColor>
		<set_borderRightColor get="inline" set="null" line="123"><f a="borderRightColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_borderRightColor>
		<computeColors set="method" line="181"><f a=""><x path="Void"/></f></computeColors>
		<computeVertices set="method" line="218"><f a=""><x path="Void"/></f></computeVertices>
		<new public="1" set="method" line="130"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A rectangle visual that display a border</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<enum path="ceramic.BorderPosition" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BorderPosition.hx">
		<INSIDE/>
		<OUTSIDE/>
		<MIDDLE/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.Camera" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Camera.hx">
		<extends path="ceramic.Entity"/>
		<angleTo get="inline" set="null" line="294" static="1"><f a="x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></angleTo>
		<x public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Camera x position</haxe_doc>
		</x>
		<y public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Camera y position</haxe_doc>
		</y>
		<pos public="1" get="inline" set="null" line="23">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set camera x & y position
     * @param x
     * @param y]]></haxe_doc>
		</pos>
		<followTarget public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* `true` if the camera should follow its target</haxe_doc>
		</followTarget>
		<clampToContentBounds public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If `true`, camera will try to stay inside content bounds. If not possible, it will be centered.</haxe_doc>
		</clampToContentBounds>
		<brakeNearBoundsX public="1" expr="0.02">
			<x path="Float"/>
			<meta><m n=":value"><e>0.02</e></m></meta>
			<haxe_doc>* Percentage of viewport width where camera will "brake" to stay inside content bounds</haxe_doc>
		</brakeNearBoundsX>
		<brakeNearBoundsY public="1" expr="0.03">
			<x path="Float"/>
			<meta><m n=":value"><e>0.03</e></m></meta>
			<haxe_doc>* Percentage of viewport height where camera will "brake" to stay inside content bounds</haxe_doc>
		</brakeNearBoundsY>
		<brakeNearBounds public="1" get="inline" set="null" line="53">
			<f a="brakeNearBoundsX:brakeNearBoundsY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set `brakeNearBoundsX`& `brakeNearBoundsY`
     * @param brakeNearBoundsX
     * @param brakeNearBoundsY]]></haxe_doc>
		</brakeNearBounds>
		<targetX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Target x position</haxe_doc>
		</targetX>
		<targetY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Target y position</haxe_doc>
		</targetY>
		<target public="1" get="inline" set="null" line="73">
			<f a="targetX:targetY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set `targetX` & `targetY`, which define the position the camera may follow if `followTarget` is `true`
     * @param targetX
     * @param targetY]]></haxe_doc>
		</target>
		<trackSpeedX public="1" expr="20.0">
			<x path="Float"/>
			<meta><m n=":value"><e>20.0</e></m></meta>
			<haxe_doc>* Tracking x speed factor</haxe_doc>
		</trackSpeedX>
		<trackSpeedY public="1" expr="15.0">
			<x path="Float"/>
			<meta><m n=":value"><e>15.0</e></m></meta>
			<haxe_doc>* Tracking y speed factor</haxe_doc>
		</trackSpeedY>
		<trackCurve public="1" expr="0.8">
			<x path="Float"/>
			<meta><m n=":value"><e>0.8</e></m></meta>
			<haxe_doc>* Affects tracking curve. Should be above 0 and below or equal to 1.</haxe_doc>
		</trackCurve>
		<zoom public="1" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Zoom scaling factor</haxe_doc>
		</zoom>
		<deadZoneX public="1" expr="0.04">
			<x path="Float"/>
			<meta><m n=":value"><e>0.04</e></m></meta>
			<haxe_doc>* Horizontal dead zone (percentage between 0 and 1 relative to viewport width)</haxe_doc>
		</deadZoneX>
		<deadZoneY public="1" expr="0.1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.1</e></m></meta>
			<haxe_doc>* Horizontal dead zone (percentage between 0 and 1 relative to viewport height)</haxe_doc>
		</deadZoneY>
		<frictionX public="1" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Horizontal friction.
     * More the value is below 1.0, higher is the friction.</haxe_doc>
		</frictionX>
		<frictionY public="1" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Vertical friction.
     * More the value is below 1.0, higher is the friction.</haxe_doc>
		</frictionY>
		<contentX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Content x (top left corner) position</haxe_doc>
		</contentX>
		<contentY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Content y (top left corner) position</haxe_doc>
		</contentY>
		<contentWidth public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Content width</haxe_doc>
		</contentWidth>
		<contentHeight public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Content height</haxe_doc>
		</contentHeight>
		<viewportWidth public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Viewport width: the actual visible with on this camera</haxe_doc>
		</viewportWidth>
		<viewportHeight public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Viewport height: the actual visible height on this camera</haxe_doc>
		</viewportHeight>
		<movementThreshold public="1" expr="0.00001">
			<x path="Float"/>
			<meta><m n=":value"><e>0.00001</e></m></meta>
			<haxe_doc>* A threshold value to stop the camera if its movement is lower than this value</haxe_doc>
		</movementThreshold>
		<contentTranslateX public="1" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
			<haxe_doc>* Translation X that should be applied to the
     * content so that the camera is pointing to the correct area.
     * This value is computed by the camera when it is updated.</haxe_doc>
		</contentTranslateX>
		<contentTranslateY public="1" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
			<haxe_doc>* Translation Y that should be applied to the
     * content so that the camera is pointing to the correct area
     * This value is computed by the camera when it is updated.</haxe_doc>
		</contentTranslateY>
		<hasPrevTransform expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasPrevTransform>
		<dx expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dx>
		<dy expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dy>
		<averageFrameTime final="1" expr="1.0 / 60">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0 / 60</e></m></meta>
		</averageFrameTime>
		<update public="1" set="method" line="183"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="177"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Component" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Component.hx" interface="1">
		<initializerName public="1" set="null">
			<c path="String"/>
			<haxe_doc>* If this component was created from an initializer,
     * its initializer name is provided to retrieve the
     * initializer from the component.
     * This field is automatically added to implementing class by ComponentMacro</haxe_doc>
		</initializerName>
		<setEntity set="method">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called by target entity to assign itself to the component
     * @param entity</haxe_doc>
		</setEntity>
		<getEntity set="method">
			<f a=""><c path="ceramic.Entity"/></f>
			<haxe_doc>* Called to retrieve entity in a generic way that works with all components</haxe_doc>
		</getEntity>
		<bindAsComponent set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the component is bound to an entity. At this stage, the `entity` property
     * should be assigned and work properly. Use this method to run initialization code once
     * the component has been plugged to a target entity.
     * When the target entity is destroyed, our instance (the component) will be unbound and destroyed as well.</haxe_doc>
		</bindAsComponent>
		<haxe_doc>* A Component is and Entity that can be bound to another Entity.
 * Any Entity can be used as a Component, given that it implement Component interface.
 * A Component must be an Entity subclass.</haxe_doc>
		<meta>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<class path="ceramic.Click" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Click.hx">
		<extends path="ceramic.Entity"/>
		<implements path="tracker.Observable"/>
		<implements path="ceramic.Component"/>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Click"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Click"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Click"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Click"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.Click"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<_dox_event_click public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_click>
		<emitClick set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>click event</haxe_doc>
		</emitClick>
		<onClick public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>click event</haxe_doc>
		</onClick>
		<onceClick public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>click event</haxe_doc>
		</onceClick>
		<offClick public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>click event</haxe_doc>
		</offClick>
		<listensClick public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to click event</haxe_doc>
		</listensClick>
		<threshold public="1" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</threshold>
		<entity public="1">
			<c path="ceramic.Visual"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<invalidatePressed public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidatePressed>
		<pressed public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="observe"/>
			</meta>
		</pressed>
		<unobservedPressed>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedPressed>
		<_dox_event_pressedChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when pressed field changes.</haxe_doc>
		</_dox_event_pressedChange>
		<emitPressedChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when pressed field changes.</haxe_doc>
		</emitPressedChange>
		<onPressedChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pressed field changes.</haxe_doc>
		</onPressedChange>
		<oncePressedChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pressed field changes.</haxe_doc>
		</oncePressedChange>
		<offPressedChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pressed field changes.</haxe_doc>
		</offPressedChange>
		<listensPressedChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pressed field changes.</haxe_doc>
		</listensPressedChange>
		<pointerStartX expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</pointerStartX>
		<pointerStartY expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</pointerStartY>
		<bindAsComponent set="method" line="27"><f a=""><x path="Void"/></f></bindAsComponent>
		<cancel public="1" set="method" line="39"><f a=""><x path="Void"/></f></cancel>
		<handlePointerDown set="method" line="47"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerDown>
		<handlePointerUp set="method" line="58"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerUp>
		<handlePointerMove set="method" line="69"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerMove>
		<handleBlur set="method" line="78"><f a=""><x path="Void"/></f></handleBlur>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<setEntity set="method" line="6">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="6">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Closure" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Closure.hx">
		<method public="1"><x path="Any"/></method>
		<args public="1"><c path="Array"><x path="Any"/></c></args>
		<call public="1" set="method" line="16"><f a=""><d/></f></call>
		<new public="1" set="method" line="9"><f a="method:?args">
	<x path="Any"/>
	<c path="Array"><x path="Any"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="ceramic.Collection" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Collection.hx">
		<this><c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c></this>
		<meta>
			<m n=":forward"/>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
		<impl><class path="ceramic._Collection.Collection_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Collection.hx" private="1" module="ceramic.Collection" final="1">
	<_new public="1" get="inline" set="null" line="12" static="1">
		<f a=""><x path="ceramic.Collection"><c path="ceramic.Collection.T"/></x></f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<arrayAccess public="1" get="inline" set="null" line="18" static="1">
		<f a="this:index">
			<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
			<x path="Int"/>
			<c path="ceramic.Collection.T"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</arrayAccess>
	<randomElement public="1" set="method" line="27" static="1">
		<f a="this">
			<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
			<c path="ceramic.Collection.T"/>
		</f>
		<haxe_doc>* Return a random element contained in the collection</haxe_doc>
	</randomElement>
	<randomElementExcept public="1" set="method" line="42" static="1">
		<f a="this:except:?unsafe" v="::false">
			<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
			<c path="ceramic.Collection.T"/>
			<x path="Bool"/>
			<c path="ceramic.Collection.T"/>
		</f>
		<meta><m n=":value"><e>{ unsafe : false }</e></m></meta>
		<haxe_doc>* Return a random element contained in the given array that is not equal to the `except` arg.
     * @param except The element we don't want
     * @param unsafe If set to `true`, will prevent allocating a new array (and may be faster) but will loop forever if there is no element except the one we don't want
     * @return The random element or `null` if nothing was found</haxe_doc>
	</randomElementExcept>
	<randomElementMatchingValidator public="1" set="method" line="58" static="1">
		<f a="this:validator">
			<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
			<f a="">
				<c path="ceramic.Collection.T"/>
				<x path="Bool"/>
			</f>
			<c path="ceramic.Collection.T"/>
		</f>
		<haxe_doc>* Return a random element contained in the given array that is validated by the provided validator.
     * If no item is valid, returns null.
     * @param array  The array in which we extract the element from
     * @param validator A function that returns true if the item is valid, false if not
     * @return The random element or `null` if nothing was found</haxe_doc>
	</randomElementMatchingValidator>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._Collection.Collection_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Collection.hx" private="1" module="ceramic.Collection" final="1">
		<_new public="1" get="inline" set="null" line="12" static="1">
			<f a=""><x path="ceramic.Collection"><c path="ceramic.Collection.T"/></x></f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<arrayAccess public="1" get="inline" set="null" line="18" static="1">
			<f a="this:index">
				<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
				<x path="Int"/>
				<c path="ceramic.Collection.T"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</arrayAccess>
		<randomElement public="1" set="method" line="27" static="1">
			<f a="this">
				<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
				<c path="ceramic.Collection.T"/>
			</f>
			<haxe_doc>* Return a random element contained in the collection</haxe_doc>
		</randomElement>
		<randomElementExcept public="1" set="method" line="42" static="1">
			<f a="this:except:?unsafe" v="::false">
				<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
				<c path="ceramic.Collection.T"/>
				<x path="Bool"/>
				<c path="ceramic.Collection.T"/>
			</f>
			<meta><m n=":value"><e>{ unsafe : false }</e></m></meta>
			<haxe_doc>* Return a random element contained in the given array that is not equal to the `except` arg.
     * @param except The element we don't want
     * @param unsafe If set to `true`, will prevent allocating a new array (and may be faster) but will loop forever if there is no element except the one we don't want
     * @return The random element or `null` if nothing was found</haxe_doc>
		</randomElementExcept>
		<randomElementMatchingValidator public="1" set="method" line="58" static="1">
			<f a="this:validator">
				<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
				<f a="">
					<c path="ceramic.Collection.T"/>
					<x path="Bool"/>
				</f>
				<c path="ceramic.Collection.T"/>
			</f>
			<haxe_doc>* Return a random element contained in the given array that is validated by the provided validator.
     * If no item is valid, returns null.
     * @param array  The array in which we extract the element from
     * @param validator A function that returns true if the item is valid, false if not
     * @return The random element or `null` if nothing was found</haxe_doc>
		</randomElementMatchingValidator>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.CollectionImpl" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Collection.hx" module="ceramic.Collection">
		<implements path="tracker.Events"/>
		<_lastCheckedCombined expr="null" line="73" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_lastCheckedCombined>
		<_nextInternalId expr="0" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_nextInternalId>
		<internalId expr="_nextInternalId++">
			<x path="Int"/>
			<meta><m n=":value"><e>_nextInternalId++</e></m></meta>
		</internalId>
		<lastChange expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastChange>
		<entries public="1" set="null" expr="[]">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.CollectionImpl.T"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
		</entries>
		<indexDirty expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</indexDirty>
		<entriesDirty expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</entriesDirty>
		<byId expr="null">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.CollectionImpl.T"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</byId>
		<filter expr="null">
			<f a="">
				<c path="Array"><c path="ceramic.CollectionImpl.T"/></c>
				<c path="Array"><c path="ceramic.CollectionImpl.T"/></c>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</filter>
		<combinedCollections expr="null">
			<c path="Array"><c path="ceramic.CollectionImpl"><c path="ceramic.CollectionImpl.T"/></c></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</combinedCollections>
		<combinedCollectionLastChanges expr="null">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</combinedCollectionLastChanges>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<get_length set="method" line="95"><f a=""><x path="Int"/></f></get_length>
		<pushAll public="1" set="method" line="103"><f a="entries">
	<c path="Array"><c path="ceramic.CollectionImpl.T"/></c>
	<x path="Void"/>
</f></pushAll>
		<clear public="1" set="method" line="117"><f a=""><x path="Void"/></f></clear>
		<push public="1" set="method" line="132"><f a="entry">
	<c path="ceramic.CollectionImpl.T"/>
	<x path="Void"/>
</f></push>
		<remove public="1" set="method" line="143"><f a="entry">
	<c path="ceramic.CollectionImpl.T"/>
	<x path="Void"/>
</f></remove>
		<synchronize public="1" set="method" line="154"><f a=""><x path="Void"/></f></synchronize>
		<get public="1" set="method" line="161"><f a="id">
	<c path="String"/>
	<c path="ceramic.CollectionImpl.T"/>
</f></get>
		<getByIndex public="1" set="method" line="183"><f a="index">
	<x path="Int"/>
	<c path="ceramic.CollectionImpl.T"/>
</f></getByIndex>
		<indexOfId public="1" set="method" line="193"><f a="id">
	<c path="String"/>
	<x path="Int"/>
</f></indexOfId>
		<indexOf public="1" set="method" line="203"><f a="entry">
	<c path="ceramic.CollectionImpl.T"/>
	<x path="Int"/>
</f></indexOf>
		<iterator public="1" get="inline" set="null" line="213"><f a=""><t path="Iterator"><c path="ceramic.CollectionImpl.T"/></t></f></iterator>
		<checkCombined get="inline" set="null" line="225"><f a=""><x path="Void"/></f></checkCombined>
		<computeIndex set="method" line="244"><f a=""><x path="Void"/></f></computeIndex>
		<computeEntries set="method" line="260"><f a=""><x path="Void"/></f></computeEntries>
		<new public="1" set="method" line="101"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.Collection</e></m>
			<m n=":allow"><e>ceramic.CollectionUtils</e></m>
		</meta>
	</class>
	<class path="ceramic.CollectionEntry" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/CollectionEntry.hx">
		<_nextId expr="1" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</_nextId>
		<_nextIndex expr="1" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</_nextIndex>
		<id public="1">
			<c path="String"/>
			<meta><m n="editable"/></meta>
		</id>
		<name public="1">
			<c path="String"/>
			<meta><m n="editable"/></meta>
		</name>
		<index public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* A unique index for this collection entry instance.
     * Warning:
     *     this index is in no way predictable and may vary
     *     for each entry between each run of the app!
     *     This is intended to be used as a fast integer-typed runtime identifier,
     *     but do not use this to identify entries when persisting data to disk etc...</haxe_doc>
		</index>
		<setRawData public="1" set="method" line="55">
			<f a="data">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set entry fields from given raw data.
     * Takes care of converting types when needed, and possible.
     * It's ok if raw field are strings, like when stored in CSV files.
     * Raw types can be converted to: `Bool`, `Int`, `Float`, `Color` (`Int`), `String` and `enum` types</haxe_doc>
		</setRawData>
		<setRawField public="1" set="method" line="141">
			<f a="name:rawValue">
				<c path="String"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Override this method to perform custom deserialisation on a specific field. If the overrided method
     * returns `true`, default behavior will be skipped for the related field.</haxe_doc>
		</setRawField>
		<new public="1" set="method" line="41">
			<f a="?id:?name">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor</haxe_doc>
		</new>
		<meta>
			<m n=":structInit"/>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<class path="ceramic.CollectionUtils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/CollectionUtils.hx">
		<combinedCollections expr="new Map()" line="13" static="1">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</combinedCollections>
		<filteredCollections expr="new Map()" line="15" static="1">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</filteredCollections>
		<toCollection public="1" params="T" set="method" line="22" static="1">
			<f a="array">
				<c path="Array"><c path="toCollection.T"/></c>
				<x path="ceramic.Collection"><c path="ceramic.ValueEntry"><c path="toCollection.T"/></c></x>
			</f>
			<haxe_doc>* Converts an array to an equivalent collection</haxe_doc>
		</toCollection>
		<filtered public="1" params="T" set="method" line="36" static="1">
			<f a="collection:filter:?cacheKey">
				<x path="ceramic.Collection"><c path="filtered.T"/></x>
				<f a="">
					<c path="Array"><c path="filtered.T"/></c>
					<c path="Array"><c path="filtered.T"/></c>
				</f>
				<c path="String"/>
				<x path="ceramic.Collection"><c path="filtered.T"/></x>
			</f>
			<haxe_doc>* Returns a filtered collection from the provided collection and filter.</haxe_doc>
		</filtered>
		<combined public="1" params="T" set="method" line="68" static="1">
			<f a="collections:?cache" v=":true">
				<c path="Array"><x path="ceramic.Collection"><c path="combined.T"/></x></c>
				<x path="Bool"/>
				<x path="ceramic.Collection"><c path="combined.T"/></x>
			</f>
			<meta><m n=":value"><e>{ cache : true }</e></m></meta>
			<haxe_doc>* Returns a combined collection from the provided ones.</haxe_doc>
		</combined>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<abstract path="ceramic.Color" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Color.hx">
		<from>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
			<icast field="toAlphaColor"><x path="ceramic.AlphaColor"/></icast>
		</to>
		<haxe_doc>* Class representing a color, based on Int. Provides a variety of methods for creating and converting colors.
 *
 * Colors can be written as Ints. This means you can pass a hex value such as
 * 0x123456 to a function expecting a Color, and it will automatically become a Color "object".
 * Similarly, Colors may be treated as Ints.
 *
 * Note that when using properties of a Color other than RGB, the values are ultimately stored as
 * RGB values, so repeatedly manipulating HSB/HSL/CMYK values may result in a gradual loss of precision.
 *
 * @author Joe Williamson (JoeCreates)
 * @author Edited by Jeremy Faivre for Ceramic engine (jeremyfa)</haxe_doc>
		<impl><class path="ceramic._Color.Color_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Color.hx" private="1" module="ceramic.Color" final="1">
	<NONE public="1" get="inline" set="null" expr="-1" line="22" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>-1</e></m></meta>
	</NONE>
	<WHITE public="1" get="inline" set="null" expr="0xFFFFFF" line="24" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFFFFF</e></m></meta>
	</WHITE>
	<GRAY public="1" get="inline" set="null" expr="0x808080" line="25" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x808080</e></m></meta>
	</GRAY>
	<BLACK public="1" get="inline" set="null" expr="0x000000" line="26" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x000000</e></m></meta>
	</BLACK>
	<GREEN public="1" get="inline" set="null" expr="0x008000" line="28" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x008000</e></m></meta>
	</GREEN>
	<LIME public="1" get="inline" set="null" expr="0x00FF00" line="29" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x00FF00</e></m></meta>
	</LIME>
	<YELLOW public="1" get="inline" set="null" expr="0xFFFF00" line="30" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFFF00</e></m></meta>
	</YELLOW>
	<ORANGE public="1" get="inline" set="null" expr="0xFFA500" line="31" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFA500</e></m></meta>
	</ORANGE>
	<RED public="1" get="inline" set="null" expr="0xFF0000" line="32" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF0000</e></m></meta>
	</RED>
	<PURPLE public="1" get="inline" set="null" expr="0x800080" line="33" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x800080</e></m></meta>
	</PURPLE>
	<BLUE public="1" get="inline" set="null" expr="0x0000FF" line="34" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x0000FF</e></m></meta>
	</BLUE>
	<BROWN public="1" get="inline" set="null" expr="0x8B4513" line="35" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x8B4513</e></m></meta>
	</BROWN>
	<PINK public="1" get="inline" set="null" expr="0xFFC0CB" line="36" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFC0CB</e></m></meta>
	</PINK>
	<MAGENTA public="1" get="inline" set="null" expr="0xFF00FF" line="37" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF00FF</e></m></meta>
	</MAGENTA>
	<CYAN public="1" get="inline" set="null" expr="0x00FFFF" line="38" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x00FFFF</e></m></meta>
	</CYAN>
	<CORNFLOWERBLUE public="1" get="inline" set="null" expr="0x6495ED" line="40" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x6495ED</e></m></meta>
	</CORNFLOWERBLUE>
	<MEDIUMVIOLETRED public="1" get="inline" set="null" expr="0xC71585" line="41" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xC71585</e></m></meta>
	</MEDIUMVIOLETRED>
	<DEEPPINK public="1" get="inline" set="null" expr="0xFF1493" line="42" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF1493</e></m></meta>
	</DEEPPINK>
	<PALEVIOLETRED public="1" get="inline" set="null" expr="0xDB7093" line="43" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xDB7093</e></m></meta>
	</PALEVIOLETRED>
	<HOTPINK public="1" get="inline" set="null" expr="0xFF69B4" line="44" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF69B4</e></m></meta>
	</HOTPINK>
	<LIGHTPINK public="1" get="inline" set="null" expr="0xFFB6C1" line="45" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFB6C1</e></m></meta>
	</LIGHTPINK>
	<DARKRED public="1" get="inline" set="null" expr="0x8B0000" line="46" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x8B0000</e></m></meta>
	</DARKRED>
	<FIREBRICK public="1" get="inline" set="null" expr="0xB22222" line="47" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xB22222</e></m></meta>
	</FIREBRICK>
	<CRIMSON public="1" get="inline" set="null" expr="0xDC143C" line="48" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xDC143C</e></m></meta>
	</CRIMSON>
	<INDIANRED public="1" get="inline" set="null" expr="0xCD5C5C" line="49" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xCD5C5C</e></m></meta>
	</INDIANRED>
	<LIGHTCORAL public="1" get="inline" set="null" expr="0xF08080" line="50" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xF08080</e></m></meta>
	</LIGHTCORAL>
	<SALMON public="1" get="inline" set="null" expr="0xFA8072" line="51" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFA8072</e></m></meta>
	</SALMON>
	<DARKSALMON public="1" get="inline" set="null" expr="0xE9967A" line="52" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xE9967A</e></m></meta>
	</DARKSALMON>
	<LIGHTSALMON public="1" get="inline" set="null" expr="0xFFA07A" line="53" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFA07A</e></m></meta>
	</LIGHTSALMON>
	<ORANGERED public="1" get="inline" set="null" expr="0xFF4500" line="54" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF4500</e></m></meta>
	</ORANGERED>
	<TOMATO public="1" get="inline" set="null" expr="0xFF6347" line="55" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF6347</e></m></meta>
	</TOMATO>
	<DARKORANGE public="1" get="inline" set="null" expr="0xFF8C00" line="56" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF8C00</e></m></meta>
	</DARKORANGE>
	<CORAL public="1" get="inline" set="null" expr="0xFF7F50" line="57" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF7F50</e></m></meta>
	</CORAL>
	<DARKKHAKI public="1" get="inline" set="null" expr="0xBDB76B" line="58" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xBDB76B</e></m></meta>
	</DARKKHAKI>
	<GOLD public="1" get="inline" set="null" expr="0xFFD700" line="59" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFD700</e></m></meta>
	</GOLD>
	<KHAKI public="1" get="inline" set="null" expr="0xF0E68C" line="60" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xF0E68C</e></m></meta>
	</KHAKI>
	<PEACHPUFF public="1" get="inline" set="null" expr="0xFFDAB9" line="61" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFDAB9</e></m></meta>
	</PEACHPUFF>
	<PALEGOLDENROD public="1" get="inline" set="null" expr="0xEEE8AA" line="62" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xEEE8AA</e></m></meta>
	</PALEGOLDENROD>
	<MOCCASIN public="1" get="inline" set="null" expr="0xFFE4B5" line="63" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFE4B5</e></m></meta>
	</MOCCASIN>
	<PAPAYAWHIP public="1" get="inline" set="null" expr="0xFFEFD5" line="64" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFEFD5</e></m></meta>
	</PAPAYAWHIP>
	<LEMONCHIFFON public="1" get="inline" set="null" expr="0xFFFACD" line="65" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFFACD</e></m></meta>
	</LEMONCHIFFON>
	<LIGHTYELLOW public="1" get="inline" set="null" expr="0xFFFFE0" line="66" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFFFE0</e></m></meta>
	</LIGHTYELLOW>
	<SIENNA public="1" get="inline" set="null" expr="0xA0522D" line="67" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xA0522D</e></m></meta>
	</SIENNA>
	<CHOCOLATE public="1" get="inline" set="null" expr="0xD2691E" line="68" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xD2691E</e></m></meta>
	</CHOCOLATE>
	<PERU public="1" get="inline" set="null" expr="0xCD853F" line="69" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xCD853F</e></m></meta>
	</PERU>
	<TAN public="1" get="inline" set="null" expr="0xD2B48C" line="70" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xD2B48C</e></m></meta>
	</TAN>
	<DARKOLIVEGREEN public="1" get="inline" set="null" expr="0x556B2F" line="71" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x556B2F</e></m></meta>
	</DARKOLIVEGREEN>
	<OLIVE public="1" get="inline" set="null" expr="0x808000" line="72" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x808000</e></m></meta>
	</OLIVE>
	<TEAL public="1" get="inline" set="null" expr="0x008080" line="73" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x008080</e></m></meta>
	</TEAL>
	<TURQUOISE public="1" get="inline" set="null" expr="0x40E0D0" line="74" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x40E0D0</e></m></meta>
	</TURQUOISE>
	<NAVY public="1" get="inline" set="null" expr="0x000080" line="75" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x000080</e></m></meta>
	</NAVY>
	<INDIGO public="1" get="inline" set="null" expr="0x4B0082" line="76" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x4B0082</e></m></meta>
	</INDIGO>
	<ORCHID public="1" get="inline" set="null" expr="0xDA70D6" line="77" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xDA70D6</e></m></meta>
	</ORCHID>
	<LAVENDER public="1" get="inline" set="null" expr="0xE6E6FA" line="78" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xE6E6FA</e></m></meta>
	</LAVENDER>
	<AZURE public="1" get="inline" set="null" expr="0xF0FFFF" line="79" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xF0FFFF</e></m></meta>
	</AZURE>
	<IVORY public="1" get="inline" set="null" expr="0xFFFFF0" line="80" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFFFF0</e></m></meta>
	</IVORY>
	<DIMGREY public="1" get="inline" set="null" expr="0x696969" line="81" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x696969</e></m></meta>
	</DIMGREY>
	<SLATEGREY public="1" get="inline" set="null" expr="0x708090" line="82" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x708090</e></m></meta>
	</SLATEGREY>
	<SNOW public="1" get="inline" set="null" expr="0xFFFAFA" line="83" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFFAFA</e></m></meta>
	</SNOW>
	<colorLookup public="1" set="null" expr="[&quot;NONE&quot; =&gt; -1, &quot;WHITE&quot; =&gt; 0xFFFFFF, &quot;GRAY&quot; =&gt; 0x808080, &quot;BLACK&quot; =&gt; 0x000000, &quot;GREEN&quot; =&gt; 0x008000, &quot;LIME&quot; =&gt; 0x00FF00, &quot;YELLOW&quot; =&gt; 0xFFFF00, &quot;ORANGE&quot; =&gt; 0xFFA500, &quot;RED&quot; =&gt; 0xFF0000, &quot;PURPLE&quot; =&gt; 0x800080, &quot;BLUE&quot; =&gt; 0x0000FF, &quot;BROWN&quot; =&gt; 0x8B4513, &quot;PINK&quot; =&gt; 0xFFC0CB, &quot;MAGENTA&quot; =&gt; 0xFF00FF, &quot;CYAN&quot; =&gt; 0x00FFFF, &quot;CORNFLOWERBLUE&quot; =&gt; 0x6495ED, &quot;MEDIUMVIOLETRED&quot; =&gt; 0xC71585, &quot;DEEPPINK&quot; =&gt; 0xFF1493, &quot;PALEVIOLETRED&quot; =&gt; 0xDB7093, &quot;HOTPINK&quot; =&gt; 0xFF69B4, &quot;LIGHTPINK&quot; =&gt; 0xFFB6C1, &quot;DARKRED&quot; =&gt; 0x8B0000, &quot;FIREBRICK&quot; =&gt; 0xB22222, &quot;CRIMSON&quot; =&gt; 0xDC143C, &quot;INDIANRED&quot; =&gt; 0xCD5C5C, &quot;LIGHTCORAL&quot; =&gt; 0xF08080, &quot;SALMON&quot; =&gt; 0xFA8072, &quot;DARKSALMON&quot; =&gt; 0xE9967A, &quot;LIGHTSALMON&quot; =&gt; 0xFFA07A, &quot;ORANGERED&quot; =&gt; 0xFF4500, &quot;TOMATO&quot; =&gt; 0xFF6347, &quot;DARKORANGE&quot; =&gt; 0xFF8C00, &quot;CORAL&quot; =&gt; 0xFF7F50, &quot;DARKKHAKI&quot; =&gt; 0xBDB76B, &quot;GOLD&quot; =&gt; 0xFFD700, &quot;KHAKI&quot; =&gt; 0xF0E68C, &quot;PEACHPUFF&quot; =&gt; 0xFFDAB9, &quot;PALEGOLDENROD&quot; =&gt; 0xEEE8AA, &quot;MOCCASIN&quot; =&gt; 0xFFE4B5, &quot;PAPAYAWHIP&quot; =&gt; 0xFFEFD5, &quot;LEMONCHIFFON&quot; =&gt; 0xFFFACD, &quot;LIGHTYELLOW&quot; =&gt; 0xFFFFE0, &quot;SIENNA&quot; =&gt; 0xA0522D, &quot;CHOCOLATE&quot; =&gt; 0xD2691E, &quot;PERU&quot; =&gt; 0xCD853F, &quot;TAN&quot; =&gt; 0xD2B48C, &quot;DARKOLIVEGREEN&quot; =&gt; 0x556B2F, &quot;OLIVE&quot; =&gt; 0x808000, &quot;TEAL&quot; =&gt; 0x008080, &quot;TURQUOISE&quot; =&gt; 0x40E0D0, &quot;NAVY&quot; =&gt; 0x000080, &quot;INDIGO&quot; =&gt; 0x4B0082, &quot;ORCHID&quot; =&gt; 0xDA70D6, &quot;LAVENDER&quot; =&gt; 0xE6E6FA, &quot;AZURE&quot; =&gt; 0xF0FFFF, &quot;IVORY&quot; =&gt; 0xFFFFF0, &quot;DIMGREY&quot; =&gt; 0x696969, &quot;SLATEGREY&quot; =&gt; 0x708090, &quot;SNOW&quot; =&gt; 0xFFFAFA]" line="85" static="1">
		<t path="Map">
			<c path="String"/>
			<x path="Int"/>
		</t>
		<meta><m n=":value"><e><![CDATA[["NONE" => -1, "WHITE" => 0xFFFFFF, "GRAY" => 0x808080, "BLACK" => 0x000000, "GREEN" => 0x008000, "LIME" => 0x00FF00, "YELLOW" => 0xFFFF00, "ORANGE" => 0xFFA500, "RED" => 0xFF0000, "PURPLE" => 0x800080, "BLUE" => 0x0000FF, "BROWN" => 0x8B4513, "PINK" => 0xFFC0CB, "MAGENTA" => 0xFF00FF, "CYAN" => 0x00FFFF, "CORNFLOWERBLUE" => 0x6495ED, "MEDIUMVIOLETRED" => 0xC71585, "DEEPPINK" => 0xFF1493, "PALEVIOLETRED" => 0xDB7093, "HOTPINK" => 0xFF69B4, "LIGHTPINK" => 0xFFB6C1, "DARKRED" => 0x8B0000, "FIREBRICK" => 0xB22222, "CRIMSON" => 0xDC143C, "INDIANRED" => 0xCD5C5C, "LIGHTCORAL" => 0xF08080, "SALMON" => 0xFA8072, "DARKSALMON" => 0xE9967A, "LIGHTSALMON" => 0xFFA07A, "ORANGERED" => 0xFF4500, "TOMATO" => 0xFF6347, "DARKORANGE" => 0xFF8C00, "CORAL" => 0xFF7F50, "DARKKHAKI" => 0xBDB76B, "GOLD" => 0xFFD700, "KHAKI" => 0xF0E68C, "PEACHPUFF" => 0xFFDAB9, "PALEGOLDENROD" => 0xEEE8AA, "MOCCASIN" => 0xFFE4B5, "PAPAYAWHIP" => 0xFFEFD5, "LEMONCHIFFON" => 0xFFFACD, "LIGHTYELLOW" => 0xFFFFE0, "SIENNA" => 0xA0522D, "CHOCOLATE" => 0xD2691E, "PERU" => 0xCD853F, "TAN" => 0xD2B48C, "DARKOLIVEGREEN" => 0x556B2F, "OLIVE" => 0x808000, "TEAL" => 0x008080, "TURQUOISE" => 0x40E0D0, "NAVY" => 0x000080, "INDIGO" => 0x4B0082, "ORCHID" => 0xDA70D6, "LAVENDER" => 0xE6E6FA, "AZURE" => 0xF0FFFF, "IVORY" => 0xFFFFF0, "DIMGREY" => 0x696969, "SLATEGREY" => 0x708090, "SNOW" => 0xFFFAFA]]]></e></m></meta>
	</colorLookup>
	<red public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Red color component as `Int` between `0` and `255`</haxe_doc>
	</red>
	<green public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Green color component as `Int` between `0` and `255`</haxe_doc>
	</green>
	<blue public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Blue color component as `Int` between `0` and `255`</haxe_doc>
	</blue>
	<redFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Red color component as `Float` between `0.0` and `1.0`</haxe_doc>
	</redFloat>
	<greenFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Green color component as `Float` between `0.0` and `1.0`</haxe_doc>
	</greenFloat>
	<blueFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Blue color component as `Float` between `0.0` and `1.0`</haxe_doc>
	</blueFloat>
	<cyan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></cyan>
	<magenta public="1" get="accessor" set="accessor" static="1"><x path="Float"/></magenta>
	<yellow public="1" get="accessor" set="accessor" static="1"><x path="Float"/></yellow>
	<black public="1" get="accessor" set="accessor" static="1"><x path="Float"/></black>
	<hue public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hue>
	<saturation public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
	</saturation>
	<brightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
	</brightness>
	<lightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
	</lightness>
	<toAlphaColor public="1" get="inline" set="null" line="201" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":to"/></meta>
		<haxe_doc>* Get the color as AlphaColor</haxe_doc>
	</toAlphaColor>
	<random public="1" get="inline" set="null" line="210" static="1">
		<f a="?minSatutation:?minBrightness" v="0.5:0.5">
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":value"><e>{ minBrightness : 0.5, minSatutation : 0.5 }</e></m></meta>
		<haxe_doc>* Generate a random color (away from white or black)
     * @return The color as a Color</haxe_doc>
	</random>
	<fromInt public="1" get="inline" set="null" line="224" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Create a color from the least significant three bytes of an Int
     *
     * @param    value And Int with bytes in the format 0xRRGGBB
     * @return    The color as a Color</haxe_doc>
	</fromInt>
	<fromRGB public="1" get="inline" set="null" line="237" static="1">
		<f a="red:green:blue">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Generate a color from integer RGB values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return The color as a Color</haxe_doc>
	</fromRGB>
	<fromRGBFloat public="1" get="inline" set="null" line="251" static="1">
		<f a="red:green:blue">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Generate a color from float RGB values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return The color as a Color</haxe_doc>
	</fromRGBFloat>
	<fromCMYK public="1" get="inline" set="null" line="266" static="1">
		<f a="cyan:magenta:yellow:black">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Generate a color from CMYK values (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return The color as a Color</haxe_doc>
	</fromCMYK>
	<fromHSB public="1" set="method" line="280" static="1">
		<f a="hue:saturation:brightness">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Generate a color from HSB (aka HSV) components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    The color as a Color</haxe_doc>
	</fromHSB>
	<fromHSL public="1" get="inline" set="null" line="294" static="1">
		<f a="hue:saturation:lightness">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Generate a color from HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a Color</haxe_doc>
	</fromHSL>
	<fromString public="1" set="method" line="313" static="1">
		<f a="str">
			<c path="String"/>
			<x path="Null"><x path="ceramic.Color"/></x>
		</f>
		<haxe_doc><![CDATA[* Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.
     *
     * Examples (input -> output in hex):
     *
     * - `0x00FF00`    -> `0x00FF00`
     * - `#0000FF`     -> `0x0000FF`
     * - `GRAY`        -> `0x808080`
     * - `blue`        -> `0x0000FF`
     *
     * @param    str     The string to be parsed
     * @return    A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
	</fromString>
	<getHSBColorWheel public="1" set="method" line="355" static="1">
		<f a=""><c path="Array"><x path="ceramic.Color"/></c></f>
		<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
     *
     * @return    HSB color wheel as Array of Colors</haxe_doc>
	</getHSBColorWheel>
	<interpolate public="1" get="inline" set="null" line="368" static="1">
		<f a="color1:color2:?factor" v="::0.5">
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":value"><e>{ factor : 0.5 }</e></m></meta>
		<haxe_doc>* Get an interpolated color based on two different colors.
     *
     * @param     color1 The first color
     * @param     color2 The second color
     * @param     factor value from 0 to 1 representing how much to shift color1 toward color2
     * @return    The interpolated color</haxe_doc>
	</interpolate>
	<gradient public="1" set="method" line="386" static="1">
		<f a="color1:color2:steps:?ease">
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
			<x path="Int"/>
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<c path="Array"><x path="ceramic.Color"/></c>
		</f>
		<haxe_doc>* Create a gradient from one color to another
     *
     * @param color1 The color to shift from
     * @param color2 The color to shift to
     * @param steps How many colors the gradient should have
     * @param ease An optional easing function, such as those provided in FlxEase
     * @return An array of colors of length steps, shifting from color1 to color2</haxe_doc>
	</gradient>
	<multiply public="1" get="inline" set="null" line="410" static="1">
		<f a="lhs:rhs">
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":op"><e>A * B</e></m></meta>
		<haxe_doc>* Multiply the RGB channels of two Colors</haxe_doc>
	</multiply>
	<add public="1" get="inline" set="null" line="419" static="1">
		<f a="lhs:rhs">
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
		<haxe_doc>* Add the RGB channels of two Colors</haxe_doc>
	</add>
	<subtract public="1" get="inline" set="null" line="428" static="1">
		<f a="lhs:rhs">
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
		<haxe_doc>* Subtract the RGB channels of one Color from another</haxe_doc>
	</subtract>
	<toHexString public="1" get="inline" set="null" line="439" static="1">
		<f a="this:?prefix" v=":true">
			<x path="Int"/>
			<x path="Bool"/>
			<c path="String"/>
		</f>
		<meta><m n=":value"><e>{ prefix : true }</e></m></meta>
		<haxe_doc>* Return a String representation of the color in the format
     *
     * @param prefix Whether to include "0x" prefix at start of string
     * @return    A string of length 8 in the format 0xRRGGBB</haxe_doc>
	</toHexString>
	<toWebString public="1" get="inline" set="null" line="450" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Return a String representation of the color in the format #RRGGBB
     *
     * @return    A string of length 7 in the format #RRGGBB</haxe_doc>
	</toWebString>
	<getColorInfo public="1" set="method" line="460" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Get a string of color information about this color
     *
     * @return A string containing information about this color</haxe_doc>
	</getColorInfo>
	<getDarkened public="1" set="method" line="479" static="1">
		<f a="this:?factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
		<haxe_doc>* Get a darkened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward black.
     * @return     A darkened version of this color</haxe_doc>
	</getDarkened>
	<getLightened public="1" get="inline" set="null" line="493" static="1">
		<f a="this:?factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
		<haxe_doc>* Get a lightened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward white.
     * @return     A lightened version of this color</haxe_doc>
	</getLightened>
	<getInverted public="1" get="inline" set="null" line="506" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Get the inversion of this color
     *
     * @return The inversion of this color</haxe_doc>
	</getInverted>
	<setRGB public="1" get="inline" set="null" line="520" static="1">
		<f a="this:red:green:blue">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Set RGB values as integers (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return This color</haxe_doc>
	</setRGB>
	<setRGBFloat public="1" get="inline" set="null" line="536" static="1">
		<f a="this:red:green:blue">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Set RGB values as floats (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return This color</haxe_doc>
	</setRGBFloat>
	<setCMYK public="1" get="inline" set="null" line="553" static="1">
		<f a="this:cyan:magenta:yellow:black">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Set CMYK values as floats (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return This color</haxe_doc>
	</setCMYK>
	<setHSB public="1" get="inline" set="null" line="569" static="1">
		<f a="this:hue:saturation:brightness">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Set HSB (aka HSV) components
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    This color</haxe_doc>
	</setHSB>
	<setHSL public="1" get="inline" set="null" line="584" static="1">
		<f a="this:hue:saturation:lightness">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Set HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
	</setHSL>
	<setHSChromaMatch get="inline" set="null" line="594" static="1">
		<f a="this:hue:saturation:chroma:match">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
	</setHSChromaMatch>
	<_new public="1" get="inline" set="null" line="613" static="1">
		<f a="?value" v="0">
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<meta>
			<m n=":value"><e>{ value : 0 }</e></m>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get_red get="inline" set="null" line="619" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_red>
	<get_green get="inline" set="null" line="624" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_green>
	<get_blue get="inline" set="null" line="629" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_blue>
	<get_redFloat get="inline" set="null" line="634" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_redFloat>
	<get_greenFloat get="inline" set="null" line="639" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_greenFloat>
	<get_blueFloat get="inline" set="null" line="644" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_blueFloat>
	<set_red get="inline" set="null" line="649" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_red>
	<set_green get="inline" set="null" line="656" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_green>
	<set_blue get="inline" set="null" line="663" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_blue>
	<set_redFloat get="inline" set="null" line="670" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_redFloat>
	<set_greenFloat get="inline" set="null" line="676" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_greenFloat>
	<set_blueFloat get="inline" set="null" line="682" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_blueFloat>
	<get_cyan get="inline" set="null" line="688" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_cyan>
	<get_magenta get="inline" set="null" line="693" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_magenta>
	<get_yellow get="inline" set="null" line="698" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_yellow>
	<get_black get="inline" set="null" line="703" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_black>
	<set_cyan get="inline" set="null" line="708" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_cyan>
	<set_magenta get="inline" set="null" line="714" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_magenta>
	<set_yellow get="inline" set="null" line="720" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_yellow>
	<set_black get="inline" set="null" line="726" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_black>
	<get_hue set="method" line="732" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hue>
	<get_brightness get="inline" set="null" line="744" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_brightness>
	<get_saturation get="inline" set="null" line="749" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturation>
	<get_lightness get="inline" set="null" line="754" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightness>
	<set_hue get="inline" set="null" line="759" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hue>
	<set_saturation get="inline" set="null" line="765" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturation>
	<set_brightness get="inline" set="null" line="771" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_brightness>
	<set_lightness get="inline" set="null" line="777" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightness>
	<maxColor get="inline" set="null" line="783" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></maxColor>
	<minColor get="inline" set="null" line="788" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></minColor>
	<boundChannel get="inline" set="null" line="793" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></boundChannel>
	<roundDecimal set="method" line="800" static="1"><f a="value:precision">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></roundDecimal>
	<bound get="inline" set="null" line="810" static="1"><f a="value:?min:?max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></bound>
	<toString public="1" get="inline" set="null" line="817" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<_hsluvTuple expr="[0, 0, 0]" line="827" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
	</_hsluvTuple>
	<_hsluvResult expr="[0, 0, 0]" line="829" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
	</_hsluvResult>
	<_hsluvCacheMap expr="new IntIntMap()" line="831" static="1">
		<c path="ceramic.IntIntMap"/>
		<meta><m n=":value"><e>new IntIntMap()</e></m></meta>
	</_hsluvCacheMap>
	<_hsluvCacheValues expr="[]" line="833" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[]</e></m></meta>
	</_hsluvCacheValues>
	<hueHSLuv public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The HSLuv hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hueHSLuv>
	<saturationHSLuv public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The HSLuv saturation of the color (from 0 to 1)</haxe_doc>
	</saturationHSLuv>
	<lightnessHSLuv public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The HSLuv lightness of the color (from 0 to 1)</haxe_doc>
	</lightnessHSLuv>
	<get_hueHSLuv set="method" line="849" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hueHSLuv>
	<set_hueHSLuv get="inline" set="null" line="854" static="1"><f a="this:hueHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hueHSLuv>
	<get_saturationHSLuv set="method" line="860" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturationHSLuv>
	<set_saturationHSLuv get="inline" set="null" line="865" static="1"><f a="this:saturationHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturationHSLuv>
	<get_lightnessHSLuv set="method" line="871" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightnessHSLuv>
	<set_lightnessHSLuv get="inline" set="null" line="876" static="1"><f a="this:lightnessHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightnessHSLuv>
	<_getOrCreateCachedHSLuvComponent get="inline" set="null" line="882" static="1"><f a="this:index">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></_getOrCreateCachedHSLuvComponent>
	<fromHSLuv public="1" get="inline" set="null" line="905" static="1">
		<f a="hue:saturation:lightness">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Generate a color from HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a Color</haxe_doc>
	</fromHSLuv>
	<setHSLuv public="1" get="inline" set="null" line="919" static="1">
		<f a="this:hue:saturation:lightness">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Set HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
	</setHSLuv>
	<getHSLuv public="1" get="inline" set="null" line="951" static="1">
		<f a="this:?result">
			<x path="Int"/>
			<c path="Array"><x path="Float"/></c>
			<c path="Array"><x path="Float"/></c>
		</f>
		<haxe_doc>* Get HSLuv components from the color instance.
     *
     * @param result A pre-allocated array to store the result into.
     * @return    The HSLuv components as a float array</haxe_doc>
	</getHSLuv>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic.IntIntMap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntIntMap.hx">
		<intMap>
			<t path="Map">
				<x path="Int"/>
				<x path="Int"/>
			</t>
			<haxe_doc>* Backing map</haxe_doc>
		</intMap>
		<iterableKeys public="1" set="null" expr="null">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* When this map is marked as iterable, this array will contain every key.</haxe_doc>
		</iterableKeys>
		<iterableKeysUsed expr="null">
			<x path="ceramic.IntBoolMap"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</iterableKeysUsed>
		<size public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</size>
		<clear public="1" set="method" line="483"><f a=""><x path="Void"/></f></clear>
		<exists public="1" get="inline" set="null" line="492"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></exists>
		<set public="1" set="method" line="496"><f a="key:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set>
		<get public="1" get="inline" set="null" line="509"><f a="key">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<remove public="1" set="method" line="513"><f a="key">
	<x path="Int"/>
	<x path="Int"/>
</f></remove>
		<getInline public="1" get="inline" set="null" line="528"><f a="key">
	<x path="Int"/>
	<x path="Int"/>
</f></getInline>
		<existsInline public="1" get="inline" set="null" line="533"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></existsInline>
		<copy public="1" get="inline" set="null" line="537"><f a=""><c path="ceramic.IntIntMap"/></f></copy>
		<iterator public="1" get="inline" set="null" line="550"><f a=""><c path="ceramic.IntIntMapIterator"/></f></iterator>
		<keys public="1" get="inline" set="null" line="554"><f a=""><c path="ceramic.IntIntMapKeyIterator"/></f></keys>
		<keyValueIterator public="1" get="inline" set="null" line="558"><f a=""><c path="ceramic.IntIntMapKeyValueIterator"/></f></keyValueIterator>
		<new public="1" set="method" line="474">
			<f a="?size:?fillFactor:?iterable" v="16:0.5:false">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ iterable : false, fillFactor : 0.5, size : 16 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic._IntBoolMap.IntBoolMap_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntBoolMap.hx" private="1" module="ceramic.IntBoolMap" final="1">
		<size public="1" get="accessor" set="null" static="1"><x path="Int"/></size>
		<get_size public="1" get="inline" set="null" line="11" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
</f></get_size>
		<iterableKeys public="1" get="accessor" set="null" static="1"><c path="Array"><x path="Int"/></c></iterableKeys>
		<get_iterableKeys get="inline" set="null" line="14" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="Array"><x path="Int"/></c>
</f></get_iterableKeys>
		<_asIntBoolMap get="inline" set="null" line="16" static="1">
			<f a="this">
				<c path="ceramic.IntIntMap"/>
				<x path="ceramic.IntBoolMap"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_asIntBoolMap>
		<_new public="1" get="inline" set="null" line="20" static="1">
			<f a="?size:?fillFactor:?iterable" v="16:0.5:false">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="ceramic.IntBoolMap"/>
			</f>
			<meta>
				<m n=":value"><e>{ iterable : false, fillFactor : 0.5, size : 16 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<exists public="1" get="inline" set="null" line="24" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></exists>
		<existsInline public="1" get="inline" set="null" line="28" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></existsInline>
		<get public="1" get="inline" set="null" line="32" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></get>
		<getInline public="1" get="inline" set="null" line="36" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getInline>
		<set public="1" get="inline" set="null" line="40" static="1"><f a="this:key:value">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></set>
		<remove public="1" get="inline" set="null" line="44" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></remove>
		<clear public="1" get="inline" set="null" line="48" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<x path="Void"/>
</f></clear>
		<copy public="1" set="method" line="52" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<x path="ceramic.IntBoolMap"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="56" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="ceramic.IntBoolMapIterator"/>
</f></iterator>
		<keys public="1" get="inline" set="null" line="60" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="ceramic.IntBoolMapKeyIterator"/>
</f></keys>
		<keyValueIterator public="1" get="inline" set="null" line="64" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="ceramic.IntBoolMapKeyValueIterator"/>
</f></keyValueIterator>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic._Color.Color_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Color.hx" private="1" module="ceramic.Color" final="1">
		<NONE public="1" get="inline" set="null" expr="-1" line="22" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</NONE>
		<WHITE public="1" get="inline" set="null" expr="0xFFFFFF" line="24" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFFFF</e></m></meta>
		</WHITE>
		<GRAY public="1" get="inline" set="null" expr="0x808080" line="25" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x808080</e></m></meta>
		</GRAY>
		<BLACK public="1" get="inline" set="null" expr="0x000000" line="26" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x000000</e></m></meta>
		</BLACK>
		<GREEN public="1" get="inline" set="null" expr="0x008000" line="28" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x008000</e></m></meta>
		</GREEN>
		<LIME public="1" get="inline" set="null" expr="0x00FF00" line="29" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x00FF00</e></m></meta>
		</LIME>
		<YELLOW public="1" get="inline" set="null" expr="0xFFFF00" line="30" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFF00</e></m></meta>
		</YELLOW>
		<ORANGE public="1" get="inline" set="null" expr="0xFFA500" line="31" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFA500</e></m></meta>
		</ORANGE>
		<RED public="1" get="inline" set="null" expr="0xFF0000" line="32" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF0000</e></m></meta>
		</RED>
		<PURPLE public="1" get="inline" set="null" expr="0x800080" line="33" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x800080</e></m></meta>
		</PURPLE>
		<BLUE public="1" get="inline" set="null" expr="0x0000FF" line="34" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x0000FF</e></m></meta>
		</BLUE>
		<BROWN public="1" get="inline" set="null" expr="0x8B4513" line="35" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x8B4513</e></m></meta>
		</BROWN>
		<PINK public="1" get="inline" set="null" expr="0xFFC0CB" line="36" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFC0CB</e></m></meta>
		</PINK>
		<MAGENTA public="1" get="inline" set="null" expr="0xFF00FF" line="37" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF00FF</e></m></meta>
		</MAGENTA>
		<CYAN public="1" get="inline" set="null" expr="0x00FFFF" line="38" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x00FFFF</e></m></meta>
		</CYAN>
		<CORNFLOWERBLUE public="1" get="inline" set="null" expr="0x6495ED" line="40" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x6495ED</e></m></meta>
		</CORNFLOWERBLUE>
		<MEDIUMVIOLETRED public="1" get="inline" set="null" expr="0xC71585" line="41" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xC71585</e></m></meta>
		</MEDIUMVIOLETRED>
		<DEEPPINK public="1" get="inline" set="null" expr="0xFF1493" line="42" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF1493</e></m></meta>
		</DEEPPINK>
		<PALEVIOLETRED public="1" get="inline" set="null" expr="0xDB7093" line="43" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xDB7093</e></m></meta>
		</PALEVIOLETRED>
		<HOTPINK public="1" get="inline" set="null" expr="0xFF69B4" line="44" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF69B4</e></m></meta>
		</HOTPINK>
		<LIGHTPINK public="1" get="inline" set="null" expr="0xFFB6C1" line="45" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFB6C1</e></m></meta>
		</LIGHTPINK>
		<DARKRED public="1" get="inline" set="null" expr="0x8B0000" line="46" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x8B0000</e></m></meta>
		</DARKRED>
		<FIREBRICK public="1" get="inline" set="null" expr="0xB22222" line="47" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xB22222</e></m></meta>
		</FIREBRICK>
		<CRIMSON public="1" get="inline" set="null" expr="0xDC143C" line="48" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xDC143C</e></m></meta>
		</CRIMSON>
		<INDIANRED public="1" get="inline" set="null" expr="0xCD5C5C" line="49" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xCD5C5C</e></m></meta>
		</INDIANRED>
		<LIGHTCORAL public="1" get="inline" set="null" expr="0xF08080" line="50" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xF08080</e></m></meta>
		</LIGHTCORAL>
		<SALMON public="1" get="inline" set="null" expr="0xFA8072" line="51" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFA8072</e></m></meta>
		</SALMON>
		<DARKSALMON public="1" get="inline" set="null" expr="0xE9967A" line="52" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xE9967A</e></m></meta>
		</DARKSALMON>
		<LIGHTSALMON public="1" get="inline" set="null" expr="0xFFA07A" line="53" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFA07A</e></m></meta>
		</LIGHTSALMON>
		<ORANGERED public="1" get="inline" set="null" expr="0xFF4500" line="54" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF4500</e></m></meta>
		</ORANGERED>
		<TOMATO public="1" get="inline" set="null" expr="0xFF6347" line="55" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF6347</e></m></meta>
		</TOMATO>
		<DARKORANGE public="1" get="inline" set="null" expr="0xFF8C00" line="56" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF8C00</e></m></meta>
		</DARKORANGE>
		<CORAL public="1" get="inline" set="null" expr="0xFF7F50" line="57" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF7F50</e></m></meta>
		</CORAL>
		<DARKKHAKI public="1" get="inline" set="null" expr="0xBDB76B" line="58" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xBDB76B</e></m></meta>
		</DARKKHAKI>
		<GOLD public="1" get="inline" set="null" expr="0xFFD700" line="59" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFD700</e></m></meta>
		</GOLD>
		<KHAKI public="1" get="inline" set="null" expr="0xF0E68C" line="60" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xF0E68C</e></m></meta>
		</KHAKI>
		<PEACHPUFF public="1" get="inline" set="null" expr="0xFFDAB9" line="61" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFDAB9</e></m></meta>
		</PEACHPUFF>
		<PALEGOLDENROD public="1" get="inline" set="null" expr="0xEEE8AA" line="62" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xEEE8AA</e></m></meta>
		</PALEGOLDENROD>
		<MOCCASIN public="1" get="inline" set="null" expr="0xFFE4B5" line="63" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFE4B5</e></m></meta>
		</MOCCASIN>
		<PAPAYAWHIP public="1" get="inline" set="null" expr="0xFFEFD5" line="64" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFEFD5</e></m></meta>
		</PAPAYAWHIP>
		<LEMONCHIFFON public="1" get="inline" set="null" expr="0xFFFACD" line="65" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFACD</e></m></meta>
		</LEMONCHIFFON>
		<LIGHTYELLOW public="1" get="inline" set="null" expr="0xFFFFE0" line="66" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFFE0</e></m></meta>
		</LIGHTYELLOW>
		<SIENNA public="1" get="inline" set="null" expr="0xA0522D" line="67" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xA0522D</e></m></meta>
		</SIENNA>
		<CHOCOLATE public="1" get="inline" set="null" expr="0xD2691E" line="68" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xD2691E</e></m></meta>
		</CHOCOLATE>
		<PERU public="1" get="inline" set="null" expr="0xCD853F" line="69" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xCD853F</e></m></meta>
		</PERU>
		<TAN public="1" get="inline" set="null" expr="0xD2B48C" line="70" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xD2B48C</e></m></meta>
		</TAN>
		<DARKOLIVEGREEN public="1" get="inline" set="null" expr="0x556B2F" line="71" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x556B2F</e></m></meta>
		</DARKOLIVEGREEN>
		<OLIVE public="1" get="inline" set="null" expr="0x808000" line="72" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x808000</e></m></meta>
		</OLIVE>
		<TEAL public="1" get="inline" set="null" expr="0x008080" line="73" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x008080</e></m></meta>
		</TEAL>
		<TURQUOISE public="1" get="inline" set="null" expr="0x40E0D0" line="74" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x40E0D0</e></m></meta>
		</TURQUOISE>
		<NAVY public="1" get="inline" set="null" expr="0x000080" line="75" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x000080</e></m></meta>
		</NAVY>
		<INDIGO public="1" get="inline" set="null" expr="0x4B0082" line="76" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x4B0082</e></m></meta>
		</INDIGO>
		<ORCHID public="1" get="inline" set="null" expr="0xDA70D6" line="77" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xDA70D6</e></m></meta>
		</ORCHID>
		<LAVENDER public="1" get="inline" set="null" expr="0xE6E6FA" line="78" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xE6E6FA</e></m></meta>
		</LAVENDER>
		<AZURE public="1" get="inline" set="null" expr="0xF0FFFF" line="79" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xF0FFFF</e></m></meta>
		</AZURE>
		<IVORY public="1" get="inline" set="null" expr="0xFFFFF0" line="80" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFFF0</e></m></meta>
		</IVORY>
		<DIMGREY public="1" get="inline" set="null" expr="0x696969" line="81" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x696969</e></m></meta>
		</DIMGREY>
		<SLATEGREY public="1" get="inline" set="null" expr="0x708090" line="82" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x708090</e></m></meta>
		</SLATEGREY>
		<SNOW public="1" get="inline" set="null" expr="0xFFFAFA" line="83" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFAFA</e></m></meta>
		</SNOW>
		<colorLookup public="1" set="null" expr="[&quot;NONE&quot; =&gt; -1, &quot;WHITE&quot; =&gt; 0xFFFFFF, &quot;GRAY&quot; =&gt; 0x808080, &quot;BLACK&quot; =&gt; 0x000000, &quot;GREEN&quot; =&gt; 0x008000, &quot;LIME&quot; =&gt; 0x00FF00, &quot;YELLOW&quot; =&gt; 0xFFFF00, &quot;ORANGE&quot; =&gt; 0xFFA500, &quot;RED&quot; =&gt; 0xFF0000, &quot;PURPLE&quot; =&gt; 0x800080, &quot;BLUE&quot; =&gt; 0x0000FF, &quot;BROWN&quot; =&gt; 0x8B4513, &quot;PINK&quot; =&gt; 0xFFC0CB, &quot;MAGENTA&quot; =&gt; 0xFF00FF, &quot;CYAN&quot; =&gt; 0x00FFFF, &quot;CORNFLOWERBLUE&quot; =&gt; 0x6495ED, &quot;MEDIUMVIOLETRED&quot; =&gt; 0xC71585, &quot;DEEPPINK&quot; =&gt; 0xFF1493, &quot;PALEVIOLETRED&quot; =&gt; 0xDB7093, &quot;HOTPINK&quot; =&gt; 0xFF69B4, &quot;LIGHTPINK&quot; =&gt; 0xFFB6C1, &quot;DARKRED&quot; =&gt; 0x8B0000, &quot;FIREBRICK&quot; =&gt; 0xB22222, &quot;CRIMSON&quot; =&gt; 0xDC143C, &quot;INDIANRED&quot; =&gt; 0xCD5C5C, &quot;LIGHTCORAL&quot; =&gt; 0xF08080, &quot;SALMON&quot; =&gt; 0xFA8072, &quot;DARKSALMON&quot; =&gt; 0xE9967A, &quot;LIGHTSALMON&quot; =&gt; 0xFFA07A, &quot;ORANGERED&quot; =&gt; 0xFF4500, &quot;TOMATO&quot; =&gt; 0xFF6347, &quot;DARKORANGE&quot; =&gt; 0xFF8C00, &quot;CORAL&quot; =&gt; 0xFF7F50, &quot;DARKKHAKI&quot; =&gt; 0xBDB76B, &quot;GOLD&quot; =&gt; 0xFFD700, &quot;KHAKI&quot; =&gt; 0xF0E68C, &quot;PEACHPUFF&quot; =&gt; 0xFFDAB9, &quot;PALEGOLDENROD&quot; =&gt; 0xEEE8AA, &quot;MOCCASIN&quot; =&gt; 0xFFE4B5, &quot;PAPAYAWHIP&quot; =&gt; 0xFFEFD5, &quot;LEMONCHIFFON&quot; =&gt; 0xFFFACD, &quot;LIGHTYELLOW&quot; =&gt; 0xFFFFE0, &quot;SIENNA&quot; =&gt; 0xA0522D, &quot;CHOCOLATE&quot; =&gt; 0xD2691E, &quot;PERU&quot; =&gt; 0xCD853F, &quot;TAN&quot; =&gt; 0xD2B48C, &quot;DARKOLIVEGREEN&quot; =&gt; 0x556B2F, &quot;OLIVE&quot; =&gt; 0x808000, &quot;TEAL&quot; =&gt; 0x008080, &quot;TURQUOISE&quot; =&gt; 0x40E0D0, &quot;NAVY&quot; =&gt; 0x000080, &quot;INDIGO&quot; =&gt; 0x4B0082, &quot;ORCHID&quot; =&gt; 0xDA70D6, &quot;LAVENDER&quot; =&gt; 0xE6E6FA, &quot;AZURE&quot; =&gt; 0xF0FFFF, &quot;IVORY&quot; =&gt; 0xFFFFF0, &quot;DIMGREY&quot; =&gt; 0x696969, &quot;SLATEGREY&quot; =&gt; 0x708090, &quot;SNOW&quot; =&gt; 0xFFFAFA]" line="85" static="1">
			<t path="Map">
				<c path="String"/>
				<x path="Int"/>
			</t>
			<meta><m n=":value"><e><![CDATA[["NONE" => -1, "WHITE" => 0xFFFFFF, "GRAY" => 0x808080, "BLACK" => 0x000000, "GREEN" => 0x008000, "LIME" => 0x00FF00, "YELLOW" => 0xFFFF00, "ORANGE" => 0xFFA500, "RED" => 0xFF0000, "PURPLE" => 0x800080, "BLUE" => 0x0000FF, "BROWN" => 0x8B4513, "PINK" => 0xFFC0CB, "MAGENTA" => 0xFF00FF, "CYAN" => 0x00FFFF, "CORNFLOWERBLUE" => 0x6495ED, "MEDIUMVIOLETRED" => 0xC71585, "DEEPPINK" => 0xFF1493, "PALEVIOLETRED" => 0xDB7093, "HOTPINK" => 0xFF69B4, "LIGHTPINK" => 0xFFB6C1, "DARKRED" => 0x8B0000, "FIREBRICK" => 0xB22222, "CRIMSON" => 0xDC143C, "INDIANRED" => 0xCD5C5C, "LIGHTCORAL" => 0xF08080, "SALMON" => 0xFA8072, "DARKSALMON" => 0xE9967A, "LIGHTSALMON" => 0xFFA07A, "ORANGERED" => 0xFF4500, "TOMATO" => 0xFF6347, "DARKORANGE" => 0xFF8C00, "CORAL" => 0xFF7F50, "DARKKHAKI" => 0xBDB76B, "GOLD" => 0xFFD700, "KHAKI" => 0xF0E68C, "PEACHPUFF" => 0xFFDAB9, "PALEGOLDENROD" => 0xEEE8AA, "MOCCASIN" => 0xFFE4B5, "PAPAYAWHIP" => 0xFFEFD5, "LEMONCHIFFON" => 0xFFFACD, "LIGHTYELLOW" => 0xFFFFE0, "SIENNA" => 0xA0522D, "CHOCOLATE" => 0xD2691E, "PERU" => 0xCD853F, "TAN" => 0xD2B48C, "DARKOLIVEGREEN" => 0x556B2F, "OLIVE" => 0x808000, "TEAL" => 0x008080, "TURQUOISE" => 0x40E0D0, "NAVY" => 0x000080, "INDIGO" => 0x4B0082, "ORCHID" => 0xDA70D6, "LAVENDER" => 0xE6E6FA, "AZURE" => 0xF0FFFF, "IVORY" => 0xFFFFF0, "DIMGREY" => 0x696969, "SLATEGREY" => 0x708090, "SNOW" => 0xFFFAFA]]]></e></m></meta>
		</colorLookup>
		<red public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Red color component as `Int` between `0` and `255`</haxe_doc>
		</red>
		<green public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Green color component as `Int` between `0` and `255`</haxe_doc>
		</green>
		<blue public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Blue color component as `Int` between `0` and `255`</haxe_doc>
		</blue>
		<redFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Red color component as `Float` between `0.0` and `1.0`</haxe_doc>
		</redFloat>
		<greenFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Green color component as `Float` between `0.0` and `1.0`</haxe_doc>
		</greenFloat>
		<blueFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Blue color component as `Float` between `0.0` and `1.0`</haxe_doc>
		</blueFloat>
		<cyan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></cyan>
		<magenta public="1" get="accessor" set="accessor" static="1"><x path="Float"/></magenta>
		<yellow public="1" get="accessor" set="accessor" static="1"><x path="Float"/></yellow>
		<black public="1" get="accessor" set="accessor" static="1"><x path="Float"/></black>
		<hue public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hue>
		<saturation public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
		</saturation>
		<brightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
		</brightness>
		<lightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
		</lightness>
		<toAlphaColor public="1" get="inline" set="null" line="201" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":to"/></meta>
			<haxe_doc>* Get the color as AlphaColor</haxe_doc>
		</toAlphaColor>
		<random public="1" get="inline" set="null" line="210" static="1">
			<f a="?minSatutation:?minBrightness" v="0.5:0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ minBrightness : 0.5, minSatutation : 0.5 }</e></m></meta>
			<haxe_doc>* Generate a random color (away from white or black)
     * @return The color as a Color</haxe_doc>
		</random>
		<fromInt public="1" get="inline" set="null" line="224" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Create a color from the least significant three bytes of an Int
     *
     * @param    value And Int with bytes in the format 0xRRGGBB
     * @return    The color as a Color</haxe_doc>
		</fromInt>
		<fromRGB public="1" get="inline" set="null" line="237" static="1">
			<f a="red:green:blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from integer RGB values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return The color as a Color</haxe_doc>
		</fromRGB>
		<fromRGBFloat public="1" get="inline" set="null" line="251" static="1">
			<f a="red:green:blue">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from float RGB values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return The color as a Color</haxe_doc>
		</fromRGBFloat>
		<fromCMYK public="1" get="inline" set="null" line="266" static="1">
			<f a="cyan:magenta:yellow:black">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from CMYK values (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return The color as a Color</haxe_doc>
		</fromCMYK>
		<fromHSB public="1" set="method" line="280" static="1">
			<f a="hue:saturation:brightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from HSB (aka HSV) components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    The color as a Color</haxe_doc>
		</fromHSB>
		<fromHSL public="1" get="inline" set="null" line="294" static="1">
			<f a="hue:saturation:lightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a Color</haxe_doc>
		</fromHSL>
		<fromString public="1" set="method" line="313" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Null"><x path="ceramic.Color"/></x>
			</f>
			<haxe_doc><![CDATA[* Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.
     *
     * Examples (input -> output in hex):
     *
     * - `0x00FF00`    -> `0x00FF00`
     * - `#0000FF`     -> `0x0000FF`
     * - `GRAY`        -> `0x808080`
     * - `blue`        -> `0x0000FF`
     *
     * @param    str     The string to be parsed
     * @return    A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
		</fromString>
		<getHSBColorWheel public="1" set="method" line="355" static="1">
			<f a=""><c path="Array"><x path="ceramic.Color"/></c></f>
			<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
     *
     * @return    HSB color wheel as Array of Colors</haxe_doc>
		</getHSBColorWheel>
		<interpolate public="1" get="inline" set="null" line="368" static="1">
			<f a="color1:color2:?factor" v="::0.5">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.5 }</e></m></meta>
			<haxe_doc>* Get an interpolated color based on two different colors.
     *
     * @param     color1 The first color
     * @param     color2 The second color
     * @param     factor value from 0 to 1 representing how much to shift color1 toward color2
     * @return    The interpolated color</haxe_doc>
		</interpolate>
		<gradient public="1" set="method" line="386" static="1">
			<f a="color1:color2:steps:?ease">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Int"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<c path="Array"><x path="ceramic.Color"/></c>
			</f>
			<haxe_doc>* Create a gradient from one color to another
     *
     * @param color1 The color to shift from
     * @param color2 The color to shift to
     * @param steps How many colors the gradient should have
     * @param ease An optional easing function, such as those provided in FlxEase
     * @return An array of colors of length steps, shifting from color1 to color2</haxe_doc>
		</gradient>
		<multiply public="1" get="inline" set="null" line="410" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":op"><e>A * B</e></m></meta>
			<haxe_doc>* Multiply the RGB channels of two Colors</haxe_doc>
		</multiply>
		<add public="1" get="inline" set="null" line="419" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
			<haxe_doc>* Add the RGB channels of two Colors</haxe_doc>
		</add>
		<subtract public="1" get="inline" set="null" line="428" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
			<haxe_doc>* Subtract the RGB channels of one Color from another</haxe_doc>
		</subtract>
		<toHexString public="1" get="inline" set="null" line="439" static="1">
			<f a="this:?prefix" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ prefix : true }</e></m></meta>
			<haxe_doc>* Return a String representation of the color in the format
     *
     * @param prefix Whether to include "0x" prefix at start of string
     * @return    A string of length 8 in the format 0xRRGGBB</haxe_doc>
		</toHexString>
		<toWebString public="1" get="inline" set="null" line="450" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a String representation of the color in the format #RRGGBB
     *
     * @return    A string of length 7 in the format #RRGGBB</haxe_doc>
		</toWebString>
		<getColorInfo public="1" set="method" line="460" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Get a string of color information about this color
     *
     * @return A string containing information about this color</haxe_doc>
		</getColorInfo>
		<getDarkened public="1" set="method" line="479" static="1">
			<f a="this:?factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
			<haxe_doc>* Get a darkened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward black.
     * @return     A darkened version of this color</haxe_doc>
		</getDarkened>
		<getLightened public="1" get="inline" set="null" line="493" static="1">
			<f a="this:?factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
			<haxe_doc>* Get a lightened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward white.
     * @return     A lightened version of this color</haxe_doc>
		</getLightened>
		<getInverted public="1" get="inline" set="null" line="506" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Get the inversion of this color
     *
     * @return The inversion of this color</haxe_doc>
		</getInverted>
		<setRGB public="1" get="inline" set="null" line="520" static="1">
			<f a="this:red:green:blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Set RGB values as integers (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return This color</haxe_doc>
		</setRGB>
		<setRGBFloat public="1" get="inline" set="null" line="536" static="1">
			<f a="this:red:green:blue">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Set RGB values as floats (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return This color</haxe_doc>
		</setRGBFloat>
		<setCMYK public="1" get="inline" set="null" line="553" static="1">
			<f a="this:cyan:magenta:yellow:black">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Set CMYK values as floats (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return This color</haxe_doc>
		</setCMYK>
		<setHSB public="1" get="inline" set="null" line="569" static="1">
			<f a="this:hue:saturation:brightness">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Set HSB (aka HSV) components
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    This color</haxe_doc>
		</setHSB>
		<setHSL public="1" get="inline" set="null" line="584" static="1">
			<f a="this:hue:saturation:lightness">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Set HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
		</setHSL>
		<setHSChromaMatch get="inline" set="null" line="594" static="1">
			<f a="this:hue:saturation:chroma:match">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
		</setHSChromaMatch>
		<_new public="1" get="inline" set="null" line="613" static="1">
			<f a="?value" v="0">
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<meta>
				<m n=":value"><e>{ value : 0 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get_red get="inline" set="null" line="619" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_red>
		<get_green get="inline" set="null" line="624" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_green>
		<get_blue get="inline" set="null" line="629" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_blue>
		<get_redFloat get="inline" set="null" line="634" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_redFloat>
		<get_greenFloat get="inline" set="null" line="639" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_greenFloat>
		<get_blueFloat get="inline" set="null" line="644" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_blueFloat>
		<set_red get="inline" set="null" line="649" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_red>
		<set_green get="inline" set="null" line="656" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_green>
		<set_blue get="inline" set="null" line="663" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_blue>
		<set_redFloat get="inline" set="null" line="670" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_redFloat>
		<set_greenFloat get="inline" set="null" line="676" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_greenFloat>
		<set_blueFloat get="inline" set="null" line="682" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_blueFloat>
		<get_cyan get="inline" set="null" line="688" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_cyan>
		<get_magenta get="inline" set="null" line="693" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_magenta>
		<get_yellow get="inline" set="null" line="698" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_yellow>
		<get_black get="inline" set="null" line="703" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_black>
		<set_cyan get="inline" set="null" line="708" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_cyan>
		<set_magenta get="inline" set="null" line="714" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_magenta>
		<set_yellow get="inline" set="null" line="720" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_yellow>
		<set_black get="inline" set="null" line="726" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_black>
		<get_hue set="method" line="732" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hue>
		<get_brightness get="inline" set="null" line="744" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_brightness>
		<get_saturation get="inline" set="null" line="749" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturation>
		<get_lightness get="inline" set="null" line="754" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightness>
		<set_hue get="inline" set="null" line="759" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hue>
		<set_saturation get="inline" set="null" line="765" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturation>
		<set_brightness get="inline" set="null" line="771" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_brightness>
		<set_lightness get="inline" set="null" line="777" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightness>
		<maxColor get="inline" set="null" line="783" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></maxColor>
		<minColor get="inline" set="null" line="788" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></minColor>
		<boundChannel get="inline" set="null" line="793" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></boundChannel>
		<roundDecimal set="method" line="800" static="1"><f a="value:precision">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></roundDecimal>
		<bound get="inline" set="null" line="810" static="1"><f a="value:?min:?max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></bound>
		<toString public="1" get="inline" set="null" line="817" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<_hsluvTuple expr="[0, 0, 0]" line="827" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
		</_hsluvTuple>
		<_hsluvResult expr="[0, 0, 0]" line="829" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
		</_hsluvResult>
		<_hsluvCacheMap expr="new IntIntMap()" line="831" static="1">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap()</e></m></meta>
		</_hsluvCacheMap>
		<_hsluvCacheValues expr="[]" line="833" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_hsluvCacheValues>
		<hueHSLuv public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The HSLuv hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hueHSLuv>
		<saturationHSLuv public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The HSLuv saturation of the color (from 0 to 1)</haxe_doc>
		</saturationHSLuv>
		<lightnessHSLuv public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The HSLuv lightness of the color (from 0 to 1)</haxe_doc>
		</lightnessHSLuv>
		<get_hueHSLuv set="method" line="849" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hueHSLuv>
		<set_hueHSLuv get="inline" set="null" line="854" static="1"><f a="this:hueHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hueHSLuv>
		<get_saturationHSLuv set="method" line="860" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturationHSLuv>
		<set_saturationHSLuv get="inline" set="null" line="865" static="1"><f a="this:saturationHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturationHSLuv>
		<get_lightnessHSLuv set="method" line="871" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightnessHSLuv>
		<set_lightnessHSLuv get="inline" set="null" line="876" static="1"><f a="this:lightnessHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightnessHSLuv>
		<_getOrCreateCachedHSLuvComponent get="inline" set="null" line="882" static="1"><f a="this:index">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></_getOrCreateCachedHSLuvComponent>
		<fromHSLuv public="1" get="inline" set="null" line="905" static="1">
			<f a="hue:saturation:lightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a Color</haxe_doc>
		</fromHSLuv>
		<setHSLuv public="1" get="inline" set="null" line="919" static="1">
			<f a="this:hue:saturation:lightness">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Set HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
		</setHSLuv>
		<getHSLuv public="1" get="inline" set="null" line="951" static="1">
			<f a="this:?result">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Get HSLuv components from the color instance.
     *
     * @param result A pre-allocated array to store the result into.
     * @return    The HSLuv components as a float array</haxe_doc>
		</getHSLuv>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.ComputeFps" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ComputeFps.hx">
		<frames><c path="Array"><x path="Float"/></c></frames>
		<index expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</index>
		<size><x path="Int"/></size>
		<fps public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</fps>
		<addFrame public="1" set="method" line="26"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></addFrame>
		<new public="1" set="method" line="15">
			<f a="?size" v="10">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ size : 10 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.ConvertField" params="T:U" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertField.hx" interface="1">
		<basicToField public="1" set="method">
			<f a="instance:field:assets:basic:done">
				<c path="ceramic.Entity"/>
				<c path="String"/>
				<c path="ceramic.Assets"/>
				<c path="ceramic.ConvertField.T"/>
				<f a="">
					<c path="ceramic.ConvertField.U"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Get field value from basic type. As this may require loading assets,
     * A usable `Assets` instance must be provided and the result will only be
     * provided asynchronously by calling `done` callback.</haxe_doc>
		</basicToField>
		<fieldToBasic public="1" set="method">
			<f a="instance:field:value">
				<c path="ceramic.Entity"/>
				<c path="String"/>
				<c path="ceramic.ConvertField.U"/>
				<c path="ceramic.ConvertField.T"/>
			</f>
			<haxe_doc>* Get a basic type from the field value.</haxe_doc>
		</fieldToBasic>
		<haxe_doc>* Interface to convert basic type `T` to field type `U` and vice versa.</haxe_doc>
	</class>
	<class path="ceramic.ConvertArray" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertArray.hx">
		<implements path="ceramic.ConvertField">
			<c path="Array"><c path="ceramic.ConvertArray.T"/></c>
			<c path="Array"><c path="ceramic.ConvertArray.T"/></c>
		</implements>
		<basicToField public="1" set="method" line="9"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<c path="Array"><c path="ceramic.ConvertArray.T"/></c>
	<f a="">
		<c path="Array"><c path="ceramic.ConvertArray.T"/></c>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="23"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="Array"><c path="ceramic.ConvertArray.T"/></c>
	<c path="Array"><c path="ceramic.ConvertArray.T"/></c>
</f></fieldToBasic>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.ConvertComponentMap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertComponentMap.hx">
		<implements path="ceramic.ConvertField">
			<x path="haxe.DynamicAccess"><c path="String"/></x>
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.Component"/>
			</t>
		</implements>
		<basicToField public="1" set="method" line="11"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<x path="haxe.DynamicAccess"><c path="String"/></x>
	<f a="">
		<t path="Map">
			<c path="String"/>
			<c path="ceramic.Component"/>
		</t>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="46"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</t>
	<x path="haxe.DynamicAccess"><c path="String"/></x>
</f></fieldToBasic>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.ConvertFont" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertFont.hx">
		<implements path="ceramic.ConvertField">
			<c path="String"/>
			<c path="ceramic.BitmapFont"/>
		</implements>
		<basicToField public="1" set="method" line="9"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<c path="String"/>
	<f a="">
		<c path="ceramic.BitmapFont"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="27"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.BitmapFont"/>
	<c path="String"/>
</f></fieldToBasic>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.ConvertFragmentData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertFragmentData.hx">
		<implements path="ceramic.ConvertField">
			<d/>
			<t path="ceramic.FragmentData"/>
		</implements>
		<basicToField public="1" set="method" line="7"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<d/>
	<f a="">
		<t path="ceramic.FragmentData"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="13"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<t path="ceramic.FragmentData"/>
	<d/>
</f></fieldToBasic>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.ConvertIntBoolMap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertIntBoolMap.hx">
		<implements path="ceramic.ConvertField">
			<d/>
			<x path="ceramic.IntBoolMap"/>
		</implements>
		<basicToField public="1" set="method" line="9"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<d/>
	<f a="">
		<x path="ceramic.IntBoolMap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="40"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<x path="ceramic.IntBoolMap"/>
	<d/>
</f></fieldToBasic>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.ConvertMap" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertMap.hx">
		<implements path="ceramic.ConvertField">
			<x path="haxe.DynamicAccess"><c path="ceramic.ConvertMap.T"/></x>
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.ConvertMap.T"/>
			</t>
		</implements>
		<basicToField public="1" set="method" line="9"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<x path="haxe.DynamicAccess"><c path="ceramic.ConvertMap.T"/></x>
	<f a="">
		<t path="Map">
			<c path="String"/>
			<c path="ceramic.ConvertMap.T"/>
		</t>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="26"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<c path="ceramic.ConvertMap.T"/>
	</t>
	<x path="haxe.DynamicAccess"><c path="ceramic.ConvertMap.T"/></x>
</f></fieldToBasic>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.ConvertTexture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertTexture.hx">
		<implements path="ceramic.ConvertField">
			<c path="String"/>
			<c path="ceramic.Texture"/>
		</implements>
		<basicToField public="1" set="method" line="7"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<c path="String"/>
	<f a="">
		<c path="ceramic.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="20"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Texture"/>
	<c path="String"/>
</f></fieldToBasic>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Csv" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Csv.hx">
		<parse public="1" set="method" line="16" static="1"><f a="csv">
	<c path="String"/>
	<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
</f></parse>
		<stringify public="1" set="method" line="171" static="1"><f a="items:?fields">
	<c path="Array"><d/></c>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
</f></stringify>
		<warning set="method" line="224" static="1"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></warning>
		<haxe_doc>* Utilities to parse CSV and related</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.CustomAssetKind" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/CustomAssetKind.hx">
		<kind public="1"><c path="String"/></kind>
		<add public="1"><f a="assets:name:variant:options">
	<c path="ceramic.Assets"/>
	<c path="String"/>
	<c path="String"/>
	<t path="ceramic.AssetOptions"/>
	<x path="Void"/>
</f></add>
		<extensions public="1"><c path="Array"><c path="String"/></c></extensions>
		<dir public="1"><x path="Bool"/></dir>
		<types public="1"><c path="Array"><c path="String"/></c></types>
		<new public="1" set="method" line="4">
			<f a="kind:add:extensions:dir:types">
				<c path="String"/>
				<f a="assets:name:variant:options">
					<c path="ceramic.Assets"/>
					<c path="String"/>
					<c path="String"/>
					<t path="ceramic.AssetOptions"/>
					<x path="Void"/>
				</f>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.DatabaseAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/DatabaseAsset.hx">
		<extends path="ceramic.Asset"/>
		<invalidateDatabase public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateDatabase>
		<database public="1" expr="null">
			<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</database>
		<unobservedDatabase>
			<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
			<haxe_doc></haxe_doc>
		</unobservedDatabase>
		<_dox_event_databaseChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
				<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when database field changes.</haxe_doc>
		</_dox_event_databaseChange>
		<emitDatabaseChange set="method" line="1095">
			<f a="current:previous">
				<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
				<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when database field changes.</haxe_doc>
		</emitDatabaseChange>
		<onDatabaseChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
					<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when database field changes.</haxe_doc>
		</onDatabaseChange>
		<onceDatabaseChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
					<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when database field changes.</haxe_doc>
		</onceDatabaseChange>
		<offDatabaseChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
					<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when database field changes.</haxe_doc>
		</offDatabaseChange>
		<listensDatabaseChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when database field changes.</haxe_doc>
		</listensDatabaseChange>
		<load public="1" set="method" line="16" override="1"><f a=""><x path="Void"/></f></load>
		<assetFilesDidChange set="method" line="67" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="88" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="10"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.DoubleClick" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/DoubleClick.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<_dox_event_doubleClick public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_doubleClick>
		<emitDoubleClick set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>doubleClick event</haxe_doc>
		</emitDoubleClick>
		<onDoubleClick public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>doubleClick event</haxe_doc>
		</onDoubleClick>
		<onceDoubleClick public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>doubleClick event</haxe_doc>
		</onceDoubleClick>
		<offDoubleClick public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>doubleClick event</haxe_doc>
		</offDoubleClick>
		<listensDoubleClick public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to doubleClick event</haxe_doc>
		</listensDoubleClick>
		<threshold public="1" expr="4.0">
			<x path="Float"/>
			<meta><m n=":value"><e>4.0</e></m></meta>
		</threshold>
		<maxDelay public="1" expr="0.4">
			<x path="Float"/>
			<meta><m n=":value"><e>0.4</e></m></meta>
		</maxDelay>
		<entity public="1">
			<c path="ceramic.Visual"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<pressed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pressed>
		<firstClickTime expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</firstClickTime>
		<pointerStartX expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</pointerStartX>
		<pointerStartY expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</pointerStartY>
		<bindAsComponent set="method" line="30"><f a=""><x path="Void"/></f></bindAsComponent>
		<cancel public="1" set="method" line="42"><f a=""><x path="Void"/></f></cancel>
		<handlePointerDown set="method" line="52"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerDown>
		<handlePointerUp set="method" line="72"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerUp>
		<handlePointerMove set="method" line="88"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerMove>
		<handleBlur set="method" line="98"><f a=""><x path="Void"/></f></handleBlur>
		<setEntity set="method" line="5">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="5">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<enum path="ceramic.Easing" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Easing.hx">
		<NONE/>
		<LINEAR/>
		<BACK_EASE_IN/>
		<BACK_EASE_IN_OUT/>
		<BACK_EASE_OUT/>
		<QUAD_EASE_IN/>
		<QUAD_EASE_IN_OUT/>
		<QUAD_EASE_OUT/>
		<CUBIC_EASE_IN/>
		<CUBIC_EASE_IN_OUT/>
		<CUBIC_EASE_OUT/>
		<QUART_EASE_IN/>
		<QUART_EASE_IN_OUT/>
		<QUART_EASE_OUT/>
		<QUINT_EASE_IN/>
		<QUINT_EASE_IN_OUT/>
		<QUINT_EASE_OUT/>
		<BOUNCE_EASE_IN/>
		<BOUNCE_EASE_IN_OUT/>
		<BOUNCE_EASE_OUT/>
		<ELASTIC_EASE_IN/>
		<ELASTIC_EASE_IN_OUT/>
		<ELASTIC_EASE_OUT/>
		<EXPO_EASE_IN/>
		<EXPO_EASE_IN_OUT/>
		<EXPO_EASE_OUT/>
		<SINE_EASE_IN/>
		<SINE_EASE_IN_OUT/>
		<SINE_EASE_OUT/>
		<BEZIER a="x1:y1:x2:y2">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</BEZIER>
		<CUSTOM a="easing"><f a="">
	<x path="Float"/>
	<x path="Float"/>
</f></CUSTOM>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="ceramic.EasingUtils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/EasingUtils.hx">
		<_emptyArray expr="[]" line="5" static="1">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_emptyArray>
		<easingFromString public="1" set="method" line="7" static="1"><f a="str">
	<c path="String"/>
	<e path="ceramic.Easing"/>
</f></easingFromString>
		<easingToString public="1" set="method" line="15" static="1"><f a="easing">
	<e path="ceramic.Easing"/>
	<c path="String"/>
</f></easingToString>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.TextInputDelegate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextInputDelegate.hx" interface="1">
		<textInputClosestPositionInLine public="1" set="method">
			<f a="fromPosition:fromLine:toLine">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the position in `toLine` which is closest
     * to the position in `fromLine`/`fromPosition` (in X coordinates).
     * Positions are relative to their line.</haxe_doc>
		</textInputClosestPositionInLine>
		<textInputNumberOfLines public="1" set="method"><f a=""><x path="Int"/></f></textInputNumberOfLines>
		<textInputIndexForPosInLine public="1" set="method"><f a="lineNumber:lineOffset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></textInputIndexForPosInLine>
		<textInputLineForIndex public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></textInputLineForIndex>
		<textInputPosInLineForIndex public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></textInputPosInLineForIndex>
	</class>
	<class path="ceramic.EditText" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/EditText.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.TextInputDelegate"/>
		<implements path="ceramic.Component"/>
		<_point expr="new Point()" line="13" static="1">
			<c path="ceramic.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
		</_point>
		<_activeEditTextInput expr="null" line="15" static="1">
			<c path="ceramic.EditText"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_activeEditTextInput>
		<_dox_event_update public="1" set="method" line="637">
			<f a="content">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_update>
		<emitUpdate set="method" line="1095">
			<f a="content">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>update event</haxe_doc>
		</emitUpdate>
		<onUpdate public="1" set="method" line="1199">
			<f a="owner:handleContent">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="content">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onUpdate>
		<onceUpdate public="1" set="method" line="1298">
			<f a="owner:handleContent">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="content">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onceUpdate>
		<offUpdate public="1" set="method" line="1368">
			<f a="?handleContent">
				<f a="content">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</offUpdate>
		<listensUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to update event</haxe_doc>
		</listensUpdate>
		<_dox_event_start public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_start>
		<emitStart set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>start event</haxe_doc>
		</emitStart>
		<onStart public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>start event</haxe_doc>
		</onStart>
		<onceStart public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>start event</haxe_doc>
		</onceStart>
		<offStart public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>start event</haxe_doc>
		</offStart>
		<listensStart public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to start event</haxe_doc>
		</listensStart>
		<_dox_event_submit public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_submit>
		<emitSubmit set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>submit event</haxe_doc>
		</emitSubmit>
		<onSubmit public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>submit event</haxe_doc>
		</onSubmit>
		<onceSubmit public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>submit event</haxe_doc>
		</onceSubmit>
		<offSubmit public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>submit event</haxe_doc>
		</offSubmit>
		<listensSubmit public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to submit event</haxe_doc>
		</listensSubmit>
		<_dox_event_stop public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_stop>
		<emitStop set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>stop event</haxe_doc>
		</emitStop>
		<onStop public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>stop event</haxe_doc>
		</onStop>
		<onceStop public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>stop event</haxe_doc>
		</onceStop>
		<offStop public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>stop event</haxe_doc>
		</offStop>
		<listensStop public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to stop event</haxe_doc>
		</listensStop>
		<entity public="1">
			<c path="ceramic.Text"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<multiline public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</multiline>
		<editing public="1" get="accessor" set="null"><x path="Bool"/></editing>
		<get_editing set="method" line="34"><f a=""><x path="Bool"/></f></get_editing>
		<selectionColor public="1" set="accessor"><x path="ceramic.Color"/></selectionColor>
		<set_selectionColor set="method" line="39"><f a="selectionColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_selectionColor>
		<textCursorColor public="1" set="accessor"><x path="ceramic.Color"/></textCursorColor>
		<set_textCursorColor set="method" line="47"><f a="textCursorColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_textCursorColor>
		<textCursorOffsetX public="1" set="accessor"><x path="Float"/></textCursorOffsetX>
		<set_textCursorOffsetX set="method" line="55"><f a="textCursorOffsetX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_textCursorOffsetX>
		<textCursorOffsetY public="1" set="accessor"><x path="Float"/></textCursorOffsetY>
		<set_textCursorOffsetY set="method" line="63"><f a="textCursorOffsetY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_textCursorOffsetY>
		<textCursorHeightFactor public="1" set="accessor"><x path="Float"/></textCursorHeightFactor>
		<set_textCursorHeightFactor set="method" line="71"><f a="textCursorHeightFactor">
	<x path="Float"/>
	<x path="Float"/>
</f></set_textCursorHeightFactor>
		<disabled public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</disabled>
		<set_disabled set="method" line="79"><f a="disabled">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_disabled>
		<container public="1" set="accessor" expr="null">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Optional container on which pointer events are bound</haxe_doc>
		</container>
		<set_container set="method" line="92"><f a="container">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
</f></set_container>
		<selectText public="1" set="null" expr="null">
			<c path="ceramic.SelectText"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* SelectText instance used internally to manage text selection.
     * Will be defined after component has been assigned to an entity.</haxe_doc>
		</selectText>
		<boundContainer expr="null">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</boundContainer>
		<selectionBackgrounds expr="[]">
			<c path="Array"><c path="ceramic.Quad"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</selectionBackgrounds>
		<inputActive expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</inputActive>
		<willUpdateSelection expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</willUpdateSelection>
		<textCursor expr="null">
			<c path="ceramic.Quad"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</textCursor>
		<textCursorToggleVisibilityTime expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</textCursorToggleVisibilityTime>
		<bindAsComponent set="method" line="137"><f a=""><x path="Void"/></f></bindAsComponent>
		<startInput public="1" set="method" line="160">
			<f a="?selectionStart:?selectionEnd" v="-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ selectionEnd : -1, selectionStart : -1 }</e></m></meta>
		</startInput>
		<stopInput public="1" set="method" line="229"><f a=""><x path="Void"/></f></stopInput>
		<updateText public="1" set="method" line="253"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></updateText>
		<focus public="1" set="method" line="261"><f a=""><x path="Void"/></f></focus>
		<handleStop set="method" line="281"><f a=""><x path="Void"/></f></handleStop>
		<handleEnter set="method" line="287"><f a=""><x path="Void"/></f></handleEnter>
		<handleEscape set="method" line="296"><f a=""><x path="Void"/></f></handleEscape>
		<updateFromTextInput set="method" line="302"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></updateFromTextInput>
		<updateFromSelection set="method" line="312"><f a="selectionStart:selectionEnd:inverted">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></updateFromSelection>
		<updateFromInputSelection set="method" line="318"><f a="selectionStart:selectionEnd">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateFromInputSelection>
		<textInputClosestPositionInLine public="1" set="method" line="327"><f a="fromPosition:fromLine:toLine">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></textInputClosestPositionInLine>
		<textInputNumberOfLines public="1" set="method" line="336"><f a=""><x path="Int"/></f></textInputNumberOfLines>
		<textInputIndexForPosInLine public="1" set="method" line="345"><f a="lineNumber:lineOffset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></textInputIndexForPosInLine>
		<textInputLineForIndex public="1" set="method" line="351"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></textInputLineForIndex>
		<textInputPosInLineForIndex public="1" set="method" line="357"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></textInputPosInLineForIndex>
		<bindPointerEvents set="method" line="365"><f a=""><x path="Void"/></f></bindPointerEvents>
		<handlePointerDown set="method" line="385"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerDown>
		<handleAppUpdate set="method" line="391"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></handleAppUpdate>
		<bindKeyBindings set="method" line="402"><f a=""><x path="Void"/></f></bindKeyBindings>
		<destroy public="1" set="method" line="447" override="1"><f a=""><x path="Void"/></f></destroy>
		<setEntity set="method" line="9">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="9">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="124">
			<f a="selectionColor:textCursorColor:?textCursorOffsetX:?textCursorOffsetY:?textCursorHeightFactor" v="::0:0:1">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ textCursorHeightFactor : 1, textCursorOffsetY : 0, textCursorOffsetX : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.Either" params="T1:T2" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Either.hx">
		<from>
			<icast><c path="ceramic.Either.T1"/></icast>
			<icast><c path="ceramic.Either.T2"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="ceramic.Either.T1"/></icast>
			<icast><c path="ceramic.Either.T2"/></icast>
		</to>
		<haxe_doc>* Useful to limit a Dynamic function argument's type to the specified
 * type parameters. This does NOT make the use of Dynamic type-safe in
 * any way (the underlying type is still Dynamic and Std.isOfType() checks +
 * casts are necessary).</haxe_doc>
		<impl><class path="ceramic._Either.Either_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Either.hx" private="1" module="ceramic.Either" extern="1" final="1"/></impl>
	</abstract>
	<class path="ceramic._Either.Either_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Either.hx" private="1" module="ceramic.Either" extern="1" final="1"/>
	<class path="ceramic.Enums" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Enums.hx"><isEnumWithName public="1" params="T" set="method" static="1">
	<f a="valueExpr:nameExpr">
		<x path="Enum"><c path="isEnumWithName.T"/></x>
		<d/>
		<d/>
	</f>
	<haxe_doc>* Returns true if the given enum value has its name equal to the given name</haxe_doc>
</isEnumWithName></class>
	<class path="ceramic.Equal" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Equal.hx">
		<equal public="1" set="method" line="13" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Equality check (deep equality only working on arrays for now)
     * @param a
     * @param b
     * @return Bool</haxe_doc>
		</equal>
		<arrayEqual public="1" get="inline" set="null" line="37" static="1"><f a="a:b">
	<c path="Array"><x path="Any"/></c>
	<c path="Array"><x path="Any"/></c>
	<x path="Bool"/>
</f></arrayEqual>
		<_arrayEqual public="1" set="method" line="41" static="1"><f a="a:b">
	<c path="Array"><x path="Any"/></c>
	<c path="Array"><x path="Any"/></c>
	<x path="Bool"/>
</f></_arrayEqual>
	</class>
	<class path="ceramic.Errors" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Errors.hx"><handleUncaughtError set="method" line="13" static="1"><f a="e">
	<d/>
	<x path="Void"/>
</f></handleUncaughtError></class>
	<class path="ceramic.Extensions" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Extensions.hx">
		<unsafeGet public="1" params="T" get="inline" set="null" line="12" static="1"><f a="array:index">
	<c path="Array"><c path="unsafeGet.T"/></c>
	<x path="Int"/>
	<c path="unsafeGet.T"/>
</f></unsafeGet>
		<unsafeSet public="1" params="T" get="inline" set="null" line="29" static="1"><f a="array:index:value">
	<c path="Array"><c path="unsafeSet.T"/></c>
	<x path="Int"/>
	<c path="unsafeSet.T"/>
	<x path="Void"/>
</f></unsafeSet>
		<setArrayLength public="1" params="T" get="inline" set="null" line="46" static="1"><f a="array:length">
	<c path="Array"><c path="setArrayLength.T"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setArrayLength>
		<randomElement public="1" params="T" get="inline" set="null" line="66" static="1">
			<f a="array">
				<c path="Array"><c path="randomElement.T"/></c>
				<c path="randomElement.T"/>
			</f>
			<haxe_doc>* Return a random element contained in the given array</haxe_doc>
		</randomElement>
		<randomElementExcept public="1" params="T" set="method" line="79" static="1">
			<f a="array:except:?unsafe" v="::false">
				<c path="Array"><c path="randomElementExcept.T"/></c>
				<c path="randomElementExcept.T"/>
				<x path="Bool"/>
				<c path="randomElementExcept.T"/>
			</f>
			<meta><m n=":value"><e>{ unsafe : false }</e></m></meta>
			<haxe_doc>* Return a random element contained in the given array that is not equal to the `except` arg.
     * @param array  The array in which we extract the element from
     * @param except The element we don't want
     * @param unsafe If set to `true`, will prevent allocating a new array (and may be faster) but will loop forever if there is no element except the one we don't want
     * @return The random element or `null` if nothing was found</haxe_doc>
		</randomElementExcept>
		<randomElementMatchingValidator public="1" params="T" set="method" line="120" static="1">
			<f a="array:validator">
				<c path="Array"><c path="randomElementMatchingValidator.T"/></c>
				<f a="">
					<c path="randomElementMatchingValidator.T"/>
					<x path="Bool"/>
				</f>
				<c path="randomElementMatchingValidator.T"/>
			</f>
			<haxe_doc>* Return a random element contained in the given array that is validated by the provided validator.
     * If no item is valid, returns null.
     * @param array  The array in which we extract the element from
     * @param validator A function that returns true if the item is valid, false if not
     * @return The random element or `null` if nothing was found</haxe_doc>
		</randomElementMatchingValidator>
		<shuffle public="1" params="T" set="method" line="145" static="1">
			<f a="arr">
				<c path="Array"><c path="shuffle.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shuffle an Array. This operation affects the array in place.
     * The shuffle algorithm used is a variation of the [Fisher Yates Shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)</haxe_doc>
		</shuffle>
		<swapElements public="1" params="T" set="method" line="163" static="1"><f a="arr:index0:index1">
	<c path="Array"><c path="swapElements.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapElements>
		<removeNullElements public="1" params="T" set="method" line="171" static="1"><f a="arr">
	<c path="Array"><c path="removeNullElements.T"/></c>
	<x path="Void"/>
</f></removeNullElements>
		<setProperty public="1" params="T" get="inline" set="null" line="207" static="1">
			<f a="instance:field:value">
				<c path="setProperty.T"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setProperty>
		<getProperty public="1" params="T" get="inline" set="null" line="214" static="1">
			<f a="instance:field">
				<c path="getProperty.T"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</getProperty>
		<haxe_doc>* A bunch of static extensions to make life easier.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.FieldInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FieldInfo.hx">
		<fieldInfoMap expr="new Map()" line="13" static="1">
			<t path="Map">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<c path="String"/>
				</t>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</fieldInfoMap>
		<types public="1" set="method" line="15" static="1">
			<f a="targetClass:?recursive" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<c path="String"/>
				</x>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
		</types>
		<typeOf public="1" set="method" line="51" static="1"><f a="targetClass:field">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></typeOf>
		<haxe_doc>* Extract field information from a given class type.
 * This is expected to only work with Entity subclasses marked with @editable, @fieldInfo or @autoFieldInfo
 * or classes using FieldInfoMacro.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.FieldMeta" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FieldMeta.hx">
		<metaMap expr="new Map()" line="10" static="1">
			<t path="Map">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<t path="Map">
						<c path="String"/>
						<d/>
					</t>
				</t>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</metaMap>
		<metaMapRecursive expr="new Map()" line="12" static="1">
			<t path="Map">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<t path="Map">
						<c path="String"/>
						<d/>
					</t>
				</t>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</metaMapRecursive>
		<hasMeta public="1" get="inline" set="null" line="14" static="1">
			<f a="clazz:field:meta:?recursive" v=":::true">
				<x path="Class"><d/></x>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
			<overloads><hasMeta public="1" get="inline" set="null" line="21">
	<f a="targetClass:field:meta:?recursive" v=":::true">
		<c path="String"/>
		<c path="String"/>
		<c path="String"/>
		<x path="Bool"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
</hasMeta></overloads>
		</hasMeta>
		<_hasMeta set="method" line="28" static="1"><f a="clazz:targetClass:field:meta:recursive">
	<x path="Class"><d/></x>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></_hasMeta>
		<getMeta public="1" get="inline" set="null" line="35" static="1">
			<f a="clazz:field:?recursive" v="::true">
				<x path="Class"><d/></x>
				<c path="String"/>
				<x path="Bool"/>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<d/>
				</x>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
			<overloads><getMeta public="1" get="inline" set="null" line="42">
	<f a="targetClass:field:?recursive" v="::true">
		<c path="String"/>
		<c path="String"/>
		<x path="Bool"/>
		<x path="ceramic.ReadOnlyMap">
			<c path="String"/>
			<d/>
		</x>
	</f>
	<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
</getMeta></overloads>
		</getMeta>
		<_getMeta set="method" line="49" static="1"><f a="clazz:targetClass:field:recursive">
	<x path="Class"><d/></x>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<d/>
	</x>
</f></_getMeta>
		<haxe_doc>* Utility to get runtime metadata</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.FileWatcher" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FileWatcher.hx">
		<extends path="ceramic.Entity"/>
		<UPDATE_INTERVAL public="1" expr="1.0" line="13" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</UPDATE_INTERVAL>
		<checkContent expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If set to `true`, actual content of files will be compared</haxe_doc>
		</checkContent>
		<watched expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic._FileWatcher.WatchedFile"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</watched>
		<timeSinceLastCheck expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</timeSinceLastCheck>
		<canWatch public="1" set="method" line="47"><f a=""><x path="Bool"/></f></canWatch>
		<watch public="1" set="method" line="68"><f a="path:onUpdate">
	<c path="String"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
</f></watch>
		<destroy public="1" set="method" line="97" override="1"><f a=""><x path="Void"/></f></destroy>
		<tick set="method" line="107"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></tick>
		<isFile set="method" line="159"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isFile>
		<lastModified set="method" line="177"><f a="path">
	<c path="String"/>
	<x path="Float"/>
</f></lastModified>
		<getContent set="method" line="199"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getContent>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A file watcher for ceramic compatible with `interpret.Watcher`.</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic._FileWatcher.WatchedFile" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FileWatcher.hx" private="1" module="ceramic.FileWatcher">
		<updateCallbacks public="1" expr="[]">
			<c path="Array"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</updateCallbacks>
		<mtime public="1" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</mtime>
		<content public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</content>
		<new public="1" set="method" line="228"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.FileWatcher</e></m>
		</meta>
	</class>
	<class path="ceramic.Files" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Files.hx">
		<haveSameContent public="1" set="method" line="24" static="1"><f a="filePath1:filePath2">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></haveSameContent>
		<haveSameLastModified public="1" set="method" line="48" static="1"><f a="filePath1:filePath2">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></haveSameLastModified>
		<setToSameLastModified public="1" set="method" line="88" static="1">
			<f a="srcFilePath:dstFilePath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Only works in nodejs for now.</haxe_doc>
		</setToSameLastModified>
		<getFlatDirectory public="1" set="method" line="110" static="1">
			<f a="dir:?excludeSystemFiles:?subCall:?recursive" v=":true:false:true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ recursive : true, subCall : false, excludeSystemFiles : true }</e></m></meta>
		</getFlatDirectory>
		<getLastModified public="1" set="method" line="193" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get file last modified time (in seconds) or `-1` if not available
     * @param path
     * @return Float</haxe_doc>
		</getLastModified>
		<removeEmptyDirectories public="1" set="method" line="215" static="1">
			<f a="dir:?excludeSystemFiles" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ excludeSystemFiles : true }</e></m></meta>
		</removeEmptyDirectories>
		<isEmptyDirectory public="1" set="method" line="240" static="1">
			<f a="dir:?excludeSystemFiles" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ excludeSystemFiles : true }</e></m></meta>
		</isEmptyDirectory>
		<deleteRecursive public="1" set="method" line="262" static="1"><f a="toDelete">
	<c path="String"/>
	<x path="Void"/>
</f></deleteRecursive>
		<getRelativePath public="1" set="method" line="305" static="1"><f a="absolutePath:relativeTo">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getRelativePath>
		<copyFileWithIntermediateDirs public="1" set="method" line="342" static="1"><f a="srcPath:dstPath">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></copyFileWithIntermediateDirs>
		<copyDirectory public="1" set="method" line="361" static="1">
			<f a="srcDir:dstDir:?removeExisting" v="::false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ removeExisting : false }</e></m></meta>
		</copyDirectory>
		<deleteFile public="1" set="method" line="395" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></deleteFile>
		<getContent public="1" set="method" line="421" static="1"><f a="path">
	<c path="String"/>
	<x path="Null"><c path="String"/></x>
</f></getContent>
		<getBytes public="1" set="method" line="448" static="1"><f a="path">
	<c path="String"/>
	<x path="Null"><c path="haxe.io.Bytes"/></x>
</f></getBytes>
		<saveContent public="1" set="method" line="476" static="1"><f a="path:content">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></saveContent>
		<saveBytes public="1" set="method" line="501" static="1"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></saveBytes>
		<createDirectory public="1" set="method" line="527" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></createDirectory>
		<exists public="1" set="method" line="572" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<isDirectory public="1" set="method" line="605" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isDirectory>
		<haxe_doc>* Filesystem-related utilities. Only work on sys targets and/or nodejs depending on the methods</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Quad" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Quad.hx">
		<extends path="ceramic.Visual"/>
		<FLAG_TRANSPARENT final="1" get="inline" set="null" expr="16" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</FLAG_TRANSPARENT>
		<FLAG_ROTATE_FRAME final="1" get="inline" set="null" expr="32" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</FLAG_ROTATE_FRAME>
		<_matrix expr="Visual._matrix" line="14" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>Visual._matrix</e></m></meta>
		</_matrix>
		<_degToRad expr="Visual._degToRad" line="16" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Visual._degToRad</e></m></meta>
		</_degToRad>
		<color public="1" expr="Color.WHITE">
			<x path="ceramic.Color"/>
			<meta>
				<m n=":value"><e>Color.WHITE</e></m>
				<m n="editable"/>
			</meta>
		</color>
		<transparent public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"/></meta>
			<haxe_doc>* If set to `true`, this quad will be considered
     * transparent thus won't be draw on screen.
     * Children still behave and get drawn as before:
     * they don't inherit this property.</haxe_doc>
		</transparent>
		<get_transparent get="inline" set="null" line="29"><f a=""><x path="Bool"/></f></get_transparent>
		<set_transparent get="inline" set="null" line="32"><f a="transparent">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_transparent>
		<tile public="1" set="accessor" expr="null">
			<c path="ceramic.TextureTile"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</tile>
		<set_tile set="method" line="38"><f a="tile">
	<c path="ceramic.TextureTile"/>
	<c path="ceramic.TextureTile"/>
</f></set_tile>
		<texture public="1" get="accessor" set="accessor">
			<c path="ceramic.Texture"/>
			<meta><m n="editable"/></meta>
			<haxe_doc>* The texture to use for this Quad object</haxe_doc>
		</texture>
		<get_texture get="inline" set="null" line="69"><f a=""><c path="ceramic.Texture"/></f></get_texture>
		<set_texture get="inline" set="null" line="72"><f a="texture">
	<c path="ceramic.Texture"/>
	<c path="ceramic.Texture"/>
</f></set_texture>
		<_texture expr="null">
			<c path="ceramic.Texture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_texture>
		<_set_texture set="method" line="81"><f a="texture">
	<c path="ceramic.Texture"/>
	<x path="Void"/>
</f></_set_texture>
		<frameX public="1" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</frameX>
		<frameY public="1" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</frameY>
		<frameWidth public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</frameWidth>
		<set_frameWidth get="inline" set="null" line="128"><f a="frameWidth">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frameWidth>
		<frameHeight public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</frameHeight>
		<set_frameHeight get="inline" set="null" line="139"><f a="frameHeight">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frameHeight>
		<rotateFrame public="1" get="accessor" set="accessor"><x path="Bool"/></rotateFrame>
		<get_rotateFrame get="inline" set="null" line="150"><f a=""><x path="Bool"/></f></get_rotateFrame>
		<set_rotateFrame get="inline" set="null" line="153"><f a="rotateFrame">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_rotateFrame>
		<destroy public="1" set="method" line="168" override="1"><f a=""><x path="Void"/></f></destroy>
		<frame public="1" get="inline" set="null" line="179"><f a="frameX:frameY:frameWidth:frameHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></frame>
		<isRegular public="1" set="method" line="191">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if this quad is a regular rectangle</haxe_doc>
		</isRegular>
		<computeMatrix set="method" line="205" override="1"><f a=""><x path="Void"/></f></computeMatrix>
		<textureDestroyed set="method" line="219"><f a="_">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></textureDestroyed>
		<new public="1" set="method" line="160"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n="editable"><e>{ implicitSizeUnlessNull : "texture" }</e></m>
		</meta>
	</class>
	<class path="ceramic.Layer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Layer.hx">
		<extends path="ceramic.Quad"/>
		<_dox_event_resize public="1" set="method" line="637">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_resize>
		<emitResize set="method" line="1095">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>resize event</haxe_doc>
		</emitResize>
		<onResize public="1" set="method" line="1199">
			<f a="owner:handleWidthHeight">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="width:height">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>resize event</haxe_doc>
		</onResize>
		<onceResize public="1" set="method" line="1298">
			<f a="owner:handleWidthHeight">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="width:height">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>resize event</haxe_doc>
		</onceResize>
		<offResize public="1" set="method" line="1368">
			<f a="?handleWidthHeight">
				<f a="width:height">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>resize event</haxe_doc>
		</offResize>
		<listensResize public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to resize event</haxe_doc>
		</listensResize>
		<sizeDirty expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</sizeDirty>
		<emitResizeIfNeeded set="method" line="25"><f a=""><x path="Void"/></f></emitResizeIfNeeded>
		<willEmitResize set="method" line="36"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitResize>
		<didEmitResize set="method" line="42"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></didEmitResize>
		<set_width set="method" line="48" override="1"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="58" override="1"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Just a regular quad (transparent by default) with a few addition to make it more convenient when used as a layer</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n="editable"><e>{ implicitSizeUnlessNull : "texture" }</e></m>
		</meta>
	</class>
	<class path="ceramic.Filter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Filter.hx">
		<extends path="ceramic.Layer"/>
		<implements path="tracker.Observable"/>
		<_matrix expr="Visual._matrix" line="17" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>Visual._matrix</e></m></meta>
		</_matrix>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Filter"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Filter"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Filter"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Filter"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.Filter"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<textureId public="1" set="accessor" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If provided, this id will be assigned to `renderTexture.id`.</haxe_doc>
		</textureId>
		<set_textureId set="method" line="25"><f a="textureId">
	<c path="String"/>
	<c path="String"/>
</f></set_textureId>
		<mesh public="1" set="accessor" expr="null">
			<c path="ceramic.Mesh"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* By default, the render texture managed by this filter is
     * rendered via itself, assigned to the `texture` field.
     * If you provide a `Mesh` instance, that mesh will be added as
     * a child of the filter and the texture will be rendered via
     * that mesh instead of itself. This opens the door to more advanced
     * post-processing in shaders.</haxe_doc>
		</mesh>
		<set_mesh set="method" line="42"><f a="mesh">
	<c path="ceramic.Mesh"/>
	<c path="ceramic.Mesh"/>
</f></set_mesh>
		<meshDirty expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</meshDirty>
		<destroyMeshOnRemove public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If set to `true`, when assigning `null` or
     * a new mesh intance to the `mesh` field will destroy
     * any existing mesh previously assigned.</haxe_doc>
		</destroyMeshOnRemove>
		<content public="1" set="null">
			<c path="ceramic.Quad"/>
			<haxe_doc>* The content in which you are expected to add visuals
     * so that they are rendered through the filter</haxe_doc>
		</content>
		<hitVisual public="1" set="accessor" expr="null">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If provided, visuals in content will react to hit tests
     * and touch events as if they were inside this hit visual.
     * By default, `hitVisual` is the `Filter` instance itself.</haxe_doc>
		</hitVisual>
		<set_hitVisual set="method" line="85"><f a="hitVisual">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
</f></set_hitVisual>
		<enabled public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If `enabled` is set to `false`, no render texture will be used.
     * The children will be displayed on screen directly.
     * Useful to toggle a filter without touching visuals hierarchy.</haxe_doc>
		</enabled>
		<set_enabled set="method" line="103"><f a="enabled">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<textureFilter public="1" set="accessor" expr="LINEAR">
			<e path="ceramic.TextureFilter"/>
			<meta><m n=":value"><e>LINEAR</e></m></meta>
			<haxe_doc>* Texture filter</haxe_doc>
		</textureFilter>
		<set_textureFilter set="method" line="115"><f a="textureFilter">
	<e path="ceramic.TextureFilter"/>
	<e path="ceramic.TextureFilter"/>
</f></set_textureFilter>
		<depthBuffer public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Texture depth</haxe_doc>
		</depthBuffer>
		<set_depthBuffer set="method" line="126"><f a="depthBuffer">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_depthBuffer>
		<stencil public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Texture stencil</haxe_doc>
		</stencil>
		<set_stencil set="method" line="137"><f a="stencil">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_stencil>
		<antialiasing public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Texture antialiasing</haxe_doc>
		</antialiasing>
		<set_antialiasing set="method" line="148"><f a="antialiasing">
	<x path="Int"/>
	<x path="Int"/>
</f></set_antialiasing>
		<autoRender public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Auto render?</haxe_doc>
		</autoRender>
		<set_autoRender set="method" line="159"><f a="autoRender">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoRender>
		<explicitRender public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If set to true, this filter will not render automatically its children.
     * It will instead set their `active` state to `false` unless explicitly rendered.
     * Note that when using explicit render, `active` property on children is managed
     * by this filter.</haxe_doc>
		</explicitRender>
		<set_explicitRender set="method" line="173"><f a="explicitRender">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_explicitRender>
		<textureTilePacker public="1" set="accessor" expr="null">
			<c path="ceramic.TextureTilePacker"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</textureTilePacker>
		<set_textureTilePacker set="method" line="181"><f a="textureTilePacker">
	<c path="ceramic.TextureTilePacker"/>
	<c path="ceramic.TextureTilePacker"/>
</f></set_textureTilePacker>
		<textureTile public="1" set="null" expr="null">
			<c path="ceramic.TextureTile"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</textureTile>
		<invalidateRenderTexture public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateRenderTexture>
		<renderTexture public="1" set="null" expr="null">
			<c path="ceramic.RenderTexture"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</renderTexture>
		<unobservedRenderTexture>
			<c path="ceramic.RenderTexture"/>
			<haxe_doc></haxe_doc>
		</unobservedRenderTexture>
		<_dox_event_renderTextureChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.RenderTexture"/>
				<c path="ceramic.RenderTexture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when renderTexture field changes.</haxe_doc>
		</_dox_event_renderTextureChange>
		<emitRenderTextureChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.RenderTexture"/>
				<c path="ceramic.RenderTexture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when renderTexture field changes.</haxe_doc>
		</emitRenderTextureChange>
		<onRenderTextureChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.RenderTexture"/>
					<c path="ceramic.RenderTexture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when renderTexture field changes.</haxe_doc>
		</onRenderTextureChange>
		<onceRenderTextureChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.RenderTexture"/>
					<c path="ceramic.RenderTexture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when renderTexture field changes.</haxe_doc>
		</onceRenderTextureChange>
		<offRenderTextureChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.RenderTexture"/>
					<c path="ceramic.RenderTexture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when renderTexture field changes.</haxe_doc>
		</offRenderTextureChange>
		<listensRenderTextureChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when renderTexture field changes.</haxe_doc>
		</listensRenderTextureChange>
		<density public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</density>
		<set_density set="method" line="202"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<explicitRenderState expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal flag used to keep track of current explicit render state</haxe_doc>
		</explicitRenderState>
		<explicitRenderPendingResultCallbacks expr="null">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Used internally when concurrent renders are trigerred</haxe_doc>
		</explicitRenderPendingResultCallbacks>
		<handleTexturesDensityChange set="method" line="240"><f a="density:prevDensity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></handleTexturesDensityChange>
		<updateRenderTextureAndContent set="method" line="249"><f a="filterWidth:filterHeight:density:depthBuffer:stencil:antialiasing">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateRenderTextureAndContent>
		<render public="1" set="method" line="329"><f a="?done">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></render>
		<visualInContentHits public="1" set="method" line="453"><f a="visual:x:y">
	<c path="ceramic.Visual"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></visualInContentHits>
		<set_width set="method" line="532" override="1"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="538" override="1"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<computeContent public="1" set="method" line="544" override="1"><f a=""><x path="Void"/></f></computeContent>
		<destroy public="1" set="method" line="549" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="221"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A visuals that displays its children through a filter. A filter draws its children into a `RenderTexture`
 * allowing to process the result through a shader, apply blending or alpha on the final result...</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.Flags" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Flags.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<impl><class path="ceramic._Flags.Flags_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Flags.hx" private="1" module="ceramic.Flags" final="1">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a=""><x path="ceramic.Flags"/></f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<toInt public="1" get="inline" set="null" line="11" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></toInt>
	<fromInt public="1" get="inline" set="null" line="15" static="1"><f a="value">
	<x path="Int"/>
	<x path="ceramic.Flags"/>
</f></fromInt>
	<bool public="1" get="inline" set="null" line="19" static="1"><f a="this:bit">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></bool>
	<setBool public="1" get="inline" set="null" line="26" static="1"><f a="this:bit:bool">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setBool>
	<getBool public="1" get="inline" set="null" line="33" static="1"><f a="flags:bit">
	<x path="ceramic.Flags"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getBool>
	<setBoolAndGetFlags public="1" get="inline" set="null" line="39" static="1"><f a="flags:bit:bool">
	<x path="ceramic.Flags"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></setBoolAndGetFlags>
	<fromValues public="1" get="inline" set="null" line="46" static="1">
		<f a="flag0">
			<x path="Bool"/>
			<x path="ceramic.Flags"/>
		</f>
		<overloads>
			<fromValues public="1" get="inline" set="null" line="86"><f a="flag0:flag1:flag2:flag3:flag4:flag5:flag6:flag7">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			<fromValues public="1" get="inline" set="null" line="79"><f a="flag0:flag1:flag2:flag3:flag4:flag5:flag6">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			<fromValues public="1" get="inline" set="null" line="72"><f a="flag0:flag1:flag2:flag3:flag4:flag5">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			<fromValues public="1" get="inline" set="null" line="65"><f a="flag0:flag1:flag2:flag3:flag4">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			<fromValues public="1" get="inline" set="null" line="58"><f a="flag0:flag1:flag2:flag3">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			<fromValues public="1" get="inline" set="null" line="54"><f a="flag0:flag1:flag2">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			<fromValues public="1" get="inline" set="null" line="50"><f a="flag0:flag1">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
		</overloads>
	</fromValues>
	<_fromValues get="inline" set="null" line="93" static="1"><f a="flag0:flag1:flag2:flag3:flag4:flag5:flag6:flag7">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></_fromValues>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._Flags.Flags_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Flags.hx" private="1" module="ceramic.Flags" final="1">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a=""><x path="ceramic.Flags"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<toInt public="1" get="inline" set="null" line="11" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></toInt>
		<fromInt public="1" get="inline" set="null" line="15" static="1"><f a="value">
	<x path="Int"/>
	<x path="ceramic.Flags"/>
</f></fromInt>
		<bool public="1" get="inline" set="null" line="19" static="1"><f a="this:bit">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></bool>
		<setBool public="1" get="inline" set="null" line="26" static="1"><f a="this:bit:bool">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setBool>
		<getBool public="1" get="inline" set="null" line="33" static="1"><f a="flags:bit">
	<x path="ceramic.Flags"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getBool>
		<setBoolAndGetFlags public="1" get="inline" set="null" line="39" static="1"><f a="flags:bit:bool">
	<x path="ceramic.Flags"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></setBoolAndGetFlags>
		<fromValues public="1" get="inline" set="null" line="46" static="1">
			<f a="flag0">
				<x path="Bool"/>
				<x path="ceramic.Flags"/>
			</f>
			<overloads>
				<fromValues public="1" get="inline" set="null" line="86"><f a="flag0:flag1:flag2:flag3:flag4:flag5:flag6:flag7">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
				<fromValues public="1" get="inline" set="null" line="79"><f a="flag0:flag1:flag2:flag3:flag4:flag5:flag6">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
				<fromValues public="1" get="inline" set="null" line="72"><f a="flag0:flag1:flag2:flag3:flag4:flag5">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
				<fromValues public="1" get="inline" set="null" line="65"><f a="flag0:flag1:flag2:flag3:flag4">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
				<fromValues public="1" get="inline" set="null" line="58"><f a="flag0:flag1:flag2:flag3">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
				<fromValues public="1" get="inline" set="null" line="54"><f a="flag0:flag1:flag2">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
				<fromValues public="1" get="inline" set="null" line="50"><f a="flag0:flag1">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			</overloads>
		</fromValues>
		<_fromValues get="inline" set="null" line="93" static="1"><f a="flag0:flag1:flag2:flag3:flag4:flag5:flag6:flag7">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></_fromValues>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="ceramic.Float32Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Float32Array.hx"><t path="backend.Float32Array"/></typedef>
	<class path="ceramic.FontAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FontAsset.hx">
		<extends path="ceramic.Asset"/>
		<_dox_event_replaceFont public="1" set="method" line="637">
			<f a="newFont:prevFont">
				<c path="ceramic.BitmapFont"/>
				<c path="ceramic.BitmapFont"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_replaceFont>
		<emitReplaceFont set="method" line="1095">
			<f a="newFont:prevFont">
				<c path="ceramic.BitmapFont"/>
				<c path="ceramic.BitmapFont"/>
				<x path="Void"/>
			</f>
			<haxe_doc>replaceFont event</haxe_doc>
		</emitReplaceFont>
		<onReplaceFont public="1" set="method" line="1199">
			<f a="owner:handleNewFontPrevFont">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newFont:prevFont">
					<c path="ceramic.BitmapFont"/>
					<c path="ceramic.BitmapFont"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceFont event</haxe_doc>
		</onReplaceFont>
		<onceReplaceFont public="1" set="method" line="1298">
			<f a="owner:handleNewFontPrevFont">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newFont:prevFont">
					<c path="ceramic.BitmapFont"/>
					<c path="ceramic.BitmapFont"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceFont event</haxe_doc>
		</onceReplaceFont>
		<offReplaceFont public="1" set="method" line="1368">
			<f a="?handleNewFontPrevFont">
				<f a="newFont:prevFont">
					<c path="ceramic.BitmapFont"/>
					<c path="ceramic.BitmapFont"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceFont event</haxe_doc>
		</offReplaceFont>
		<listensReplaceFont public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to replaceFont event</haxe_doc>
		</listensReplaceFont>
		<fontData public="1" expr="null">
			<c path="ceramic.BitmapFontData"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</fontData>
		<pages public="1" expr="null">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.Texture"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</pages>
		<invalidateFont public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateFont>
		<font public="1" expr="null">
			<c path="ceramic.BitmapFont"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</font>
		<unobservedFont>
			<c path="ceramic.BitmapFont"/>
			<haxe_doc></haxe_doc>
		</unobservedFont>
		<_dox_event_fontChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.BitmapFont"/>
				<c path="ceramic.BitmapFont"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when font field changes.</haxe_doc>
		</_dox_event_fontChange>
		<emitFontChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.BitmapFont"/>
				<c path="ceramic.BitmapFont"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when font field changes.</haxe_doc>
		</emitFontChange>
		<onFontChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.BitmapFont"/>
					<c path="ceramic.BitmapFont"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when font field changes.</haxe_doc>
		</onFontChange>
		<onceFontChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.BitmapFont"/>
					<c path="ceramic.BitmapFont"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when font field changes.</haxe_doc>
		</onceFontChange>
		<offFontChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.BitmapFont"/>
					<c path="ceramic.BitmapFont"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when font field changes.</haxe_doc>
		</offFontChange>
		<listensFontChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when font field changes.</haxe_doc>
		</listensFontChange>
		<load public="1" set="method" line="31" override="1"><f a=""><x path="Void"/></f></load>
		<texturesDensityDidChange set="method" line="196" override="1"><f a="newDensity:prevDensity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texturesDensityDidChange>
		<checkTexturesDensity set="method" line="207"><f a=""><x path="Void"/></f></checkTexturesDensity>
		<assetFilesDidChange set="method" line="222" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="243" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="22"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Value" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Value.hx">
		<value public="1"><c path="ceramic.Value.T"/></value>
		<new public="1" set="method" line="10"><f a="?value">
	<c path="ceramic.Value.T"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* An object that can hold any value</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Fragment" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Fragment.hx">
		<extends path="ceramic.Layer"/>
		<basicTypes expr="[&quot;Bool&quot; =&gt; true, &quot;Int&quot; =&gt; true, &quot;Float&quot; =&gt; true, &quot;String&quot; =&gt; true, &quot;ceramic.Color&quot; =&gt; true, &quot;ceramic.ScriptContent&quot; =&gt; true]" line="136" static="1">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<meta><m n=":value"><e><![CDATA[["Bool" => true, "Int" => true, "Float" => true, "String" => true, "ceramic.Color" => true, "ceramic.ScriptContent" => true]]]></e></m></meta>
		</basicTypes>
		<cachedFragmentData expr="new Map()" line="147" static="1">
			<t path="Map">
				<c path="String"/>
				<t path="ceramic.FragmentData"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</cachedFragmentData>
		<cacheData public="1" set="method" line="149" static="1"><f a="fragmentData">
	<t path="ceramic.FragmentData"/>
	<x path="Void"/>
</f></cacheData>
		<getData public="1" set="method" line="162" static="1">
			<f a="fragmentId">
				<c path="String"/>
				<x path="Null"><t path="ceramic.FragmentData"/></x>
			</f>
			<haxe_doc><![CDATA[* A static helper to get a fragment data object from fragment id.
     * Fragments need to be cached first with `cacheFragmentData()`,
     * unless an editor instance is being active.
     * @param fragmentId
     * @return Null<FragmentData>]]></haxe_doc>
		</getData>
		<_trackResult expr="new Value&lt;TimelineTrack&lt;TimelineKeyframe&gt;&gt;()" line="948" static="1">
			<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
			<meta><m n=":value"><e><![CDATA[new Value<TimelineTrack<TimelineKeyframe>>()]]></e></m></meta>
			<haxe_doc>* Internal value used to hold timeline tracks created from `createTrack` events</haxe_doc>
		</_trackResult>
		<_keyframeResult expr="new Value&lt;TimelineKeyframe&gt;()" line="953" static="1">
			<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
			<meta><m n=":value"><e><![CDATA[new Value<TimelineKeyframe>()]]></e></m></meta>
			<haxe_doc>* Internal value used to hold timeline keyframes created from `createKeyframe` events</haxe_doc>
		</_keyframeResult>
		<_usedKeyframes expr="[]" line="959" static="1">
			<c path="Array"><c path="ceramic.TimelineKeyframe"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal list used to keep track of used keyframes when updating a track,
     * then be able to remove the keyframes that are not used anymore</haxe_doc>
		</_usedKeyframes>
		<_dox_event_floatAChange public="1" set="method" line="637">
			<f a="floatA:prevFloatA">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_floatAChange>
		<emitFloatAChange set="method" line="1095">
			<f a="floatA:prevFloatA">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>floatAChange event</haxe_doc>
		</emitFloatAChange>
		<onFloatAChange public="1" set="method" line="1199">
			<f a="owner:handleFloatAPrevFloatA">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatA:prevFloatA">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatAChange event</haxe_doc>
		</onFloatAChange>
		<onceFloatAChange public="1" set="method" line="1298">
			<f a="owner:handleFloatAPrevFloatA">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatA:prevFloatA">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatAChange event</haxe_doc>
		</onceFloatAChange>
		<offFloatAChange public="1" set="method" line="1368">
			<f a="?handleFloatAPrevFloatA">
				<f a="floatA:prevFloatA">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatAChange event</haxe_doc>
		</offFloatAChange>
		<listensFloatAChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to floatAChange event</haxe_doc>
		</listensFloatAChange>
		<_dox_event_floatBChange public="1" set="method" line="637">
			<f a="floatB:prevFloatB">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_floatBChange>
		<emitFloatBChange set="method" line="1095">
			<f a="floatB:prevFloatB">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>floatBChange event</haxe_doc>
		</emitFloatBChange>
		<onFloatBChange public="1" set="method" line="1199">
			<f a="owner:handleFloatBPrevFloatB">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatB:prevFloatB">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatBChange event</haxe_doc>
		</onFloatBChange>
		<onceFloatBChange public="1" set="method" line="1298">
			<f a="owner:handleFloatBPrevFloatB">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatB:prevFloatB">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatBChange event</haxe_doc>
		</onceFloatBChange>
		<offFloatBChange public="1" set="method" line="1368">
			<f a="?handleFloatBPrevFloatB">
				<f a="floatB:prevFloatB">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatBChange event</haxe_doc>
		</offFloatBChange>
		<listensFloatBChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to floatBChange event</haxe_doc>
		</listensFloatBChange>
		<_dox_event_floatCChange public="1" set="method" line="637">
			<f a="floatC:prevFloatC">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_floatCChange>
		<emitFloatCChange set="method" line="1095">
			<f a="floatC:prevFloatC">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>floatCChange event</haxe_doc>
		</emitFloatCChange>
		<onFloatCChange public="1" set="method" line="1199">
			<f a="owner:handleFloatCPrevFloatC">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatC:prevFloatC">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatCChange event</haxe_doc>
		</onFloatCChange>
		<onceFloatCChange public="1" set="method" line="1298">
			<f a="owner:handleFloatCPrevFloatC">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatC:prevFloatC">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatCChange event</haxe_doc>
		</onceFloatCChange>
		<offFloatCChange public="1" set="method" line="1368">
			<f a="?handleFloatCPrevFloatC">
				<f a="floatC:prevFloatC">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatCChange event</haxe_doc>
		</offFloatCChange>
		<listensFloatCChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to floatCChange event</haxe_doc>
		</listensFloatCChange>
		<_dox_event_floatDChange public="1" set="method" line="637">
			<f a="floatD:prevFloatD">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_floatDChange>
		<emitFloatDChange set="method" line="1095">
			<f a="floatD:prevFloatD">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>floatDChange event</haxe_doc>
		</emitFloatDChange>
		<onFloatDChange public="1" set="method" line="1199">
			<f a="owner:handleFloatDPrevFloatD">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatD:prevFloatD">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatDChange event</haxe_doc>
		</onFloatDChange>
		<onceFloatDChange public="1" set="method" line="1298">
			<f a="owner:handleFloatDPrevFloatD">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatD:prevFloatD">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatDChange event</haxe_doc>
		</onceFloatDChange>
		<offFloatDChange public="1" set="method" line="1368">
			<f a="?handleFloatDPrevFloatD">
				<f a="floatD:prevFloatD">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatDChange event</haxe_doc>
		</offFloatDChange>
		<listensFloatDChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to floatDChange event</haxe_doc>
		</listensFloatDChange>
		<_dox_event_location public="1" set="method" line="637">
			<f a="location">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Emit this event to change current location.
     * Behavior depends on how this event is handled and does nothing by default.</haxe_doc>
		</_dox_event_location>
		<emitLocation public="1" set="method" line="1095">
			<f a="location">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Emit this event to change current location.
     * Behavior depends on how this event is handled and does nothing by default.</haxe_doc>
		</emitLocation>
		<onLocation public="1" set="method" line="1199">
			<f a="owner:handleLocation">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="location">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Emit this event to change current location.
     * Behavior depends on how this event is handled and does nothing by default.</haxe_doc>
		</onLocation>
		<onceLocation public="1" set="method" line="1298">
			<f a="owner:handleLocation">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="location">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Emit this event to change current location.
     * Behavior depends on how this event is handled and does nothing by default.</haxe_doc>
		</onceLocation>
		<offLocation public="1" set="method" line="1368">
			<f a="?handleLocation">
				<f a="location">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Emit this event to change current location.
     * Behavior depends on how this event is handled and does nothing by default.</haxe_doc>
		</offLocation>
		<listensLocation public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Emit this event to change current location.
     * Behavior depends on how this event is handled and does nothing by default.</haxe_doc>
		</listensLocation>
		<editedItems public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</editedItems>
		<assets public="1" set="null" expr="null">
			<c path="ceramic.Assets"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</assets>
		<entities public="1" set="null"><c path="Array"><c path="ceramic.Entity"/></c></entities>
		<items public="1" set="null"><c path="Array"><t path="ceramic.FragmentItem"/></c></items>
		<tracks public="1" set="null"><c path="Array"><t path="ceramic.TimelineTrackData"/></c></tracks>
		<fps public="1" set="accessor" expr="30">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
		</fps>
		<fragmentData public="1" set="accessor" expr="null">
			<t path="ceramic.FragmentData"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="editable"/>
			</meta>
		</fragmentData>
		<resizable public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="editable"/>
			</meta>
		</resizable>
		<autoUpdateTimeline public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="editable"/>
			</meta>
		</autoUpdateTimeline>
		<set_autoUpdateTimeline set="method" line="54"><f a="autoUpdateTimeline">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoUpdateTimeline>
		<floatA public="1" set="accessor" expr="0.0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.0</e></m>
				<m n="editable"><e>{ group : "floatsAB" }</e></m>
			</meta>
			<haxe_doc>* Custom float value that can be used in editor</haxe_doc>
		</floatA>
		<set_floatA set="method" line="69"><f a="floatA">
	<x path="Float"/>
	<x path="Float"/>
</f></set_floatA>
		<floatB public="1" set="accessor" expr="0.0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.0</e></m>
				<m n="editable"><e>{ group : "floatsAB" }</e></m>
			</meta>
			<haxe_doc>* Custom float value that can be used in editor</haxe_doc>
		</floatB>
		<set_floatB set="method" line="83"><f a="floatB">
	<x path="Float"/>
	<x path="Float"/>
</f></set_floatB>
		<floatC public="1" set="accessor" expr="0.0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.0</e></m>
				<m n="editable"><e>{ group : "floatsCD" }</e></m>
			</meta>
			<haxe_doc>* Custom float value that can be used in editor</haxe_doc>
		</floatC>
		<set_floatC set="method" line="97"><f a="floatC">
	<x path="Float"/>
	<x path="Float"/>
</f></set_floatC>
		<floatD public="1" set="accessor" expr="0.0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.0</e></m>
				<m n="editable"><e>{ group : "floatsCD" }</e></m>
			</meta>
			<haxe_doc>* Custom float value that can be used in editor</haxe_doc>
		</floatD>
		<set_floatD set="method" line="111"><f a="floatD">
	<x path="Float"/>
	<x path="Float"/>
</f></set_floatD>
		<pendingLoads public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pendingLoads>
		<timeline public="1" expr="null">
			<c path="ceramic.Timeline"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</timeline>
		<_dox_event_ready public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_ready>
		<emitReady set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>ready event</haxe_doc>
		</emitReady>
		<onReady public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>ready event</haxe_doc>
		</onReady>
		<onceReady public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>ready event</haxe_doc>
		</onceReady>
		<offReady public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>ready event</haxe_doc>
		</offReady>
		<listensReady public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to ready event</haxe_doc>
		</listensReady>
		<set_fragmentData set="method" line="205"><f a="fragmentData">
	<t path="ceramic.FragmentData"/>
	<t path="ceramic.FragmentData"/>
</f></set_fragmentData>
		<set_fps set="method" line="348"><f a="fps">
	<x path="Int"/>
	<x path="Int"/>
</f></set_fps>
		<putItem public="1" set="method" line="366"><f a="item">
	<t path="ceramic.FragmentItem"/>
	<c path="ceramic.Entity"/>
</f></putItem>
		<putItemField set="method" line="525"><f a="isFragment:item:instance:field:value:converter">
	<x path="Bool"/>
	<t path="ceramic.FragmentItem"/>
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<d/>
	<c path="ceramic.ConvertField">
		<d/>
		<d/>
	</c>
	<x path="Void"/>
</f></putItemField>
		<get public="1" set="method" line="625"><f a="itemId">
	<c path="String"/>
	<c path="ceramic.Entity"/>
</f></get>
		<getItemInstanceByName public="1" set="method" line="639">
			<f a="name">
				<c path="String"/>
				<c path="ceramic.Entity"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":deprecated"/>
			</meta>
		</getItemInstanceByName>
		<getItem public="1" set="method" line="652"><f a="itemId">
	<c path="String"/>
	<t path="ceramic.FragmentItem"/>
</f></getItem>
		<getItemByName public="1" set="method" line="665"><f a="name">
	<c path="String"/>
	<t path="ceramic.FragmentItem"/>
</f></getItemByName>
		<typeOfItem public="1" set="method" line="678"><f a="itemId">
	<c path="String"/>
	<c path="String"/>
</f></typeOfItem>
		<removeItem public="1" set="method" line="691"><f a="itemId">
	<c path="String"/>
	<x path="Void"/>
</f></removeItem>
		<removeAllItems public="1" set="method" line="714"><f a=""><x path="Void"/></f></removeAllItems>
		<destroy public="1" set="method" line="731" override="1"><f a=""><x path="Void"/></f></destroy>
		<set_components set="method" line="856" override="1"><f a="components">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</x>
</f></set_components>
		<fragmentComponents public="1" set="accessor" expr="null">
			<x path="ceramic.ReadOnlyMap">
				<c path="String"/>
				<c path="ceramic.Component"/>
			</x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Fragment components mapping. Does not contain components
     * created separatelywith `component()` or macro-based components or components property.</haxe_doc>
		</fragmentComponents>
		<set_fragmentComponents set="method" line="901"><f a="fragmentComponents">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</x>
</f></set_fragmentComponents>
		<isManagedComponent set="method" line="939"><f a=""><x path="Void"/></f></isManagedComponent>
		<putTrack public="1" set="method" line="968">
			<f a="?entityType:track">
				<c path="String"/>
				<t path="ceramic.TimelineTrackData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create or update a timeline track from the provided track data
     * @param entityType
     *      (optional) entity type being targeted by the track.
     *      If not provided, will try to resolve it from track's target entity id
     * @param track Track data used to create or update timeline track</haxe_doc>
		</putTrack>
		<putTracksForItem set="method" line="1164"><f a="itemId">
	<c path="String"/>
	<x path="Void"/>
</f></putTracksForItem>
		<getTrack public="1" set="method" line="1177"><f a="entity:field">
	<c path="String"/>
	<c path="String"/>
	<t path="ceramic.TimelineTrackData"/>
</f></getTrack>
		<removeTrack public="1" set="method" line="1191"><f a="entity:field">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></removeTrack>
		<createTimelineIfNeeded public="1" set="method" line="1220"><f a=""><x path="Void"/></f></createTimelineIfNeeded>
		<putLabel public="1" set="method" line="1235">
			<f a="index:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create or update a timeline label from the provided label index and name
     * @param index Label index (position)
     * @param name Label name</haxe_doc>
		</putLabel>
		<indexOfLabel public="1" set="method" line="1250">
			<f a="name">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Return the index (position) of the given label name or -1 if no such label exists.
     * @param name
     * @return Int</haxe_doc>
		</indexOfLabel>
		<labelAtIndex public="1" set="method" line="1265">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return the label at the given index (position), if any exists.
     * @param index
     * @return Int</haxe_doc>
		</labelAtIndex>
		<removeLabel public="1" set="method" line="1279">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove label with the given name
     * @param name Label name</haxe_doc>
		</removeLabel>
		<removeLabelAtIndex public="1" set="method" line="1291">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove label at the given index (position)
     * @param index Label index</haxe_doc>
		</removeLabelAtIndex>
		<paused public="1" get="accessor" set="accessor"><x path="Bool"/></paused>
		<get_paused set="method" line="1300"><f a=""><x path="Bool"/></f></get_paused>
		<set_paused set="method" line="1303"><f a="paused">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_paused>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="187">
			<f a="?assets:?editedItems" v=":false">
				<c path="ceramic.Assets"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ editedItems : false }</e></m></meta>
		</new>
		<haxe_doc>* A fragment is a group of visuals rendered from data (.fragment file)</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n="editable"><e>{ implicitSizeUnlessTrue : "resizable" }</e></m>
		</meta>
	</class>
	<typedef path="ceramic.FragmentData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FragmentData.hx"><a>
	<width>
		<x path="Float"/>
		<haxe_doc>* Fragment width</haxe_doc>
	</width>
	<transparent>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Fragment being transparent or not (default `true`)</haxe_doc>
	</transparent>
	<tracks>
		<x path="Null"><c path="Array"><t path="ceramic.TimelineTrackData"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Timeline tracks</haxe_doc>
	</tracks>
	<overflow>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Whether fragment background overflows (no effect on fragment itself, depends on player implementation)</haxe_doc>
	</overflow>
	<labels>
		<x path="Null"><x path="haxe.DynamicAccess"><x path="Int"/></x></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Timeline labels</haxe_doc>
	</labels>
	<items>
		<x path="Null"><c path="Array"><t path="ceramic.FragmentItem"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Fragment items (visuals or other entities)</haxe_doc>
	</items>
	<id>
		<c path="String"/>
		<haxe_doc>* Identifier of the fragment.</haxe_doc>
	</id>
	<height>
		<x path="Float"/>
		<haxe_doc>* Fragment height</haxe_doc>
	</height>
	<fps>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Frames per second (used in timeline, default is 30).
     * Note that this is only affecting how long a frame in the timeline lasts.
     * Using 30FPS doesn't mean the screen will be rendered at 30FPS.
     * Frame values are interpolated to match screen frame rate.</haxe_doc>
	</fps>
	<data>
		<d><d/></d>
		<haxe_doc>* Arbitrary data hold by this fragment.</haxe_doc>
	</data>
	<components>
		<x path="haxe.DynamicAccess"><c path="String"/></x>
		<haxe_doc>* Fragment-level components</haxe_doc>
	</components>
	<color>
		<x path="Null"><x path="ceramic.Color"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Fragment color (if not transparent, default `BLACK`)</haxe_doc>
	</color>
</a></typedef>
	<typedef path="ceramic.FragmentItem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FragmentItem.hx"><a>
	<props>
		<d><d/></d>
		<haxe_doc>* Properties assigned after creating entity.</haxe_doc>
	</props>
	<name>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Entity name.</haxe_doc>
	</name>
	<id>
		<c path="String"/>
		<haxe_doc>* Entity identifier.</haxe_doc>
	</id>
	<entity>
		<c path="String"/>
		<haxe_doc>* Entity class (ex: ceramic.Visual, ceramic.Quad, ...).</haxe_doc>
	</entity>
	<data>
		<x path="Null"><d><d/></d></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Arbitrary data hold by this item.</haxe_doc>
	</data>
	<components>
		<d><c path="String"/></d>
		<haxe_doc>* Entity components.</haxe_doc>
	</components>
</a></typedef>
	<class path="ceramic.Fragments" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Fragments.hx"><meta><m n=":build"><e>ceramic.macros.AssetsMacro.buildNames("fragments")</e></m></meta></class>
	<class path="ceramic.FragmentsAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FragmentsAsset.hx">
		<extends path="ceramic.Asset"/>
		<invalidateFragments public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateFragments>
		<fragments public="1" expr="null">
			<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</fragments>
		<unobservedFragments>
			<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
			<haxe_doc></haxe_doc>
		</unobservedFragments>
		<_dox_event_fragmentsChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
				<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when fragments field changes.</haxe_doc>
		</_dox_event_fragmentsChange>
		<emitFragmentsChange set="method" line="1095">
			<f a="current:previous">
				<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
				<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when fragments field changes.</haxe_doc>
		</emitFragmentsChange>
		<onFragmentsChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
					<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fragments field changes.</haxe_doc>
		</onFragmentsChange>
		<onceFragmentsChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
					<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fragments field changes.</haxe_doc>
		</onceFragmentsChange>
		<offFragmentsChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
					<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fragments field changes.</haxe_doc>
		</offFragmentsChange>
		<listensFragmentsChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fragments field changes.</haxe_doc>
		</listensFragmentsChange>
		<load public="1" set="method" line="17" override="1"><f a=""><x path="Void"/></f></load>
		<assetFilesDidChange set="method" line="68" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="89" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="11"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.GamepadAxis" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GamepadAxis.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._GamepadAxis.GamepadAxis_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GamepadAxis.hx" private="1" module="ceramic.GamepadAxis" final="1">
	<LEFT_X public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="ceramic.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT_X>
	<LEFT_Y public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="ceramic.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT_Y>
	<RIGHT_X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="ceramic.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT_X>
	<RIGHT_Y public="1" get="inline" set="null" expr="cast 3" line="11" static="1">
		<x path="ceramic.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT_Y>
	<LEFT_TRIGGER public="1" get="inline" set="null" expr="cast 4" line="13" static="1">
		<x path="ceramic.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT_TRIGGER>
	<RIGHT_TRIGGER public="1" get="inline" set="null" expr="cast 5" line="15" static="1">
		<x path="ceramic.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT_TRIGGER>
	<toString get="inline" set="null" line="17" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._GamepadAxis.GamepadAxis_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GamepadAxis.hx" private="1" module="ceramic.GamepadAxis" final="1">
		<LEFT_X public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="ceramic.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT_X>
		<LEFT_Y public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="ceramic.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT_Y>
		<RIGHT_X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="ceramic.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT_X>
		<RIGHT_Y public="1" get="inline" set="null" expr="cast 3" line="11" static="1">
			<x path="ceramic.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT_Y>
		<LEFT_TRIGGER public="1" get="inline" set="null" expr="cast 4" line="13" static="1">
			<x path="ceramic.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT_TRIGGER>
		<RIGHT_TRIGGER public="1" get="inline" set="null" expr="cast 5" line="15" static="1">
			<x path="ceramic.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT_TRIGGER>
		<toString get="inline" set="null" line="17" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="ceramic.GamepadButton" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GamepadButton.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._GamepadButton.GamepadButton_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GamepadButton.hx" private="1" module="ceramic.GamepadButton" final="1">
	<A public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</A>
	<B public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</B>
	<X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</X>
	<Y public="1" get="inline" set="null" expr="cast 3" line="11" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Y>
	<L1 public="1" get="inline" set="null" expr="cast 4" line="13" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</L1>
	<R1 public="1" get="inline" set="null" expr="cast 5" line="15" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</R1>
	<L2 public="1" get="inline" set="null" expr="cast 6" line="17" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</L2>
	<R2 public="1" get="inline" set="null" expr="cast 7" line="19" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</R2>
	<SELECT public="1" get="inline" set="null" expr="cast 8" line="21" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SELECT>
	<START public="1" get="inline" set="null" expr="cast 9" line="23" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</START>
	<L3 public="1" get="inline" set="null" expr="cast 10" line="25" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</L3>
	<R3 public="1" get="inline" set="null" expr="cast 11" line="27" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</R3>
	<DPAD_UP public="1" get="inline" set="null" expr="cast 12" line="29" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DPAD_UP>
	<DPAD_DOWN public="1" get="inline" set="null" expr="cast 13" line="31" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DPAD_DOWN>
	<DPAD_LEFT public="1" get="inline" set="null" expr="cast 14" line="33" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DPAD_LEFT>
	<DPAD_RIGHT public="1" get="inline" set="null" expr="cast 15" line="35" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DPAD_RIGHT>
	<toString get="inline" set="null" line="37" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._GamepadButton.GamepadButton_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GamepadButton.hx" private="1" module="ceramic.GamepadButton" final="1">
		<A public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</A>
		<B public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</B>
		<X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</X>
		<Y public="1" get="inline" set="null" expr="cast 3" line="11" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Y>
		<L1 public="1" get="inline" set="null" expr="cast 4" line="13" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</L1>
		<R1 public="1" get="inline" set="null" expr="cast 5" line="15" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</R1>
		<L2 public="1" get="inline" set="null" expr="cast 6" line="17" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</L2>
		<R2 public="1" get="inline" set="null" expr="cast 7" line="19" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</R2>
		<SELECT public="1" get="inline" set="null" expr="cast 8" line="21" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SELECT>
		<START public="1" get="inline" set="null" expr="cast 9" line="23" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</START>
		<L3 public="1" get="inline" set="null" expr="cast 10" line="25" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</L3>
		<R3 public="1" get="inline" set="null" expr="cast 11" line="27" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</R3>
		<DPAD_UP public="1" get="inline" set="null" expr="cast 12" line="29" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" expr="cast 13" line="31" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" expr="cast 14" line="33" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="cast 15" line="35" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DPAD_RIGHT>
		<toString get="inline" set="null" line="37" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="ceramic.GeometryUtils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GeometryUtils.hx">
		<pointInTriangle public="1" set="method" line="11" static="1">
			<f a="x:y:ax:ay:bx:by:cx:cy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns `true` if the point `(x,y)` is inside the given (a,b,c) triangle</haxe_doc>
		</pointInTriangle>
		<pointInRectangle public="1" set="method" line="31" static="1">
			<f a="x:y:rectX:rectY:rectWidth:rectHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns `true` if the point `(x,y)` is inside the given (rectX, rectY, rectWidth, rectHeight) rectangle</haxe_doc>
		</pointInRectangle>
		<pointInCircle public="1" get="inline" set="null" line="49" static="1">
			<f a="x:y:cx:cy:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns `true` if the point `(x,y)` is inside the given (cx, cy, radius) circle</haxe_doc>
		</pointInCircle>
		<distance public="1" get="inline" set="null" line="58" static="1">
			<f a="x1:y1:x2:y2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the distance between point (x1, y1) and point (x2, y2)</haxe_doc>
		</distance>
		<squareDistance public="1" get="inline" set="null" line="72" static="1">
			<f a="x1:y1:x2:y2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the square of the distance between point (x1, y1) and point (x2, y2)
     * It is expected to be used to simply compare two different distances when you
     * don't need the actual distance value (that needs sqrt call).</haxe_doc>
		</squareDistance>
		<angleTo public="1" set="method" line="84" static="1">
			<f a="x0:y0:x1:y1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the angle between (x0, y0) and (x1, y1) in degrees.</haxe_doc>
		</angleTo>
		<angleDelta public="1" set="method" line="98" static="1">
			<f a="angle0:angle1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the delta between `angle0` and `angle1`, all values being angles in degrees.</haxe_doc>
		</angleDelta>
		<clampDegrees public="1" set="method" line="119" static="1">
			<f a="deg">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Clamp an degrees (angle) value between 0 (included) and 360 (excluded)</haxe_doc>
		</clampDegrees>
		<angleDirection public="1" set="method" line="139" static="1">
			<f a="angle:result">
				<x path="Float"/>
				<c path="ceramic.Point"/>
				<c path="ceramic.Point"/>
			</f>
			<haxe_doc>* Set the given result's `x` and `y` values so that it's a vector representing
     * a direction matching the angle (in degrees)
     * @param angle The angle to compute the direction from
     * @param result The vector (a `Point` object) receiving the result</haxe_doc>
		</angleDirection>
		<haxe_doc>* Geometry-related utilities.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.GlyphQuad" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GlyphQuad.hx">
		<extends path="ceramic.Quad"/>
		<_dox_event_clear public="1" set="method" line="637">
			<f a="quad">
				<c path="ceramic.GlyphQuad"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_clear>
		<emitClear set="method" line="1095">
			<f a="quad">
				<c path="ceramic.GlyphQuad"/>
				<x path="Void"/>
			</f>
			<haxe_doc>clear event</haxe_doc>
		</emitClear>
		<onClear public="1" set="method" line="1199">
			<f a="owner:handleQuad">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="quad">
					<c path="ceramic.GlyphQuad"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>clear event</haxe_doc>
		</onClear>
		<onceClear public="1" set="method" line="1298">
			<f a="owner:handleQuad">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="quad">
					<c path="ceramic.GlyphQuad"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>clear event</haxe_doc>
		</onceClear>
		<offClear public="1" set="method" line="1368">
			<f a="?handleQuad">
				<f a="quad">
					<c path="ceramic.GlyphQuad"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>clear event</haxe_doc>
		</offClear>
		<listensClear public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to clear event</haxe_doc>
		</listensClear>
		<char public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</char>
		<glyph public="1" expr="null">
			<c path="ceramic.BitmapFontCharacter"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</glyph>
		<index public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</index>
		<posInLine public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</posInLine>
		<line public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</line>
		<code public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</code>
		<glyphX public="1" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</glyphX>
		<glyphY public="1" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</glyphY>
		<glyphAdvance public="1" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</glyphAdvance>
		<toString set="method" line="27" override="1"><f a=""><c path="String"/></f></toString>
		<clear public="1" set="method" line="33" override="1"><f a=""><x path="Void"/></f></clear>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Group" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Group.hx">
		<extends path="ceramic.Entity"/>
		<items public="1" expr="[]">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.Group.T"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
		</items>
		<add public="1" set="method" line="36"><f a="item">
	<c path="ceramic.Group.T"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method" line="51"><f a="item">
	<c path="ceramic.Group.T"/>
	<x path="Void"/>
</f></remove>
		<contains public="1" get="inline" set="null" line="66"><f a="item">
	<c path="ceramic.Group.T"/>
	<x path="Bool"/>
</f></contains>
		<itemDestroyed set="method" line="72"><f a="item">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></itemDestroyed>
		<clear public="1" set="method" line="78"><f a=""><x path="Void"/></f></clear>
		<destroy public="1" set="method" line="100" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="24"><f a="?id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A group of entities, which is itself an entity.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.HashedString" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/HashedString.hx">
		<_lastDecodeIncomplete expr="false" line="16" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_lastDecodeIncomplete>
		<encode public="1" set="method" line="21" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Encode the given string `str` and return the result.</haxe_doc>
		</encode>
		<append public="1" set="method" line="34" static="1">
			<f a="encoded:str">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Encode and append `str` to the already encoded string `encoded` and return the results.
     * This is equivalent to `result = encoded + HashedString.encode(str)`</haxe_doc>
		</append>
		<decode public="1" set="method" line="43" static="1">
			<f a="encoded">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Decode the given `encoded` string and return the result.</haxe_doc>
		</decode>
		<isLastDecodeIncomplete public="1" get="inline" set="null" line="102"><f a=""><x path="Bool"/></f></isLastDecodeIncomplete>
		<haxe_doc>* An utility to encode strings with hashes, allowing to check their validity on decode.</haxe_doc>
	</class>
	<class path="ceramic.ImageAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ImageAsset.hx">
		<extends path="ceramic.Asset"/>
		<_dox_event_replaceTexture public="1" set="method" line="637">
			<f a="newTexture:prevTexture">
				<c path="ceramic.Texture"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_replaceTexture>
		<emitReplaceTexture set="method" line="1095">
			<f a="newTexture:prevTexture">
				<c path="ceramic.Texture"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>replaceTexture event</haxe_doc>
		</emitReplaceTexture>
		<onReplaceTexture public="1" set="method" line="1199">
			<f a="owner:handleNewTexturePrevTexture">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newTexture:prevTexture">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceTexture event</haxe_doc>
		</onReplaceTexture>
		<onceReplaceTexture public="1" set="method" line="1298">
			<f a="owner:handleNewTexturePrevTexture">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newTexture:prevTexture">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceTexture event</haxe_doc>
		</onceReplaceTexture>
		<offReplaceTexture public="1" set="method" line="1368">
			<f a="?handleNewTexturePrevTexture">
				<f a="newTexture:prevTexture">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceTexture event</haxe_doc>
		</offReplaceTexture>
		<listensReplaceTexture public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to replaceTexture event</haxe_doc>
		</listensReplaceTexture>
		<invalidateTexture public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTexture>
		<texture public="1" expr="null">
			<c path="ceramic.Texture"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</texture>
		<unobservedTexture>
			<c path="ceramic.Texture"/>
			<haxe_doc></haxe_doc>
		</unobservedTexture>
		<_dox_event_textureChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.Texture"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</_dox_event_textureChange>
		<emitTextureChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.Texture"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</emitTextureChange>
		<onTextureChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</onTextureChange>
		<onceTextureChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</onceTextureChange>
		<offTextureChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</offTextureChange>
		<listensTextureChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</listensTextureChange>
		<defaultImageOptions expr="null">
			<t path="ceramic.AssetOptions"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":allow"><e>ceramic.Assets</e></m>
			</meta>
		</defaultImageOptions>
		<reloadBecauseOfDensityChange expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</reloadBecauseOfDensityChange>
		<load public="1" set="method" line="49" override="1"><f a=""><x path="Void"/></f></load>
		<loadTexture set="method" line="164"><f a="path:loadOptions:callback">
	<c path="String"/>
	<t path="ceramic.AssetOptions"/>
	<f a="texture:backendPath">
		<c path="ceramic.Texture"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadTexture>
		<texturesDensityDidChange set="method" line="253" override="1"><f a="newDensity:prevDensity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texturesDensityDidChange>
		<checkTexturesDensity set="method" line="264"><f a=""><x path="Void"/></f></checkTexturesDensity>
		<assetFilesDidChange set="method" line="280" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="301" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="42"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.ImageType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ImageType.hx">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._ImageType.ImageType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ImageType.hx" private="1" module="ceramic.ImageType" extern="1" final="1">
	<PNG public="1" get="inline" set="null" expr="cast &quot;png&quot;" line="5" static="1">
		<x path="ceramic.ImageType"/>
		<meta>
			<m n=":value"><e>cast "png"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PNG>
	<JPEG public="1" get="inline" set="null" expr="cast &quot;jpeg&quot;" line="7" static="1">
		<x path="ceramic.ImageType"/>
		<meta>
			<m n=":value"><e>cast "jpeg"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</JPEG>
	<GIF public="1" get="inline" set="null" expr="cast &quot;gif&quot;" line="9" static="1">
		<x path="ceramic.ImageType"/>
		<meta>
			<m n=":value"><e>cast "gif"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</GIF>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._ImageType.ImageType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ImageType.hx" private="1" module="ceramic.ImageType" extern="1" final="1">
		<PNG public="1" get="inline" set="null" expr="cast &quot;png&quot;" line="5" static="1">
			<x path="ceramic.ImageType"/>
			<meta>
				<m n=":value"><e>cast "png"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PNG>
		<JPEG public="1" get="inline" set="null" expr="cast &quot;jpeg&quot;" line="7" static="1">
			<x path="ceramic.ImageType"/>
			<meta>
				<m n=":value"><e>cast "jpeg"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</JPEG>
		<GIF public="1" get="inline" set="null" expr="cast &quot;gif&quot;" line="9" static="1">
			<x path="ceramic.ImageType"/>
			<meta>
				<m n=":value"><e>cast "gif"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</GIF>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="ceramic.Immediate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Immediate.hx">
		<immediateCallbacks expr="[]">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</immediateCallbacks>
		<immediateCallbacksCapacity expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</immediateCallbacksCapacity>
		<immediateCallbacksLen expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</immediateCallbacksLen>
		<push public="1" set="method" line="20">
			<f a="handleImmediate">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Schedule a callback that will be run when flush() is called</haxe_doc>
		</push>
		<flush public="1" set="method" line="39">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Execute and flush every awaiting callback, including the ones that
        could have been added with `push()` after executing the existing callbacks.</haxe_doc>
		</flush>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.InitSettings" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/InitSettings.hx">
		<settings>
			<c path="ceramic.Settings"/>
			<haxe_doc>* App settings</haxe_doc>
		</settings>
		<targetWidth public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Target width. Affects window size at startup
     * and affects screen scaling at any time.
     * Ignored if set to 0 (default)</haxe_doc>
		</targetWidth>
		<get_targetWidth get="inline" set="null" line="28"><f a=""><x path="Int"/></f></get_targetWidth>
		<set_targetWidth get="inline" set="null" line="31"><f a="targetWidth">
	<x path="Int"/>
	<x path="Int"/>
</f></set_targetWidth>
		<targetHeight public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Target height. Affects window size at startup
     * and affects screen scaling at any time.
     * Ignored if set to 0 (default)</haxe_doc>
		</targetHeight>
		<get_targetHeight get="inline" set="null" line="41"><f a=""><x path="Int"/></f></get_targetHeight>
		<set_targetHeight get="inline" set="null" line="44"><f a="targetHeight">
	<x path="Int"/>
	<x path="Int"/>
</f></set_targetHeight>
		<targetSize public="1" get="inline" set="null" line="55">
			<f a="targetWidth:targetHeight">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Target width and height. Affects window size at startup
     * and affects screen scaling at any time.
     * Ignored if set to 0 (default)
     * @param targetWidth Target width
     * @param targetHeight Target height</haxe_doc>
		</targetSize>
		<windowWidth public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Target window width at startup
     * Uses `targetWidth` as fallback if set to 0 (default)</haxe_doc>
		</windowWidth>
		<get_windowWidth get="inline" set="null" line="65"><f a=""><x path="Int"/></f></get_windowWidth>
		<set_windowWidth get="inline" set="null" line="68"><f a="windowWidth">
	<x path="Int"/>
	<x path="Int"/>
</f></set_windowWidth>
		<windowHeight public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Target window height at startup
     * Uses `targetHeight` as fallback if set to 0 (default)</haxe_doc>
		</windowHeight>
		<get_windowHeight get="inline" set="null" line="77"><f a=""><x path="Int"/></f></get_windowHeight>
		<set_windowHeight get="inline" set="null" line="80"><f a="windowHeight">
	<x path="Int"/>
	<x path="Int"/>
</f></set_windowHeight>
		<windowSize public="1" get="inline" set="null" line="90">
			<f a="windowWidth:windowHeight">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Target window width and height at startup
     * Uses `targetWidth` and `targetHeight` as fallback if set to 0 (default)
     * @param windowWidth Window width
     * @param windowHeight Window height</haxe_doc>
		</windowSize>
		<targetDensity public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Target density. Affects the quality of textures
     * being loaded. Changing it at runtime will update
     * texture quality if needed.
     * Ignored if set to 0 (default)</haxe_doc>
		</targetDensity>
		<get_targetDensity get="inline" set="null" line="102"><f a=""><x path="Int"/></f></get_targetDensity>
		<set_targetDensity get="inline" set="null" line="105"><f a="targetDensity">
	<x path="Int"/>
	<x path="Int"/>
</f></set_targetDensity>
		<background public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<haxe_doc>* Background color.</haxe_doc>
		</background>
		<get_background get="inline" set="null" line="113"><f a=""><x path="ceramic.Color"/></f></get_background>
		<set_background get="inline" set="null" line="116"><f a="background">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_background>
		<scaling public="1" get="accessor" set="accessor">
			<e path="ceramic.ScreenScaling"/>
			<haxe_doc>* Screen scaling (FIT, FILL, RESIZE, FIT_RESIZE).</haxe_doc>
		</scaling>
		<get_scaling get="inline" set="null" line="124"><f a=""><e path="ceramic.ScreenScaling"/></f></get_scaling>
		<set_scaling get="inline" set="null" line="127"><f a="scaling">
	<e path="ceramic.ScreenScaling"/>
	<e path="ceramic.ScreenScaling"/>
</f></set_scaling>
		<title public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* App window title.</haxe_doc>
		</title>
		<get_title get="inline" set="null" line="135"><f a=""><c path="String"/></f></get_title>
		<set_title get="inline" set="null" line="138"><f a="title">
	<c path="String"/>
	<c path="String"/>
</f></set_title>
		<fullscreen public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Fullscreen enabled or not.</haxe_doc>
		</fullscreen>
		<get_fullscreen get="inline" set="null" line="146"><f a=""><x path="Bool"/></f></get_fullscreen>
		<set_fullscreen get="inline" set="null" line="149"><f a="fullscreen">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fullscreen>
		<targetFps public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Target FPS. Using default FPS if value < 1 or try to match the given value if >= 1.]]></haxe_doc>
		</targetFps>
		<get_targetFps get="inline" set="null" line="157"><f a=""><x path="Int"/></f></get_targetFps>
		<set_targetFps get="inline" set="null" line="160"><f a="targetFps">
	<x path="Int"/>
	<x path="Int"/>
</f></set_targetFps>
		<maxDelta public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Maximum app update delta time.
     * During app update (at each frame), `app.delta` will be capped to `maxDelta`
     * if its value is above `maxDelta`.
     * If needed, use `app.realDelta` to get real elapsed time since last frame.</haxe_doc>
		</maxDelta>
		<get_maxDelta get="inline" set="null" line="171"><f a=""><x path="Float"/></f></get_maxDelta>
		<set_maxDelta get="inline" set="null" line="174"><f a="maxDelta">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxDelta>
		<overrideDelta public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Override app update delta time.
     * This can be used to ignore completely the actual elapsed time between frames
     * and replace it with an explicit delta time of your choice.
     * This will affect timers, tween, systems update etc...
     * Use with caution.</haxe_doc>
		</overrideDelta>
		<get_overrideDelta get="inline" set="null" line="186"><f a=""><x path="Float"/></f></get_overrideDelta>
		<set_overrideDelta get="inline" set="null" line="189"><f a="overrideDelta">
	<x path="Float"/>
	<x path="Float"/>
</f></set_overrideDelta>
		<preventDefaultMouseWheel public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* If set to `true` (default). Default mouse wheel events
     * will be prevented. This is relevant when running the ceramic
     * app from an `iframe` inside a page that can scroll.</haxe_doc>
		</preventDefaultMouseWheel>
		<get_preventDefaultMouseWheel get="inline" set="null" line="200"><f a=""><x path="Bool"/></f></get_preventDefaultMouseWheel>
		<set_preventDefaultMouseWheel get="inline" set="null" line="203"><f a="preventDefaultMouseWheel">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_preventDefaultMouseWheel>
		<preventDefaultTouches public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* If set to `true` (default). Default touch events
     * will be prevented. This is relevant when running the ceramic
     * app from an `iframe` inside a page that can scroll,
     * on a touchscreen device.</haxe_doc>
		</preventDefaultTouches>
		<get_preventDefaultTouches get="inline" set="null" line="214"><f a=""><x path="Bool"/></f></get_preventDefaultTouches>
		<set_preventDefaultTouches get="inline" set="null" line="217"><f a="preventDefaultTouches">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_preventDefaultTouches>
		<orientation public="1" get="accessor" set="accessor">
			<x path="ceramic.ScreenOrientation"/>
			<haxe_doc>* Setup screen orientation. Default is `NONE`,
     * meaning nothing is enforced and project defaults will be used.</haxe_doc>
		</orientation>
		<get_orientation get="inline" set="null" line="226"><f a=""><x path="ceramic.ScreenOrientation"/></f></get_orientation>
		<set_orientation get="inline" set="null" line="229"><f a="orientation">
	<x path="ceramic.ScreenOrientation"/>
	<x path="ceramic.ScreenOrientation"/>
</f></set_orientation>
		<antialiasing public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Antialiasing value (0 means disabled).</haxe_doc>
		</antialiasing>
		<get_antialiasing get="inline" set="null" line="237"><f a=""><x path="Int"/></f></get_antialiasing>
		<set_antialiasing get="inline" set="null" line="240"><f a="antialiasing">
	<x path="Int"/>
	<x path="Int"/>
</f></set_antialiasing>
		<collections public="1" get="accessor" set="accessor">
			<f a=""><c path="ceramic.AutoCollections"/></f>
			<haxe_doc>* App collections.</haxe_doc>
		</collections>
		<get_collections get="inline" set="null" line="248"><f a=""><f a=""><c path="ceramic.AutoCollections"/></f></f></get_collections>
		<set_collections get="inline" set="null" line="251"><f a="collections">
	<f a=""><c path="ceramic.AutoCollections"/></f>
	<f a=""><c path="ceramic.AutoCollections"/></f>
</f></set_collections>
		<appInfo public="1" get="accessor" set="accessor">
			<d/>
			<haxe_doc>* App info (useful when dynamically loaded, not needed otherwise).</haxe_doc>
		</appInfo>
		<get_appInfo get="inline" set="null" line="259"><f a=""><d/></f></get_appInfo>
		<set_appInfo get="inline" set="null" line="262"><f a="appInfo">
	<d/>
	<d/>
</f></set_appInfo>
		<resizable public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the window can be resized or not.</haxe_doc>
		</resizable>
		<get_resizable get="inline" set="null" line="270"><f a=""><x path="Bool"/></f></get_resizable>
		<set_resizable get="inline" set="null" line="273"><f a="resizable">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_resizable>
		<assetsPath public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Assets path.</haxe_doc>
		</assetsPath>
		<get_assetsPath get="inline" set="null" line="281"><f a=""><c path="String"/></f></get_assetsPath>
		<set_assetsPath get="inline" set="null" line="284"><f a="assetsPath">
	<c path="String"/>
	<c path="String"/>
</f></set_assetsPath>
		<backend public="1" get="accessor" set="accessor">
			<d/>
			<haxe_doc>* Settings passed to backend.</haxe_doc>
		</backend>
		<get_backend get="inline" set="null" line="292"><f a=""><d/></f></get_backend>
		<set_backend get="inline" set="null" line="295"><f a="backend">
	<d/>
	<d/>
</f></set_backend>
		<defaultFont public="1" get="accessor" set="accessor">
			<x path="ceramic.AssetId"><c path="String"/></x>
			<haxe_doc>* Default font asset</haxe_doc>
		</defaultFont>
		<get_defaultFont get="inline" set="null" line="303"><f a=""><x path="ceramic.AssetId"><c path="String"/></x></f></get_defaultFont>
		<set_defaultFont get="inline" set="null" line="306"><f a="defaultFont">
	<x path="ceramic.AssetId"><c path="String"/></x>
	<x path="ceramic.AssetId"><c path="String"/></x>
</f></set_defaultFont>
		<defaultShader public="1" get="accessor" set="accessor">
			<x path="ceramic.AssetId"><c path="String"/></x>
			<haxe_doc>* Default shader asset</haxe_doc>
		</defaultShader>
		<get_defaultShader get="inline" set="null" line="314"><f a=""><x path="ceramic.AssetId"><c path="String"/></x></f></get_defaultShader>
		<set_defaultShader get="inline" set="null" line="317"><f a="defaultShader">
	<x path="ceramic.AssetId"><c path="String"/></x>
	<x path="ceramic.AssetId"><c path="String"/></x>
</f></set_defaultShader>
		<new set="method" line="16">
			<f a="settings">
				<c path="ceramic.Settings"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>ceramic.App</e></m></meta>
		</new>
		<haxe_doc>* Same as Settings, but for app startup (inside Project.new(settings)).
 * Read-only values can still
 * be edited at that stage.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Input" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Input.hx">
		<extends path="ceramic.Entity"/>
		<GAMEPAD_STORAGE_SIZE final="1" get="inline" set="null" expr="32" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
			<haxe_doc>* Internal value to store gamepad state</haxe_doc>
		</GAMEPAD_STORAGE_SIZE>
		<_dox_event_keyDown public="1" set="method" line="637">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* @event keyDown
     * Triggered when a key from the keyboard is being pressed.
     * @param key The key being pressed</haxe_doc>
		</_dox_event_keyDown>
		<emitKeyDown set="method" line="1095">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @event keyDown
     * Triggered when a key from the keyboard is being pressed.
     * @param key The key being pressed</haxe_doc>
		</emitKeyDown>
		<onKeyDown public="1" set="method" line="1199">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyDown
     * Triggered when a key from the keyboard is being pressed.
     * @param key The key being pressed</haxe_doc>
		</onKeyDown>
		<onceKeyDown public="1" set="method" line="1298">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyDown
     * Triggered when a key from the keyboard is being pressed.
     * @param key The key being pressed</haxe_doc>
		</onceKeyDown>
		<offKeyDown public="1" set="method" line="1368">
			<f a="?handleKey">
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyDown
     * Triggered when a key from the keyboard is being pressed.
     * @param key The key being pressed</haxe_doc>
		</offKeyDown>
		<listensKeyDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyDown
     * Triggered when a key from the keyboard is being pressed.
     * @param key The key being pressed</haxe_doc>
		</listensKeyDown>
		<_dox_event_keyUp public="1" set="method" line="637">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* @event keyUp
     * Triggered when a key from the keyboard is being released.
     * @param key The key being released</haxe_doc>
		</_dox_event_keyUp>
		<emitKeyUp set="method" line="1095">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @event keyUp
     * Triggered when a key from the keyboard is being released.
     * @param key The key being released</haxe_doc>
		</emitKeyUp>
		<onKeyUp public="1" set="method" line="1199">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyUp
     * Triggered when a key from the keyboard is being released.
     * @param key The key being released</haxe_doc>
		</onKeyUp>
		<onceKeyUp public="1" set="method" line="1298">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyUp
     * Triggered when a key from the keyboard is being released.
     * @param key The key being released</haxe_doc>
		</onceKeyUp>
		<offKeyUp public="1" set="method" line="1368">
			<f a="?handleKey">
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyUp
     * Triggered when a key from the keyboard is being released.
     * @param key The key being released</haxe_doc>
		</offKeyUp>
		<listensKeyUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyUp
     * Triggered when a key from the keyboard is being released.
     * @param key The key being released</haxe_doc>
		</listensKeyUp>
		<_dox_event_gamepadAxis public="1" set="method" line="637">
			<f a="gamepadId:axis:value">
				<x path="Int"/>
				<x path="ceramic.GamepadAxis"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadAxis>
		<emitGamepadAxis set="method" line="1095">
			<f a="gamepadId:axis:value">
				<x path="Int"/>
				<x path="ceramic.GamepadAxis"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</emitGamepadAxis>
		<onGamepadAxis public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdAxisValue">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:axis:value">
					<x path="Int"/>
					<x path="ceramic.GamepadAxis"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</onGamepadAxis>
		<onceGamepadAxis public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdAxisValue">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:axis:value">
					<x path="Int"/>
					<x path="ceramic.GamepadAxis"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</onceGamepadAxis>
		<offGamepadAxis public="1" set="method" line="1368">
			<f a="?handleGamepadIdAxisValue">
				<f a="gamepadId:axis:value">
					<x path="Int"/>
					<x path="ceramic.GamepadAxis"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</offGamepadAxis>
		<listensGamepadAxis public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadAxis event</haxe_doc>
		</listensGamepadAxis>
		<_dox_event_gamepadDown public="1" set="method" line="637">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadDown>
		<emitGamepadDown set="method" line="1095">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadDown event</haxe_doc>
		</emitGamepadDown>
		<onGamepadDown public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdButton">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:button">
					<x path="Int"/>
					<x path="ceramic.GamepadButton"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDown event</haxe_doc>
		</onGamepadDown>
		<onceGamepadDown public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdButton">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:button">
					<x path="Int"/>
					<x path="ceramic.GamepadButton"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDown event</haxe_doc>
		</onceGamepadDown>
		<offGamepadDown public="1" set="method" line="1368">
			<f a="?handleGamepadIdButton">
				<f a="gamepadId:button">
					<x path="Int"/>
					<x path="ceramic.GamepadButton"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDown event</haxe_doc>
		</offGamepadDown>
		<listensGamepadDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadDown event</haxe_doc>
		</listensGamepadDown>
		<_dox_event_gamepadUp public="1" set="method" line="637">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadUp>
		<emitGamepadUp set="method" line="1095">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadUp event</haxe_doc>
		</emitGamepadUp>
		<onGamepadUp public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdButton">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:button">
					<x path="Int"/>
					<x path="ceramic.GamepadButton"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadUp event</haxe_doc>
		</onGamepadUp>
		<onceGamepadUp public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdButton">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:button">
					<x path="Int"/>
					<x path="ceramic.GamepadButton"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadUp event</haxe_doc>
		</onceGamepadUp>
		<offGamepadUp public="1" set="method" line="1368">
			<f a="?handleGamepadIdButton">
				<f a="gamepadId:button">
					<x path="Int"/>
					<x path="ceramic.GamepadButton"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadUp event</haxe_doc>
		</offGamepadUp>
		<listensGamepadUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadUp event</haxe_doc>
		</listensGamepadUp>
		<_dox_event_gamepadGyro public="1" set="method" line="637">
			<f a="gamepadId:dx:dy:dz">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadGyro>
		<emitGamepadGyro set="method" line="1095">
			<f a="gamepadId:dx:dy:dz">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</emitGamepadGyro>
		<onGamepadGyro public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdDxDyDz">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:dx:dy:dz">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</onGamepadGyro>
		<onceGamepadGyro public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdDxDyDz">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:dx:dy:dz">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</onceGamepadGyro>
		<offGamepadGyro public="1" set="method" line="1368">
			<f a="?handleGamepadIdDxDyDz">
				<f a="gamepadId:dx:dy:dz">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</offGamepadGyro>
		<listensGamepadGyro public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadGyro event</haxe_doc>
		</listensGamepadGyro>
		<_dox_event_gamepadEnable public="1" set="method" line="637">
			<f a="gamepadId:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadEnable>
		<emitGamepadEnable set="method" line="1095">
			<f a="gamepadId:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</emitGamepadEnable>
		<onGamepadEnable public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</onGamepadEnable>
		<onceGamepadEnable public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</onceGamepadEnable>
		<offGamepadEnable public="1" set="method" line="1368">
			<f a="?handleGamepadIdName">
				<f a="gamepadId:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</offGamepadEnable>
		<listensGamepadEnable public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadEnable event</haxe_doc>
		</listensGamepadEnable>
		<_dox_event_gamepadDisable public="1" set="method" line="637">
			<f a="gamepadId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadDisable>
		<emitGamepadDisable set="method" line="1095">
			<f a="gamepadId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</emitGamepadDisable>
		<onGamepadDisable public="1" set="method" line="1199">
			<f a="owner:handleGamepadId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</onGamepadDisable>
		<onceGamepadDisable public="1" set="method" line="1298">
			<f a="owner:handleGamepadId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</onceGamepadDisable>
		<offGamepadDisable public="1" set="method" line="1368">
			<f a="?handleGamepadId">
				<f a="gamepadId">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</offGamepadDisable>
		<listensGamepadDisable public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadDisable event</haxe_doc>
		</listensGamepadDisable>
		<pressedScanCodes expr="new IntIntMap(16, 0.5, false)">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</pressedScanCodes>
		<pressedKeyCodes expr="new IntIntMap(16, 0.5, false)">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</pressedKeyCodes>
		<pressedGamepadButtons expr="new IntIntMap(16, 0.5, false)">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</pressedGamepadButtons>
		<gamepadAxisValues expr="new IntFloatMap(16, 0.5, false)">
			<c path="ceramic.IntFloatMap"/>
			<meta><m n=":value"><e>new IntFloatMap(16, 0.5, false)</e></m></meta>
		</gamepadAxisValues>
		<gamepadGyroDeltas expr="new IntMap()">
			<c path="ceramic.IntMap"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>new IntMap()</e></m></meta>
		</gamepadGyroDeltas>
		<gamepadGyroKeys expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</gamepadGyroKeys>
		<gamepadNames expr="new IntMap()">
			<c path="ceramic.IntMap"><c path="String"/></c>
			<meta><m n=":value"><e>new IntMap()</e></m></meta>
		</gamepadNames>
		<activeGamepads public="1" expr="[]">
			<x path="ceramic.ReadOnlyArray"><x path="Int"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
		</activeGamepads>
		<resetDeltas set="method" line="53"><f a=""><x path="Void"/></f></resetDeltas>
		<willEmitKeyDown set="method" line="104"><f a="key">
	<c path="ceramic.Key"/>
	<x path="Void"/>
</f></willEmitKeyDown>
		<willEmitKeyUp set="method" line="131"><f a="key">
	<c path="ceramic.Key"/>
	<x path="Void"/>
</f></willEmitKeyUp>
		<keyPressed public="1" get="inline" set="null" line="151">
			<f a="keyCode">
				<x path="ceramic.KeyCode"/>
				<x path="Bool"/>
			</f>
			<overloads><keyPressed public="1" get="inline" set="null" line="187"><f a="keyCode:owner">
	<x path="ceramic.KeyCode"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></keyPressed></overloads>
		</keyPressed>
		<keyJustPressed public="1" get="inline" set="null" line="157">
			<f a="keyCode">
				<x path="ceramic.KeyCode"/>
				<x path="Bool"/>
			</f>
			<overloads><keyJustPressed public="1" get="inline" set="null" line="193"><f a="keyCode:owner">
	<x path="ceramic.KeyCode"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></keyJustPressed></overloads>
		</keyJustPressed>
		<keyJustReleased public="1" get="inline" set="null" line="163">
			<f a="keyCode">
				<x path="ceramic.KeyCode"/>
				<x path="Bool"/>
			</f>
			<overloads><keyJustReleased public="1" get="inline" set="null" line="199"><f a="keyCode:owner">
	<x path="ceramic.KeyCode"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></keyJustReleased></overloads>
		</keyJustReleased>
		<scanPressed public="1" get="inline" set="null" line="169">
			<f a="scanCode">
				<x path="ceramic.ScanCode"/>
				<x path="Bool"/>
			</f>
			<overloads><scanPressed public="1" get="inline" set="null" line="205"><f a="scanCode:owner">
	<x path="ceramic.ScanCode"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></scanPressed></overloads>
		</scanPressed>
		<scanJustPressed public="1" get="inline" set="null" line="175">
			<f a="scanCode">
				<x path="ceramic.ScanCode"/>
				<x path="Bool"/>
			</f>
			<overloads><scanJustPressed public="1" get="inline" set="null" line="211"><f a="scanCode:owner">
	<x path="ceramic.ScanCode"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></scanJustPressed></overloads>
		</scanJustPressed>
		<scanJustReleased public="1" get="inline" set="null" line="181">
			<f a="scanCode">
				<x path="ceramic.ScanCode"/>
				<x path="Bool"/>
			</f>
			<overloads><scanJustReleased public="1" get="inline" set="null" line="217"><f a="scanCode:owner">
	<x path="ceramic.ScanCode"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></scanJustReleased></overloads>
		</scanJustReleased>
		<_keyPressed set="method" line="223"><f a="keyCode">
	<x path="ceramic.KeyCode"/>
	<x path="Bool"/>
</f></_keyPressed>
		<_keyJustPressed set="method" line="229"><f a="keyCode">
	<x path="ceramic.KeyCode"/>
	<x path="Bool"/>
</f></_keyJustPressed>
		<_keyJustReleased set="method" line="235"><f a="keyCode">
	<x path="ceramic.KeyCode"/>
	<x path="Bool"/>
</f></_keyJustReleased>
		<_scanPressed set="method" line="241"><f a="scanCode">
	<x path="ceramic.ScanCode"/>
	<x path="Bool"/>
</f></_scanPressed>
		<_scanJustPressed set="method" line="247"><f a="scanCode">
	<x path="ceramic.ScanCode"/>
	<x path="Bool"/>
</f></_scanJustPressed>
		<_scanJustReleased set="method" line="253"><f a="scanCode">
	<x path="ceramic.ScanCode"/>
	<x path="Bool"/>
</f></_scanJustReleased>
		<willEmitGamepadEnable set="method" line="261"><f a="gamepadId:name">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></willEmitGamepadEnable>
		<willEmitGamepadDisable set="method" line="281"><f a="gamepadId">
	<x path="Int"/>
	<x path="Void"/>
</f></willEmitGamepadDisable>
		<willEmitGamepadDown set="method" line="308"><f a="gamepadId:button">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<x path="Void"/>
</f></willEmitGamepadDown>
		<willEmitGamepadUp set="method" line="330"><f a="gamepadId:button">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<x path="Void"/>
</f></willEmitGamepadUp>
		<willEmitGamepadGyro set="method" line="343"><f a="gamepadId:dx:dy:dz">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitGamepadGyro>
		<gamepadPressed public="1" get="inline" set="null" line="360">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Bool"/>
			</f>
			<overloads><gamepadPressed public="1" get="inline" set="null" line="378"><f a="gamepadId:button:owner">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></gamepadPressed></overloads>
		</gamepadPressed>
		<gamepadJustPressed public="1" get="inline" set="null" line="366">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Bool"/>
			</f>
			<overloads><gamepadJustPressed public="1" get="inline" set="null" line="384"><f a="gamepadId:button:owner">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></gamepadJustPressed></overloads>
		</gamepadJustPressed>
		<gamepadJustReleased public="1" get="inline" set="null" line="372">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Bool"/>
			</f>
			<overloads><gamepadJustReleased public="1" get="inline" set="null" line="390"><f a="gamepadId:button:owner">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></gamepadJustReleased></overloads>
		</gamepadJustReleased>
		<_gamepadPressed set="method" line="396"><f a="gamepadId:button">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<x path="Bool"/>
</f></_gamepadPressed>
		<_gamepadJustPressed set="method" line="403"><f a="gamepadId:button">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<x path="Bool"/>
</f></_gamepadJustPressed>
		<_gamepadJustReleased set="method" line="410"><f a="gamepadId:button">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<x path="Bool"/>
</f></_gamepadJustReleased>
		<willEmitGamepadAxis get="inline" set="null" line="417"><f a="gamepadId:axis:value">
	<x path="Int"/>
	<x path="ceramic.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitGamepadAxis>
		<gamepadAxisValue public="1" set="method" line="424"><f a="gamepadId:axis">
	<x path="Int"/>
	<x path="ceramic.GamepadAxis"/>
	<x path="Float"/>
</f></gamepadAxisValue>
		<gamepadGyroDeltaX public="1" set="method" line="431"><f a="gamepadId">
	<x path="Int"/>
	<x path="Float"/>
</f></gamepadGyroDeltaX>
		<gamepadGyroDeltaY public="1" set="method" line="442"><f a="gamepadId">
	<x path="Int"/>
	<x path="Float"/>
</f></gamepadGyroDeltaY>
		<gamepadGyroDeltaZ public="1" set="method" line="453"><f a="gamepadId">
	<x path="Int"/>
	<x path="Float"/>
</f></gamepadGyroDeltaZ>
		<startGamepadRumble public="1" set="method" line="471">
			<f a="gamepadId:duration:lowFrequency:highFrequency">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Starts a controller rumble.
     * @param gamepadId The id of the gamepad getting rumble
     * @param duration The duration, in seconds
     * @param lowFrequency Low frequency: value between 0 and 1
     * @param highFrequency High frequency: value between 0 and 1</haxe_doc>
		</startGamepadRumble>
		<stopGamepadRumble public="1" set="method" line="477"><f a="gamepadId">
	<x path="Int"/>
	<x path="Void"/>
</f></stopGamepadRumble>
		<gamepadName public="1" set="method" line="483"><f a="gamepadId">
	<x path="Int"/>
	<c path="String"/>
</f></gamepadName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new set="method" line="47"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<abstract path="ceramic.IntBoolMap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntBoolMap.hx">
		<this><c path="ceramic.IntIntMap"/></this>
		<haxe_doc>* A map that uses int as keys and booleans as values.</haxe_doc>
		<impl><class path="ceramic._IntBoolMap.IntBoolMap_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntBoolMap.hx" private="1" module="ceramic.IntBoolMap" final="1">
	<size public="1" get="accessor" set="null" static="1"><x path="Int"/></size>
	<get_size public="1" get="inline" set="null" line="11" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
</f></get_size>
	<iterableKeys public="1" get="accessor" set="null" static="1"><c path="Array"><x path="Int"/></c></iterableKeys>
	<get_iterableKeys get="inline" set="null" line="14" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="Array"><x path="Int"/></c>
</f></get_iterableKeys>
	<_asIntBoolMap get="inline" set="null" line="16" static="1">
		<f a="this">
			<c path="ceramic.IntIntMap"/>
			<x path="ceramic.IntBoolMap"/>
		</f>
		<meta><m n=":has_untyped"/></meta>
	</_asIntBoolMap>
	<_new public="1" get="inline" set="null" line="20" static="1">
		<f a="?size:?fillFactor:?iterable" v="16:0.5:false">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="ceramic.IntBoolMap"/>
		</f>
		<meta>
			<m n=":value"><e>{ iterable : false, fillFactor : 0.5, size : 16 }</e></m>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<exists public="1" get="inline" set="null" line="24" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></exists>
	<existsInline public="1" get="inline" set="null" line="28" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></existsInline>
	<get public="1" get="inline" set="null" line="32" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></get>
	<getInline public="1" get="inline" set="null" line="36" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getInline>
	<set public="1" get="inline" set="null" line="40" static="1"><f a="this:key:value">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></set>
	<remove public="1" get="inline" set="null" line="44" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></remove>
	<clear public="1" get="inline" set="null" line="48" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<x path="Void"/>
</f></clear>
	<copy public="1" set="method" line="52" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<x path="ceramic.IntBoolMap"/>
</f></copy>
	<iterator public="1" get="inline" set="null" line="56" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="ceramic.IntBoolMapIterator"/>
</f></iterator>
	<keys public="1" get="inline" set="null" line="60" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="ceramic.IntBoolMapKeyIterator"/>
</f></keys>
	<keyValueIterator public="1" get="inline" set="null" line="64" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="ceramic.IntBoolMapKeyValueIterator"/>
</f></keyValueIterator>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic.IntBoolMapIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntBoolMap.hx" module="ceramic.IntBoolMap">
		<intBoolMap><x path="ceramic.IntBoolMap"/></intBoolMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="86"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="90"><f a=""><x path="Bool"/></f></next>
		<new get="inline" set="null" line="77"><f a="intBoolMap">
	<x path="ceramic.IntBoolMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.IntBoolMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntBoolMapKeyIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntBoolMap.hx" module="ceramic.IntBoolMap">
		<iterableKeys><c path="Array"><x path="Int"/></c></iterableKeys>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="115"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="119"><f a=""><x path="Int"/></f></next>
		<new get="inline" set="null" line="107"><f a="intBoolMap">
	<x path="ceramic.IntBoolMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.IntBoolMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntBoolMapKeyValueIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntBoolMap.hx" module="ceramic.IntBoolMap">
		<intBoolMap><x path="ceramic.IntBoolMap"/></intBoolMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="144"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="148"><f a=""><a>
	<value><x path="Bool"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new get="inline" set="null" line="135"><f a="intBoolMap">
	<x path="ceramic.IntBoolMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.IntBoolMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntFloatMap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntFloatMap.hx">
		<intMap>
			<t path="Map">
				<x path="Int"/>
				<x path="Float"/>
			</t>
			<haxe_doc>* Backing map</haxe_doc>
		</intMap>
		<iterableKeys public="1" set="null" expr="null">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* When this map is marked as iterable, this array will contain every key.</haxe_doc>
		</iterableKeys>
		<iterableKeysUsed expr="null">
			<x path="ceramic.IntBoolMap"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</iterableKeysUsed>
		<size public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</size>
		<clear public="1" set="method" line="215"><f a=""><x path="Void"/></f></clear>
		<exists public="1" get="inline" set="null" line="224"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></exists>
		<set public="1" set="method" line="228"><f a="key:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set>
		<get public="1" get="inline" set="null" line="241"><f a="key">
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<remove public="1" set="method" line="245"><f a="key">
	<x path="Int"/>
	<x path="Float"/>
</f></remove>
		<getInline public="1" get="inline" set="null" line="260"><f a="key">
	<x path="Int"/>
	<x path="Float"/>
</f></getInline>
		<existsInline public="1" get="inline" set="null" line="265"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></existsInline>
		<copy public="1" get="inline" set="null" line="269"><f a=""><c path="ceramic.IntFloatMap"/></f></copy>
		<iterator public="1" get="inline" set="null" line="282"><f a=""><c path="ceramic.IntFloatMapIterator"/></f></iterator>
		<keys public="1" get="inline" set="null" line="286"><f a=""><c path="ceramic.IntFloatMapKeyIterator"/></f></keys>
		<keyValueIterator public="1" get="inline" set="null" line="290"><f a=""><c path="ceramic.IntFloatMapKeyValueIterator"/></f></keyValueIterator>
		<new public="1" set="method" line="206">
			<f a="?size:?fillFactor:?iterable" v="16:0.5:false">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ iterable : false, fillFactor : 0.5, size : 16 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.IntFloatMapIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntFloatMap.hx" module="ceramic.IntFloatMap">
		<intFloatMap><c path="ceramic.IntFloatMap"/></intFloatMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="314"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="318"><f a=""><x path="Float"/></f></next>
		<new get="inline" set="null" line="305"><f a="intFloatMap">
	<c path="ceramic.IntFloatMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.IntFloatMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntFloatMapKeyIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntFloatMap.hx" module="ceramic.IntFloatMap">
		<iterableKeys><c path="Array"><x path="Int"/></c></iterableKeys>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="343"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="347"><f a=""><x path="Float"/></f></next>
		<new get="inline" set="null" line="335"><f a="intFloatMap">
	<c path="ceramic.IntFloatMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.IntFloatMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntFloatMapKeyValueIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntFloatMap.hx" module="ceramic.IntFloatMap">
		<intFloatMap><c path="ceramic.IntFloatMap"/></intFloatMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="372"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="376"><f a=""><a>
	<value><x path="Float"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new get="inline" set="null" line="363"><f a="intFloatMap">
	<c path="ceramic.IntFloatMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.IntFloatMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntIntMapIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntIntMap.hx" module="ceramic.IntIntMap">
		<intIntMap><c path="ceramic.IntIntMap"/></intIntMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="582"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="586"><f a=""><x path="Int"/></f></next>
		<new get="inline" set="null" line="573"><f a="intIntMap">
	<c path="ceramic.IntIntMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.IntIntMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntIntMapKeyIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntIntMap.hx" module="ceramic.IntIntMap">
		<iterableKeys><c path="Array"><x path="Int"/></c></iterableKeys>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="611"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="615"><f a=""><x path="Int"/></f></next>
		<new get="inline" set="null" line="603"><f a="intIntMap">
	<c path="ceramic.IntIntMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.IntIntMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntIntMapKeyValueIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntIntMap.hx" module="ceramic.IntIntMap">
		<intIntMap><c path="ceramic.IntIntMap"/></intIntMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="640"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="644"><f a=""><a>
	<value><x path="Int"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new get="inline" set="null" line="631"><f a="intIntMap">
	<c path="ceramic.IntIntMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.IntIntMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntMap" params="V" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntMap.hx">
		<NO_VALUE get="inline" set="null" expr="0" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_VALUE>
		<NULL_VALUE get="inline" set="null" expr="1" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</NULL_VALUE>
		<RESERVED_GAP get="inline" set="null" expr="2" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</RESERVED_GAP>
		<RET_NULL final="1" set="null" expr="null" line="18" static="1">
			<c path="ceramic.IntMap.V"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</RET_NULL>
		<_keys><c path="ceramic.IntIntMap"/></_keys>
		<nextFreeIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextFreeIndex>
		<initialSize><x path="Int"/></initialSize>
		<initialFillFactor><x path="Float"/></initialFillFactor>
		<iterableKeys public="1" set="null" expr="null">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* When this map is marked as iterable, this array will contain every key.</haxe_doc>
		</iterableKeys>
		<values public="1" set="null">
			<x path="haxe.ds.Vector"><c path="ceramic.IntMap.V"/></x>
			<haxe_doc>* Values as they are stored.
     * Can be used to iterate on values directly,
     * but can contain null values.</haxe_doc>
		</values>
		<get public="1" set="method" line="58"><f a="key">
	<x path="Int"/>
	<c path="ceramic.IntMap.V"/>
</f></get>
		<getInline public="1" get="inline" set="null" line="64"><f a="key">
	<x path="Int"/>
	<c path="ceramic.IntMap.V"/>
</f></getInline>
		<exists public="1" set="method" line="71"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></exists>
		<existsInline public="1" get="inline" set="null" line="77"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></existsInline>
		<set public="1" set="method" line="83"><f a="key:value">
	<x path="Int"/>
	<c path="ceramic.IntMap.V"/>
	<x path="Void"/>
</f></set>
		<remove public="1" set="method" line="136"><f a="key">
	<x path="Int"/>
	<x path="Void"/>
</f></remove>
		<copy public="1" set="method" line="163"><f a=""><c path="ceramic.IntMap"><c path="ceramic.IntMap.V"/></c></f></copy>
		<clear public="1" set="method" line="178"><f a=""><x path="Void"/></f></clear>
		<iterator public="1" get="inline" set="null" line="190"><f a=""><c path="ceramic.IntMapIterator"><c path="ceramic.IntMap.V"/></c></f></iterator>
		<keys public="1" get="inline" set="null" line="194"><f a=""><c path="ceramic.IntMapKeyIterator"><c path="ceramic.IntMap.V"/></c></f></keys>
		<keyValueIterator public="1" get="inline" set="null" line="198"><f a=""><c path="ceramic.IntMapKeyValueIterator"><c path="ceramic.IntMap.V"/></c></f></keyValueIterator>
		<resizeValues set="method" line="204"><f a="targetSize">
	<x path="Int"/>
	<x path="Void"/>
</f></resizeValues>
		<new public="1" set="method" line="44">
			<f a="?size:?fillFactor:?iterable" v="16:0.5:false">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ iterable : false, fillFactor : 0.5, size : 16 }</e></m></meta>
		</new>
		<haxe_doc>* An object map that uses integers as key.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.IntMapIterator" params="V" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntMap.hx" module="ceramic.IntMap">
		<intMap><c path="ceramic.IntMap"><c path="ceramic.IntMapIterator.V"/></c></intMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="239"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="243"><f a=""><c path="ceramic.IntMapIterator.V"/></f></next>
		<new get="inline" set="null" line="230"><f a="intMap">
	<c path="ceramic.IntMap"><c path="ceramic.IntMapIterator.V"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.IntMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntMapKeyIterator" params="V" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntMap.hx" module="ceramic.IntMap">
		<iterableKeys><c path="Array"><x path="Int"/></c></iterableKeys>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="270"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="274"><f a=""><x path="Int"/></f></next>
		<new get="inline" set="null" line="262"><f a="intMap">
	<c path="ceramic.IntMap"><c path="ceramic.IntMapKeyIterator.V"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.IntMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntMapKeyValueIterator" params="V" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntMap.hx" module="ceramic.IntMap">
		<intMap><c path="ceramic.IntMap"><c path="ceramic.IntMapKeyValueIterator.V"/></c></intMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="302"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="306"><f a=""><a>
	<value><c path="ceramic.IntMapKeyValueIterator.V"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new get="inline" set="null" line="293"><f a="intMap">
	<c path="ceramic.IntMap"><c path="ceramic.IntMapKeyValueIterator.V"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.IntMap</e></m>
		</meta>
	</class>
	<class path="ceramic.Json" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Json.hx">
		<stringify public="1" get="inline" set="null" line="5" static="1"><f a="value:?replacer:?space">
	<d/>
	<f a="key:value">
		<d/>
		<d/>
		<d/>
	</f>
	<c path="String"/>
	<c path="String"/>
</f></stringify>
		<parse public="1" get="inline" set="null" line="11" static="1"><f a="text">
	<c path="String"/>
	<d/>
</f></parse>
	</class>
	<class path="ceramic.Key" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Key.hx">
		<keyCode public="1" set="null">
			<x path="ceramic.KeyCode"/>
			<haxe_doc>* Key code (localized key) depends on keyboard mapping (QWERTY, AZERTY, ...)</haxe_doc>
		</keyCode>
		<keyCodeName public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>* Name associated to the key code (localized key)</haxe_doc>
		</keyCodeName>
		<get_keyCodeName get="inline" set="null" line="21"><f a=""><c path="String"/></f></get_keyCodeName>
		<scanCode public="1" set="null">
			<x path="ceramic.ScanCode"/>
			<haxe_doc>* Scan code (US international key) doesn't depend on keyboard mapping (QWERTY, AZERTY, ...)</haxe_doc>
		</scanCode>
		<scanCodeName public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>* Name associated to the scan code (US international key)</haxe_doc>
		</scanCodeName>
		<get_scanCodeName get="inline" set="null" line="34"><f a=""><c path="String"/></f></get_scanCodeName>
		<toString set="method" line="38"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="5"><f a="keyCode:scanCode">
	<x path="ceramic.KeyCode"/>
	<x path="ceramic.ScanCode"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":structInit"/></meta>
	</class>
	<enum path="ceramic.KeyAcceleratorItem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/KeyAcceleratorItem.hx">
		<SHIFT/>
		<CMD_OR_CTRL/>
		<SCAN a="scanCode"><x path="ceramic.ScanCode"/></SCAN>
		<KEY a="keyCode"><x path="ceramic.KeyCode"/></KEY>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="ceramic.KeyBinding" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/KeyBinding.hx">
		<extends path="ceramic.Entity"/>
		<_dox_event_trigger public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_trigger>
		<emitTrigger set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>trigger event</haxe_doc>
		</emitTrigger>
		<onTrigger public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>trigger event</haxe_doc>
		</onTrigger>
		<onceTrigger public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>trigger event</haxe_doc>
		</onceTrigger>
		<offTrigger public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>trigger event</haxe_doc>
		</offTrigger>
		<listensTrigger public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to trigger event</haxe_doc>
		</listensTrigger>
		<accelerator public="1" set="null"><x path="ceramic.ReadOnlyArray"><e path="ceramic.KeyAcceleratorItem"/></x></accelerator>
		<bindings public="1" set="null" expr="null">
			<c path="ceramic.KeyBindings"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</bindings>
		<pressedItems expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pressedItems>
		<matches expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</matches>
		<leftShiftPressed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</leftShiftPressed>
		<rightShiftPressed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rightShiftPressed>
		<disableIfShiftPressed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</disableIfShiftPressed>
		<forceKeysUp public="1" set="method" line="48">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</forceKeysUp>
		<bindKeyboardEvents set="method" line="62"><f a=""><x path="Void"/></f></bindKeyboardEvents>
		<bindScanCode set="method" line="101"><f a="scanCode:itemIndex">
	<x path="ceramic.ScanCode"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bindScanCode>
		<bindKeyCode set="method" line="175"><f a="keyCode:itemIndex">
	<x path="ceramic.KeyCode"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bindKeyCode>
		<bindShift set="method" line="213"><f a=""><x path="Void"/></f></bindShift>
		<checkStatus set="method" line="239"><f a=""><x path="Void"/></f></checkStatus>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new set="method" line="35"><f a="accelerator:?bindings">
	<c path="Array"><e path="ceramic.KeyAcceleratorItem"/></c>
	<c path="ceramic.KeyBindings"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.KeyBindings</e></m>
		</meta>
	</class>
	<class path="ceramic.KeyBindings" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/KeyBindings.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<instances expr="[]" line="9" static="1">
			<c path="Array"><c path="ceramic.KeyBindings"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</instances>
		<forceKeysUp public="1" set="method" line="64" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</forceKeysUp>
		<bindings expr="[]">
			<c path="Array"><c path="ceramic.KeyBinding"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</bindings>
		<bindAsComponent set="method" line="17"><f a=""><x path="Void"/></f></bindAsComponent>
		<destroy public="1" set="method" line="31" override="1"><f a=""><x path="Void"/></f></destroy>
		<bind public="1" set="method" line="48"><f a="accelerator:?callback">
	<c path="Array"><e path="ceramic.KeyAcceleratorItem"/></c>
	<f a=""><x path="Void"/></f>
	<c path="ceramic.KeyBinding"/>
</f></bind>
		<entity public="1">
			<c path="ceramic.Entity"/>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</entity>
		<setEntity set="method" line="7">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="7">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.KeyCode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/KeyCode.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._KeyCode.KeyCode_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/KeyCode.hx" private="1" module="ceramic.KeyCode" final="1">
	<UNKNOWN public="1" get="inline" set="null" expr="cast 0" line="13" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNKNOWN>
	<ENTER public="1" get="inline" set="null" expr="cast 13" line="15" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ENTER>
	<ESCAPE public="1" get="inline" set="null" expr="cast 27" line="16" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 27</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ESCAPE>
	<BACKSPACE public="1" get="inline" set="null" expr="cast 8" line="17" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BACKSPACE>
	<TAB public="1" get="inline" set="null" expr="cast 9" line="18" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TAB>
	<SPACE public="1" get="inline" set="null" expr="cast 32" line="19" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 32</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SPACE>
	<EXCLAIM public="1" get="inline" set="null" expr="cast 33" line="20" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 33</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EXCLAIM>
	<QUOTEDBL public="1" get="inline" set="null" expr="cast 34" line="21" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 34</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUOTEDBL>
	<HASH public="1" get="inline" set="null" expr="cast 35" line="22" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 35</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HASH>
	<PERCENT public="1" get="inline" set="null" expr="cast 37" line="23" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 37</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PERCENT>
	<DOLLAR public="1" get="inline" set="null" expr="cast 36" line="24" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 36</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DOLLAR>
	<AMPERSAND public="1" get="inline" set="null" expr="cast 38" line="25" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 38</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AMPERSAND>
	<QUOTE public="1" get="inline" set="null" expr="cast 39" line="26" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 39</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUOTE>
	<LEFTPAREN public="1" get="inline" set="null" expr="cast 40" line="27" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 40</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFTPAREN>
	<RIGHTPAREN public="1" get="inline" set="null" expr="cast 41" line="28" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 41</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHTPAREN>
	<ASTERISK public="1" get="inline" set="null" expr="cast 42" line="29" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 42</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ASTERISK>
	<PLUS public="1" get="inline" set="null" expr="cast 43" line="30" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 43</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PLUS>
	<COMMA public="1" get="inline" set="null" expr="cast 44" line="31" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 44</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COMMA>
	<MINUS public="1" get="inline" set="null" expr="cast 45" line="32" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 45</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MINUS>
	<PERIOD public="1" get="inline" set="null" expr="cast 46" line="33" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 46</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PERIOD>
	<SLASH public="1" get="inline" set="null" expr="cast 47" line="34" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 47</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SLASH>
	<KEY_0 public="1" get="inline" set="null" expr="cast 48" line="35" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 48</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_0>
	<KEY_1 public="1" get="inline" set="null" expr="cast 49" line="36" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 49</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_1>
	<KEY_2 public="1" get="inline" set="null" expr="cast 50" line="37" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 50</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_2>
	<KEY_3 public="1" get="inline" set="null" expr="cast 51" line="38" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 51</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_3>
	<KEY_4 public="1" get="inline" set="null" expr="cast 52" line="39" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 52</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_4>
	<KEY_5 public="1" get="inline" set="null" expr="cast 53" line="40" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 53</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_5>
	<KEY_6 public="1" get="inline" set="null" expr="cast 54" line="41" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 54</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_6>
	<KEY_7 public="1" get="inline" set="null" expr="cast 55" line="42" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 55</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_7>
	<KEY_8 public="1" get="inline" set="null" expr="cast 56" line="43" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 56</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_8>
	<KEY_9 public="1" get="inline" set="null" expr="cast 57" line="44" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 57</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_9>
	<COLON public="1" get="inline" set="null" expr="cast 58" line="45" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 58</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COLON>
	<SEMICOLON public="1" get="inline" set="null" expr="cast 59" line="46" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 59</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SEMICOLON>
	<LESS public="1" get="inline" set="null" expr="cast 60" line="47" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 60</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LESS>
	<EQUALS public="1" get="inline" set="null" expr="cast 61" line="48" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 61</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EQUALS>
	<GREATER public="1" get="inline" set="null" expr="cast 62" line="49" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 62</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</GREATER>
	<QUESTION public="1" get="inline" set="null" expr="cast 63" line="50" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 63</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUESTION>
	<AT public="1" get="inline" set="null" expr="cast 64" line="51" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 64</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AT>
	<LEFTBRACKET public="1" get="inline" set="null" expr="cast 91" line="55" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 91</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFTBRACKET>
	<BACKSLASH public="1" get="inline" set="null" expr="cast 92" line="56" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 92</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BACKSLASH>
	<RIGHTBRACKET public="1" get="inline" set="null" expr="cast 93" line="57" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 93</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHTBRACKET>
	<CARET public="1" get="inline" set="null" expr="cast 94" line="58" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 94</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CARET>
	<UNDERSCORE public="1" get="inline" set="null" expr="cast 95" line="59" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 95</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNDERSCORE>
	<BACKQUOTE public="1" get="inline" set="null" expr="cast 96" line="60" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 96</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BACKQUOTE>
	<KEY_A public="1" get="inline" set="null" expr="cast 97" line="61" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 97</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_A>
	<KEY_B public="1" get="inline" set="null" expr="cast 98" line="62" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 98</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_B>
	<KEY_C public="1" get="inline" set="null" expr="cast 99" line="63" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 99</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_C>
	<KEY_D public="1" get="inline" set="null" expr="cast 100" line="64" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 100</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_D>
	<KEY_E public="1" get="inline" set="null" expr="cast 101" line="65" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 101</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_E>
	<KEY_F public="1" get="inline" set="null" expr="cast 102" line="66" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 102</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_F>
	<KEY_G public="1" get="inline" set="null" expr="cast 103" line="67" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 103</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_G>
	<KEY_H public="1" get="inline" set="null" expr="cast 104" line="68" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 104</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_H>
	<KEY_I public="1" get="inline" set="null" expr="cast 105" line="69" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 105</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_I>
	<KEY_J public="1" get="inline" set="null" expr="cast 106" line="70" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 106</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_J>
	<KEY_K public="1" get="inline" set="null" expr="cast 107" line="71" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 107</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_K>
	<KEY_L public="1" get="inline" set="null" expr="cast 108" line="72" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 108</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_L>
	<KEY_M public="1" get="inline" set="null" expr="cast 109" line="73" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 109</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_M>
	<KEY_N public="1" get="inline" set="null" expr="cast 110" line="74" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 110</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_N>
	<KEY_O public="1" get="inline" set="null" expr="cast 111" line="75" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 111</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_O>
	<KEY_P public="1" get="inline" set="null" expr="cast 112" line="76" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 112</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_P>
	<KEY_Q public="1" get="inline" set="null" expr="cast 113" line="77" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 113</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_Q>
	<KEY_R public="1" get="inline" set="null" expr="cast 114" line="78" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 114</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_R>
	<KEY_S public="1" get="inline" set="null" expr="cast 115" line="79" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 115</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_S>
	<KEY_T public="1" get="inline" set="null" expr="cast 116" line="80" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 116</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_T>
	<KEY_U public="1" get="inline" set="null" expr="cast 117" line="81" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 117</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_U>
	<KEY_V public="1" get="inline" set="null" expr="cast 118" line="82" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 118</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_V>
	<KEY_W public="1" get="inline" set="null" expr="cast 119" line="83" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 119</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_W>
	<KEY_X public="1" get="inline" set="null" expr="cast 120" line="84" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 120</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_X>
	<KEY_Y public="1" get="inline" set="null" expr="cast 121" line="85" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 121</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_Y>
	<KEY_Z public="1" get="inline" set="null" expr="cast 122" line="86" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 122</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_Z>
	<CAPSLOCK public="1" get="inline" set="null" expr="cast 57 | (1 &lt;&lt; 30)" line="88" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 57 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CAPSLOCK>
	<F1 public="1" get="inline" set="null" expr="cast 58 | (1 &lt;&lt; 30)" line="90" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 58 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F1>
	<F2 public="1" get="inline" set="null" expr="cast 59 | (1 &lt;&lt; 30)" line="91" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 59 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F2>
	<F3 public="1" get="inline" set="null" expr="cast 60 | (1 &lt;&lt; 30)" line="92" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 60 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F3>
	<F4 public="1" get="inline" set="null" expr="cast 61 | (1 &lt;&lt; 30)" line="93" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 61 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F4>
	<F5 public="1" get="inline" set="null" expr="cast 62 | (1 &lt;&lt; 30)" line="94" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 62 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F5>
	<F6 public="1" get="inline" set="null" expr="cast 63 | (1 &lt;&lt; 30)" line="95" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 63 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F6>
	<F7 public="1" get="inline" set="null" expr="cast 64 | (1 &lt;&lt; 30)" line="96" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 64 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F7>
	<F8 public="1" get="inline" set="null" expr="cast 65 | (1 &lt;&lt; 30)" line="97" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 65 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F8>
	<F9 public="1" get="inline" set="null" expr="cast 66 | (1 &lt;&lt; 30)" line="98" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 66 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F9>
	<F10 public="1" get="inline" set="null" expr="cast 67 | (1 &lt;&lt; 30)" line="99" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 67 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F10>
	<F11 public="1" get="inline" set="null" expr="cast 68 | (1 &lt;&lt; 30)" line="100" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 68 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F11>
	<F12 public="1" get="inline" set="null" expr="cast 69 | (1 &lt;&lt; 30)" line="101" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 69 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F12>
	<PRINTSCREEN public="1" get="inline" set="null" expr="cast 70 | (1 &lt;&lt; 30)" line="103" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 70 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PRINTSCREEN>
	<SCROLLLOCK public="1" get="inline" set="null" expr="cast 71 | (1 &lt;&lt; 30)" line="104" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 71 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCROLLLOCK>
	<PAUSE public="1" get="inline" set="null" expr="cast 72 | (1 &lt;&lt; 30)" line="105" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 72 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAUSE>
	<INSERT public="1" get="inline" set="null" expr="cast 73 | (1 &lt;&lt; 30)" line="107" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 73 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INSERT>
	<HOME public="1" get="inline" set="null" expr="cast 74 | (1 &lt;&lt; 30)" line="108" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 74 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HOME>
	<PAGEUP public="1" get="inline" set="null" expr="cast 75 | (1 &lt;&lt; 30)" line="109" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 75 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAGEUP>
	<DELETE public="1" get="inline" set="null" expr="cast 127" line="110" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 127</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DELETE>
	<END public="1" get="inline" set="null" expr="cast 77 | (1 &lt;&lt; 30)" line="111" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 77 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</END>
	<PAGEDOWN public="1" get="inline" set="null" expr="cast 78 | (1 &lt;&lt; 30)" line="112" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 78 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAGEDOWN>
	<RIGHT public="1" get="inline" set="null" expr="cast 79 | (1 &lt;&lt; 30)" line="113" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 79 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT>
	<LEFT public="1" get="inline" set="null" expr="cast 80 | (1 &lt;&lt; 30)" line="114" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 80 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT>
	<DOWN public="1" get="inline" set="null" expr="cast 81 | (1 &lt;&lt; 30)" line="115" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 81 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DOWN>
	<UP public="1" get="inline" set="null" expr="cast 82 | (1 &lt;&lt; 30)" line="116" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 82 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UP>
	<NUMLOCKCLEAR public="1" get="inline" set="null" expr="cast 83 | (1 &lt;&lt; 30)" line="118" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 83 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NUMLOCKCLEAR>
	<KP_DIVIDE public="1" get="inline" set="null" expr="cast 84 | (1 &lt;&lt; 30)" line="119" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 84 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DIVIDE>
	<KP_MULTIPLY public="1" get="inline" set="null" expr="cast 85 | (1 &lt;&lt; 30)" line="120" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 85 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MULTIPLY>
	<KP_MINUS public="1" get="inline" set="null" expr="cast 86 | (1 &lt;&lt; 30)" line="121" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 86 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MINUS>
	<KP_PLUS public="1" get="inline" set="null" expr="cast 87 | (1 &lt;&lt; 30)" line="122" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 87 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PLUS>
	<KP_ENTER public="1" get="inline" set="null" expr="cast 88 | (1 &lt;&lt; 30)" line="123" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 88 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_ENTER>
	<KP_1 public="1" get="inline" set="null" expr="cast 89 | (1 &lt;&lt; 30)" line="124" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 89 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_1>
	<KP_2 public="1" get="inline" set="null" expr="cast 90 | (1 &lt;&lt; 30)" line="125" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 90 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_2>
	<KP_3 public="1" get="inline" set="null" expr="cast 91 | (1 &lt;&lt; 30)" line="126" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 91 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_3>
	<KP_4 public="1" get="inline" set="null" expr="cast 92 | (1 &lt;&lt; 30)" line="127" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 92 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_4>
	<KP_5 public="1" get="inline" set="null" expr="cast 93 | (1 &lt;&lt; 30)" line="128" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 93 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_5>
	<KP_6 public="1" get="inline" set="null" expr="cast 94 | (1 &lt;&lt; 30)" line="129" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 94 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_6>
	<KP_7 public="1" get="inline" set="null" expr="cast 95 | (1 &lt;&lt; 30)" line="130" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 95 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_7>
	<KP_8 public="1" get="inline" set="null" expr="cast 96 | (1 &lt;&lt; 30)" line="131" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 96 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_8>
	<KP_9 public="1" get="inline" set="null" expr="cast 97 | (1 &lt;&lt; 30)" line="132" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 97 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_9>
	<KP_0 public="1" get="inline" set="null" expr="cast 98 | (1 &lt;&lt; 30)" line="133" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 98 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_0>
	<KP_PERIOD public="1" get="inline" set="null" expr="cast 99 | (1 &lt;&lt; 30)" line="134" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 99 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PERIOD>
	<APPLICATION public="1" get="inline" set="null" expr="cast 101 | (1 &lt;&lt; 30)" line="136" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 101 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</APPLICATION>
	<POWER public="1" get="inline" set="null" expr="cast 102 | (1 &lt;&lt; 30)" line="138" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 102 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</POWER>
	<KP_EQUALS public="1" get="inline" set="null" expr="cast 103 | (1 &lt;&lt; 30)" line="139" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 103 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_EQUALS>
	<F13 public="1" get="inline" set="null" expr="cast 104 | (1 &lt;&lt; 30)" line="140" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 104 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F13>
	<F14 public="1" get="inline" set="null" expr="cast 105 | (1 &lt;&lt; 30)" line="141" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 105 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F14>
	<F15 public="1" get="inline" set="null" expr="cast 106 | (1 &lt;&lt; 30)" line="142" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 106 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F15>
	<F16 public="1" get="inline" set="null" expr="cast 107 | (1 &lt;&lt; 30)" line="143" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 107 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F16>
	<F17 public="1" get="inline" set="null" expr="cast 108 | (1 &lt;&lt; 30)" line="144" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 108 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F17>
	<F18 public="1" get="inline" set="null" expr="cast 109 | (1 &lt;&lt; 30)" line="145" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 109 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F18>
	<F19 public="1" get="inline" set="null" expr="cast 110 | (1 &lt;&lt; 30)" line="146" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 110 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F19>
	<F20 public="1" get="inline" set="null" expr="cast 111 | (1 &lt;&lt; 30)" line="147" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 111 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F20>
	<F21 public="1" get="inline" set="null" expr="cast 112 | (1 &lt;&lt; 30)" line="148" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 112 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F21>
	<F22 public="1" get="inline" set="null" expr="cast 113 | (1 &lt;&lt; 30)" line="149" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 113 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F22>
	<F23 public="1" get="inline" set="null" expr="cast 114 | (1 &lt;&lt; 30)" line="150" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 114 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F23>
	<F24 public="1" get="inline" set="null" expr="cast 115 | (1 &lt;&lt; 30)" line="151" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 115 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F24>
	<EXECUTE public="1" get="inline" set="null" expr="cast 116 | (1 &lt;&lt; 30)" line="152" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 116 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EXECUTE>
	<HELP public="1" get="inline" set="null" expr="cast 117 | (1 &lt;&lt; 30)" line="153" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 117 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HELP>
	<MENU public="1" get="inline" set="null" expr="cast 118 | (1 &lt;&lt; 30)" line="154" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 118 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MENU>
	<SELECT public="1" get="inline" set="null" expr="cast 119 | (1 &lt;&lt; 30)" line="155" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 119 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SELECT>
	<STOP public="1" get="inline" set="null" expr="cast 120 | (1 &lt;&lt; 30)" line="156" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 120 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</STOP>
	<AGAIN public="1" get="inline" set="null" expr="cast 121 | (1 &lt;&lt; 30)" line="158" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 121 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AGAIN>
	<UNDO public="1" get="inline" set="null" expr="cast 122 | (1 &lt;&lt; 30)" line="159" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 122 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNDO>
	<CUT public="1" get="inline" set="null" expr="cast 123 | (1 &lt;&lt; 30)" line="160" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 123 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CUT>
	<COPY public="1" get="inline" set="null" expr="cast 124 | (1 &lt;&lt; 30)" line="161" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 124 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COPY>
	<PASTE public="1" get="inline" set="null" expr="cast 125 | (1 &lt;&lt; 30)" line="162" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 125 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PASTE>
	<FIND public="1" get="inline" set="null" expr="cast 126 | (1 &lt;&lt; 30)" line="163" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 126 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</FIND>
	<MUTE public="1" get="inline" set="null" expr="cast 127 | (1 &lt;&lt; 30)" line="164" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 127 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MUTE>
	<VOLUMEUP public="1" get="inline" set="null" expr="cast 128 | (1 &lt;&lt; 30)" line="165" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 128 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VOLUMEUP>
	<VOLUMEDOWN public="1" get="inline" set="null" expr="cast 129 | (1 &lt;&lt; 30)" line="166" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 129 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VOLUMEDOWN>
	<KP_COMMA public="1" get="inline" set="null" expr="cast 133 | (1 &lt;&lt; 30)" line="168" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 133 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_COMMA>
	<KP_EQUALSAS400 public="1" get="inline" set="null" expr="cast 134 | (1 &lt;&lt; 30)" line="169" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 134 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_EQUALSAS400>
	<ALTERASE public="1" get="inline" set="null" expr="cast 153 | (1 &lt;&lt; 30)" line="171" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 153 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ALTERASE>
	<SYSREQ public="1" get="inline" set="null" expr="cast 154 | (1 &lt;&lt; 30)" line="172" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 154 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SYSREQ>
	<CANCEL public="1" get="inline" set="null" expr="cast 155 | (1 &lt;&lt; 30)" line="173" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 155 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CANCEL>
	<CLEAR public="1" get="inline" set="null" expr="cast 156 | (1 &lt;&lt; 30)" line="174" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 156 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CLEAR>
	<PRIOR public="1" get="inline" set="null" expr="cast 157 | (1 &lt;&lt; 30)" line="175" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 157 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PRIOR>
	<RETURN2 public="1" get="inline" set="null" expr="cast 158 | (1 &lt;&lt; 30)" line="176" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 158 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RETURN2>
	<SEPARATOR public="1" get="inline" set="null" expr="cast 159 | (1 &lt;&lt; 30)" line="177" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 159 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SEPARATOR>
	<OUT public="1" get="inline" set="null" expr="cast 160 | (1 &lt;&lt; 30)" line="178" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 160 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OUT>
	<OPER public="1" get="inline" set="null" expr="cast 161 | (1 &lt;&lt; 30)" line="179" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 161 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OPER>
	<CLEARAGAIN public="1" get="inline" set="null" expr="cast 162 | (1 &lt;&lt; 30)" line="180" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 162 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CLEARAGAIN>
	<CRSEL public="1" get="inline" set="null" expr="cast 163 | (1 &lt;&lt; 30)" line="181" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 163 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CRSEL>
	<EXSEL public="1" get="inline" set="null" expr="cast 164 | (1 &lt;&lt; 30)" line="182" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 164 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EXSEL>
	<KP_00 public="1" get="inline" set="null" expr="cast 176 | (1 &lt;&lt; 30)" line="184" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 176 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_00>
	<KP_000 public="1" get="inline" set="null" expr="cast 177 | (1 &lt;&lt; 30)" line="185" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 177 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_000>
	<THOUSANDSSEPARATOR public="1" get="inline" set="null" expr="cast 178 | (1 &lt;&lt; 30)" line="186" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 178 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</THOUSANDSSEPARATOR>
	<DECIMALSEPARATOR public="1" get="inline" set="null" expr="cast 179 | (1 &lt;&lt; 30)" line="187" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 179 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DECIMALSEPARATOR>
	<CURRENCYUNIT public="1" get="inline" set="null" expr="cast 180 | (1 &lt;&lt; 30)" line="188" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 180 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CURRENCYUNIT>
	<CURRENCYSUBUNIT public="1" get="inline" set="null" expr="cast 181 | (1 &lt;&lt; 30)" line="189" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 181 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CURRENCYSUBUNIT>
	<KP_LEFTPAREN public="1" get="inline" set="null" expr="cast 182 | (1 &lt;&lt; 30)" line="190" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 182 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_LEFTPAREN>
	<KP_RIGHTPAREN public="1" get="inline" set="null" expr="cast 183 | (1 &lt;&lt; 30)" line="191" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 183 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_RIGHTPAREN>
	<KP_LEFTBRACE public="1" get="inline" set="null" expr="cast 184 | (1 &lt;&lt; 30)" line="192" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 184 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_LEFTBRACE>
	<KP_RIGHTBRACE public="1" get="inline" set="null" expr="cast 185 | (1 &lt;&lt; 30)" line="193" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 185 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_RIGHTBRACE>
	<KP_TAB public="1" get="inline" set="null" expr="cast 186 | (1 &lt;&lt; 30)" line="194" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 186 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_TAB>
	<KP_BACKSPACE public="1" get="inline" set="null" expr="cast 187 | (1 &lt;&lt; 30)" line="195" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 187 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_BACKSPACE>
	<KP_A public="1" get="inline" set="null" expr="cast 188 | (1 &lt;&lt; 30)" line="196" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 188 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_A>
	<KP_B public="1" get="inline" set="null" expr="cast 189 | (1 &lt;&lt; 30)" line="197" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 189 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_B>
	<KP_C public="1" get="inline" set="null" expr="cast 190 | (1 &lt;&lt; 30)" line="198" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 190 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_C>
	<KP_D public="1" get="inline" set="null" expr="cast 191 | (1 &lt;&lt; 30)" line="199" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 191 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_D>
	<KP_E public="1" get="inline" set="null" expr="cast 192 | (1 &lt;&lt; 30)" line="200" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 192 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_E>
	<KP_F public="1" get="inline" set="null" expr="cast 193 | (1 &lt;&lt; 30)" line="201" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 193 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_F>
	<KP_XOR public="1" get="inline" set="null" expr="cast 194 | (1 &lt;&lt; 30)" line="202" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 194 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_XOR>
	<KP_POWER public="1" get="inline" set="null" expr="cast 195 | (1 &lt;&lt; 30)" line="203" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 195 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_POWER>
	<KP_PERCENT public="1" get="inline" set="null" expr="cast 196 | (1 &lt;&lt; 30)" line="204" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 196 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PERCENT>
	<KP_LESS public="1" get="inline" set="null" expr="cast 197 | (1 &lt;&lt; 30)" line="205" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 197 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_LESS>
	<KP_GREATER public="1" get="inline" set="null" expr="cast 198 | (1 &lt;&lt; 30)" line="206" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 198 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_GREATER>
	<KP_AMPERSAND public="1" get="inline" set="null" expr="cast 199 | (1 &lt;&lt; 30)" line="207" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 199 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_AMPERSAND>
	<KP_DBLAMPERSAND public="1" get="inline" set="null" expr="cast 200 | (1 &lt;&lt; 30)" line="208" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 200 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DBLAMPERSAND>
	<KP_VERTICALBAR public="1" get="inline" set="null" expr="cast 201 | (1 &lt;&lt; 30)" line="209" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 201 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_VERTICALBAR>
	<KP_DBLVERTICALBAR public="1" get="inline" set="null" expr="cast 202 | (1 &lt;&lt; 30)" line="210" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 202 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DBLVERTICALBAR>
	<KP_COLON public="1" get="inline" set="null" expr="cast 203 | (1 &lt;&lt; 30)" line="211" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 203 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_COLON>
	<KP_HASH public="1" get="inline" set="null" expr="cast 204 | (1 &lt;&lt; 30)" line="212" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 204 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_HASH>
	<KP_SPACE public="1" get="inline" set="null" expr="cast 205 | (1 &lt;&lt; 30)" line="213" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 205 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_SPACE>
	<KP_AT public="1" get="inline" set="null" expr="cast 206 | (1 &lt;&lt; 30)" line="214" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 206 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_AT>
	<KP_EXCLAM public="1" get="inline" set="null" expr="cast 207 | (1 &lt;&lt; 30)" line="215" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 207 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_EXCLAM>
	<KP_MEMSTORE public="1" get="inline" set="null" expr="cast 208 | (1 &lt;&lt; 30)" line="216" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 208 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMSTORE>
	<KP_MEMRECALL public="1" get="inline" set="null" expr="cast 209 | (1 &lt;&lt; 30)" line="217" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 209 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMRECALL>
	<KP_MEMCLEAR public="1" get="inline" set="null" expr="cast 210 | (1 &lt;&lt; 30)" line="218" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 210 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMCLEAR>
	<KP_MEMADD public="1" get="inline" set="null" expr="cast 211 | (1 &lt;&lt; 30)" line="219" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 211 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMADD>
	<KP_MEMSUBTRACT public="1" get="inline" set="null" expr="cast 212 | (1 &lt;&lt; 30)" line="220" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 212 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMSUBTRACT>
	<KP_MEMMULTIPLY public="1" get="inline" set="null" expr="cast 213 | (1 &lt;&lt; 30)" line="221" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 213 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMMULTIPLY>
	<KP_MEMDIVIDE public="1" get="inline" set="null" expr="cast 214 | (1 &lt;&lt; 30)" line="222" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 214 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMDIVIDE>
	<KP_PLUSMINUS public="1" get="inline" set="null" expr="cast 215 | (1 &lt;&lt; 30)" line="223" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 215 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PLUSMINUS>
	<KP_CLEAR public="1" get="inline" set="null" expr="cast 216 | (1 &lt;&lt; 30)" line="224" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 216 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_CLEAR>
	<KP_CLEARENTRY public="1" get="inline" set="null" expr="cast 217 | (1 &lt;&lt; 30)" line="225" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 217 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_CLEARENTRY>
	<KP_BINARY public="1" get="inline" set="null" expr="cast 218 | (1 &lt;&lt; 30)" line="226" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 218 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_BINARY>
	<KP_OCTAL public="1" get="inline" set="null" expr="cast 219 | (1 &lt;&lt; 30)" line="227" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 219 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_OCTAL>
	<KP_DECIMAL public="1" get="inline" set="null" expr="cast 220 | (1 &lt;&lt; 30)" line="228" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 220 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DECIMAL>
	<KP_HEXADECIMAL public="1" get="inline" set="null" expr="cast 221 | (1 &lt;&lt; 30)" line="229" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 221 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_HEXADECIMAL>
	<LCTRL public="1" get="inline" set="null" expr="cast 224 | (1 &lt;&lt; 30)" line="231" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 224 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LCTRL>
	<LSHIFT public="1" get="inline" set="null" expr="cast 225 | (1 &lt;&lt; 30)" line="232" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 225 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LSHIFT>
	<LALT public="1" get="inline" set="null" expr="cast 226 | (1 &lt;&lt; 30)" line="233" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 226 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LALT>
	<LMETA public="1" get="inline" set="null" expr="cast 227 | (1 &lt;&lt; 30)" line="234" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 227 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LMETA>
	<RCTRL public="1" get="inline" set="null" expr="cast 228 | (1 &lt;&lt; 30)" line="235" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 228 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RCTRL>
	<RSHIFT public="1" get="inline" set="null" expr="cast 229 | (1 &lt;&lt; 30)" line="236" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 229 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RSHIFT>
	<RALT public="1" get="inline" set="null" expr="cast 230 | (1 &lt;&lt; 30)" line="237" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 230 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RALT>
	<RMETA public="1" get="inline" set="null" expr="cast 231 | (1 &lt;&lt; 30)" line="238" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 231 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RMETA>
	<MODE public="1" get="inline" set="null" expr="cast 257 | (1 &lt;&lt; 30)" line="240" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 257 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MODE>
	<AUDIONEXT public="1" get="inline" set="null" expr="cast 258 | (1 &lt;&lt; 30)" line="242" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 258 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIONEXT>
	<AUDIOPREV public="1" get="inline" set="null" expr="cast 259 | (1 &lt;&lt; 30)" line="243" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 259 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOPREV>
	<AUDIOSTOP public="1" get="inline" set="null" expr="cast 260 | (1 &lt;&lt; 30)" line="244" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 260 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOSTOP>
	<AUDIOPLAY public="1" get="inline" set="null" expr="cast 261 | (1 &lt;&lt; 30)" line="245" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 261 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOPLAY>
	<AUDIOMUTE public="1" get="inline" set="null" expr="cast 262 | (1 &lt;&lt; 30)" line="246" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 262 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOMUTE>
	<MEDIASELECT public="1" get="inline" set="null" expr="cast 263 | (1 &lt;&lt; 30)" line="247" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 263 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MEDIASELECT>
	<WWW public="1" get="inline" set="null" expr="cast 264 | (1 &lt;&lt; 30)" line="248" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 264 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WWW>
	<MAIL public="1" get="inline" set="null" expr="cast 265 | (1 &lt;&lt; 30)" line="249" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 265 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MAIL>
	<CALCULATOR public="1" get="inline" set="null" expr="cast 266 | (1 &lt;&lt; 30)" line="250" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 266 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CALCULATOR>
	<COMPUTER public="1" get="inline" set="null" expr="cast 267 | (1 &lt;&lt; 30)" line="251" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 267 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COMPUTER>
	<AC_SEARCH public="1" get="inline" set="null" expr="cast 268 | (1 &lt;&lt; 30)" line="252" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 268 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_SEARCH>
	<AC_HOME public="1" get="inline" set="null" expr="cast 269 | (1 &lt;&lt; 30)" line="253" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 269 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_HOME>
	<AC_BACK public="1" get="inline" set="null" expr="cast 270 | (1 &lt;&lt; 30)" line="254" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 270 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_BACK>
	<AC_FORWARD public="1" get="inline" set="null" expr="cast 271 | (1 &lt;&lt; 30)" line="255" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 271 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_FORWARD>
	<AC_STOP public="1" get="inline" set="null" expr="cast 272 | (1 &lt;&lt; 30)" line="256" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 272 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_STOP>
	<AC_REFRESH public="1" get="inline" set="null" expr="cast 273 | (1 &lt;&lt; 30)" line="257" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 273 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_REFRESH>
	<AC_BOOKMARKS public="1" get="inline" set="null" expr="cast 274 | (1 &lt;&lt; 30)" line="258" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 274 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_BOOKMARKS>
	<BRIGHTNESSDOWN public="1" get="inline" set="null" expr="cast 275 | (1 &lt;&lt; 30)" line="260" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 275 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BRIGHTNESSDOWN>
	<BRIGHTNESSUP public="1" get="inline" set="null" expr="cast 276 | (1 &lt;&lt; 30)" line="261" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 276 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BRIGHTNESSUP>
	<DISPLAYSWITCH public="1" get="inline" set="null" expr="cast 277 | (1 &lt;&lt; 30)" line="262" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 277 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DISPLAYSWITCH>
	<KBDILLUMTOGGLE public="1" get="inline" set="null" expr="cast 278 | (1 &lt;&lt; 30)" line="263" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 278 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KBDILLUMTOGGLE>
	<KBDILLUMDOWN public="1" get="inline" set="null" expr="cast 279 | (1 &lt;&lt; 30)" line="264" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 279 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KBDILLUMDOWN>
	<KBDILLUMUP public="1" get="inline" set="null" expr="cast 280 | (1 &lt;&lt; 30)" line="265" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 280 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KBDILLUMUP>
	<EJECT public="1" get="inline" set="null" expr="cast 281 | (1 &lt;&lt; 30)" line="266" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 281 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EJECT>
	<SLEEP public="1" get="inline" set="null" expr="cast 282 | (1 &lt;&lt; 30)" line="267" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 282 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SLEEP>
	<name public="1" set="method" line="272" static="1">
		<f a="keyCode">
			<x path="ceramic.KeyCode"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Convert a keyCode to string</haxe_doc>
	</name>
	<toString set="method" line="327" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._KeyCode.KeyCode_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/KeyCode.hx" private="1" module="ceramic.KeyCode" final="1">
		<UNKNOWN public="1" get="inline" set="null" expr="cast 0" line="13" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNKNOWN>
		<ENTER public="1" get="inline" set="null" expr="cast 13" line="15" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ENTER>
		<ESCAPE public="1" get="inline" set="null" expr="cast 27" line="16" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 27</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ESCAPE>
		<BACKSPACE public="1" get="inline" set="null" expr="cast 8" line="17" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BACKSPACE>
		<TAB public="1" get="inline" set="null" expr="cast 9" line="18" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TAB>
		<SPACE public="1" get="inline" set="null" expr="cast 32" line="19" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 32</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SPACE>
		<EXCLAIM public="1" get="inline" set="null" expr="cast 33" line="20" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 33</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EXCLAIM>
		<QUOTEDBL public="1" get="inline" set="null" expr="cast 34" line="21" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 34</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUOTEDBL>
		<HASH public="1" get="inline" set="null" expr="cast 35" line="22" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 35</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HASH>
		<PERCENT public="1" get="inline" set="null" expr="cast 37" line="23" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 37</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PERCENT>
		<DOLLAR public="1" get="inline" set="null" expr="cast 36" line="24" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 36</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DOLLAR>
		<AMPERSAND public="1" get="inline" set="null" expr="cast 38" line="25" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 38</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AMPERSAND>
		<QUOTE public="1" get="inline" set="null" expr="cast 39" line="26" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 39</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUOTE>
		<LEFTPAREN public="1" get="inline" set="null" expr="cast 40" line="27" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 40</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFTPAREN>
		<RIGHTPAREN public="1" get="inline" set="null" expr="cast 41" line="28" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 41</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHTPAREN>
		<ASTERISK public="1" get="inline" set="null" expr="cast 42" line="29" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 42</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ASTERISK>
		<PLUS public="1" get="inline" set="null" expr="cast 43" line="30" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 43</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PLUS>
		<COMMA public="1" get="inline" set="null" expr="cast 44" line="31" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 44</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COMMA>
		<MINUS public="1" get="inline" set="null" expr="cast 45" line="32" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 45</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MINUS>
		<PERIOD public="1" get="inline" set="null" expr="cast 46" line="33" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 46</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" expr="cast 47" line="34" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 47</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SLASH>
		<KEY_0 public="1" get="inline" set="null" expr="cast 48" line="35" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 48</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_0>
		<KEY_1 public="1" get="inline" set="null" expr="cast 49" line="36" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 49</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_1>
		<KEY_2 public="1" get="inline" set="null" expr="cast 50" line="37" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 50</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_2>
		<KEY_3 public="1" get="inline" set="null" expr="cast 51" line="38" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 51</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_3>
		<KEY_4 public="1" get="inline" set="null" expr="cast 52" line="39" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 52</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_4>
		<KEY_5 public="1" get="inline" set="null" expr="cast 53" line="40" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 53</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_5>
		<KEY_6 public="1" get="inline" set="null" expr="cast 54" line="41" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 54</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_6>
		<KEY_7 public="1" get="inline" set="null" expr="cast 55" line="42" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 55</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_7>
		<KEY_8 public="1" get="inline" set="null" expr="cast 56" line="43" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 56</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_8>
		<KEY_9 public="1" get="inline" set="null" expr="cast 57" line="44" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 57</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_9>
		<COLON public="1" get="inline" set="null" expr="cast 58" line="45" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 58</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COLON>
		<SEMICOLON public="1" get="inline" set="null" expr="cast 59" line="46" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 59</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SEMICOLON>
		<LESS public="1" get="inline" set="null" expr="cast 60" line="47" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 60</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LESS>
		<EQUALS public="1" get="inline" set="null" expr="cast 61" line="48" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 61</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EQUALS>
		<GREATER public="1" get="inline" set="null" expr="cast 62" line="49" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 62</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</GREATER>
		<QUESTION public="1" get="inline" set="null" expr="cast 63" line="50" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 63</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUESTION>
		<AT public="1" get="inline" set="null" expr="cast 64" line="51" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 64</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AT>
		<LEFTBRACKET public="1" get="inline" set="null" expr="cast 91" line="55" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 91</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFTBRACKET>
		<BACKSLASH public="1" get="inline" set="null" expr="cast 92" line="56" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 92</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BACKSLASH>
		<RIGHTBRACKET public="1" get="inline" set="null" expr="cast 93" line="57" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 93</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHTBRACKET>
		<CARET public="1" get="inline" set="null" expr="cast 94" line="58" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 94</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CARET>
		<UNDERSCORE public="1" get="inline" set="null" expr="cast 95" line="59" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 95</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNDERSCORE>
		<BACKQUOTE public="1" get="inline" set="null" expr="cast 96" line="60" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 96</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BACKQUOTE>
		<KEY_A public="1" get="inline" set="null" expr="cast 97" line="61" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 97</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_A>
		<KEY_B public="1" get="inline" set="null" expr="cast 98" line="62" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 98</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_B>
		<KEY_C public="1" get="inline" set="null" expr="cast 99" line="63" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 99</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_C>
		<KEY_D public="1" get="inline" set="null" expr="cast 100" line="64" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 100</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_D>
		<KEY_E public="1" get="inline" set="null" expr="cast 101" line="65" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 101</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_E>
		<KEY_F public="1" get="inline" set="null" expr="cast 102" line="66" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 102</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_F>
		<KEY_G public="1" get="inline" set="null" expr="cast 103" line="67" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 103</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_G>
		<KEY_H public="1" get="inline" set="null" expr="cast 104" line="68" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 104</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_H>
		<KEY_I public="1" get="inline" set="null" expr="cast 105" line="69" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 105</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_I>
		<KEY_J public="1" get="inline" set="null" expr="cast 106" line="70" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 106</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_J>
		<KEY_K public="1" get="inline" set="null" expr="cast 107" line="71" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 107</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_K>
		<KEY_L public="1" get="inline" set="null" expr="cast 108" line="72" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 108</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_L>
		<KEY_M public="1" get="inline" set="null" expr="cast 109" line="73" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 109</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_M>
		<KEY_N public="1" get="inline" set="null" expr="cast 110" line="74" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 110</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_N>
		<KEY_O public="1" get="inline" set="null" expr="cast 111" line="75" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 111</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_O>
		<KEY_P public="1" get="inline" set="null" expr="cast 112" line="76" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 112</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_P>
		<KEY_Q public="1" get="inline" set="null" expr="cast 113" line="77" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 113</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_Q>
		<KEY_R public="1" get="inline" set="null" expr="cast 114" line="78" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 114</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_R>
		<KEY_S public="1" get="inline" set="null" expr="cast 115" line="79" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 115</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_S>
		<KEY_T public="1" get="inline" set="null" expr="cast 116" line="80" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 116</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_T>
		<KEY_U public="1" get="inline" set="null" expr="cast 117" line="81" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 117</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_U>
		<KEY_V public="1" get="inline" set="null" expr="cast 118" line="82" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 118</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_V>
		<KEY_W public="1" get="inline" set="null" expr="cast 119" line="83" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 119</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_W>
		<KEY_X public="1" get="inline" set="null" expr="cast 120" line="84" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 120</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_X>
		<KEY_Y public="1" get="inline" set="null" expr="cast 121" line="85" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 121</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_Y>
		<KEY_Z public="1" get="inline" set="null" expr="cast 122" line="86" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 122</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_Z>
		<CAPSLOCK public="1" get="inline" set="null" expr="cast 57 | (1 &lt;&lt; 30)" line="88" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 57 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CAPSLOCK>
		<F1 public="1" get="inline" set="null" expr="cast 58 | (1 &lt;&lt; 30)" line="90" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 58 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="cast 59 | (1 &lt;&lt; 30)" line="91" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 59 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="cast 60 | (1 &lt;&lt; 30)" line="92" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 60 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="cast 61 | (1 &lt;&lt; 30)" line="93" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 61 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="cast 62 | (1 &lt;&lt; 30)" line="94" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 62 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="cast 63 | (1 &lt;&lt; 30)" line="95" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 63 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="cast 64 | (1 &lt;&lt; 30)" line="96" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 64 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="cast 65 | (1 &lt;&lt; 30)" line="97" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 65 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="cast 66 | (1 &lt;&lt; 30)" line="98" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 66 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="cast 67 | (1 &lt;&lt; 30)" line="99" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 67 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="cast 68 | (1 &lt;&lt; 30)" line="100" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 68 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="cast 69 | (1 &lt;&lt; 30)" line="101" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 69 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F12>
		<PRINTSCREEN public="1" get="inline" set="null" expr="cast 70 | (1 &lt;&lt; 30)" line="103" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 70 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PRINTSCREEN>
		<SCROLLLOCK public="1" get="inline" set="null" expr="cast 71 | (1 &lt;&lt; 30)" line="104" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 71 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCROLLLOCK>
		<PAUSE public="1" get="inline" set="null" expr="cast 72 | (1 &lt;&lt; 30)" line="105" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 72 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAUSE>
		<INSERT public="1" get="inline" set="null" expr="cast 73 | (1 &lt;&lt; 30)" line="107" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 73 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INSERT>
		<HOME public="1" get="inline" set="null" expr="cast 74 | (1 &lt;&lt; 30)" line="108" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 74 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HOME>
		<PAGEUP public="1" get="inline" set="null" expr="cast 75 | (1 &lt;&lt; 30)" line="109" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 75 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAGEUP>
		<DELETE public="1" get="inline" set="null" expr="cast 127" line="110" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 127</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DELETE>
		<END public="1" get="inline" set="null" expr="cast 77 | (1 &lt;&lt; 30)" line="111" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 77 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</END>
		<PAGEDOWN public="1" get="inline" set="null" expr="cast 78 | (1 &lt;&lt; 30)" line="112" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 78 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAGEDOWN>
		<RIGHT public="1" get="inline" set="null" expr="cast 79 | (1 &lt;&lt; 30)" line="113" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 79 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT>
		<LEFT public="1" get="inline" set="null" expr="cast 80 | (1 &lt;&lt; 30)" line="114" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 80 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT>
		<DOWN public="1" get="inline" set="null" expr="cast 81 | (1 &lt;&lt; 30)" line="115" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 81 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DOWN>
		<UP public="1" get="inline" set="null" expr="cast 82 | (1 &lt;&lt; 30)" line="116" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 82 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UP>
		<NUMLOCKCLEAR public="1" get="inline" set="null" expr="cast 83 | (1 &lt;&lt; 30)" line="118" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 83 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NUMLOCKCLEAR>
		<KP_DIVIDE public="1" get="inline" set="null" expr="cast 84 | (1 &lt;&lt; 30)" line="119" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 84 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DIVIDE>
		<KP_MULTIPLY public="1" get="inline" set="null" expr="cast 85 | (1 &lt;&lt; 30)" line="120" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 85 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MULTIPLY>
		<KP_MINUS public="1" get="inline" set="null" expr="cast 86 | (1 &lt;&lt; 30)" line="121" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 86 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MINUS>
		<KP_PLUS public="1" get="inline" set="null" expr="cast 87 | (1 &lt;&lt; 30)" line="122" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 87 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PLUS>
		<KP_ENTER public="1" get="inline" set="null" expr="cast 88 | (1 &lt;&lt; 30)" line="123" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 88 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_ENTER>
		<KP_1 public="1" get="inline" set="null" expr="cast 89 | (1 &lt;&lt; 30)" line="124" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 89 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_1>
		<KP_2 public="1" get="inline" set="null" expr="cast 90 | (1 &lt;&lt; 30)" line="125" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 90 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_2>
		<KP_3 public="1" get="inline" set="null" expr="cast 91 | (1 &lt;&lt; 30)" line="126" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 91 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_3>
		<KP_4 public="1" get="inline" set="null" expr="cast 92 | (1 &lt;&lt; 30)" line="127" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 92 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_4>
		<KP_5 public="1" get="inline" set="null" expr="cast 93 | (1 &lt;&lt; 30)" line="128" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 93 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_5>
		<KP_6 public="1" get="inline" set="null" expr="cast 94 | (1 &lt;&lt; 30)" line="129" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 94 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_6>
		<KP_7 public="1" get="inline" set="null" expr="cast 95 | (1 &lt;&lt; 30)" line="130" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 95 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_7>
		<KP_8 public="1" get="inline" set="null" expr="cast 96 | (1 &lt;&lt; 30)" line="131" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 96 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_8>
		<KP_9 public="1" get="inline" set="null" expr="cast 97 | (1 &lt;&lt; 30)" line="132" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 97 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_9>
		<KP_0 public="1" get="inline" set="null" expr="cast 98 | (1 &lt;&lt; 30)" line="133" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 98 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_0>
		<KP_PERIOD public="1" get="inline" set="null" expr="cast 99 | (1 &lt;&lt; 30)" line="134" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 99 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PERIOD>
		<APPLICATION public="1" get="inline" set="null" expr="cast 101 | (1 &lt;&lt; 30)" line="136" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 101 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</APPLICATION>
		<POWER public="1" get="inline" set="null" expr="cast 102 | (1 &lt;&lt; 30)" line="138" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 102 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</POWER>
		<KP_EQUALS public="1" get="inline" set="null" expr="cast 103 | (1 &lt;&lt; 30)" line="139" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 103 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_EQUALS>
		<F13 public="1" get="inline" set="null" expr="cast 104 | (1 &lt;&lt; 30)" line="140" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 104 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F13>
		<F14 public="1" get="inline" set="null" expr="cast 105 | (1 &lt;&lt; 30)" line="141" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 105 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F14>
		<F15 public="1" get="inline" set="null" expr="cast 106 | (1 &lt;&lt; 30)" line="142" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 106 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F15>
		<F16 public="1" get="inline" set="null" expr="cast 107 | (1 &lt;&lt; 30)" line="143" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 107 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F16>
		<F17 public="1" get="inline" set="null" expr="cast 108 | (1 &lt;&lt; 30)" line="144" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 108 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F17>
		<F18 public="1" get="inline" set="null" expr="cast 109 | (1 &lt;&lt; 30)" line="145" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 109 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F18>
		<F19 public="1" get="inline" set="null" expr="cast 110 | (1 &lt;&lt; 30)" line="146" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 110 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F19>
		<F20 public="1" get="inline" set="null" expr="cast 111 | (1 &lt;&lt; 30)" line="147" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 111 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F20>
		<F21 public="1" get="inline" set="null" expr="cast 112 | (1 &lt;&lt; 30)" line="148" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 112 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F21>
		<F22 public="1" get="inline" set="null" expr="cast 113 | (1 &lt;&lt; 30)" line="149" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 113 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F22>
		<F23 public="1" get="inline" set="null" expr="cast 114 | (1 &lt;&lt; 30)" line="150" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 114 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F23>
		<F24 public="1" get="inline" set="null" expr="cast 115 | (1 &lt;&lt; 30)" line="151" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 115 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F24>
		<EXECUTE public="1" get="inline" set="null" expr="cast 116 | (1 &lt;&lt; 30)" line="152" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 116 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EXECUTE>
		<HELP public="1" get="inline" set="null" expr="cast 117 | (1 &lt;&lt; 30)" line="153" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 117 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HELP>
		<MENU public="1" get="inline" set="null" expr="cast 118 | (1 &lt;&lt; 30)" line="154" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 118 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MENU>
		<SELECT public="1" get="inline" set="null" expr="cast 119 | (1 &lt;&lt; 30)" line="155" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 119 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SELECT>
		<STOP public="1" get="inline" set="null" expr="cast 120 | (1 &lt;&lt; 30)" line="156" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 120 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</STOP>
		<AGAIN public="1" get="inline" set="null" expr="cast 121 | (1 &lt;&lt; 30)" line="158" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 121 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AGAIN>
		<UNDO public="1" get="inline" set="null" expr="cast 122 | (1 &lt;&lt; 30)" line="159" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 122 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNDO>
		<CUT public="1" get="inline" set="null" expr="cast 123 | (1 &lt;&lt; 30)" line="160" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 123 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CUT>
		<COPY public="1" get="inline" set="null" expr="cast 124 | (1 &lt;&lt; 30)" line="161" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 124 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COPY>
		<PASTE public="1" get="inline" set="null" expr="cast 125 | (1 &lt;&lt; 30)" line="162" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 125 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PASTE>
		<FIND public="1" get="inline" set="null" expr="cast 126 | (1 &lt;&lt; 30)" line="163" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 126 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</FIND>
		<MUTE public="1" get="inline" set="null" expr="cast 127 | (1 &lt;&lt; 30)" line="164" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 127 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MUTE>
		<VOLUMEUP public="1" get="inline" set="null" expr="cast 128 | (1 &lt;&lt; 30)" line="165" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 128 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VOLUMEUP>
		<VOLUMEDOWN public="1" get="inline" set="null" expr="cast 129 | (1 &lt;&lt; 30)" line="166" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 129 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VOLUMEDOWN>
		<KP_COMMA public="1" get="inline" set="null" expr="cast 133 | (1 &lt;&lt; 30)" line="168" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 133 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_COMMA>
		<KP_EQUALSAS400 public="1" get="inline" set="null" expr="cast 134 | (1 &lt;&lt; 30)" line="169" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 134 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_EQUALSAS400>
		<ALTERASE public="1" get="inline" set="null" expr="cast 153 | (1 &lt;&lt; 30)" line="171" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 153 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ALTERASE>
		<SYSREQ public="1" get="inline" set="null" expr="cast 154 | (1 &lt;&lt; 30)" line="172" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 154 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SYSREQ>
		<CANCEL public="1" get="inline" set="null" expr="cast 155 | (1 &lt;&lt; 30)" line="173" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 155 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CANCEL>
		<CLEAR public="1" get="inline" set="null" expr="cast 156 | (1 &lt;&lt; 30)" line="174" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 156 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CLEAR>
		<PRIOR public="1" get="inline" set="null" expr="cast 157 | (1 &lt;&lt; 30)" line="175" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 157 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PRIOR>
		<RETURN2 public="1" get="inline" set="null" expr="cast 158 | (1 &lt;&lt; 30)" line="176" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 158 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RETURN2>
		<SEPARATOR public="1" get="inline" set="null" expr="cast 159 | (1 &lt;&lt; 30)" line="177" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 159 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SEPARATOR>
		<OUT public="1" get="inline" set="null" expr="cast 160 | (1 &lt;&lt; 30)" line="178" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 160 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OUT>
		<OPER public="1" get="inline" set="null" expr="cast 161 | (1 &lt;&lt; 30)" line="179" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 161 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OPER>
		<CLEARAGAIN public="1" get="inline" set="null" expr="cast 162 | (1 &lt;&lt; 30)" line="180" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 162 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CLEARAGAIN>
		<CRSEL public="1" get="inline" set="null" expr="cast 163 | (1 &lt;&lt; 30)" line="181" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 163 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CRSEL>
		<EXSEL public="1" get="inline" set="null" expr="cast 164 | (1 &lt;&lt; 30)" line="182" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 164 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EXSEL>
		<KP_00 public="1" get="inline" set="null" expr="cast 176 | (1 &lt;&lt; 30)" line="184" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 176 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_00>
		<KP_000 public="1" get="inline" set="null" expr="cast 177 | (1 &lt;&lt; 30)" line="185" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 177 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_000>
		<THOUSANDSSEPARATOR public="1" get="inline" set="null" expr="cast 178 | (1 &lt;&lt; 30)" line="186" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 178 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</THOUSANDSSEPARATOR>
		<DECIMALSEPARATOR public="1" get="inline" set="null" expr="cast 179 | (1 &lt;&lt; 30)" line="187" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 179 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DECIMALSEPARATOR>
		<CURRENCYUNIT public="1" get="inline" set="null" expr="cast 180 | (1 &lt;&lt; 30)" line="188" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 180 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CURRENCYUNIT>
		<CURRENCYSUBUNIT public="1" get="inline" set="null" expr="cast 181 | (1 &lt;&lt; 30)" line="189" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 181 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CURRENCYSUBUNIT>
		<KP_LEFTPAREN public="1" get="inline" set="null" expr="cast 182 | (1 &lt;&lt; 30)" line="190" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 182 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_LEFTPAREN>
		<KP_RIGHTPAREN public="1" get="inline" set="null" expr="cast 183 | (1 &lt;&lt; 30)" line="191" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 183 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_RIGHTPAREN>
		<KP_LEFTBRACE public="1" get="inline" set="null" expr="cast 184 | (1 &lt;&lt; 30)" line="192" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 184 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_LEFTBRACE>
		<KP_RIGHTBRACE public="1" get="inline" set="null" expr="cast 185 | (1 &lt;&lt; 30)" line="193" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 185 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_RIGHTBRACE>
		<KP_TAB public="1" get="inline" set="null" expr="cast 186 | (1 &lt;&lt; 30)" line="194" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 186 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_TAB>
		<KP_BACKSPACE public="1" get="inline" set="null" expr="cast 187 | (1 &lt;&lt; 30)" line="195" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 187 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_BACKSPACE>
		<KP_A public="1" get="inline" set="null" expr="cast 188 | (1 &lt;&lt; 30)" line="196" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 188 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_A>
		<KP_B public="1" get="inline" set="null" expr="cast 189 | (1 &lt;&lt; 30)" line="197" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 189 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_B>
		<KP_C public="1" get="inline" set="null" expr="cast 190 | (1 &lt;&lt; 30)" line="198" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 190 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_C>
		<KP_D public="1" get="inline" set="null" expr="cast 191 | (1 &lt;&lt; 30)" line="199" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 191 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_D>
		<KP_E public="1" get="inline" set="null" expr="cast 192 | (1 &lt;&lt; 30)" line="200" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 192 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_E>
		<KP_F public="1" get="inline" set="null" expr="cast 193 | (1 &lt;&lt; 30)" line="201" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 193 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_F>
		<KP_XOR public="1" get="inline" set="null" expr="cast 194 | (1 &lt;&lt; 30)" line="202" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 194 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_XOR>
		<KP_POWER public="1" get="inline" set="null" expr="cast 195 | (1 &lt;&lt; 30)" line="203" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 195 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_POWER>
		<KP_PERCENT public="1" get="inline" set="null" expr="cast 196 | (1 &lt;&lt; 30)" line="204" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 196 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PERCENT>
		<KP_LESS public="1" get="inline" set="null" expr="cast 197 | (1 &lt;&lt; 30)" line="205" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 197 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_LESS>
		<KP_GREATER public="1" get="inline" set="null" expr="cast 198 | (1 &lt;&lt; 30)" line="206" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 198 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_GREATER>
		<KP_AMPERSAND public="1" get="inline" set="null" expr="cast 199 | (1 &lt;&lt; 30)" line="207" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 199 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_AMPERSAND>
		<KP_DBLAMPERSAND public="1" get="inline" set="null" expr="cast 200 | (1 &lt;&lt; 30)" line="208" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 200 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DBLAMPERSAND>
		<KP_VERTICALBAR public="1" get="inline" set="null" expr="cast 201 | (1 &lt;&lt; 30)" line="209" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 201 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_VERTICALBAR>
		<KP_DBLVERTICALBAR public="1" get="inline" set="null" expr="cast 202 | (1 &lt;&lt; 30)" line="210" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 202 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DBLVERTICALBAR>
		<KP_COLON public="1" get="inline" set="null" expr="cast 203 | (1 &lt;&lt; 30)" line="211" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 203 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_COLON>
		<KP_HASH public="1" get="inline" set="null" expr="cast 204 | (1 &lt;&lt; 30)" line="212" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 204 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_HASH>
		<KP_SPACE public="1" get="inline" set="null" expr="cast 205 | (1 &lt;&lt; 30)" line="213" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 205 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_SPACE>
		<KP_AT public="1" get="inline" set="null" expr="cast 206 | (1 &lt;&lt; 30)" line="214" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 206 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_AT>
		<KP_EXCLAM public="1" get="inline" set="null" expr="cast 207 | (1 &lt;&lt; 30)" line="215" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 207 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_EXCLAM>
		<KP_MEMSTORE public="1" get="inline" set="null" expr="cast 208 | (1 &lt;&lt; 30)" line="216" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 208 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMSTORE>
		<KP_MEMRECALL public="1" get="inline" set="null" expr="cast 209 | (1 &lt;&lt; 30)" line="217" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 209 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMRECALL>
		<KP_MEMCLEAR public="1" get="inline" set="null" expr="cast 210 | (1 &lt;&lt; 30)" line="218" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 210 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMCLEAR>
		<KP_MEMADD public="1" get="inline" set="null" expr="cast 211 | (1 &lt;&lt; 30)" line="219" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 211 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMADD>
		<KP_MEMSUBTRACT public="1" get="inline" set="null" expr="cast 212 | (1 &lt;&lt; 30)" line="220" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 212 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMSUBTRACT>
		<KP_MEMMULTIPLY public="1" get="inline" set="null" expr="cast 213 | (1 &lt;&lt; 30)" line="221" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 213 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMMULTIPLY>
		<KP_MEMDIVIDE public="1" get="inline" set="null" expr="cast 214 | (1 &lt;&lt; 30)" line="222" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 214 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMDIVIDE>
		<KP_PLUSMINUS public="1" get="inline" set="null" expr="cast 215 | (1 &lt;&lt; 30)" line="223" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 215 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PLUSMINUS>
		<KP_CLEAR public="1" get="inline" set="null" expr="cast 216 | (1 &lt;&lt; 30)" line="224" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 216 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_CLEAR>
		<KP_CLEARENTRY public="1" get="inline" set="null" expr="cast 217 | (1 &lt;&lt; 30)" line="225" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 217 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_CLEARENTRY>
		<KP_BINARY public="1" get="inline" set="null" expr="cast 218 | (1 &lt;&lt; 30)" line="226" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 218 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_BINARY>
		<KP_OCTAL public="1" get="inline" set="null" expr="cast 219 | (1 &lt;&lt; 30)" line="227" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 219 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_OCTAL>
		<KP_DECIMAL public="1" get="inline" set="null" expr="cast 220 | (1 &lt;&lt; 30)" line="228" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 220 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DECIMAL>
		<KP_HEXADECIMAL public="1" get="inline" set="null" expr="cast 221 | (1 &lt;&lt; 30)" line="229" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 221 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_HEXADECIMAL>
		<LCTRL public="1" get="inline" set="null" expr="cast 224 | (1 &lt;&lt; 30)" line="231" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 224 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LCTRL>
		<LSHIFT public="1" get="inline" set="null" expr="cast 225 | (1 &lt;&lt; 30)" line="232" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 225 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LSHIFT>
		<LALT public="1" get="inline" set="null" expr="cast 226 | (1 &lt;&lt; 30)" line="233" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 226 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LALT>
		<LMETA public="1" get="inline" set="null" expr="cast 227 | (1 &lt;&lt; 30)" line="234" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 227 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LMETA>
		<RCTRL public="1" get="inline" set="null" expr="cast 228 | (1 &lt;&lt; 30)" line="235" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 228 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RCTRL>
		<RSHIFT public="1" get="inline" set="null" expr="cast 229 | (1 &lt;&lt; 30)" line="236" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 229 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RSHIFT>
		<RALT public="1" get="inline" set="null" expr="cast 230 | (1 &lt;&lt; 30)" line="237" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 230 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RALT>
		<RMETA public="1" get="inline" set="null" expr="cast 231 | (1 &lt;&lt; 30)" line="238" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 231 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RMETA>
		<MODE public="1" get="inline" set="null" expr="cast 257 | (1 &lt;&lt; 30)" line="240" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 257 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MODE>
		<AUDIONEXT public="1" get="inline" set="null" expr="cast 258 | (1 &lt;&lt; 30)" line="242" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 258 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIONEXT>
		<AUDIOPREV public="1" get="inline" set="null" expr="cast 259 | (1 &lt;&lt; 30)" line="243" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 259 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOPREV>
		<AUDIOSTOP public="1" get="inline" set="null" expr="cast 260 | (1 &lt;&lt; 30)" line="244" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 260 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOSTOP>
		<AUDIOPLAY public="1" get="inline" set="null" expr="cast 261 | (1 &lt;&lt; 30)" line="245" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 261 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOPLAY>
		<AUDIOMUTE public="1" get="inline" set="null" expr="cast 262 | (1 &lt;&lt; 30)" line="246" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 262 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOMUTE>
		<MEDIASELECT public="1" get="inline" set="null" expr="cast 263 | (1 &lt;&lt; 30)" line="247" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 263 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MEDIASELECT>
		<WWW public="1" get="inline" set="null" expr="cast 264 | (1 &lt;&lt; 30)" line="248" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 264 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WWW>
		<MAIL public="1" get="inline" set="null" expr="cast 265 | (1 &lt;&lt; 30)" line="249" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 265 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MAIL>
		<CALCULATOR public="1" get="inline" set="null" expr="cast 266 | (1 &lt;&lt; 30)" line="250" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 266 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CALCULATOR>
		<COMPUTER public="1" get="inline" set="null" expr="cast 267 | (1 &lt;&lt; 30)" line="251" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 267 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COMPUTER>
		<AC_SEARCH public="1" get="inline" set="null" expr="cast 268 | (1 &lt;&lt; 30)" line="252" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 268 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_SEARCH>
		<AC_HOME public="1" get="inline" set="null" expr="cast 269 | (1 &lt;&lt; 30)" line="253" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 269 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_HOME>
		<AC_BACK public="1" get="inline" set="null" expr="cast 270 | (1 &lt;&lt; 30)" line="254" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 270 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_BACK>
		<AC_FORWARD public="1" get="inline" set="null" expr="cast 271 | (1 &lt;&lt; 30)" line="255" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 271 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_FORWARD>
		<AC_STOP public="1" get="inline" set="null" expr="cast 272 | (1 &lt;&lt; 30)" line="256" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 272 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_STOP>
		<AC_REFRESH public="1" get="inline" set="null" expr="cast 273 | (1 &lt;&lt; 30)" line="257" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 273 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_REFRESH>
		<AC_BOOKMARKS public="1" get="inline" set="null" expr="cast 274 | (1 &lt;&lt; 30)" line="258" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 274 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_BOOKMARKS>
		<BRIGHTNESSDOWN public="1" get="inline" set="null" expr="cast 275 | (1 &lt;&lt; 30)" line="260" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 275 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BRIGHTNESSDOWN>
		<BRIGHTNESSUP public="1" get="inline" set="null" expr="cast 276 | (1 &lt;&lt; 30)" line="261" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 276 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BRIGHTNESSUP>
		<DISPLAYSWITCH public="1" get="inline" set="null" expr="cast 277 | (1 &lt;&lt; 30)" line="262" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 277 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DISPLAYSWITCH>
		<KBDILLUMTOGGLE public="1" get="inline" set="null" expr="cast 278 | (1 &lt;&lt; 30)" line="263" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 278 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KBDILLUMTOGGLE>
		<KBDILLUMDOWN public="1" get="inline" set="null" expr="cast 279 | (1 &lt;&lt; 30)" line="264" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 279 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KBDILLUMDOWN>
		<KBDILLUMUP public="1" get="inline" set="null" expr="cast 280 | (1 &lt;&lt; 30)" line="265" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 280 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KBDILLUMUP>
		<EJECT public="1" get="inline" set="null" expr="cast 281 | (1 &lt;&lt; 30)" line="266" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 281 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EJECT>
		<SLEEP public="1" get="inline" set="null" expr="cast 282 | (1 &lt;&lt; 30)" line="267" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 282 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SLEEP>
		<name public="1" set="method" line="272" static="1">
			<f a="keyCode">
				<x path="ceramic.KeyCode"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Convert a keyCode to string</haxe_doc>
		</name>
		<toString set="method" line="327" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="polyline.MiterUtils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/polyline/polyline/MiterUtils.hx">
		<tangentX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tangentX>
		<tangentY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tangentY>
		<miterX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</miterX>
		<miterY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</miterY>
		<aX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</aX>
		<aY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</aY>
		<bX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bX>
		<bY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bY>
		<outX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</outX>
		<outY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</outY>
		<tmpX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tmpX>
		<tmpY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tmpY>
		<computeMiter public="1" get="inline" set="null" line="31"><f a="halfThick">
	<x path="Float"/>
	<x path="Float"/>
</f></computeMiter>
		<normal public="1" get="inline" set="null" line="48"><f a="dirX:dirY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></normal>
		<direction public="1" get="inline" set="null" line="56"><f a=""><x path="Void"/></f></direction>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="polyline.Stroke" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/polyline/polyline/Stroke.hx">
		<NUMBER_NONE get="inline" set="null" expr="-9999999999.0" line="7" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>-9999999999.0</e></m></meta>
		</NUMBER_NONE>
		<MATH_TWO_PI get="inline" set="null" expr="6.28318530718" line="9" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>6.28318530718</e></m></meta>
		</MATH_TWO_PI>
		<MATH_HALF_PI get="inline" set="null" expr="1.57079632679" line="11" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.57079632679</e></m></meta>
		</MATH_HALF_PI>
		<MATH_PI_AND_HALF get="inline" set="null" expr="4.71238898038" line="13" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>4.71238898038</e></m></meta>
		</MATH_PI_AND_HALF>
		<miterUtils expr="new MiterUtils()" line="15" static="1">
			<c path="polyline.MiterUtils"/>
			<meta><m n=":value"><e>new MiterUtils()</e></m></meta>
		</miterUtils>
		<miterLimit public="1" expr="10">
			<x path="Float"/>
			<meta><m n=":value"><e>10</e></m></meta>
			<haxe_doc>The limit before miters turn into bevels. Default 10</haxe_doc>
		</miterLimit>
		<thickness public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>The line thickness</haxe_doc>
		</thickness>
		<join public="1" expr="MITER">
			<e path="polyline.StrokeJoin"/>
			<meta><m n=":value"><e>MITER</e></m></meta>
			<haxe_doc>The join type, can be `MITER` or `BEVEL`. Default `MITER`</haxe_doc>
		</join>
		<cap public="1" expr="BUTT">
			<e path="polyline.StrokeCap"/>
			<meta><m n=":value"><e>BUTT</e></m></meta>
			<haxe_doc>The cap type. Can be `BUTT` or `SQUARE`. Default `BUTT`</haxe_doc>
		</cap>
		<canLoop public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Will try to join the first and last points together if they are identical</haxe_doc>
		</canLoop>
		<tmpX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tmpX>
		<tmpY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tmpY>
		<lineAX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lineAX>
		<lineAY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lineAY>
		<lineBX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lineBX>
		<lineBY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lineBY>
		<tangentX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tangentX>
		<tangentY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tangentY>
		<miterX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</miterX>
		<miterY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</miterY>
		<capEndX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</capEndX>
		<capEndY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</capEndY>
		<_hasNormal expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_hasNormal>
		<_normalX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_normalX>
		<_normalY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_normalY>
		<_lastFlip expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</_lastFlip>
		<_started expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_started>
		<_points expr="null">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</_points>
		<build public="1" set="method" line="74"><f a="points:vertices:indices">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></build>
		<mapThickness set="method" line="188"><f a="pointX:pointY:i:points">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
</f></mapThickness>
		<_seg get="inline" set="null" line="194"><f a="vertices:indices:index:lastX:lastY:curX:curY:nextX:nextY:halfThick">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></_seg>
		<extrusions get="inline" set="null" line="386"><f a="vertices:pointX:pointY:normalX:normalY:scale">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></extrusions>
		<pointsAngle get="inline" set="null" line="401"><f a="x:y:x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pointsAngle>
		<distanceToLine get="inline" set="null" line="410"><f a="x:y:x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></distanceToLine>
		<new public="1" set="method" line="68"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Line" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Line.hx">
		<extends path="ceramic.Mesh"/>
		<_stroke expr="new Stroke()" line="21" static="1">
			<c path="polyline.Stroke"/>
			<meta><m n=":value"><e>new Stroke()</e></m></meta>
		</_stroke>
		<points public="1" set="accessor" expr="null">
			<c path="Array"><x path="Float"/></c>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* Line points.
     * Note: when editing array content without reassigning it,
     * `contentDirty` must be set to `true` to let the line being updated accordingly.</haxe_doc>
		</points>
		<set_points get="inline" set="null" line="30"><f a="points">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
</f></set_points>
		<miterLimit public="1" set="accessor" expr="10">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>10</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* The limit before miters turn into bevels. Default 10</haxe_doc>
		</miterLimit>
		<set_miterLimit get="inline" set="null" line="41"><f a="miterLimit">
	<x path="Float"/>
	<x path="Float"/>
</f></set_miterLimit>
		<thickness public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n="editable"><e>{ slider : [1, 64] }</e></m>
			</meta>
			<haxe_doc>* The line thickness</haxe_doc>
		</thickness>
		<set_thickness get="inline" set="null" line="53"><f a="thickness">
	<x path="Float"/>
	<x path="Float"/>
</f></set_thickness>
		<join public="1" set="accessor" expr="BEVEL">
			<t path="ceramic.LineJoin"/>
			<meta>
				<m n=":value"><e>BEVEL</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* The join type, can be `MITER` or `BEVEL`. Default `BEVEL`</haxe_doc>
		</join>
		<set_join get="inline" set="null" line="65"><f a="join">
	<t path="ceramic.LineJoin"/>
	<t path="ceramic.LineJoin"/>
</f></set_join>
		<cap public="1" set="accessor" expr="BUTT">
			<t path="ceramic.LineCap"/>
			<meta>
				<m n=":value"><e>BUTT</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* The cap type. Can be `BUTT` or `SQUARE`. Default `BUTT`</haxe_doc>
		</cap>
		<set_cap get="inline" set="null" line="77"><f a="cap">
	<t path="ceramic.LineCap"/>
	<t path="ceramic.LineCap"/>
</f></set_cap>
		<loop public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* If `loop` is `true`, will try to join the first and last
     * points together if they are identical. Default `false`</haxe_doc>
		</loop>
		<set_loop get="inline" set="null" line="90"><f a="loop">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_loop>
		<autoComputeSize public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="editable"><e>{ label : "Auto Size" }</e></m>
			</meta>
			<haxe_doc>* If set to `true`, width and heigh will be computed from line points.</haxe_doc>
		</autoComputeSize>
		<set_autoComputeSize get="inline" set="null" line="102"><f a="autoComputeSize">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoComputeSize>
		<computeContent public="1" set="method" line="110" override="1"><f a=""><x path="Void"/></f></computeContent>
		<computeSize public="1" set="method" line="136" override="1"><f a=""><x path="Void"/></f></computeSize>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Display lines composed of multiple segments, curves...</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n="editable"><e>{ implicitSize : true, highlight : { points : "points", minPoints : 2, maxPoints : 999999999 }, disable : ["texture", "vertices", "indices", "uvs"] }</e></m>
		</meta>
	</class>
	<typedef path="ceramic.LineCap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/LineCap.hx"><e path="polyline.StrokeCap"/></typedef>
	<typedef path="ceramic.LineJoin" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/LineJoin.hx"><e path="polyline.StrokeJoin"/></typedef>
	<class path="ceramic.Logger" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Logger.hx">
		<extends path="ceramic.Entity"/>
		<didInitOnce expr="false" line="26" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</didInitOnce>
		<_dox_event__info public="1" set="method" line="637">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__info>
		<emitInfo set="method" line="1095">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>info event</haxe_doc>
		</emitInfo>
		<onInfo public="1" set="method" line="1199">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>info event</haxe_doc>
		</onInfo>
		<onceInfo public="1" set="method" line="1298">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>info event</haxe_doc>
		</onceInfo>
		<offInfo public="1" set="method" line="1368">
			<f a="?handleValuePos">
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>info event</haxe_doc>
		</offInfo>
		<listensInfo public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to info event</haxe_doc>
		</listensInfo>
		<_dox_event__debug public="1" set="method" line="637">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__debug>
		<emitDebug set="method" line="1095">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>debug event</haxe_doc>
		</emitDebug>
		<onDebug public="1" set="method" line="1199">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>debug event</haxe_doc>
		</onDebug>
		<onceDebug public="1" set="method" line="1298">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>debug event</haxe_doc>
		</onceDebug>
		<offDebug public="1" set="method" line="1368">
			<f a="?handleValuePos">
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>debug event</haxe_doc>
		</offDebug>
		<listensDebug public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to debug event</haxe_doc>
		</listensDebug>
		<_dox_event__success public="1" set="method" line="637">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__success>
		<emitSuccess set="method" line="1095">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>success event</haxe_doc>
		</emitSuccess>
		<onSuccess public="1" set="method" line="1199">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>success event</haxe_doc>
		</onSuccess>
		<onceSuccess public="1" set="method" line="1298">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>success event</haxe_doc>
		</onceSuccess>
		<offSuccess public="1" set="method" line="1368">
			<f a="?handleValuePos">
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>success event</haxe_doc>
		</offSuccess>
		<listensSuccess public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to success event</haxe_doc>
		</listensSuccess>
		<_dox_event__warning public="1" set="method" line="637">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__warning>
		<emitWarning set="method" line="1095">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>warning event</haxe_doc>
		</emitWarning>
		<onWarning public="1" set="method" line="1199">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>warning event</haxe_doc>
		</onWarning>
		<onceWarning public="1" set="method" line="1298">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>warning event</haxe_doc>
		</onceWarning>
		<offWarning public="1" set="method" line="1368">
			<f a="?handleValuePos">
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>warning event</haxe_doc>
		</offWarning>
		<listensWarning public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to warning event</haxe_doc>
		</listensWarning>
		<_dox_event__error public="1" set="method" line="637">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__error>
		<emitError set="method" line="1095">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>error event</haxe_doc>
		</emitError>
		<onError public="1" set="method" line="1199">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>error event</haxe_doc>
		</onError>
		<onceError public="1" set="method" line="1298">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>error event</haxe_doc>
		</onceError>
		<offError public="1" set="method" line="1368">
			<f a="?handleValuePos">
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>error event</haxe_doc>
		</offError>
		<listensError public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to error event</haxe_doc>
		</listensError>
		<indentPrefix expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</indentPrefix>
		<debug public="1" set="method" line="46"><f a="value:?pos">
	<d/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></debug>
		<info public="1" set="method" line="69"><f a="value:?pos">
	<d/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></info>
		<success public="1" set="method" line="92"><f a="value:?pos">
	<d/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></success>
		<warning public="1" set="method" line="115"><f a="value:?pos">
	<d/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></warning>
		<error public="1" set="method" line="144"><f a="value:?pos">
	<d/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></error>
		<pushIndent public="1" get="inline" set="null" line="173"><f a=""><x path="Void"/></f></pushIndent>
		<popIndent public="1" get="inline" set="null" line="179"><f a=""><x path="Void"/></f></popIndent>
		<prefixLines set="method" line="187"><f a="prefix:input">
	<c path="String"/>
	<d/>
	<c path="String"/>
</f></prefixLines>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<class path="ceramic.LongPress" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/LongPress.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<_dox_event_longPress public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_longPress>
		<emitLongPress set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>longPress event</haxe_doc>
		</emitLongPress>
		<onLongPress public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>longPress event</haxe_doc>
		</onLongPress>
		<onceLongPress public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>longPress event</haxe_doc>
		</onceLongPress>
		<offLongPress public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>longPress event</haxe_doc>
		</offLongPress>
		<listensLongPress public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to longPress event</haxe_doc>
		</listensLongPress>
		<threshold public="1" expr="4.0">
			<x path="Float"/>
			<meta><m n=":value"><e>4.0</e></m></meta>
		</threshold>
		<requiredDuration public="1" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</requiredDuration>
		<entity public="1">
			<c path="ceramic.Visual"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<click public="1"><c path="ceramic.Click"/></click>
		<bindAsComponent set="method" line="35"><f a=""><x path="Void"/></f></bindAsComponent>
		<pointerStartX expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</pointerStartX>
		<pointerStartY expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</pointerStartY>
		<didLongPress expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</didLongPress>
		<cancelLongPress expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</cancelLongPress>
		<bindPointerEvents set="method" line="52"><f a=""><x path="Void"/></f></bindPointerEvents>
		<handlePointerDown set="method" line="59"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerDown>
		<handlePointerMove set="method" line="81"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerMove>
		<handlePointerUp set="method" line="93"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerUp>
		<setEntity set="method" line="5">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="5">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="23"><f a="?handleLongPress:?click">
	<f a="">
		<c path="ceramic.TouchInfo"/>
		<x path="Void"/>
	</f>
	<c path="ceramic.Click"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.LowRes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/LowRes.hx">
		<extends path="ceramic.Layer"/>
		<pixelArt>
			<c path="ceramic.PixelArt"/>
			<haxe_doc>* Pixel art container to display nice and sharp pixels at any size</haxe_doc>
		</pixelArt>
		<filter>
			<c path="ceramic.Filter"/>
			<haxe_doc>* Filter used to create supersampled content</haxe_doc>
		</filter>
		<sharpness public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Sharpness of the pixels (from 1.0 to above)</haxe_doc>
		</sharpness>
		<get_sharpness get="inline" set="null" line="23"><f a=""><x path="Float"/></f></get_sharpness>
		<set_sharpness get="inline" set="null" line="26"><f a="sharpness">
	<x path="Float"/>
	<x path="Float"/>
</f></set_sharpness>
		<explicitRender public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Explicit render?</haxe_doc>
		</explicitRender>
		<get_explicitRender get="inline" set="null" line="34"><f a=""><x path="Bool"/></f></get_explicitRender>
		<set_explicitRender get="inline" set="null" line="37"><f a="explicitRender">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_explicitRender>
		<autoRender public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Auto render?</haxe_doc>
		</autoRender>
		<get_autoRender get="inline" set="null" line="45"><f a=""><x path="Bool"/></f></get_autoRender>
		<set_autoRender get="inline" set="null" line="48"><f a="autoRender">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoRender>
		<density public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Density value used for supersampled content.
     * A density of 1 means no supersampling (thus no antialiasing).
     * Any value above (2 or more) will increase the supersampled content size and generate antialiasing.
     * Use a power of two and not a too high value (2 is recommended if result is nice enough).</haxe_doc>
		</density>
		<set_density set="method" line="59"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<content public="1" set="null">
			<c path="ceramic.Quad"/>
			<haxe_doc>* The visual containing what should be displayed</haxe_doc>
		</content>
		<handleResize set="method" line="90"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></handleResize>
		<new public="1" set="method" line="72"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A container to display visuals at low resolution,
 * with the possibility to use antialiasing (supersampling).</haxe_doc>
		<meta>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.MeshColorMapping" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MeshColorMapping.hx">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._MeshColorMapping.MeshColorMapping_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MeshColorMapping.hx" private="1" module="ceramic.MeshColorMapping" extern="1" final="1">
	<MESH public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
		<x path="ceramic.MeshColorMapping"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Map a single color to the whole mesh.</haxe_doc>
	</MESH>
	<INDICES public="1" get="inline" set="null" expr="cast 1" line="11" static="1">
		<x path="ceramic.MeshColorMapping"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Map a color to each indice.</haxe_doc>
	</INDICES>
	<VERTICES public="1" get="inline" set="null" expr="cast 2" line="15" static="1">
		<x path="ceramic.MeshColorMapping"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Map a color to each vertex.</haxe_doc>
	</VERTICES>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._MeshColorMapping.MeshColorMapping_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MeshColorMapping.hx" private="1" module="ceramic.MeshColorMapping" extern="1" final="1">
		<MESH public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
			<x path="ceramic.MeshColorMapping"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Map a single color to the whole mesh.</haxe_doc>
		</MESH>
		<INDICES public="1" get="inline" set="null" expr="cast 1" line="11" static="1">
			<x path="ceramic.MeshColorMapping"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Map a color to each indice.</haxe_doc>
		</INDICES>
		<VERTICES public="1" get="inline" set="null" expr="cast 2" line="15" static="1">
			<x path="ceramic.MeshColorMapping"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Map a color to each vertex.</haxe_doc>
		</VERTICES>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="ceramic.MeshExtensions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MeshExtensions.hx">
		<createQuad public="1" set="method" line="20" static="1">
			<f a="mesh:width:height:?floatsPerVertex" v=":::-1">
				<c path="ceramic.Mesh"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ floatsPerVertex : -1 }</e></m></meta>
			<haxe_doc>* Generate vertices, indices and uvs on the given mesh to make it form a quad
     * @param mesh The mesh to work with
     * @param width With of the quad to form
     * @param height Height of the quad to form
     * @param floatsPerVertex
     *          (optional) Number of floats per vertex
     *          Set to 2 for regular quad, 6 for quads with dark color, must be 2 or higher.
     *          If not provided, will resolve the value from `mesh.customFloatAttributesSize`</haxe_doc>
		</createQuad>
		<setDarkColor public="1" set="method" line="101" static="1">
			<f a="mesh:darkColor">
				<c path="ceramic.Mesh"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assign a dark color to the given mesh.
     * The mesh is expected to have 6 floats per vertex
     * and 4 last vertices will be used for color values.
     * @param mesh The mesh to work with
     * @param darkColor The dark color to assign</haxe_doc>
		</setDarkColor>
		<setDarkAlphaColor public="1" set="method" line="130" static="1">
			<f a="mesh:darkAlphaColor">
				<c path="ceramic.Mesh"/>
				<x path="ceramic.AlphaColor"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assign a dark color (with alpha included) to the given mesh.
     * The mesh is expected to have 6 floats per vertex
     * and 4 last vertices will be used for color values.
     * @param mesh The mesh to work with
     * @param darkColor The dark color to assign</haxe_doc>
		</setDarkAlphaColor>
		<createArc public="1" set="method" line="162" static="1">
			<f a="mesh:radius:angle:thickness:sides:borderPosition">
				<c path="ceramic.Mesh"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<e path="ceramic.BorderPosition"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Generate vertices and indices to draw arc, pie, ring or disc geometry
     * @param mesh The mesh to work with
     * @param radius Radius of the arc
     * @param angle Angle (from 0 to 360). 360 will make it draw a full circle/ring
     * @param thickness Thickness of the arc. If same value as radius and borderPosition is `INSIDE`, will draw a pie.
     * @param sides Number of sides. Higher is smoother but needs more vertices
     * @param borderPosition Position of the drawn border</haxe_doc>
		</createArc>
		<createVerticesGrid public="1" set="method" line="235" static="1">
			<f a="mesh:columns:rows:width:height:?staggerX:?staggerY:?attrLength:?attrValues" v=":::::0:0:0:">
				<c path="ceramic.Mesh"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ attrLength : 0, staggerY : 0, staggerX : 0 }</e></m></meta>
			<haxe_doc>* Create vertices to form a grid with the given options
     * @param mesh The mesh to work with
     * @param columns The number of columns in the grid
     * @param rows The number of rows in the grid
     * @param width The total width of the grid
     * @param height The total height of the grid
     * @param staggerX (optional, default 0) A stagger value to offset rows by this value
     * @param staggerY (optional, default 0) A stagger value to offset columns by this value
     * @param attrLength (optional, default 0) The number of attribute values per vertex
     * @param attrValues (optional) The attributes buffer that will be added to vertex data</haxe_doc>
		</createVerticesGrid>
		<createIndicesGrid public="1" set="method" line="248" static="1">
			<f a="mesh:columns:rows:?mirrorX:?mirrorY:?mirrorFlip" v=":::false:false:false">
				<c path="ceramic.Mesh"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mirrorFlip : false, mirrorY : false, mirrorX : false }</e></m></meta>
			<haxe_doc>* Create indices to form a grid with the given options
     * @param mesh The mesh to work with
     * @param columns The number of columns in the grid
     * @param rows The number of rows in the grid
     * @param mirrorX (optional, default false) Mirror triangles horizontally in odd columns
     * @param mirrorY (optional, default false) Mirror triangles vertically in odd rows
     * @param mirrorFlip (optional, default false) Invert the mirroring described by `mirrorX` and `mirrorY`</haxe_doc>
		</createIndicesGrid>
		<createUVsGrid public="1" set="method" line="260" static="1">
			<f a="mesh:columns:rows">
				<c path="ceramic.Mesh"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create uvs to match a grid with the given options.
     * The uvs will be distributed linearly across the mesh so that
     * when displaying a texture it would be stretched to the grid.
     * @param mesh The mesh to work with
     * @param columns The number of columns in the grid
     * @param rows The number of rows in the grid</haxe_doc>
		</createUVsGrid>
		<haxe_doc>* Static extension with additional helpers for `ceramic.Mesh`</haxe_doc>
	</class>
	<class path="ceramic.MeshPool" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MeshPool.hx">
		<availableMeshes expr="[]" line="10" static="1">
			<c path="Array"><c path="ceramic.Mesh"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</availableMeshes>
		<availableFloatArrays expr="[]" line="12" static="1">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</availableFloatArrays>
		<availableIntArrays expr="[]" line="13" static="1">
			<c path="Array"><c path="Array"><x path="Int"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</availableIntArrays>
		<getIntArray public="1" get="inline" set="null" line="15" static="1">
			<f a=""><c path="Array"><x path="Int"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</getIntArray>
		<getFloatArray public="1" get="inline" set="null" line="21" static="1">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</getFloatArray>
		<recycleIntArray public="1" get="inline" set="null" line="27" static="1">
			<f a="array">
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</recycleIntArray>
		<recycleFloatArray public="1" get="inline" set="null" line="42" static="1">
			<f a="array">
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</recycleFloatArray>
		<get public="1" set="method" line="60" static="1">
			<f a=""><c path="ceramic.Mesh"/></f>
			<haxe_doc>* Get or create a mesh. The mesh is active an ready to be displayed.</haxe_doc>
		</get>
		<recycle public="1" set="method" line="90" static="1">
			<f a="mesh">
				<c path="ceramic.Mesh"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Recycle an existing mesh. The mesh will be cleaned up and marked as inactive (e.g. not displayed)</haxe_doc>
		</recycle>
		<clear public="1" set="method" line="167" static="1"><f a=""><x path="Void"/></f></clear>
		<haxe_doc>* An utility to reuse meshes at application level.</haxe_doc>
	</class>
	<class path="ceramic.MeshUtils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MeshUtils.hx">
		<createVerticesGrid public="1" set="method" line="20" static="1">
			<f a="?vertices:columns:rows:width:height:?staggerX:?staggerY:?attrLength:?attrValues" v=":::::0:0:0:">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ attrLength : 0, staggerY : 0, staggerX : 0 }</e></m></meta>
			<haxe_doc>* Create vertices to form a grid with the given options
     * @param vertices (optional) The existing vertices. If provided, will be used as result instead of creating a new array
     * @param columns The number of columns in the grid
     * @param rows The number of rows in the grid
     * @param width The total width of the grid
     * @param height The total height of the grid
     * @param staggerX (optional, default 0) A stagger value to offset rows by this value
     * @param staggerY (optional, default 0) A stagger value to offset columns by this value
     * @param attrLength (optional, default 0) The number of attribute values per vertex
     * @param attrValues (optional) The attributes buffer that will be added to vertex data
     * @return The generated vertices</haxe_doc>
		</createVerticesGrid>
		<createIndicesGrid public="1" set="method" line="124" static="1">
			<f a="?indices:columns:rows:?mirrorX:?mirrorY:?mirrorFlip" v=":::false:false:false">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ mirrorFlip : false, mirrorY : false, mirrorX : false }</e></m></meta>
			<haxe_doc>* Create indices to form a grid with the given options
     * @param indices (optional) The existing indices. If provided, will be used as result instead of creating a new array
     * @param columns The number of columns in the grid
     * @param rows The number of rows in the grid
     * @param mirrorX (optional, default false) Mirror triangles horizontally in odd columns
     * @param mirrorY (optional, default false) Mirror triangles vertically in odd rows
     * @param mirrorFlip (optional, default false) Invert the mirroring described by `mirrorX` and `mirrorY`
     * @return The generated indices</haxe_doc>
		</createIndicesGrid>
		<createUVsGrid public="1" set="method" line="187" static="1">
			<f a="?uvs:columns:rows">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Create uvs to match a grid with the given options.
     * The uvs will be distributed linearly across the mesh so that
     * when displaying a texture it would be stretched to the grid.
     * @param uvs (optional) The existing uvs. If provided, will be used as result instead of creating a new array
     * @param columns The number of columns in the grid
     * @param rows The number of rows in the grid
     * @return The generated uvs</haxe_doc>
		</createUVsGrid>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="ceramic.MouseButton" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MouseButton.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>* A typed (mouse) button id</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._MouseButton.MouseButton_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MouseButton.hx" private="1" module="ceramic.MouseButton" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast -1" line="11" static="1">
		<x path="ceramic.MouseButton"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* No mouse buttons</haxe_doc>
	</NONE>
	<LEFT public="1" get="inline" set="null" expr="cast 0" line="15" static="1">
		<x path="ceramic.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Left mouse button</haxe_doc>
	</LEFT>
	<MIDDLE public="1" get="inline" set="null" expr="cast 1" line="19" static="1">
		<x path="ceramic.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Middle mouse button</haxe_doc>
	</MIDDLE>
	<RIGHT public="1" get="inline" set="null" expr="cast 2" line="23" static="1">
		<x path="ceramic.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Right mouse button</haxe_doc>
	</RIGHT>
	<EXTRA1 public="1" get="inline" set="null" expr="cast 3" line="27" static="1">
		<x path="ceramic.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Extra button pressed</haxe_doc>
	</EXTRA1>
	<EXTRA2 public="1" get="inline" set="null" expr="cast 4" line="31" static="1">
		<x path="ceramic.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Extra button pressed</haxe_doc>
	</EXTRA2>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._MouseButton.MouseButton_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MouseButton.hx" private="1" module="ceramic.MouseButton" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast -1" line="11" static="1">
			<x path="ceramic.MouseButton"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* No mouse buttons</haxe_doc>
		</NONE>
		<LEFT public="1" get="inline" set="null" expr="cast 0" line="15" static="1">
			<x path="ceramic.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Left mouse button</haxe_doc>
		</LEFT>
		<MIDDLE public="1" get="inline" set="null" expr="cast 1" line="19" static="1">
			<x path="ceramic.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Middle mouse button</haxe_doc>
		</MIDDLE>
		<RIGHT public="1" get="inline" set="null" expr="cast 2" line="23" static="1">
			<x path="ceramic.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Right mouse button</haxe_doc>
		</RIGHT>
		<EXTRA1 public="1" get="inline" set="null" expr="cast 3" line="27" static="1">
			<x path="ceramic.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Extra button pressed</haxe_doc>
		</EXTRA1>
		<EXTRA2 public="1" get="inline" set="null" expr="cast 4" line="31" static="1">
			<x path="ceramic.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Extra button pressed</haxe_doc>
		</EXTRA2>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="ceramic.Ngon" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Ngon.hx">
		<extends path="ceramic.Mesh"/>
		<sides public="1" set="accessor" expr="32">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>32</e></m>
				<m n="editable"><e>{ slider : [3, 100] }</e></m>
			</meta>
		</sides>
		<set_sides get="inline" set="null" line="10"><f a="sides">
	<x path="Int"/>
	<x path="Int"/>
</f></set_sides>
		<radius public="1" set="accessor" expr="50">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>50</e></m>
				<m n="editable"><e>{ slider : [0, 999] }</e></m>
			</meta>
		</radius>
		<set_radius set="method" line="19"><f a="radius">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius>
		<computeContent public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></computeContent>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n="editable"><e>{ implicitSize : true }</e></m>
		</meta>
	</class>
	<class path="ceramic.ParticleEmitter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ParticleEmitter.hx">
		<extends path="ceramic.Entity"/>
		<implements path="tracker.Observable"/>
		<implements path="ceramic.Component"/>
		<_point expr="new Point(0, 0)" line="797" static="1">
			<c path="ceramic.Point"/>
			<meta><m n=":value"><e>new Point(0, 0)</e></m></meta>
			<haxe_doc>* Internal point object, handy for reusing for memory management purposes.</haxe_doc>
		</_point>
		<degToRad get="inline" set="null" line="1317" static="1"><f a="deg">
	<x path="Float"/>
	<x path="Float"/>
</f></degToRad>
		<interpolateColor get="inline" set="null" line="1340" static="1"><f a="a:b:percent">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
	<x path="Float"/>
	<x path="ceramic.Color"/>
</f></interpolateColor>
		<velocityFromAngle get="inline" set="null" line="1350" static="1"><f a="angle:speed:result">
	<x path="Float"/>
	<x path="Float"/>
	<c path="ceramic.Point"/>
	<x path="Void"/>
</f></velocityFromAngle>
		<computeVelocity get="inline" set="null" line="1369" static="1">
			<f a="velocity:acceleration:drag:max:elapsed">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* A tween-like function that takes a starting velocity and some other factors and returns an altered velocity.
     *
     * @param	velocity		Any component of velocity (e.g. 20).
     * @param	acceleration	Rate at which the velocity is changing.
     * @param	drag	This is how much the velocity changes if acceleration is not set.
     * @param	max				An absolute value cap for the velocity (0 for no cap).
     * @param	elapsed			The amount of time passed in to the latest update cycle
     * @return	The altered velocity value.</haxe_doc>
		</computeVelocity>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.ParticleEmitter"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.ParticleEmitter"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.ParticleEmitter"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.ParticleEmitter"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.ParticleEmitter"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<entity public="1">
			<c path="ceramic.Visual"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<visual public="1" get="accessor" set="accessor"><c path="ceramic.Visual"/></visual>
		<get_visual get="inline" set="null" line="21"><f a=""><c path="ceramic.Visual"/></f></get_visual>
		<set_visual get="inline" set="null" line="22"><f a="visual">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
</f></set_visual>
		<_dox_event__emitParticle public="1" set="method" line="637">
			<f a="particle">
				<c path="ceramic.ParticleItem"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__emitParticle>
		<emitEmitParticle set="method" line="1095">
			<f a="particle">
				<c path="ceramic.ParticleItem"/>
				<x path="Void"/>
			</f>
			<haxe_doc>emitParticle event</haxe_doc>
		</emitEmitParticle>
		<onEmitParticle public="1" set="method" line="1199">
			<f a="owner:handleParticle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="particle">
					<c path="ceramic.ParticleItem"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>emitParticle event</haxe_doc>
		</onEmitParticle>
		<onceEmitParticle public="1" set="method" line="1298">
			<f a="owner:handleParticle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="particle">
					<c path="ceramic.ParticleItem"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>emitParticle event</haxe_doc>
		</onceEmitParticle>
		<offEmitParticle public="1" set="method" line="1368">
			<f a="?handleParticle">
				<f a="particle">
					<c path="ceramic.ParticleItem"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>emitParticle event</haxe_doc>
		</offEmitParticle>
		<listensEmitParticle public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to emitParticle event</haxe_doc>
		</listensEmitParticle>
		<size public="1" get="inline" set="null" line="34">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The width and height of the emission area.
     * If not defined (`-1`), will use visual's width and height bound to this `ParticleEmitter` object, if any</haxe_doc>
		</size>
		<pos public="1" get="inline" set="null" line="42">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The x and y position of the emission, relative to particles parent (if any)</haxe_doc>
		</pos>
		<maxVelocity public="1" get="inline" set="null" line="51">
			<f a="maxVelocityX:maxVelocityY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
     * to cap the speed automatically (very useful!).</haxe_doc>
		</maxVelocity>
		<velocityStart public="1" get="inline" set="null" line="59">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the velocity starting range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityStart>
		<velocityEnd public="1" get="inline" set="null" line="79">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the velocity ending range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityEnd>
		<speedStart public="1" get="inline" set="null" line="99">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the speed starting range of particles launched from this emitter. Only used with `CIRCLE`.</haxe_doc>
		</speedStart>
		<speedEnd public="1" get="inline" set="null" line="107">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the speed ending range of particles launched from this emitter. Only used with `CIRCLE`.</haxe_doc>
		</speedEnd>
		<angularAcceleration public="1" get="inline" set="null" line="115">
			<f a="startMin:startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the angular acceleration range of particles launched from this emitter.</haxe_doc>
		</angularAcceleration>
		<angularDrag public="1" get="inline" set="null" line="123">
			<f a="startMin:startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the angular drag range of particles launched from this emitter.</haxe_doc>
		</angularDrag>
		<angularVelocityStart public="1" get="inline" set="null" line="131">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angular velocity starting range of particles launched from this emitter.</haxe_doc>
		</angularVelocityStart>
		<angularVelocityEnd public="1" get="inline" set="null" line="139">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angular velocity ending range of particles launched from this emitter.</haxe_doc>
		</angularVelocityEnd>
		<angleStart public="1" get="inline" set="null" line="148">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angle starting range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleStart>
		<angleEnd public="1" get="inline" set="null" line="157">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angle ending range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleEnd>
		<launchAngle public="1" get="inline" set="null" line="166">
			<f a="min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angle range at which particles will be launched from this emitter.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</launchAngle>
		<lifespan public="1" get="inline" set="null" line="174">
			<f a="min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The life, or duration, range of particles launched from this emitter.</haxe_doc>
		</lifespan>
		<scaleStart public="1" get="inline" set="null" line="182">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `scale` starting range of particles launched from this emitter.</haxe_doc>
		</scaleStart>
		<scaleEnd public="1" get="inline" set="null" line="202">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `scale` ending range of particles launched from this emitter.</haxe_doc>
		</scaleEnd>
		<accelerationStart public="1" get="inline" set="null" line="222">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `acceleration` starting range of particles launched from this emitter.</haxe_doc>
		</accelerationStart>
		<accelerationEnd public="1" get="inline" set="null" line="242">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `acceleration` ending range of particles launched from this emitter.</haxe_doc>
		</accelerationEnd>
		<dragStart public="1" get="inline" set="null" line="262">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `drag` starting range of particles launched from this emitter.</haxe_doc>
		</dragStart>
		<dragEnd public="1" get="inline" set="null" line="282">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `drag` ending range of particles launched from this emitter.</haxe_doc>
		</dragEnd>
		<colorStart public="1" get="inline" set="null" line="302">
			<f a="startMin:?startMax">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `color` starting range of particles launched from this emitter.</haxe_doc>
		</colorStart>
		<colorEnd public="1" get="inline" set="null" line="310">
			<f a="endMin:?endMax">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `color` ending range of particles launched from this emitter.</haxe_doc>
		</colorEnd>
		<alphaStart public="1" get="inline" set="null" line="318">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `alpha` starting range of particles launched from this emitter.</haxe_doc>
		</alphaStart>
		<alphaEnd public="1" get="inline" set="null" line="326">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `alpha` ending range of particles launched from this emitter.</haxe_doc>
		</alphaEnd>
		<invalidateStatus public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateStatus>
		<status public="1" set="null" expr="IDLE">
			<e path="ceramic.ParticlesStatus"/>
			<meta>
				<m n=":value"><e>IDLE</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Determines whether the emitter is currently emitting particles or not</haxe_doc>
		</status>
		<unobservedStatus>
			<e path="ceramic.ParticlesStatus"/>
			<haxe_doc></haxe_doc>
		</unobservedStatus>
		<_dox_event_statusChange public="1" set="method" line="637">
			<f a="current:previous">
				<e path="ceramic.ParticlesStatus"/>
				<e path="ceramic.ParticlesStatus"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</_dox_event_statusChange>
		<emitStatusChange set="method" line="1095">
			<f a="current:previous">
				<e path="ceramic.ParticlesStatus"/>
				<e path="ceramic.ParticlesStatus"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</emitStatusChange>
		<onStatusChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.ParticlesStatus"/>
					<e path="ceramic.ParticlesStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</onStatusChange>
		<onceStatusChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.ParticlesStatus"/>
					<e path="ceramic.ParticlesStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</onceStatusChange>
		<offStatusChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<e path="ceramic.ParticlesStatus"/>
					<e path="ceramic.ParticlesStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</offStatusChange>
		<listensStatusChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</listensStatusChange>
		<paused public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Determines whether the emitter is currently paused. It is totally safe to directly toggle this.</haxe_doc>
		</paused>
		<interval public="1" expr="0.1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.1</e></m></meta>
			<haxe_doc>* How often a particle is emitted, if currently emitting.
     * Can be modified at the middle of an emission safely;</haxe_doc>
		</interval>
		<launchMode public="1" expr="CIRCLE">
			<e path="ceramic.ParticlesLaunchMode"/>
			<meta><m n=":value"><e>CIRCLE</e></m></meta>
			<haxe_doc>* How particles should be launched. If `CIRCLE` (default), particles will use `launchAngle` and `speed`.
     * Otherwise, particles will just use `velocityX` and `velocityY`.</haxe_doc>
		</launchMode>
		<keepScaleRatio public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Keep the scale ratio of the particle. Uses the `scaleX` value for reference.</haxe_doc>
		</keepScaleRatio>
		<visualScaleActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Apply particle scale to underlying visual or not.</haxe_doc>
		</visualScaleActive>
		<visualColorActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Apply particle color to underlying visual or not.</haxe_doc>
		</visualColorActive>
		<visualPositionActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc><![CDATA[* Apply particle position (x & y) to underlying visual or not.]]></haxe_doc>
		</visualPositionActive>
		<visualRotationActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Apply particle angle to underlying visual rotation or not.</haxe_doc>
		</visualRotationActive>
		<visualAlphaActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Apply particle alpha to underlying visual or not.</haxe_doc>
		</visualAlphaActive>
		<width public="1" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The width of the emission area.
     * If not defined (`-1`), will use visual's width bound to this `ParticleEmitter` object, if any</haxe_doc>
		</width>
		<height public="1" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The height of the emission area.
     * If not defined (`-1`), will use visual's height bound to this `ParticleEmitter` object, if any</haxe_doc>
		</height>
		<x public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The x position of the emission, relative to particles parent (if any)</haxe_doc>
		</x>
		<y public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The y position of the emission, relative to particles parent (if any)</haxe_doc>
		</y>
		<maxVelocityX public="1" expr="10000">
			<x path="Float"/>
			<meta><m n=":value"><e>10000</e></m></meta>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
     * to cap the speed automatically (very useful!).</haxe_doc>
		</maxVelocityX>
		<maxVelocityY public="1" expr="10000">
			<x path="Float"/>
			<meta><m n=":value"><e>10000</e></m></meta>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
     * to cap the speed automatically (very useful!).</haxe_doc>
		</maxVelocityY>
		<velocityActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityActive>
		<velocityStartMinX public="1" expr="-100">
			<x path="Float"/>
			<meta><m n=":value"><e>-100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityStartMinX>
		<velocityStartMinY public="1" expr="-100">
			<x path="Float"/>
			<meta><m n=":value"><e>-100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityStartMinY>
		<velocityStartMaxX public="1" expr="100">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityStartMaxX>
		<velocityStartMaxY public="1" expr="100">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityStartMaxY>
		<velocityEndMinX public="1" expr="-100">
			<x path="Float"/>
			<meta><m n=":value"><e>-100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityEndMinX>
		<velocityEndMinY public="1" expr="-100">
			<x path="Float"/>
			<meta><m n=":value"><e>-100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityEndMinY>
		<velocityEndMaxX public="1" expr="100">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityEndMaxX>
		<velocityEndMaxY public="1" expr="100">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityEndMaxY>
		<speedStartMin public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this emitter. Only used with `CIRCLE`.</haxe_doc>
		</speedStartMin>
		<speedStartMax public="1" expr="100">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this emitter. Only used with `CIRCLE`.</haxe_doc>
		</speedStartMax>
		<speedEndMin public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this emitter. Only used with `CIRCLE`.</haxe_doc>
		</speedEndMin>
		<speedEndMax public="1" expr="100">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this emitter. Only used with `CIRCLE`.</haxe_doc>
		</speedEndMax>
		<maxAngularVelocity public="1" expr="10000">
			<x path="Float"/>
			<meta><m n=":value"><e>10000</e></m></meta>
			<haxe_doc>* Use in conjunction with angularAcceleration for fluid spin speed control.</haxe_doc>
		</maxAngularVelocity>
		<angularAccelerationActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the angular acceleration range of particles launched from this emitter.</haxe_doc>
		</angularAccelerationActive>
		<angularAccelerationStartMin public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the angular acceleration range of particles launched from this emitter.</haxe_doc>
		</angularAccelerationStartMin>
		<angularAccelerationStartMax public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the angular acceleration range of particles launched from this emitter.</haxe_doc>
		</angularAccelerationStartMax>
		<angularDragActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the angular drag range of particles launched from this emitter.</haxe_doc>
		</angularDragActive>
		<angularDragStartMin public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the angular drag range of particles launched from this emitter.</haxe_doc>
		</angularDragStartMin>
		<angularDragStartMax public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the angular drag range of particles launched from this emitter.</haxe_doc>
		</angularDragStartMax>
		<angularVelocityActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the angular velocity range of particles launched from this emitter.</haxe_doc>
		</angularVelocityActive>
		<angularVelocityStartMin public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this emitter.</haxe_doc>
		</angularVelocityStartMin>
		<angularVelocityStartMax public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this emitter.</haxe_doc>
		</angularVelocityStartMax>
		<angularVelocityEndMin public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this emitter.</haxe_doc>
		</angularVelocityEndMin>
		<angularVelocityEndMax public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this emitter.</haxe_doc>
		</angularVelocityEndMax>
		<angleActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the angle range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleActive>
		<angleStartMin public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleStartMin>
		<angleStartMax public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleStartMax>
		<angleEndMin public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleEndMin>
		<angleEndMax public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleEndMax>
		<ignoreAngularVelocity public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Set this if you want to specify the beginning and ending value of angle,
     * instead of using `angularVelocity` (or `angularAcceleration`).</haxe_doc>
		</ignoreAngularVelocity>
		<launchAngleActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the angle range at which particles will be launched from this emitter.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</launchAngleActive>
		<launchAngleMin public="1" expr="-180">
			<x path="Float"/>
			<meta><m n=":value"><e>-180</e></m></meta>
			<haxe_doc>* The angle range at which particles will be launched from this emitter.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</launchAngleMin>
		<launchAngleMax public="1" expr="180">
			<x path="Float"/>
			<meta><m n=":value"><e>180</e></m></meta>
			<haxe_doc>* The angle range at which particles will be launched from this emitter.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</launchAngleMax>
		<lifespanActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the life, or duration, range of particles launched from this emitter.</haxe_doc>
		</lifespanActive>
		<lifespanMin public="1" expr="3">
			<x path="Float"/>
			<meta><m n=":value"><e>3</e></m></meta>
			<haxe_doc>* The life, or duration, range of particles launched from this emitter.</haxe_doc>
		</lifespanMin>
		<lifespanMax public="1" expr="3">
			<x path="Float"/>
			<meta><m n=":value"><e>3</e></m></meta>
			<haxe_doc>* The life, or duration, range of particles launched from this emitter.</haxe_doc>
		</lifespanMax>
		<scaleActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleActive>
		<scaleStartMinX public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleStartMinX>
		<scaleStartMinY public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleStartMinY>
		<scaleStartMaxX public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleStartMaxX>
		<scaleStartMaxY public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleStartMaxY>
		<scaleEndMinX public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleEndMinX>
		<scaleEndMinY public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleEndMinY>
		<scaleEndMaxX public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleEndMaxX>
		<scaleEndMaxY public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleEndMaxY>
		<alphaActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable `alpha` range of particles launched from this emitter.</haxe_doc>
		</alphaActive>
		<alphaStartMin public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this emitter.</haxe_doc>
		</alphaStartMin>
		<alphaStartMax public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this emitter.</haxe_doc>
		</alphaStartMax>
		<alphaEndMin public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this emitter.</haxe_doc>
		</alphaEndMin>
		<alphaEndMax public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this emitter.</haxe_doc>
		</alphaEndMax>
		<colorActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable `color` range of particles launched from this emitter.</haxe_doc>
		</colorActive>
		<colorStartMin public="1" expr="Color.WHITE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this emitter.</haxe_doc>
		</colorStartMin>
		<colorStartMax public="1" expr="Color.WHITE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this emitter.</haxe_doc>
		</colorStartMax>
		<colorEndMin public="1" expr="Color.WHITE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this emitter.</haxe_doc>
		</colorEndMin>
		<colorEndMax public="1" expr="Color.WHITE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this emitter.</haxe_doc>
		</colorEndMax>
		<dragActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragActive>
		<dragStartMinX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragStartMinX>
		<dragStartMinY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragStartMinY>
		<dragStartMaxX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragStartMaxX>
		<dragStartMaxY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragStartMaxY>
		<dragEndMinX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragEndMinX>
		<dragEndMinY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragEndMinY>
		<dragEndMaxX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragEndMaxX>
		<dragEndMaxY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragEndMaxY>
		<accelerationActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationActive>
		<accelerationStartMinX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationStartMinX>
		<accelerationStartMinY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationStartMinY>
		<accelerationStartMaxX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationStartMaxX>
		<accelerationStartMaxY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationStartMaxY>
		<accelerationEndMinX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationEndMinX>
		<accelerationEndMinY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationEndMinY>
		<accelerationEndMaxX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationEndMaxX>
		<accelerationEndMaxY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationEndMaxY>
		<seed public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* A random seed used to generated particles.
     * Provide a custom seed to reproduce same chain of particles.</haxe_doc>
		</seed>
		<get_seed get="inline" set="null" line="750"><f a=""><x path="Float"/></f></get_seed>
		<set_seed set="method" line="753"><f a="seed">
	<x path="Float"/>
	<x path="Float"/>
</f></set_seed>
		<getCustomParticleVisual public="1">
			<f a="existingVisual">
				<c path="ceramic.Visual"/>
				<c path="ceramic.Visual"/>
			</f>
			<haxe_doc>* Custom particle visual creation. Use this to emit custom visuals as particle. Another option
     * is to create a subclass of `ParticleEmitter` and override `getParticleVisual()` method.</haxe_doc>
		</getCustomParticleVisual>
		<_quantityToEmit expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The internal quantity we want to emit (when emitting continuously)</haxe_doc>
		</_quantityToEmit>
		<_continuousTimer expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Timer used when emitting continuously</haxe_doc>
		</_continuousTimer>
		<_activeParticles expr="[]">
			<c path="Array"><c path="ceramic.ParticleItem"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal list of active particle items</haxe_doc>
		</_activeParticles>
		<_recycledParticles expr="[]">
			<c path="Array"><c path="ceramic.ParticleItem"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal list of recycled particle items</haxe_doc>
		</_recycledParticles>
		<_updatingParticles expr="[]">
			<c path="Array"><c path="ceramic.ParticleItem"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal list of particle items when they are being iterated on to be updated</haxe_doc>
		</_updatingParticles>
		<_seedRandom expr="new SeedRandom(Math.random() * 999999999)">
			<c path="ceramic.SeedRandom"/>
			<meta><m n=":value"><e>new SeedRandom(Math.random() * 999999999)</e></m></meta>
			<haxe_doc>* The seeded random used internally</haxe_doc>
		</_seedRandom>
		<destroy public="1" set="method" line="811" override="1"><f a=""><x path="Void"/></f></destroy>
		<bindAsComponent set="method" line="830"><f a=""><x path="Void"/></f></bindAsComponent>
		<update set="method" line="838">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called automatically by the game loop</haxe_doc>
		</update>
		<emitContinuousParticlesIfNeeded get="inline" set="null" line="879">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Emit one or more particles if continuous emission is active and enough time has passed</haxe_doc>
		</emitContinuousParticlesIfNeeded>
		<updateParticle set="method" line="914">
			<f a="particle:delta">
				<c path="ceramic.ParticleItem"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Update a particle (and its visual) from its parameter and elapsed time</haxe_doc>
		</updateParticle>
		<createParticleItem set="method" line="1002">
			<f a=""><c path="ceramic.ParticleItem"/></f>
			<haxe_doc>* Instanciate and return a new ParticleItem object.
     * Override this method if you want to instanciate a custom ParticleItem subclass
     * @return ParticleItem</haxe_doc>
		</createParticleItem>
		<getParticle set="method" line="1008"><f a=""><c path="ceramic.ParticleItem"/></f></getParticle>
		<getParticleVisual set="method" line="1036">
			<f a="existingVisual">
				<c path="ceramic.Visual"/>
				<c path="ceramic.Visual"/>
			</f>
			<haxe_doc>* Get a visual for a particle that will be emitted right after.
     * If a visual is being recycled, provide it as argument.</haxe_doc>
		</getParticleVisual>
		<recycleParticle set="method" line="1061"><f a="particle">
	<c path="ceramic.ParticleItem"/>
	<x path="Void"/>
</f></recycleParticle>
		<recycleParticleVisual set="method" line="1079">
			<f a="visualToRecycle">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Recycle a particle's visual to reuse it later.</haxe_doc>
		</recycleParticleVisual>
		<emitContinuously public="1" set="method" line="1097">
			<f a="?interval:?quantity" v="0.1:-1">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ quantity : -1, interval : 0.1 }</e></m></meta>
			<haxe_doc>* Start emitting particles continuously.
     *
     * @param   interval   How often to emit a particle.
     *                      `0` = never emit, `0.1` = 1 particle every 0.1 seconds, `5` = 1 particle every 5 seconds.
     * @param   quantity    How many particles to launch before stopping. `-1` (default) = never stop</haxe_doc>
		</emitContinuously>
		<explode public="1" set="method" line="1116">
			<f a="quantity">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Burst a given quantity number of particles at once
     *
     * @param   quantity    How many particles to launch. Does nothing if lower than `1`</haxe_doc>
		</explode>
		<stop public="1" set="method" line="1132">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stop emitting (if it was emitting)</haxe_doc>
		</stop>
		<emitParticle public="1" set="method" line="1144">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function can be used both internally and externally to emit the next particle.</haxe_doc>
		</emitParticle>
		<randomBetweenFloats get="inline" set="null" line="1323"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></randomBetweenFloats>
		<randomBetweenColors get="inline" set="null" line="1329"><f a="a:b">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></randomBetweenColors>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<setEntity set="method" line="14">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="14">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="804">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a new `ParticleEmitter` object.</haxe_doc>
		</new>
		<haxe_doc>* A particle emitter.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.ParticleItem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ParticleItem.hx">
		<visual public="1" expr="null">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</visual>
		<visualScaleActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</visualScaleActive>
		<visualColorActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</visualColorActive>
		<visualPositionActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</visualPositionActive>
		<visualRotationActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</visualRotationActive>
		<visualAlphaActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</visualAlphaActive>
		<active public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</active>
		<lifespan public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lifespan>
		<age public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</age>
		<time public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The time relative to app when this particule was emitted</haxe_doc>
		</time>
		<random public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Convenience: hold a random value between 0 and 1 for each particle</haxe_doc>
		</random>
		<status public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* In case implementation needs to keep a status for each particle, this property can be used for that</haxe_doc>
		</status>
		<colorRangeActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</colorRangeActive>
		<colorRangeStart public="1" expr="Color.WHITE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
		</colorRangeStart>
		<colorRangeEnd public="1" expr="Color.WHITE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
		</colorRangeEnd>
		<color public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<meta><m n=":isVar"/></meta>
		</color>
		<get_color get="inline" set="null" line="43"><f a=""><x path="ceramic.Color"/></f></get_color>
		<set_color get="inline" set="null" line="58"><f a="color">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
		<accelerationRangeActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</accelerationRangeActive>
		<accelerationRangeStartX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accelerationRangeStartX>
		<accelerationRangeStartY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accelerationRangeStartY>
		<accelerationRangeEndX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accelerationRangeEndX>
		<accelerationRangeEndY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accelerationRangeEndY>
		<accelerationX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accelerationX>
		<accelerationY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accelerationY>
		<dragRangeActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</dragRangeActive>
		<dragRangeStartX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dragRangeStartX>
		<dragRangeStartY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dragRangeStartY>
		<dragRangeEndX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dragRangeEndX>
		<dragRangeEndY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dragRangeEndY>
		<dragX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dragX>
		<dragY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dragY>
		<velocityRangeActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</velocityRangeActive>
		<velocityRangeStartX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</velocityRangeStartX>
		<velocityRangeStartY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</velocityRangeStartY>
		<velocityRangeEndX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</velocityRangeEndX>
		<velocityRangeEndY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</velocityRangeEndY>
		<velocityX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</velocityX>
		<velocityY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</velocityY>
		<angularVelocityRangeActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</angularVelocityRangeActive>
		<angularVelocityRangeStart public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularVelocityRangeStart>
		<angularVelocityRangeEnd public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularVelocityRangeEnd>
		<angularVelocity public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularVelocity>
		<angularAccelerationRangeActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</angularAccelerationRangeActive>
		<angularAccelerationRangeStart public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularAccelerationRangeStart>
		<angularAccelerationRangeEnd public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularAccelerationRangeEnd>
		<angularAcceleration public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularAcceleration>
		<angularDrag public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularDrag>
		<scaleRangeActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</scaleRangeActive>
		<scaleRangeStartX public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</scaleRangeStartX>
		<scaleRangeStartY public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</scaleRangeStartY>
		<scaleRangeEndX public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</scaleRangeEndX>
		<scaleRangeEndY public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</scaleRangeEndY>
		<scaleX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</scaleX>
		<get_scaleX get="inline" set="null" line="112"><f a=""><x path="Float"/></f></get_scaleX>
		<set_scaleX get="inline" set="null" line="115"><f a="scaleX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<scaleY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</scaleY>
		<get_scaleY get="inline" set="null" line="122"><f a=""><x path="Float"/></f></get_scaleY>
		<set_scaleY get="inline" set="null" line="125"><f a="scaleY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<scale public="1" get="inline" set="null" line="131"><f a="scaleX:scaleY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</x>
		<get_x get="inline" set="null" line="137"><f a=""><x path="Float"/></f></get_x>
		<set_x get="inline" set="null" line="140"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</y>
		<get_y get="inline" set="null" line="147"><f a=""><x path="Float"/></f></get_y>
		<set_y get="inline" set="null" line="150"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<pos public="1" get="inline" set="null" line="156"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pos>
		<angle public="1" get="accessor" set="accessor" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":isVar"/>
			</meta>
		</angle>
		<get_angle get="inline" set="null" line="162"><f a=""><x path="Float"/></f></get_angle>
		<set_angle get="inline" set="null" line="165"><f a="angle">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<alphaRangeActive public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</alphaRangeActive>
		<alphaRangeStart public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</alphaRangeStart>
		<alphaRangeEnd public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</alphaRangeEnd>
		<alpha public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</alpha>
		<get_alpha get="inline" set="null" line="176"><f a=""><x path="Float"/></f></get_alpha>
		<set_alpha get="inline" set="null" line="179"><f a="alpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<reset public="1" get="inline" set="null" line="188"><f a=""><x path="Void"/></f></reset>
		<new set="method" line="186"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A particle item.
 * You should not instanciate this yourself as
 * it is managed by a `Particles` emitter object.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.ParticleEmitter</e></m>
		</meta>
	</class>
	<class path="ceramic.Particles" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Particles.hx">
		<extends path="ceramic.Visual"/>
		<emitter public="1">
			<c path="ceramic.Particles.T"/>
			<meta><m n="component"/></meta>
		</emitter>
		<init set="method" line="30"><f a=""><x path="Void"/></f></init>
		<autoEmit public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="editable"><e>{ group : "emitterInterval" }</e></m>
			</meta>
		</autoEmit>
		<set_autoEmit set="method" line="61"><f a="autoEmit">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoEmit>
		<clearExplodeInterval expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</clearExplodeInterval>
		<autoExplodeInterval public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="editable"><e>{ label : "Explode Interval", group : "autoExplode" }</e></m>
			</meta>
		</autoExplodeInterval>
		<set_autoExplodeInterval set="method" line="78"><f a="autoExplodeInterval">
	<x path="Float"/>
	<x path="Float"/>
</f></set_autoExplodeInterval>
		<autoExplodeQuantity public="1" set="accessor" expr="64">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>64</e></m>
				<m n="editable"><e>{ label : "Explode Quantity", group : "autoExplode" }</e></m>
			</meta>
		</autoExplodeQuantity>
		<set_autoExplodeQuantity set="method" line="88"><f a="autoExplodeQuantity">
	<x path="Int"/>
	<x path="Int"/>
</f></set_autoExplodeQuantity>
		<computeAutoExplode set="method" line="96"><f a=""><x path="Void"/></f></computeAutoExplode>
		<doAutoExplode set="method" line="109"><f a=""><x path="Void"/></f></doAutoExplode>
		<emitterPaused public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Paused" }</e></m></meta>
			<haxe_doc>* Determines whether the emitter is currently paused. It is totally safe to directly toggle this.</haxe_doc>
		</emitterPaused>
		<get_emitterPaused get="inline" set="null" line="129"><f a=""><x path="Bool"/></f></get_emitterPaused>
		<set_emitterPaused get="inline" set="null" line="130"><f a="paused">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterPaused>
		<emitterInterval public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Interval", group : "emitterInterval" }</e></m></meta>
			<haxe_doc>* How often a particle is emitted, if currently emitting.
     * Can be modified at the middle of an emission safely;</haxe_doc>
		</emitterInterval>
		<get_emitterInterval get="inline" set="null" line="139"><f a=""><x path="Float"/></f></get_emitterInterval>
		<set_emitterInterval get="inline" set="null" line="140"><f a="interval">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterInterval>
		<emitterLaunchMode public="1" get="accessor" set="accessor">
			<e path="ceramic.ParticlesLaunchMode"/>
			<meta><m n="editable"><e>{ label : "Launch Mode" }</e></m></meta>
			<haxe_doc>* How particles should be launched. If `CIRCLE` (default), particles will use `launchAngle` and `speed`.
     * Otherwise, particles will just use `velocityX` and `velocityY`.</haxe_doc>
		</emitterLaunchMode>
		<get_emitterLaunchMode get="inline" set="null" line="148"><f a=""><e path="ceramic.ParticlesLaunchMode"/></f></get_emitterLaunchMode>
		<set_emitterLaunchMode get="inline" set="null" line="149"><f a="launchMode">
	<e path="ceramic.ParticlesLaunchMode"/>
	<e path="ceramic.ParticlesLaunchMode"/>
</f></set_emitterLaunchMode>
		<emitterVisualScaleActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Scale Active", group : "emitterScale" }</e></m></meta>
			<haxe_doc>* Apply particle scale to underlying visual or not.</haxe_doc>
		</emitterVisualScaleActive>
		<get_emitterVisualScaleActive get="inline" set="null" line="156"><f a=""><x path="Bool"/></f></get_emitterVisualScaleActive>
		<set_emitterVisualScaleActive get="inline" set="null" line="157"><f a="visualScaleActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterVisualScaleActive>
		<emitterKeepScaleRatio public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Keep Scale Ratio", group : "emitterScale" }</e></m></meta>
			<haxe_doc>* Keep the scale ratio of the particle. Uses the `scaleX` value for reference.</haxe_doc>
		</emitterKeepScaleRatio>
		<get_emitterKeepScaleRatio get="inline" set="null" line="164"><f a=""><x path="Bool"/></f></get_emitterKeepScaleRatio>
		<set_emitterKeepScaleRatio get="inline" set="null" line="165"><f a="keepScaleRatio">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterKeepScaleRatio>
		<emitterVisualColorActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Color Active", group : "emitterColorAlphaActive" }</e></m></meta>
			<haxe_doc>* Apply particle color to underlying visual or not.</haxe_doc>
		</emitterVisualColorActive>
		<get_emitterVisualColorActive get="inline" set="null" line="172"><f a=""><x path="Bool"/></f></get_emitterVisualColorActive>
		<set_emitterVisualColorActive get="inline" set="null" line="173"><f a="visualColorActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterVisualColorActive>
		<emitterVisualAlphaActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Alpha Active", group : "emitterColorAlphaActive" }</e></m></meta>
			<haxe_doc>* Apply particle alpha to underlying visual or not.</haxe_doc>
		</emitterVisualAlphaActive>
		<get_emitterVisualAlphaActive get="inline" set="null" line="180"><f a=""><x path="Bool"/></f></get_emitterVisualAlphaActive>
		<set_emitterVisualAlphaActive get="inline" set="null" line="181"><f a="visualAlphaActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterVisualAlphaActive>
		<emitterVisualPositionActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Position Active", group : "emitterPosRotationActive" }</e></m></meta>
			<haxe_doc><![CDATA[* Apply particle position (x & y) to underlying visual or not.]]></haxe_doc>
		</emitterVisualPositionActive>
		<get_emitterVisualPositionActive get="inline" set="null" line="188"><f a=""><x path="Bool"/></f></get_emitterVisualPositionActive>
		<set_emitterVisualPositionActive get="inline" set="null" line="189"><f a="visualPositionActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterVisualPositionActive>
		<emitterVisualRotationActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Rotation Active", group : "emitterPosRotationActive" }</e></m></meta>
			<haxe_doc>* Apply particle angle to underlying visual rotation or not.</haxe_doc>
		</emitterVisualRotationActive>
		<get_emitterVisualRotationActive get="inline" set="null" line="196"><f a=""><x path="Bool"/></f></get_emitterVisualRotationActive>
		<set_emitterVisualRotationActive get="inline" set="null" line="197"><f a="visualRotationActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterVisualRotationActive>
		<emitterWidth public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Emitter Width", group : "emitterSize" }</e></m></meta>
			<haxe_doc>* The width of the emission area.
     * If not defined (`-1`), will use visual's width bound to this `ParticleEmitter` object, if any</haxe_doc>
		</emitterWidth>
		<get_emitterWidth get="inline" set="null" line="205"><f a=""><x path="Float"/></f></get_emitterWidth>
		<set_emitterWidth get="inline" set="null" line="206"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterWidth>
		<emitterHeight public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Emitter Height", group : "emitterSize" }</e></m></meta>
			<haxe_doc>* The height of the emission area.
     * If not defined (`-1`), will use visual's height bound to this `ParticleEmitter` object, if any</haxe_doc>
		</emitterHeight>
		<get_emitterHeight get="inline" set="null" line="213"><f a=""><x path="Float"/></f></get_emitterHeight>
		<set_emitterHeight get="inline" set="null" line="214"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterHeight>
		<emitterX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Emitter X", group : "emitterPos" }</e></m></meta>
			<haxe_doc>* The x position of the emission, relative to particles parent (if any)</haxe_doc>
		</emitterX>
		<get_emitterX get="inline" set="null" line="221"><f a=""><x path="Float"/></f></get_emitterX>
		<set_emitterX get="inline" set="null" line="222"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterX>
		<emitterY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Emitter Y", group : "emitterPos" }</e></m></meta>
			<haxe_doc>* The y position of the emission, relative to particles parent (if any)</haxe_doc>
		</emitterY>
		<get_emitterY get="inline" set="null" line="228"><f a=""><x path="Float"/></f></get_emitterY>
		<set_emitterY get="inline" set="null" line="229"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterY>
		<emitterVelocityActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Vel. Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityActive>
		<get_emitterVelocityActive get="inline" set="null" line="236"><f a=""><x path="Bool"/></f></get_emitterVelocityActive>
		<set_emitterVelocityActive get="inline" set="null" line="237"><f a="velocityActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterVelocityActive>
		<emitterMaxVelocityX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Max Vel. X", group : "emitterMaxVelocity" }</e></m></meta>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
     * to cap the speed automatically (very useful!).</haxe_doc>
		</emitterMaxVelocityX>
		<get_emitterMaxVelocityX get="inline" set="null" line="245"><f a=""><x path="Float"/></f></get_emitterMaxVelocityX>
		<set_emitterMaxVelocityX get="inline" set="null" line="246"><f a="maxVelocityX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterMaxVelocityX>
		<emitterMaxVelocityY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Max Vel. Y", group : "emitterMaxVelocity" }</e></m></meta>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
     * to cap the speed automatically (very useful!).</haxe_doc>
		</emitterMaxVelocityY>
		<get_emitterMaxVelocityY get="inline" set="null" line="253"><f a=""><x path="Float"/></f></get_emitterMaxVelocityY>
		<set_emitterMaxVelocityY get="inline" set="null" line="254"><f a="maxVelocityY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterMaxVelocityY>
		<emitterVelocityStartMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. Start Min X", group : "emitterVelocityStartMin" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityStartMinX>
		<get_emitterVelocityStartMinX get="inline" set="null" line="260"><f a=""><x path="Float"/></f></get_emitterVelocityStartMinX>
		<set_emitterVelocityStartMinX get="inline" set="null" line="261"><f a="velocityStartMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityStartMinX>
		<emitterVelocityStartMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. Start Min Y", group : "emitterVelocityStartMin" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityStartMinY>
		<get_emitterVelocityStartMinY get="inline" set="null" line="267"><f a=""><x path="Float"/></f></get_emitterVelocityStartMinY>
		<set_emitterVelocityStartMinY get="inline" set="null" line="268"><f a="velocityStartMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityStartMinY>
		<emitterVelocityStartMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. Start Max X", group : "emitterVelocityStartMax" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityStartMaxX>
		<get_emitterVelocityStartMaxX get="inline" set="null" line="274"><f a=""><x path="Float"/></f></get_emitterVelocityStartMaxX>
		<set_emitterVelocityStartMaxX get="inline" set="null" line="275"><f a="velocityStartMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityStartMaxX>
		<emitterVelocityStartMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. Start Max Y", group : "emitterVelocityStartMax" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityStartMaxY>
		<get_emitterVelocityStartMaxY get="inline" set="null" line="281"><f a=""><x path="Float"/></f></get_emitterVelocityStartMaxY>
		<set_emitterVelocityStartMaxY get="inline" set="null" line="282"><f a="velocityStartMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityStartMaxY>
		<emitterVelocityEndMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. End Min X", group : "emitterVelocityEndMin" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityEndMinX>
		<get_emitterVelocityEndMinX get="inline" set="null" line="288"><f a=""><x path="Float"/></f></get_emitterVelocityEndMinX>
		<set_emitterVelocityEndMinX get="inline" set="null" line="289"><f a="velocityEndMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityEndMinX>
		<emitterVelocityEndMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. End Min Y", group : "emitterVelocityEndMin" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityEndMinY>
		<get_emitterVelocityEndMinY get="inline" set="null" line="295"><f a=""><x path="Float"/></f></get_emitterVelocityEndMinY>
		<set_emitterVelocityEndMinY get="inline" set="null" line="296"><f a="velocityEndMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityEndMinY>
		<emitterVelocityEndMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. End Max X", group : "emitterVelocityEndMax" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityEndMaxX>
		<get_emitterVelocityEndMaxX get="inline" set="null" line="302"><f a=""><x path="Float"/></f></get_emitterVelocityEndMaxX>
		<set_emitterVelocityEndMaxX get="inline" set="null" line="303"><f a="velocityEndMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityEndMaxX>
		<emitterVelocityEndMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. End Max Y", group : "emitterVelocityEndMax" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityEndMaxY>
		<get_emitterVelocityEndMaxY get="inline" set="null" line="309"><f a=""><x path="Float"/></f></get_emitterVelocityEndMaxY>
		<set_emitterVelocityEndMaxY get="inline" set="null" line="310"><f a="velocityEndMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityEndMaxY>
		<emitterSpeedStartMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Speed Start Min", group : "emitterSpeedStart" }</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `CIRCLE`.</haxe_doc>
		</emitterSpeedStartMin>
		<get_emitterSpeedStartMin get="inline" set="null" line="317"><f a=""><x path="Float"/></f></get_emitterSpeedStartMin>
		<set_emitterSpeedStartMin get="inline" set="null" line="318"><f a="speedStartMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterSpeedStartMin>
		<emitterSpeedStartMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Speed Start Max", group : "emitterSpeedStart" }</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `CIRCLE`.</haxe_doc>
		</emitterSpeedStartMax>
		<get_emitterSpeedStartMax get="inline" set="null" line="324"><f a=""><x path="Float"/></f></get_emitterSpeedStartMax>
		<set_emitterSpeedStartMax get="inline" set="null" line="325"><f a="speedStartMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterSpeedStartMax>
		<emitterSpeedEndMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Speed End Min", group : "emitterSpeedEnd" }</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `CIRCLE`.</haxe_doc>
		</emitterSpeedEndMin>
		<get_emitterSpeedEndMin get="inline" set="null" line="332"><f a=""><x path="Float"/></f></get_emitterSpeedEndMin>
		<set_emitterSpeedEndMin get="inline" set="null" line="333"><f a="speedEndMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterSpeedEndMin>
		<emitterSpeedEndMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Speed End Max", group : "emitterSpeedEnd" }</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `CIRCLE`.</haxe_doc>
		</emitterSpeedEndMax>
		<get_emitterSpeedEndMax get="inline" set="null" line="339"><f a=""><x path="Float"/></f></get_emitterSpeedEndMax>
		<set_emitterSpeedEndMax get="inline" set="null" line="340"><f a="speedEndMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterSpeedEndMax>
		<emitterMaxAngularVelocity public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Max Angular Vel.", group : "emitterAngularVelocityAcceleration" }</e></m></meta>
			<haxe_doc>* Use in conjunction with angularAcceleration for fluid spin speed control.</haxe_doc>
		</emitterMaxAngularVelocity>
		<get_emitterMaxAngularVelocity get="inline" set="null" line="347"><f a=""><x path="Float"/></f></get_emitterMaxAngularVelocity>
		<set_emitterMaxAngularVelocity get="inline" set="null" line="348"><f a="maxAngularVelocity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterMaxAngularVelocity>
		<emitterAngularAccelerationActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Angular Accel. Active", group : "emitterAngularVelocityAcceleration" }</e></m></meta>
			<haxe_doc>* Enable or disable the angular acceleration range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularAccelerationActive>
		<get_emitterAngularAccelerationActive get="inline" set="null" line="354"><f a=""><x path="Bool"/></f></get_emitterAngularAccelerationActive>
		<set_emitterAngularAccelerationActive get="inline" set="null" line="355"><f a="angularAccelerationActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterAngularAccelerationActive>
		<emitterAngularAccelerationStartMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Accel. Start Min", group : "emitterAngularAccelerationStart" }</e></m></meta>
			<haxe_doc>* Set the angular acceleration range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularAccelerationStartMin>
		<get_emitterAngularAccelerationStartMin get="inline" set="null" line="362"><f a=""><x path="Float"/></f></get_emitterAngularAccelerationStartMin>
		<set_emitterAngularAccelerationStartMin get="inline" set="null" line="363"><f a="angularAccelerationStartMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularAccelerationStartMin>
		<emitterAngularAccelerationStartMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Accel. Start Max", group : "emitterAngularAccelerationStart" }</e></m></meta>
			<haxe_doc>* Set the angular acceleration range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularAccelerationStartMax>
		<get_emitterAngularAccelerationStartMax get="inline" set="null" line="369"><f a=""><x path="Float"/></f></get_emitterAngularAccelerationStartMax>
		<set_emitterAngularAccelerationStartMax get="inline" set="null" line="370"><f a="angularAccelerationStartMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularAccelerationStartMax>
		<emitterAngularDragActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Angular Drag Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the angular drag range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularDragActive>
		<get_emitterAngularDragActive get="inline" set="null" line="377"><f a=""><x path="Bool"/></f></get_emitterAngularDragActive>
		<set_emitterAngularDragActive get="inline" set="null" line="378"><f a="angularDragActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterAngularDragActive>
		<emitterAngularDragStartMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Drag Start Min", group : "emitterAngularDragStart" }</e></m></meta>
			<haxe_doc>* Set the angular drag range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularDragStartMin>
		<get_emitterAngularDragStartMin get="inline" set="null" line="385"><f a=""><x path="Float"/></f></get_emitterAngularDragStartMin>
		<set_emitterAngularDragStartMin get="inline" set="null" line="386"><f a="angularDragStartMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularDragStartMin>
		<emitterAngularDragStartMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Drag Start Max", group : "emitterAngularDragStart" }</e></m></meta>
			<haxe_doc>* Set the angular drag range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularDragStartMax>
		<get_emitterAngularDragStartMax get="inline" set="null" line="392"><f a=""><x path="Float"/></f></get_emitterAngularDragStartMax>
		<set_emitterAngularDragStartMax get="inline" set="null" line="393"><f a="angularDragStartMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularDragStartMax>
		<emitterAngularVelocityActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Angular Vel. Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the angular velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityActive>
		<get_emitterAngularVelocityActive get="inline" set="null" line="400"><f a=""><x path="Bool"/></f></get_emitterAngularVelocityActive>
		<set_emitterAngularVelocityActive get="inline" set="null" line="401"><f a="angularVelocityActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterAngularVelocityActive>
		<emitterAngularVelocityStartMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Vel. Start Min", group : "emitterAngularVelocityStart" }</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityStartMin>
		<get_emitterAngularVelocityStartMin get="inline" set="null" line="408"><f a=""><x path="Float"/></f></get_emitterAngularVelocityStartMin>
		<set_emitterAngularVelocityStartMin get="inline" set="null" line="409"><f a="angularVelocityStartMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularVelocityStartMin>
		<emitterAngularVelocityStartMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Vel. Start Max", group : "emitterAngularVelocityStart" }</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityStartMax>
		<get_emitterAngularVelocityStartMax get="inline" set="null" line="415"><f a=""><x path="Float"/></f></get_emitterAngularVelocityStartMax>
		<set_emitterAngularVelocityStartMax get="inline" set="null" line="416"><f a="angularVelocityStartMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularVelocityStartMax>
		<emitterAngularVelocityEndMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Vel. End Min", group : "emitterAngularVelocityEnd" }</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityEndMin>
		<get_emitterAngularVelocityEndMin get="inline" set="null" line="423"><f a=""><x path="Float"/></f></get_emitterAngularVelocityEndMin>
		<set_emitterAngularVelocityEndMin get="inline" set="null" line="424"><f a="angularVelocityEndMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularVelocityEndMin>
		<emitterAngularVelocityEndMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Vel. End Max", group : "emitterAngularVelocityEnd" }</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityEndMax>
		<get_emitterAngularVelocityEndMax get="inline" set="null" line="430"><f a=""><x path="Float"/></f></get_emitterAngularVelocityEndMax>
		<set_emitterAngularVelocityEndMax get="inline" set="null" line="431"><f a="angularVelocityEndMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularVelocityEndMax>
		<emitterAngleActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Angle Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the angle range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleActive>
		<get_emitterAngleActive get="inline" set="null" line="439"><f a=""><x path="Bool"/></f></get_emitterAngleActive>
		<set_emitterAngleActive get="inline" set="null" line="440"><f a="angleActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterAngleActive>
		<emitterAngleStartMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angle Start Min", group : "emitterAngleStart" }</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleStartMin>
		<get_emitterAngleStartMin get="inline" set="null" line="448"><f a=""><x path="Float"/></f></get_emitterAngleStartMin>
		<set_emitterAngleStartMin get="inline" set="null" line="449"><f a="angleStartMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngleStartMin>
		<emitterAngleStartMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angle Start Max", group : "emitterAngleStart" }</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleStartMax>
		<get_emitterAngleStartMax get="inline" set="null" line="456"><f a=""><x path="Float"/></f></get_emitterAngleStartMax>
		<set_emitterAngleStartMax get="inline" set="null" line="457"><f a="angleStartMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngleStartMax>
		<emitterAngleEndMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angle End Min", group : "emitterAngleEnd" }</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleEndMin>
		<get_emitterAngleEndMin get="inline" set="null" line="465"><f a=""><x path="Float"/></f></get_emitterAngleEndMin>
		<set_emitterAngleEndMin get="inline" set="null" line="466"><f a="angleEndMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngleEndMin>
		<emitterAngleEndMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angle End Max", group : "emitterAngleEnd" }</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleEndMax>
		<get_emitterAngleEndMax get="inline" set="null" line="473"><f a=""><x path="Float"/></f></get_emitterAngleEndMax>
		<set_emitterAngleEndMax get="inline" set="null" line="474"><f a="angleEndMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngleEndMax>
		<emitterIgnoreAngularVelocity public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Ignore Angular Vel." }</e></m></meta>
			<haxe_doc>* Set this if you want to specify the beginning and ending value of angle,
     * instead of using `angularVelocity` (or `angularAcceleration`).</haxe_doc>
		</emitterIgnoreAngularVelocity>
		<get_emitterIgnoreAngularVelocity get="inline" set="null" line="482"><f a=""><x path="Bool"/></f></get_emitterIgnoreAngularVelocity>
		<set_emitterIgnoreAngularVelocity get="inline" set="null" line="483"><f a="ignoreAngularVelocity">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterIgnoreAngularVelocity>
		<emitterLaunchAngleActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Launch Angle Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the angle range at which particles will be launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</emitterLaunchAngleActive>
		<get_emitterLaunchAngleActive get="inline" set="null" line="491"><f a=""><x path="Bool"/></f></get_emitterLaunchAngleActive>
		<set_emitterLaunchAngleActive get="inline" set="null" line="492"><f a="launchAngleActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterLaunchAngleActive>
		<emitterLaunchAngleMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Launch Angle Min", group : "emitterLaunchAngle" }</e></m></meta>
			<haxe_doc>* The angle range at which particles will be launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</emitterLaunchAngleMin>
		<get_emitterLaunchAngleMin get="inline" set="null" line="500"><f a=""><x path="Float"/></f></get_emitterLaunchAngleMin>
		<set_emitterLaunchAngleMin get="inline" set="null" line="501"><f a="launchAngleMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterLaunchAngleMin>
		<emitterLaunchAngleMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Launch Angle Max", group : "emitterLaunchAngle" }</e></m></meta>
			<haxe_doc>* The angle range at which particles will be launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</emitterLaunchAngleMax>
		<get_emitterLaunchAngleMax get="inline" set="null" line="508"><f a=""><x path="Float"/></f></get_emitterLaunchAngleMax>
		<set_emitterLaunchAngleMax get="inline" set="null" line="509"><f a="launchAngleMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterLaunchAngleMax>
		<emitterLifespanActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Lifespan Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the life, or duration, range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterLifespanActive>
		<get_emitterLifespanActive get="inline" set="null" line="516"><f a=""><x path="Bool"/></f></get_emitterLifespanActive>
		<set_emitterLifespanActive get="inline" set="null" line="517"><f a="lifespanActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterLifespanActive>
		<emitterLifespanMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Lifespan Min", group : "emitterLifespan" }</e></m></meta>
			<haxe_doc>* The life, or duration, range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterLifespanMin>
		<get_emitterLifespanMin get="inline" set="null" line="524"><f a=""><x path="Float"/></f></get_emitterLifespanMin>
		<set_emitterLifespanMin get="inline" set="null" line="525"><f a="lifespanMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterLifespanMin>
		<emitterLifespanMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Lifespan Max", group : "emitterLifespan" }</e></m></meta>
			<haxe_doc>* The life, or duration, range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterLifespanMax>
		<get_emitterLifespanMax get="inline" set="null" line="531"><f a=""><x path="Float"/></f></get_emitterLifespanMax>
		<set_emitterLifespanMax get="inline" set="null" line="532"><f a="lifespanMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterLifespanMax>
		<emitterScaleActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Scale Active" }</e></m></meta>
			<haxe_doc>* Enable or disable `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleActive>
		<get_emitterScaleActive get="inline" set="null" line="539"><f a=""><x path="Bool"/></f></get_emitterScaleActive>
		<set_emitterScaleActive get="inline" set="null" line="540"><f a="scaleActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterScaleActive>
		<emitterScaleStartMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale Start Min X", group : "emitterScaleStartMin" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleStartMinX>
		<get_emitterScaleStartMinX get="inline" set="null" line="547"><f a=""><x path="Float"/></f></get_emitterScaleStartMinX>
		<set_emitterScaleStartMinX get="inline" set="null" line="548"><f a="scaleStartMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleStartMinX>
		<emitterScaleStartMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale Start Min Y", group : "emitterScaleStartMin" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleStartMinY>
		<get_emitterScaleStartMinY get="inline" set="null" line="554"><f a=""><x path="Float"/></f></get_emitterScaleStartMinY>
		<set_emitterScaleStartMinY get="inline" set="null" line="555"><f a="scaleStartMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleStartMinY>
		<emitterScaleStartMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale Start Max X", group : "emitterScaleStartMax" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleStartMaxX>
		<get_emitterScaleStartMaxX get="inline" set="null" line="561"><f a=""><x path="Float"/></f></get_emitterScaleStartMaxX>
		<set_emitterScaleStartMaxX get="inline" set="null" line="562"><f a="scaleStartMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleStartMaxX>
		<emitterScaleStartMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale Start Max Y", group : "emitterScaleStartMax" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleStartMaxY>
		<get_emitterScaleStartMaxY get="inline" set="null" line="568"><f a=""><x path="Float"/></f></get_emitterScaleStartMaxY>
		<set_emitterScaleStartMaxY get="inline" set="null" line="569"><f a="scaleStartMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleStartMaxY>
		<emitterScaleEndMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale End Min X", group : "emitterScaleEndMin" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleEndMinX>
		<get_emitterScaleEndMinX get="inline" set="null" line="575"><f a=""><x path="Float"/></f></get_emitterScaleEndMinX>
		<set_emitterScaleEndMinX get="inline" set="null" line="576"><f a="scaleEndMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleEndMinX>
		<emitterScaleEndMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale End Min Y", group : "emitterScaleEndMin" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleEndMinY>
		<get_emitterScaleEndMinY get="inline" set="null" line="582"><f a=""><x path="Float"/></f></get_emitterScaleEndMinY>
		<set_emitterScaleEndMinY get="inline" set="null" line="583"><f a="scaleEndMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleEndMinY>
		<emitterScaleEndMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale End Max X", group : "emitterScaleEndMax" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleEndMaxX>
		<get_emitterScaleEndMaxX get="inline" set="null" line="589"><f a=""><x path="Float"/></f></get_emitterScaleEndMaxX>
		<set_emitterScaleEndMaxX get="inline" set="null" line="590"><f a="scaleEndMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleEndMaxX>
		<emitterScaleEndMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale End Max Y", group : "emitterScaleEndMax" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleEndMaxY>
		<get_emitterScaleEndMaxY get="inline" set="null" line="596"><f a=""><x path="Float"/></f></get_emitterScaleEndMaxY>
		<set_emitterScaleEndMaxY get="inline" set="null" line="597"><f a="scaleEndMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleEndMaxY>
		<emitterAlphaActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Alpha Active" }</e></m></meta>
			<haxe_doc>* Enable or disable `alpha` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaActive>
		<get_emitterAlphaActive get="inline" set="null" line="604"><f a=""><x path="Bool"/></f></get_emitterAlphaActive>
		<set_emitterAlphaActive get="inline" set="null" line="605"><f a="alphaActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterAlphaActive>
		<emitterAlphaStartMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Alpha Start Min", group : "emitterAlphaStart" }</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaStartMin>
		<get_emitterAlphaStartMin get="inline" set="null" line="612"><f a=""><x path="Float"/></f></get_emitterAlphaStartMin>
		<set_emitterAlphaStartMin get="inline" set="null" line="613"><f a="alphaStartMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAlphaStartMin>
		<emitterAlphaStartMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Alpha Start Max", group : "emitterAlphaStart" }</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaStartMax>
		<get_emitterAlphaStartMax get="inline" set="null" line="619"><f a=""><x path="Float"/></f></get_emitterAlphaStartMax>
		<set_emitterAlphaStartMax get="inline" set="null" line="620"><f a="alphaStartMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAlphaStartMax>
		<emitterAlphaEndMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Alpha End Min", group : "emitterAlphaEnd" }</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaEndMin>
		<get_emitterAlphaEndMin get="inline" set="null" line="627"><f a=""><x path="Float"/></f></get_emitterAlphaEndMin>
		<set_emitterAlphaEndMin get="inline" set="null" line="628"><f a="alphaEndMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAlphaEndMin>
		<emitterAlphaEndMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Alpha End Max", group : "emitterAlphaEnd" }</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaEndMax>
		<get_emitterAlphaEndMax get="inline" set="null" line="634"><f a=""><x path="Float"/></f></get_emitterAlphaEndMax>
		<set_emitterAlphaEndMax get="inline" set="null" line="635"><f a="alphaEndMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAlphaEndMax>
		<emitterColorActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Color Active" }</e></m></meta>
			<haxe_doc>* Enable or disable `color` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorActive>
		<get_emitterColorActive get="inline" set="null" line="642"><f a=""><x path="Bool"/></f></get_emitterColorActive>
		<set_emitterColorActive get="inline" set="null" line="643"><f a="colorActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterColorActive>
		<emitterColorStartMin public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<meta><m n="editable"><e>{ label : "Color Start Min", group : "emitterColorStart" }</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorStartMin>
		<get_emitterColorStartMin get="inline" set="null" line="650"><f a=""><x path="ceramic.Color"/></f></get_emitterColorStartMin>
		<set_emitterColorStartMin get="inline" set="null" line="651"><f a="colorStartMin">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_emitterColorStartMin>
		<emitterColorStartMax public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<meta><m n="editable"><e>{ label : "Color Start Max", group : "emitterColorStart" }</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorStartMax>
		<get_emitterColorStartMax get="inline" set="null" line="657"><f a=""><x path="ceramic.Color"/></f></get_emitterColorStartMax>
		<set_emitterColorStartMax get="inline" set="null" line="658"><f a="colorStartMax">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_emitterColorStartMax>
		<emitterColorEndMin public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<meta><m n="editable"><e>{ label : "Color End Min", group : "emitterColorEnd" }</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorEndMin>
		<get_emitterColorEndMin get="inline" set="null" line="665"><f a=""><x path="ceramic.Color"/></f></get_emitterColorEndMin>
		<set_emitterColorEndMin get="inline" set="null" line="666"><f a="colorEndMin">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_emitterColorEndMin>
		<emitterColorEndMax public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<meta><m n="editable"><e>{ label : "Color End Max", group : "emitterColorEnd" }</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorEndMax>
		<get_emitterColorEndMax get="inline" set="null" line="672"><f a=""><x path="ceramic.Color"/></f></get_emitterColorEndMax>
		<set_emitterColorEndMax get="inline" set="null" line="673"><f a="colorEndMax">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_emitterColorEndMax>
		<emitterDragActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Drag Active" }</e></m></meta>
			<haxe_doc>* Enable or disable X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragActive>
		<get_emitterDragActive get="inline" set="null" line="680"><f a=""><x path="Bool"/></f></get_emitterDragActive>
		<set_emitterDragActive get="inline" set="null" line="681"><f a="dragActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterDragActive>
		<emitterDragStartMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag Start Min X", group : "emitterDragStartMin" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragStartMinX>
		<get_emitterDragStartMinX get="inline" set="null" line="688"><f a=""><x path="Float"/></f></get_emitterDragStartMinX>
		<set_emitterDragStartMinX get="inline" set="null" line="689"><f a="dragStartMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragStartMinX>
		<emitterDragStartMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag Start Min Y", group : "emitterDragStartMin" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragStartMinY>
		<get_emitterDragStartMinY get="inline" set="null" line="695"><f a=""><x path="Float"/></f></get_emitterDragStartMinY>
		<set_emitterDragStartMinY get="inline" set="null" line="696"><f a="dragStartMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragStartMinY>
		<emitterDragStartMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag Start Max X", group : "emitterDragStartMax" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragStartMaxX>
		<get_emitterDragStartMaxX get="inline" set="null" line="702"><f a=""><x path="Float"/></f></get_emitterDragStartMaxX>
		<set_emitterDragStartMaxX get="inline" set="null" line="703"><f a="dragStartMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragStartMaxX>
		<emitterDragStartMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag Start Max Y", group : "emitterDragStartMax" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragStartMaxY>
		<get_emitterDragStartMaxY get="inline" set="null" line="709"><f a=""><x path="Float"/></f></get_emitterDragStartMaxY>
		<set_emitterDragStartMaxY get="inline" set="null" line="710"><f a="dragStartMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragStartMaxY>
		<emitterDragEndMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag End Min X", group : "emitterDragEndMin" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragEndMinX>
		<get_emitterDragEndMinX get="inline" set="null" line="716"><f a=""><x path="Float"/></f></get_emitterDragEndMinX>
		<set_emitterDragEndMinX get="inline" set="null" line="717"><f a="dragEndMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragEndMinX>
		<emitterDragEndMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag End Min Y", group : "emitterDragEndMin" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragEndMinY>
		<get_emitterDragEndMinY get="inline" set="null" line="723"><f a=""><x path="Float"/></f></get_emitterDragEndMinY>
		<set_emitterDragEndMinY get="inline" set="null" line="724"><f a="dragEndMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragEndMinY>
		<emitterDragEndMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag End Max X", group : "emitterDragEndMax" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragEndMaxX>
		<get_emitterDragEndMaxX get="inline" set="null" line="730"><f a=""><x path="Float"/></f></get_emitterDragEndMaxX>
		<set_emitterDragEndMaxX get="inline" set="null" line="731"><f a="dragEndMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragEndMaxX>
		<emitterDragEndMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag End Max Y", group : "emitterDragEndMax" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragEndMaxY>
		<get_emitterDragEndMaxY get="inline" set="null" line="737"><f a=""><x path="Float"/></f></get_emitterDragEndMaxY>
		<set_emitterDragEndMaxY get="inline" set="null" line="738"><f a="dragEndMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragEndMaxY>
		<emitterAccelerationActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Accel. Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationActive>
		<get_emitterAccelerationActive get="inline" set="null" line="746"><f a=""><x path="Bool"/></f></get_emitterAccelerationActive>
		<set_emitterAccelerationActive get="inline" set="null" line="747"><f a="accelerationActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterAccelerationActive>
		<emitterAccelerationStartMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. Start Min X", group : "emitterAccelerationStartMin" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationStartMinX>
		<get_emitterAccelerationStartMinX get="inline" set="null" line="755"><f a=""><x path="Float"/></f></get_emitterAccelerationStartMinX>
		<set_emitterAccelerationStartMinX get="inline" set="null" line="756"><f a="accelerationStartMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationStartMinX>
		<emitterAccelerationStartMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. Start Min Y", group : "emitterAccelerationStartMin" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationStartMinY>
		<get_emitterAccelerationStartMinY get="inline" set="null" line="763"><f a=""><x path="Float"/></f></get_emitterAccelerationStartMinY>
		<set_emitterAccelerationStartMinY get="inline" set="null" line="764"><f a="accelerationStartMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationStartMinY>
		<emitterAccelerationStartMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. Start Max X", group : "emitterAccelerationStartMax" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationStartMaxX>
		<get_emitterAccelerationStartMaxX get="inline" set="null" line="771"><f a=""><x path="Float"/></f></get_emitterAccelerationStartMaxX>
		<set_emitterAccelerationStartMaxX get="inline" set="null" line="772"><f a="accelerationStartMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationStartMaxX>
		<emitterAccelerationStartMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. Start Max Y", group : "emitterAccelerationStartMax" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationStartMaxY>
		<get_emitterAccelerationStartMaxY get="inline" set="null" line="779"><f a=""><x path="Float"/></f></get_emitterAccelerationStartMaxY>
		<set_emitterAccelerationStartMaxY get="inline" set="null" line="780"><f a="accelerationStartMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationStartMaxY>
		<emitterAccelerationEndMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. End Min X", group : "emitterAccelerationEndMin" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationEndMinX>
		<get_emitterAccelerationEndMinX get="inline" set="null" line="787"><f a=""><x path="Float"/></f></get_emitterAccelerationEndMinX>
		<set_emitterAccelerationEndMinX get="inline" set="null" line="788"><f a="accelerationEndMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationEndMinX>
		<emitterAccelerationEndMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. End Min Y", group : "emitterAccelerationEndMin" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationEndMinY>
		<get_emitterAccelerationEndMinY get="inline" set="null" line="795"><f a=""><x path="Float"/></f></get_emitterAccelerationEndMinY>
		<set_emitterAccelerationEndMinY get="inline" set="null" line="796"><f a="accelerationEndMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationEndMinY>
		<emitterAccelerationEndMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. End Max X", group : "emitterAccelerationEndMax" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationEndMaxX>
		<get_emitterAccelerationEndMaxX get="inline" set="null" line="803"><f a=""><x path="Float"/></f></get_emitterAccelerationEndMaxX>
		<set_emitterAccelerationEndMaxX get="inline" set="null" line="804"><f a="accelerationEndMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationEndMaxX>
		<emitterAccelerationEndMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. End Max Y", group : "emitterAccelerationEndMax" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationEndMaxY>
		<get_emitterAccelerationEndMaxY get="inline" set="null" line="811"><f a=""><x path="Float"/></f></get_emitterAccelerationEndMaxY>
		<set_emitterAccelerationEndMaxY get="inline" set="null" line="812"><f a="accelerationEndMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationEndMaxY>
		<emitterSize public="1" get="inline" set="null" line="820">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The width and height of the emission area.
     * If not defined (`-1`), will use visual's width and height bound to this `ParticleEmitter` object, if any</haxe_doc>
		</emitterSize>
		<emitterPos public="1" get="inline" set="null" line="827">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The x and y position of the emission, relative to particles parent (if any)</haxe_doc>
		</emitterPos>
		<emitterMaxVelocity public="1" get="inline" set="null" line="835">
			<f a="maxVelocityX:maxVelocityY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
     * to cap the speed automatically (very useful!).</haxe_doc>
		</emitterMaxVelocity>
		<emitterVelocityStart public="1" get="inline" set="null" line="842">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the velocity starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityStart>
		<emitterVelocityEnd public="1" get="inline" set="null" line="849">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the velocity ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityEnd>
		<emitterSpeedStart public="1" get="inline" set="null" line="856">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the speed starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `CIRCLE`.</haxe_doc>
		</emitterSpeedStart>
		<emitterSpeedEnd public="1" get="inline" set="null" line="863">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the speed ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `CIRCLE`.</haxe_doc>
		</emitterSpeedEnd>
		<emitterAngularAcceleration public="1" get="inline" set="null" line="870">
			<f a="startMin:startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the angular acceleration range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularAcceleration>
		<emitterAngularDrag public="1" get="inline" set="null" line="877">
			<f a="startMin:startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the angular drag range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularDrag>
		<emitterAngularVelocityStart public="1" get="inline" set="null" line="884">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angular velocity starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityStart>
		<emitterAngularVelocityEnd public="1" get="inline" set="null" line="891">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angular velocity ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityEnd>
		<emitterAngleStart public="1" get="inline" set="null" line="899">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angle starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleStart>
		<emitterAngleEnd public="1" get="inline" set="null" line="907">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angle ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleEnd>
		<emitterLaunchAngle public="1" get="inline" set="null" line="915">
			<f a="min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angle range at which particles will be launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</emitterLaunchAngle>
		<emitterLifespan public="1" get="inline" set="null" line="922">
			<f a="min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The life, or duration, range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterLifespan>
		<emitterScaleStart public="1" get="inline" set="null" line="929">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `scale` starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleStart>
		<emitterScaleEnd public="1" get="inline" set="null" line="936">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `scale` ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleEnd>
		<emitterAccelerationStart public="1" get="inline" set="null" line="943">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `acceleration` starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAccelerationStart>
		<emitterAccelerationEnd public="1" get="inline" set="null" line="950">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `acceleration` ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAccelerationEnd>
		<emitterDragStart public="1" get="inline" set="null" line="957">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `drag` starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragStart>
		<emitterdragEnd public="1" get="inline" set="null" line="964">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `drag` ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterdragEnd>
		<emitterColorStart public="1" get="inline" set="null" line="971">
			<f a="startMin:?startMax">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `color` starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorStart>
		<emitterColorEnd public="1" get="inline" set="null" line="978">
			<f a="endMin:?endMax">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `color` ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorEnd>
		<emitterAlphaStart public="1" get="inline" set="null" line="985">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `alpha` starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaStart>
		<emitterAlphaEnd public="1" get="inline" set="null" line="992">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `alpha` ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaEnd>
		<new public="1" set="method" line="15"><f a="?emitter">
	<c path="ceramic.Particles.T"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n="editable"/>
		</meta>
	</class>
	<enum path="ceramic.ParticlesLaunchMode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ParticlesLaunchMode.hx">
		<CIRCLE><haxe_doc>* Particles will use `launchAngle` and `speed` to be launched</haxe_doc></CIRCLE>
		<SQUARE><haxe_doc>* Particles will use `velocityX` and `velocityY` to be launched</haxe_doc></SQUARE>
		<haxe_doc>* How particles should be launched. If `CIRCLE`, particles will use `launchAngle` and `speed`.
 * Otherwise, particles will just use `velocityX` and `velocityY`.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="ceramic.ParticlesStatus" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ParticlesStatus.hx">
		<IDLE><haxe_doc>* Not emitting particles, and no particle is visible.</haxe_doc></IDLE>
		<EMITTING><haxe_doc>* Emitting particles.</haxe_doc></EMITTING>
		<SPREADING><haxe_doc>* Not emitting particles, but previously emitted particles are still spreading</haxe_doc></SPREADING>
		<haxe_doc>* Which status a `Particles` emitter object has.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.Path" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Path.hx">
		<withoutExtension public="1" set="method" line="126" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the file extension.

        If `path` is null, the result is unspecified.</haxe_doc>
		</withoutExtension>
		<withoutDirectory public="1" set="method" line="137" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the directory.

        If `path` is null, the result is unspecified.</haxe_doc>
		</withoutDirectory>
		<directory public="1" set="method" line="150" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

        If the directory is null, the empty String `""` is returned.

        If `path` is null, the result is unspecified.</haxe_doc>
		</directory>
		<extension public="1" set="method" line="164" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the extension of `path`.

        If the extension is null, the empty String `""` is returned.

        If `path` is null, the result is unspecified.</haxe_doc>
		</extension>
		<withExtension public="1" set="method" line="178" static="1">
			<f a="path:ext">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String representation of `path` where the extension is `ext`.

        If `path` has no extension, `ext` is added as extension.

        If `path` or `ext` are null, the result is unspecified.</haxe_doc>
		</withExtension>
		<join public="1" set="method" line="192" static="1">
			<f a="paths">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all paths in `paths` together.

        If `paths` is empty, the empty String `""` is returned. Otherwise the
        paths are joined with a slash between them.

        If `paths` is null, the result is unspecified.</haxe_doc>
		</join>
		<normalize public="1" set="method" line="213" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Normalize a given `path` (e.g. make '/usr/local/../lib' to '/usr/lib').

        Also replaces backslashes \ with slashes / and afterwards turns
        multiple slashes into a single one.

        If `path` is null, the result is unspecified.</haxe_doc>
		</normalize>
		<addTrailingSlash public="1" set="method" line="270" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

        If the last slash in `path` is a backslash, a backslash is appended to
        `path`.

        If the last slash in `path` is a slash, or if no slash is found, a slash
        is appended to `path`. In particular, this applies to the empty String
        `""`.

        If `path` is null, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<removeTrailingSlashes public="1" set="method" line="295" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":require"><e><![CDATA[haxe_ver >= 3.1]]></e></m></meta>
			<haxe_doc>Removes trailing slashes from `path`.

        If `path` does not end with a `/` or `\`, `path` is returned unchanged.

        Otherwise the substring of `path` excluding the trailing slashes or
        backslashes is returned.

        If `path` is null, the result is unspecified.</haxe_doc>
		</removeTrailingSlashes>
		<isAbsolute public="1" set="method" line="308" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the path is an absolute path, and false otherwise.</haxe_doc>
		</isAbsolute>
		<dir public="1">
			<c path="String"/>
			<haxe_doc>The directory.

        This is the leading part of the path that is not part of the file name
        and the extension.

        Does not end with a `/` or `\` separator.

        If the path has no directory, the value is null.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

        This is the part of the part between the directory and the extension.

        If there is no file name, e.g. for ".htaccess" or "/dir/", the value
        is the empty String "".</haxe_doc>
		</file>
		<ext public="1">
			<c path="String"/>
			<haxe_doc>The file extension.

        It is separated from the file name by a dot. This dot is not part of
        the extension.

        If the path has no extension, the value is null.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>True if the last directory separator is a backslash, false otherwise.</haxe_doc>
		</backslash>
		<toString public="1" set="method" line="117">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of `this` path.

        If `this.backslash` is true, backslash is used as directory separator,
        otherwise slash is used. This only affects the separator between
        `this.dir` and `this.file`.

        If `this.directory` or `this.extension` is null, their representation
        is the empty String "".</haxe_doc>
		</toString>
		<new public="1" set="method" line="79">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Path instance by parsing `path`.

        Path information can be retrieved by accessing the dir, file and ext
        properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
    common path formats:

    - directory1/directory2/filename.extension
    - directory1\directory2\filename.extension</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.PersistentData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/PersistentData.hx">
		<internalData><x path="haxe.DynamicAccess"><d/></x></internalData>
		<id public="1" set="null"><c path="String"/></id>
		<get public="1" get="inline" set="null" line="30"><f a="key">
	<c path="String"/>
	<d/>
</f></get>
		<set public="1" get="inline" set="null" line="36"><f a="key:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></set>
		<remove public="1" get="inline" set="null" line="42"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></remove>
		<clear public="1" get="inline" set="null" line="48"><f a=""><x path="Void"/></f></clear>
		<exists public="1" get="inline" set="null" line="56"><f a="key">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<keys public="1" get="inline" set="null" line="62"><f a=""><c path="Array"><c path="String"/></c></f></keys>
		<save public="1" set="method" line="68"><f a=""><x path="Void"/></f></save>
		<new public="1" set="method" line="12"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.PixelArt" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/PixelArt.hx">
		<extends path="ceramic.Filter"/>
		<sharpness public="1" set="accessor" expr="8.0">
			<x path="Float"/>
			<meta><m n=":value"><e>8.0</e></m></meta>
			<haxe_doc>* Sharpness of the pixels (from 1.0 to above)</haxe_doc>
		</sharpness>
		<set_sharpness set="method" line="15"><f a="sharpness">
	<x path="Float"/>
	<x path="Float"/>
</f></set_sharpness>
		<gridThickness public="1" set="accessor" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
			<haxe_doc>* If set above 0.0, a grid will be displayed.
     * Can be used to simulate GBA-style LCD displays.</haxe_doc>
		</gridThickness>
		<set_gridThickness set="method" line="28"><f a="gridThickness">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gridThickness>
		<gridColor public="1" set="accessor" expr="Color.BLACK">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.BLACK</e></m></meta>
			<haxe_doc>* When using a grid, this is the color of the grid</haxe_doc>
		</gridColor>
		<set_gridColor set="method" line="40"><f a="gridColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_gridColor>
		<gridAlpha public="1" set="accessor" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
			<haxe_doc>* When using a grid, this is the alpha of the grid</haxe_doc>
		</gridAlpha>
		<set_gridAlpha set="method" line="52"><f a="gridAlpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gridAlpha>
		<set_density set="method" line="60" override="1"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<handleResize set="method" line="83"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></handleResize>
		<updateResolution set="method" line="89"><f a=""><x path="Void"/></f></updateResolution>
		<destroy public="1" set="method" line="100" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="67"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A filter configured to display pixel art content.
 * Uses a shader to get a nicer rendering of upscaled pixel art.
 * Better than NEAREST or LINEAR texture filtering.
 * (see https://colececil.io/blog/2017/scaling-pixel-art-without-destroying-it/)</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Pixels" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Pixels.hx">
		<copy public="1" set="method" line="36" static="1">
			<f a="srcBuffer:srcBufferWidth:dstBuffer:dstBufferWidth:srcX:srcY:srcWidth:srcHeight:dstX:dstY:?copyRed:?copyGreen:?copyBlue:?copyAlpha" v="::::::::::true:true:true:true">
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ copyAlpha : true, copyBlue : true, copyGreen : true, copyRed : true }</e></m></meta>
			<haxe_doc>* Copy pixels from `srcBuffer` to `dstBuffer`
     * @param srcBuffer Source buffer to copy pixels from
     * @param srcBufferWidth Source buffer image width (needed to know index from x,y coordinates)
     * @param dstBuffer Destination buffer to past pixels into
     * @param dstBufferWidth Destination buffer image width (needed to know index from x,y coordinates)
     * @param srcX Source x position to copy from
     * @param srcY Source y position to copy from
     * @param srcWidth Source width to copy from
     * @param srcHeight Source height to copy from
     * @param dstX Destination x to paste into
     * @param dstY Destination y to paste into
     * @param copyRed Set to `true` default to copy red channel
     * @param copyGreen Set to `true` default to copy green channel
     * @param copyBlue Set to `true` default to copy blue channel
     * @param copyAlpha Set to `true` default to copy alpha channel</haxe_doc>
		</copy>
		<create public="1" set="method" line="99" static="1">
			<f a="width:height:fillColor">
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
				<t path="ceramic.UInt8Array"/>
			</f>
			<haxe_doc>* Create a pixels buffer
     * @param width Image width
     * @param height Image height
     * @param fillColor Default color
     * @return UInt8Array</haxe_doc>
		</create>
		<fromBytes public="1" set="method" line="119" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<t path="ceramic.UInt8Array"/>
			</f>
			<haxe_doc>* Create a pixels buffer from bytes with RGBA representation</haxe_doc>
		</fromBytes>
		<get public="1" get="inline" set="null" line="140" static="1">
			<f a="buffer:bufferWidth:x:y">
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Get a pixel as `AlphaColor` at `x`,`y` coordinates on the given buffer
     * @param buffer The pixel buffer to read from
     * @param bufferWidth Image width
     * @param x Pixel x position
     * @param y Pixel y position
     * @return AlphaColor</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="160" static="1">
			<f a="buffer:bufferWidth:x:y:color">
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set a pixel as `AlphaColor` at `x`,`y` coordinates on the given buffer
     * @param buffer The pixel buffer to write into
     * @param bufferWidth Image width
     * @param x Pixel x position
     * @param y Pixel y position
     * @param color AlphaColor of the pixel</haxe_doc>
		</set>
		<setRectangle public="1" get="inline" set="null" line="183" static="1">
			<f a="buffer:bufferWidth:x:y:width:height:color">
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set a rectangle of pixels as `AlphaColor` at `x`,`y` coordinates and with the specified `width` and `height` on the given buffer
     * @param buffer The pixel buffer to write into
     * @param bufferWidth Image width
     * @param x Rectangle x position
     * @param y Rectangle y position
     * @param width Rectangle width
     * @param height Rectangle height
     * @param color AlphaColor of the rectangle's pixels</haxe_doc>
		</setRectangle>
		<pixelsToPng public="1" get="inline" set="null" line="199" static="1">
			<f a="width:height:pixels:path:done">
				<x path="Int"/>
				<x path="Int"/>
				<t path="ceramic.UInt8Array"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Export the given pixels pixels as PNG data and save it to the given file path
     * @param width Image width
     * @param height Image height
     * @param pixels The pixels buffer
     * @param path The png file path where to save the image (`'/path/to/image.png'`)
     * @param done Called when the png has been exported</haxe_doc>
			<overloads><pixelsToPng public="1" get="inline" set="null" line="213">
	<f a="width:height:pixels:done">
		<x path="Int"/>
		<x path="Int"/>
		<t path="ceramic.UInt8Array"/>
		<f a="data">
			<c path="haxe.io.Bytes"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<haxe_doc><![CDATA[* Export the given pixels to PNG data/bytes
     * @param width Image width
     * @param height Image height
     * @param pixels The pixels buffer
     * @param done Called when the png has been exported, with `data` containing PNG bytes
     * @return ->Void):Void]]></haxe_doc>
</pixelsToPng></overloads>
		</pixelsToPng>
		<_pixelsToPng set="method" line="219" static="1"><f a="width:height:pixels:?path:done">
	<x path="Int"/>
	<x path="Int"/>
	<t path="ceramic.UInt8Array"/>
	<c path="String"/>
	<f a="?data">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></_pixelsToPng>
		<rgbaPixelsToRgbPixels public="1" set="method" line="233" static="1">
			<f a="width:height:inPixels:?outPixels">
				<x path="Int"/>
				<x path="Int"/>
				<t path="ceramic.UInt8Array"/>
				<x path="Null"><t path="ceramic.UInt8Array"/></x>
				<t path="ceramic.UInt8Array"/>
			</f>
			<haxe_doc>* Converts a RGBA pixels buffer into RGB pixels buffer
     * @param width Image width
     * @param height Image height
     * @param inPixels The source RGBA pixels buffer
     * @param outPixels (optional) The destination RGB pixels buffer
     * @return The final RGB pixels buffer</haxe_doc>
		</rgbaPixelsToRgbPixels>
		<rgbPixelsToRgbaPixels public="1" set="method" line="268" static="1">
			<f a="width:height:?alpha:inPixels:?outPixels" v="::255::">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="ceramic.UInt8Array"/>
				<x path="Null"><t path="ceramic.UInt8Array"/></x>
				<t path="ceramic.UInt8Array"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 255 }</e></m></meta>
			<haxe_doc>* Converts a RGB pixels buffer into RGBA pixels buffer
     * @param width Image width
     * @param height Image height
     * @param alpha Alpha value (0-255) to use (default to 255)
     * @param inPixels The source RGBA pixels buffer
     * @param outPixels (optional) The destination RGB pixels buffer
     * @return The final RGBA pixels buffer</haxe_doc>
		</rgbPixelsToRgbaPixels>
		<mixPixelsBuffers public="1" set="method" line="303" static="1">
			<f a="inPixelsList:?middleFactor:?outPixels" v=":1:">
				<c path="Array"><t path="ceramic.UInt8Array"/></c>
				<x path="Float"/>
				<x path="Null"><t path="ceramic.UInt8Array"/></x>
				<t path="ceramic.UInt8Array"/>
			</f>
			<meta><m n=":value"><e>{ middleFactor : 1 }</e></m></meta>
			<haxe_doc>* Mix the given list of pixels buffers into a single one.
     * @param inPixelsList An array of pixels buffers
     * @param middleFactor A multiplicator that makes the middle buffers more important than the rest if above 1
     * @param outPixels (optional) The destination pixels buffer
     * @return The final mixed pixels buffer</haxe_doc>
		</mixPixelsBuffers>
		<flipY public="1" set="method" line="351" static="1">
			<f a="buffer:bufferWidth">
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Flip the given pixels buffer on the Y axis
     * @param buffer The pixel buffer to read from and write to
     * @param bufferWidth Image width</haxe_doc>
		</flipY>
		<flipX public="1" set="method" line="388" static="1">
			<f a="buffer:bufferWidth">
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Flip the given pixels buffer on the X axis
     * @param buffer The pixel buffer to read from and write to
     * @param bufferWidth Image width</haxe_doc>
		</flipX>
		<haxe_doc>* Utilities to manipulate RGBA pixels.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.PlatformSpecific" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/PlatformSpecific.hx">
		<postAppInit public="1" set="method" line="25" static="1"><f a=""><x path="Void"/></f></postAppInit>
		<readStringFromAsset public="1" set="method" line="41" static="1">
			<f a="assetPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Read a string from an asset file, synchronously.
     * Warning: not available on every targets
     * @return String</haxe_doc>
		</readStringFromAsset>
		<readBytesFromAsset public="1" set="method" line="90" static="1">
			<f a="assetPath">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Read bytes from an asset file, synchronously.
     * Warning: not available on every targets
     * @return String</haxe_doc>
		</readBytesFromAsset>
		<getAssetsPath public="1" set="method" line="139" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns assets paths on disk (if any)
     * Warning: not available on every targets
     * @return String</haxe_doc>
		</getAssetsPath>
		<getRtti public="1" params="T" set="method" line="177" static="1"><f a="c">
	<x path="Class"><c path="getRtti.T"/></x>
	<t path="haxe.rtti.Classdef"/>
</f></getRtti>
		<nodeRequire public="1" set="method" line="255" static="1"><f a="module">
	<c path="String"/>
	<d/>
</f></nodeRequire>
		<quit public="1" set="method" line="264" static="1"><f a=""><x path="Void"/></f></quit>
		<haxe_doc>* An internal class that encapsulate platform-specific code.
 * We usually want platform-specific code to be located in a backend,
 * but it may happen that sometimes creating a backend interface is overkill.
 * That's where this comes handy.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.PremultiplyAlpha" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/PremultiplyAlpha.hx">
		<premultiplyAlpha public="1" set="method" line="5" static="1"><f a="pixels">
	<t path="ceramic.UInt8Array"/>
	<x path="Void"/>
</f></premultiplyAlpha>
		<reversePremultiplyAlpha public="1" set="method" line="27" static="1"><f a="pixels">
	<t path="ceramic.UInt8Array"/>
	<x path="Void"/>
</f></reversePremultiplyAlpha>
	</class>
	<abstract path="ceramic.ReadOnlyArray" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="ceramic.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
 APIs that don't modify the instance, hence "read-only".
 
 Note that this doesn't necessarily mean that the instance is *immutable*.
 Other code holding a reference to the underlying `Array` can still modify it,
 and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>get</e>
	<e>concat</e>
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="ceramic._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyArray.hx" private="1" module="ceramic.ReadOnlyArray" final="1">
	<arrayAccess public="1" get="inline" set="null" line="38" static="1">
		<f a="this:key">
			<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
			<x path="Int"/>
			<c path="ceramic.ReadOnlyArray.T"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</arrayAccess>
	<original public="1" get="accessor" set="null" static="1">
		<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
		<haxe_doc>* Returns the underlying (and mutable) data. Use at your own risk!</haxe_doc>
	</original>
	<get_original get="inline" set="null" line="44" static="1"><f a="this">
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
</f></get_original>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>The length of `this` Array.</haxe_doc>
	</length>
	<get_length get="inline" set="null" line="51" static="1"><f a="this">
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
	<x path="Int"/>
</f></get_length>
	<unsafeGet public="1" get="inline" set="null" line="55" static="1"><f a="this:index">
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
	<x path="Int"/>
	<c path="ceramic.ReadOnlyArray.T"/>
</f></unsafeGet>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyArray.hx" private="1" module="ceramic.ReadOnlyArray" final="1">
		<arrayAccess public="1" get="inline" set="null" line="38" static="1">
			<f a="this:key">
				<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
				<x path="Int"/>
				<c path="ceramic.ReadOnlyArray.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</arrayAccess>
		<original public="1" get="accessor" set="null" static="1">
			<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
			<haxe_doc>* Returns the underlying (and mutable) data. Use at your own risk!</haxe_doc>
		</original>
		<get_original get="inline" set="null" line="44" static="1"><f a="this">
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
</f></get_original>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="51" static="1"><f a="this">
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
	<x path="Int"/>
</f></get_length>
		<unsafeGet public="1" get="inline" set="null" line="55" static="1"><f a="this:index">
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
	<x path="Int"/>
	<c path="ceramic.ReadOnlyArray.T"/>
</f></unsafeGet>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="ceramic.ReadOnlyMap" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyMap.hx">
		<from><icast><t path="Map">
	<c path="ceramic.ReadOnlyMap.K"/>
	<c path="ceramic.ReadOnlyMap.V"/>
</t></icast></from>
		<this><t path="Map">
	<c path="ceramic.ReadOnlyMap.K"/>
	<c path="ceramic.ReadOnlyMap.V"/>
</t></this>
		<to><icast><t path="Map">
	<c path="ceramic.ReadOnlyMap.K"/>
	<c path="ceramic.ReadOnlyMap.V"/>
</t></icast></to>
		<meta><m n=":forward">
	<e>get</e>
	<e>exists</e>
	<e>keys</e>
	<e>toString</e>
</m></meta>
		<impl><class path="ceramic._ReadOnlyMap.ReadOnlyMap_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyMap.hx" private="1" module="ceramic.ReadOnlyMap" final="1">
	<arrayAccess public="1" get="inline" set="null" line="6" static="1">
		<f a="this:key">
			<t path="Map">
				<c path="ceramic.ReadOnlyMap.K"/>
				<c path="ceramic.ReadOnlyMap.V"/>
			</t>
			<c path="ceramic.ReadOnlyMap.K"/>
			<c path="ceramic.ReadOnlyMap.V"/>
		</f>
		<meta>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</arrayAccess>
	<original public="1" get="accessor" set="null" static="1">
		<t path="Map">
			<c path="ceramic.ReadOnlyMap.K"/>
			<c path="ceramic.ReadOnlyMap.V"/>
		</t>
		<haxe_doc>* Returns the underlying (and mutable) data. Use at your own risk!</haxe_doc>
	</original>
	<get_original get="inline" set="null" line="12" static="1"><f a="this">
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
</f></get_original>
	<iterator public="1" get="inline" set="null" line="15" static="1"><f a="this">
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
	<t path="Iterator"><c path="ceramic.ReadOnlyMap.V"/></t>
</f></iterator>
	<keyValueIterator public="1" get="inline" set="null" line="18" static="1"><f a="this">
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
	<t path="KeyValueIterator">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
</f></keyValueIterator>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._ReadOnlyMap.ReadOnlyMap_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyMap.hx" private="1" module="ceramic.ReadOnlyMap" final="1">
		<arrayAccess public="1" get="inline" set="null" line="6" static="1">
			<f a="this:key">
				<t path="Map">
					<c path="ceramic.ReadOnlyMap.K"/>
					<c path="ceramic.ReadOnlyMap.V"/>
				</t>
				<c path="ceramic.ReadOnlyMap.K"/>
				<c path="ceramic.ReadOnlyMap.V"/>
			</f>
			<meta>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</arrayAccess>
		<original public="1" get="accessor" set="null" static="1">
			<t path="Map">
				<c path="ceramic.ReadOnlyMap.K"/>
				<c path="ceramic.ReadOnlyMap.V"/>
			</t>
			<haxe_doc>* Returns the underlying (and mutable) data. Use at your own risk!</haxe_doc>
		</original>
		<get_original get="inline" set="null" line="12" static="1"><f a="this">
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
</f></get_original>
		<iterator public="1" get="inline" set="null" line="15" static="1"><f a="this">
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
	<t path="Iterator"><c path="ceramic.ReadOnlyMap.V"/></t>
</f></iterator>
		<keyValueIterator public="1" get="inline" set="null" line="18" static="1"><f a="this">
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
	<t path="KeyValueIterator">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
</f></keyValueIterator>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="ceramic.ReadOnlyPoint" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyPoint.hx">
		<from><icast><c path="ceramic.Point"/></icast></from>
		<this><c path="ceramic.Point"/></this>
		<meta>
			<m n=":structInit"/>
			<m n=":allow"><e>ceramic.Screen</e></m>
		</meta>
		<impl><class path="ceramic._ReadOnlyPoint.ReadOnlyPoint_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyPoint.hx" private="1" module="ceramic.ReadOnlyPoint" final="1">
	<x public="1" get="accessor" set="null" static="1"><x path="Float"/></x>
	<get_x get="inline" set="null" line="8" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<x path="Float"/>
</f></get_x>
	<y public="1" get="accessor" set="null" static="1"><x path="Float"/></y>
	<get_y get="inline" set="null" line="11" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<x path="Float"/>
</f></get_y>
	<z public="1" get="accessor" set="null" static="1"><x path="Float"/></z>
	<get_z get="inline" set="null" line="14" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<x path="Float"/>
</f></get_z>
	<toPoint public="1" get="inline" set="null" line="16" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<c path="ceramic.Point"/>
</f></toPoint>
	<toString set="method" line="20" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<c path="String"/>
</f></toString>
	<meta><m n=":allow"><e>ceramic.Screen</e></m></meta>
</class></impl>
	</abstract>
	<class path="ceramic._ReadOnlyPoint.ReadOnlyPoint_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyPoint.hx" private="1" module="ceramic.ReadOnlyPoint" final="1">
		<x public="1" get="accessor" set="null" static="1"><x path="Float"/></x>
		<get_x get="inline" set="null" line="8" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<x path="Float"/>
</f></get_x>
		<y public="1" get="accessor" set="null" static="1"><x path="Float"/></y>
		<get_y get="inline" set="null" line="11" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<x path="Float"/>
</f></get_y>
		<z public="1" get="accessor" set="null" static="1"><x path="Float"/></z>
		<get_z get="inline" set="null" line="14" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<x path="Float"/>
</f></get_z>
		<toPoint public="1" get="inline" set="null" line="16" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<c path="ceramic.Point"/>
</f></toPoint>
		<toString set="method" line="20" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<c path="String"/>
</f></toString>
		<meta><m n=":allow"><e>ceramic.Screen</e></m></meta>
	</class>
	<class path="ceramic.Rect" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Rect.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<toString set="method" line="14"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="20">
			<f a="?x:?y:?width:?height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<abstract path="ceramic.RenderPrimitiveType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/RenderPrimitiveType.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._RenderPrimitiveType.RenderPrimitiveType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/RenderPrimitiveType.hx" private="1" module="ceramic.RenderPrimitiveType" extern="1" final="1">
	<TRIANGLE public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="ceramic.RenderPrimitiveType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TRIANGLE>
	<LINE public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
		<x path="ceramic.RenderPrimitiveType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LINE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._RenderPrimitiveType.RenderPrimitiveType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/RenderPrimitiveType.hx" private="1" module="ceramic.RenderPrimitiveType" extern="1" final="1">
		<TRIANGLE public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="ceramic.RenderPrimitiveType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TRIANGLE>
		<LINE public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
			<x path="ceramic.RenderPrimitiveType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LINE>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="ceramic.Texture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Texture.hx">
		<extends path="ceramic.Entity"/>
		<_nextIndex expr="1" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</_nextIndex>
		<fromPixels public="1" set="method" line="140" static="1">
			<f a="width:height:pixels:?density" v=":::1">
				<x path="Float"/>
				<x path="Float"/>
				<t path="ceramic.UInt8Array"/>
				<x path="Float"/>
				<c path="ceramic.Texture"/>
			</f>
			<meta><m n=":value"><e>{ density : 1 }</e></m></meta>
			<haxe_doc>* Create a new texture from the given pixels buffer
     * @param width Width of the texture
     * @param height Height of the texture
     * @param pixels A pixel buffer in integer RGBA format
     * @param density (optional) density of the texture
     * @return Texture</haxe_doc>
		</fromPixels>
		<fromBytes public="1" set="method" line="155" static="1">
			<f a="bytes:?density:?options:done" v=":1::">
				<c path="haxe.io.Bytes"/>
				<x path="Float"/>
				<x path="Null"><t path="backend.LoadTextureOptions"/></x>
				<f a="texture">
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ density : 1 }</e></m></meta>
			<haxe_doc>* Create a new texture from the given bytes.
     * The bytes must be PNG or JPEG data
     * @param bytes The PNG or JPEG data as bytes
     * @param density (optional) Density of the texture
     * @param options (optional) Additional options when loading texture (could depend on backend)
     * @param done A callback receiving the loaded texture, or `null` if it failed</haxe_doc>
		</fromBytes>
		<index public="1" expr="_nextIndex++">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>_nextIndex++</e></m>
				<m n=":noCompletion"/>
			</meta>
		</index>
		<isRenderTexture public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isRenderTexture>
		<asRenderTexture public="1" set="null" expr="null">
			<c path="ceramic.RenderTexture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</asRenderTexture>
		<textureId public="1" get="accessor" set="null">
			<t path="backend.TextureId"/>
			<haxe_doc>* The texture ID used by the underlying backend (OpenGL etc...)</haxe_doc>
		</textureId>
		<get_textureId get="inline" set="null" line="33"><f a=""><t path="backend.TextureId"/></f></get_textureId>
		<nativeWidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The native width of the texture, not depending on texture density</haxe_doc>
		</nativeWidth>
		<get_nativeWidth get="inline" set="null" line="41"><f a=""><x path="Int"/></f></get_nativeWidth>
		<nativeHeight public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The native height of the texture, not depending on texture density</haxe_doc>
		</nativeHeight>
		<get_nativeHeight get="inline" set="null" line="49"><f a=""><x path="Int"/></f></get_nativeHeight>
		<nativeWidthActual public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The native actual width of the texture.
     * Same as native width unless underlying backend needs pot (power of two) sizes.</haxe_doc>
		</nativeWidthActual>
		<get_nativeWidthActual get="inline" set="null" line="58"><f a=""><x path="Int"/></f></get_nativeWidthActual>
		<nativeHeightActual public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The native actual height of the texture.
     * Same as native height unless underlying backend needs pot (power of two) sizes.</haxe_doc>
		</nativeHeightActual>
		<get_nativeHeightActual get="inline" set="null" line="67"><f a=""><x path="Int"/></f></get_nativeHeightActual>
		<width public="1" set="null"><x path="Float"/></width>
		<height public="1" set="null"><x path="Float"/></height>
		<density public="1" set="accessor"><x path="Float"/></density>
		<set_density set="method" line="76"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<filter public="1" set="accessor" expr="LINEAR">
			<e path="ceramic.TextureFilter"/>
			<meta><m n=":value"><e>LINEAR</e></m></meta>
		</filter>
		<set_filter set="method" line="85"><f a="filter">
	<e path="ceramic.TextureFilter"/>
	<e path="ceramic.TextureFilter"/>
</f></set_filter>
		<wrapS public="1" set="accessor" expr="CLAMP">
			<x path="ceramic.TextureWrap"/>
			<meta><m n=":value"><e>CLAMP</e></m></meta>
			<haxe_doc>* Horizontal texture wrap mode</haxe_doc>
		</wrapS>
		<set_wrapS set="method" line="96"><f a="wrapS">
	<x path="ceramic.TextureWrap"/>
	<x path="ceramic.TextureWrap"/>
</f></set_wrapS>
		<wrapT public="1" set="accessor" expr="CLAMP">
			<x path="ceramic.TextureWrap"/>
			<meta><m n=":value"><e>CLAMP</e></m></meta>
			<haxe_doc>* Vertical texture wrapping mode</haxe_doc>
		</wrapT>
		<set_wrapT set="method" line="107"><f a="wrapT">
	<x path="ceramic.TextureWrap"/>
	<x path="ceramic.TextureWrap"/>
</f></set_wrapT>
		<setWrap public="1" set="method" line="120">
			<f a="wrapS:?wrapT">
				<x path="ceramic.TextureWrap"/>
				<x path="ceramic.TextureWrap"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand for setting both wrapS and wrapT at the same time.
     * Possible values: `CLAMP`, `REPEAT`, `MIRROR`
     * @param wrapS horizontal wrap mode
     * @param wrapT vertical wrap mode</haxe_doc>
		</setWrap>
		<backendItem public="1"><t path="backend.Texture"/></backendItem>
		<asset public="1" expr="null">
			<c path="ceramic.ImageAsset"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</asset>
		<destroy public="1" set="method" line="174" override="1"><f a=""><x path="Void"/></f></destroy>
		<fetchPixels public="1" set="method" line="187"><f a="?result">
	<x path="Null"><t path="ceramic.UInt8Array"/></x>
	<t path="ceramic.UInt8Array"/>
</f></fetchPixels>
		<submitPixels public="1" set="method" line="193"><f a="pixels">
	<t path="ceramic.UInt8Array"/>
	<x path="Void"/>
</f></submitPixels>
		<toPng public="1" get="inline" set="null" line="206">
			<f a="path:?reversePremultiplyAlpha:done" v=":true:">
				<c path="String"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ reversePremultiplyAlpha : true }</e></m></meta>
			<haxe_doc>* Export texture as PNG data and save it to the given file path
     * @param path The png file path where to save the image (`'/path/to/image.png'`)
     * @param done Called when the png has been exported</haxe_doc>
			<overloads><toPng public="1" get="inline" set="null" line="216">
	<f a="?reversePremultiplyAlpha:done" v="true:">
		<x path="Bool"/>
		<f a="data">
			<c path="haxe.io.Bytes"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{ reversePremultiplyAlpha : true }</e></m></meta>
	<haxe_doc>* Export texture to PNG data/bytes
     * @param done Called when the png has been exported, with `data` containing PNG bytes</haxe_doc>
</toPng></overloads>
		</toPng>
		<_toPng set="method" line="222">
			<f a="?path:?reversePremultiplyAlpha:done" v=":true:">
				<c path="String"/>
				<x path="Bool"/>
				<f a="?data">
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ reversePremultiplyAlpha : true }</e></m></meta>
		</_toPng>
		<toString set="method" line="230" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="163">
			<f a="backendItem:?density" v=":-1">
				<t path="backend.Texture"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ density : -1 }</e></m></meta>
		</new>
		<haxe_doc>* A texture is an image ready to be drawn.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.RenderTexture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/RenderTexture.hx">
		<extends path="ceramic.Texture"/>
		<_clearQuad expr="null" line="15" static="1">
			<c path="ceramic.Quad"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_clearQuad>
		<autoRender public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoRender>
		<clearOnRender public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</clearOnRender>
		<renderDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</renderDirty>
		<depth public="1" set="null" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</depth>
		<stencil public="1" set="null" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</stencil>
		<antialiasing public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</antialiasing>
		<dependingTextures public="1" expr="null">
			<c path="ceramic.IntIntMap"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dependingTextures>
		<priority public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</priority>
		<_usedInRendering expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":allow"><e>ceramic.Renderer</e></m>
			</meta>
		</_usedInRendering>
		<_renderedOnce set="accessor" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":allow"><e>ceramic.Renderer</e></m>
			</meta>
		</_renderedOnce>
		<set__renderedOnce set="method" line="46"><f a="_renderedOnce">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set__renderedOnce>
		<_initialClearQuad expr="null">
			<c path="ceramic.Quad"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_initialClearQuad>
		<destroy public="1" set="method" line="98" override="1"><f a=""><x path="Void"/></f></destroy>
		<stamp public="1" set="method" line="120">
			<f a="visual:done">
				<c path="ceramic.Visual"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws the given visual onto the render texture.
     * The drawing operation is not done synchronously.
     * It waits for the next draw stage of the app to perform it,
     * then calls done() when finished.
     * This is expected to be used with a texture `autoRender` set to `false`.</haxe_doc>
		</stamp>
		<_stamp set="method" line="144"><f a="visual:done">
	<c path="ceramic.Visual"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></_stamp>
		<clear public="1" set="method" line="199">
			<f a="?color:?alpha:?clipX:?clipY:?clipWidth:?clipHeight:done" v="0xFFFFFF:0:-1:-1:-1:-1:">
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ clipHeight : -1, clipWidth : -1, clipY : -1, clipX : -1, alpha : 0, color : 0xFFFFFF }</e></m></meta>
			<haxe_doc>* Clears the texture, or a specific area of it with a fill color and alpha.
     * The drawing operation is not done synchronously.
     * It waits for the next draw stage of the app to perform it,
     * then calls done() when finished.
     * This is expected to be used with a texture `autoRender` set to `false`.</haxe_doc>
		</clear>
		<dependsOnTexture public="1" get="inline" set="null" line="225">
			<f a="texture">
				<c path="ceramic.Texture"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</dependsOnTexture>
		<dependsOnTextureCount public="1" get="inline" set="null" line="235">
			<f a="texture">
				<c path="ceramic.Texture"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</dependsOnTextureCount>
		<incrementDependingTextureCount public="1" get="inline" set="null" line="245">
			<f a="texture">
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</incrementDependingTextureCount>
		<resetDependingTextureCounts public="1" get="inline" set="null" line="265">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</resetDependingTextureCounts>
		<toString set="method" line="275" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="63">
			<f a="width:height:?density:?depth:?stencil:?antialiasing" v="::-1:true:true:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ antialiasing : 0, stencil : true, depth : true, density : -1 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<class path="ceramic.Renderer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Renderer.hx">
		<extends path="ceramic.Entity"/>
		<drawCalls expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</drawCalls>
		<activeShader expr="null">
			<x path="backend.Shader"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</activeShader>
		<customFloatAttributesSize expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</customFloatAttributesSize>
		<stencilClip expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</stencilClip>
		<lastTexture expr="null">
			<c path="ceramic.Texture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastTexture>
		<lastTextureId expr="backend.TextureId.DEFAULT">
			<t path="backend.TextureId"/>
			<meta><m n=":value"><e>backend.TextureId.DEFAULT</e></m></meta>
		</lastTextureId>
		<lastShader expr="null">
			<c path="ceramic.Shader"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastShader>
		<lastRenderTarget expr="null">
			<c path="ceramic.RenderTexture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastRenderTarget>
		<lastComputedBlending expr="ceramic.Blending.PREMULTIPLIED_ALPHA">
			<x path="ceramic.Blending"/>
			<meta><m n=":value"><e>ceramic.Blending.PREMULTIPLIED_ALPHA</e></m></meta>
		</lastComputedBlending>
		<lastClip expr="null">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastClip>
		<lastClipIsRegular expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lastClipIsRegular>
		<activeTextureSlot expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</activeTextureSlot>
		<backendTextures><c path="backend.Textures"/></backendTextures>
		<backendShaders><c path="backend.Shaders"/></backendShaders>
		<texWidth expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texWidth>
		<texHeight expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texHeight>
		<texWidthActual expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texWidthActual>
		<texHeightActual expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texHeightActual>
		<defaultTexturedShader expr="null">
			<x path="backend.Shader"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</defaultTexturedShader>
		<defaultWhiteTexture expr="null">
			<c path="ceramic.Texture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</defaultWhiteTexture>
		<quad expr="null">
			<c path="ceramic.Quad"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</quad>
		<mesh expr="null">
			<c path="ceramic.Mesh"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</mesh>
		<stateDirty expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</stateDirty>
		<z expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</z>
		<usedTextureIndexes expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</usedTextureIndexes>
		<usedTextures expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</usedTextures>
		<maxUsableTexturesInBatch expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</maxUsableTexturesInBatch>
		<activeShaderCanBatchMultipleTextures expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</activeShaderCanBatchMultipleTextures>
		<usedRenderTarget expr="null">
			<c path="ceramic.RenderTexture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</usedRenderTarget>
		<render public="1" set="method" line="74"><f a="isMainRender:ceramicVisuals">
	<x path="Bool"/>
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Void"/>
</f></render>
		<drawQuad get="inline" set="null" line="334"><f a="draw:quad">
	<c path="backend.Draw"/>
	<c path="ceramic.Quad"/>
	<x path="Void"/>
</f></drawQuad>
		<drawMesh get="inline" set="null" line="892">
			<f a="draw:mesh">
				<c path="backend.Draw"/>
				<c path="ceramic.Mesh"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Using an inline internal function because we want to use similar code multiple times,
            and let haxe compiler evaluate `hasCustomAttributes` and `hasTextureSlot`
            at compile time.</haxe_doc>
		</drawMesh>
		<flush get="inline" set="null" line="1340"><f a="draw">
	<c path="backend.Draw"/>
	<x path="Bool"/>
</f></flush>
		<computeQuadBlending get="inline" set="null" line="1363"><f a="quad">
	<c path="ceramic.Quad"/>
	<x path="ceramic.Blending"/>
</f></computeQuadBlending>
		<computeMeshBlending get="inline" set="null" line="1391"><f a="mesh">
	<c path="ceramic.Mesh"/>
	<x path="ceramic.Blending"/>
</f></computeMeshBlending>
		<isSameShader get="inline" set="null" line="1427"><f a="shaderA:shaderB">
	<c path="ceramic.Shader"/>
	<c path="ceramic.Shader"/>
	<x path="Bool"/>
</f></isSameShader>
		<useShader get="inline" set="null" line="1436"><f a="draw:shader">
	<c path="backend.Draw"/>
	<x path="backend.Shader"/>
	<x path="Void"/>
</f></useShader>
		<useBlending get="inline" set="null" line="1457"><f a="draw:blending">
	<c path="backend.Draw"/>
	<x path="ceramic.Blending"/>
	<x path="Void"/>
</f></useBlending>
		<scissorWithQuad get="inline" set="null" line="1514"><f a="draw:quad">
	<c path="backend.Draw"/>
	<c path="ceramic.Quad"/>
	<x path="Void"/>
</f></scissorWithQuad>
		<isNotRenderedRenderTexture get="inline" set="null" line="1525"><f a="texture">
	<c path="ceramic.Texture"/>
	<x path="Bool"/>
</f></isNotRenderedRenderTexture>
		<useRenderTarget get="inline" set="null" line="1532"><f a="draw:renderTarget">
	<c path="backend.Draw"/>
	<c path="ceramic.RenderTexture"/>
	<x path="Void"/>
</f></useRenderTarget>
		<useFirstTextureInBatch get="inline" set="null" line="1546"><f a="draw:texture">
	<c path="backend.Draw"/>
	<c path="ceramic.Texture"/>
	<x path="Void"/>
</f></useFirstTextureInBatch>
		<useTexture get="inline" set="null" line="1568"><f a="draw:texture:reusing">
	<c path="backend.Draw"/>
	<c path="ceramic.Texture"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></useTexture>
		<canUseTextureInSameBatch get="inline" set="null" line="1599"><f a="draw:texture">
	<c path="backend.Draw"/>
	<c path="ceramic.Texture"/>
	<x path="Bool"/>
</f></canUseTextureInSameBatch>
		<useTextureInSameBatch get="inline" set="null" line="1636"><f a="draw:texture">
	<c path="backend.Draw"/>
	<c path="ceramic.Texture"/>
	<x path="Void"/>
</f></useTextureInSameBatch>
		<unbindUsedTextures get="inline" set="null" line="1670"><f a="draw">
	<c path="backend.Draw"/>
	<x path="Void"/>
</f></unbindUsedTextures>
		<new public="1" set="method" line="68"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* An implementation-independant GPU 2D renderer.
 * To be used in pair with a draw backend implementation.</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.ReusableArray" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReusableArray.hx">
		<_poolIndex expr="-1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_poolIndex>
		<vector><x path="haxe.ds.Vector"><c path="ceramic.ReusableArray.T"/></x></vector>
		<length public="1" set="accessor"><x path="Int"/></length>
		<set_length set="method" line="24"><f a="length">
	<x path="Int"/>
	<x path="Int"/>
</f></set_length>
		<get public="1" get="inline" set="null" line="54"><f a="index">
	<x path="Int"/>
	<c path="ceramic.ReusableArray.T"/>
</f></get>
		<set public="1" get="inline" set="null" line="60"><f a="index:value">
	<x path="Int"/>
	<c path="ceramic.ReusableArray.T"/>
	<x path="Void"/>
</f></set>
		<new public="1" get="inline" set="null" line="18"><f a="length">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A reusable array to use in places that need a temporary array many times.
 * Changing array size only increases the backing array size but never decreases it.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Runner" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Runner.hx">
		<currentIsMainThread public="1" get="inline" set="null" line="43" static="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if current running thread is main thread
     * @return Bool</haxe_doc>
		</currentIsMainThread>
		<init public="1" set="method" line="57" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Call this on your thread to make primary,
     * the calling thread will be used for callbacks.</haxe_doc>
		</init>
		<tick public="1" set="method" line="68" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Call this on the primary manually,
     * Returns the number of callbacks called.</haxe_doc>
		</tick>
		<isEmulatingBackgroundWithMain public="1" get="inline" set="null" line="90" static="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if _running in background_ is emulated on this platform by
     * running _background_ code in main thread instead of using background thread.</haxe_doc>
		</isEmulatingBackgroundWithMain>
		<runInMain public="1" set="method" line="104" static="1">
			<f a="_fn">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Call a function on the primary thread without waiting or blocking.
     * If you want return values see runInMainBlocking</haxe_doc>
		</runInMain>
		<runInBackground public="1" set="method" line="117" static="1">
			<f a="fn">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a background thread using the given function, or just run (deferred) the function if threads are not supported</haxe_doc>
		</runInBackground>
		<haxe_doc>A simple Haxe class for easily running threads and calling functions on the primary thread.
from https://github.com/underscorediscovery/

Usage:
- call Runner.init() from your primary thread 
- call Runner.tick() periodically to service callbacks (i.e inside your main loop)
- use Runner.thread(function() { ... }) to make a thread
- use Runner.runInMainThread(function() { ... }) to run code on the main thread
- use runInMainThreadBlocking to run code on the main thread and wait for the return value</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.RuntimeAssets" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/RuntimeAssets.hx">
		<fromPath public="1" set="method" line="65" static="1"><f a="path">
	<c path="String"/>
	<c path="ceramic.RuntimeAssets"/>
</f></fromPath>
		<toAssetConstName set="method" line="253" static="1"><f a="input">
	<c path="String"/>
	<c path="String"/>
</f></toAssetConstName>
		<isAsciiChar set="method" line="365" static="1"><f a="c">
	<c path="String"/>
	<x path="Bool"/>
</f></isAsciiChar>
		<allAssets expr="null">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</allAssets>
		<allAssetDirs expr="null">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</allAssetDirs>
		<assetsByBaseName expr="null">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</assetsByBaseName>
		<assetDirsByBaseName expr="null">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</assetDirsByBaseName>
		<cachedNames expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><a>
	<paths><c path="Array"><c path="String"/></c></paths>
	<name><c path="String"/></name>
	<constName><c path="String"/></constName>
</a></c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</cachedNames>
		<cachedLists expr="null">
			<a>
				<allDirsByName><t path="Map">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</t></allDirsByName>
				<allDirs><c path="Array"><c path="String"/></c></allDirs>
				<allByName><t path="Map">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</t></allByName>
				<all><c path="Array"><c path="String"/></c></all>
			</a>
			<meta><m n=":value"><e>null</e></m></meta>
		</cachedLists>
		<path public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</path>
		<reset public="1" set="method" line="50"><f a="allAssets:?path">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></reset>
		<getNames public="1" set="method" line="81">
			<f a="kind:?extensions:?dir" v="::false">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<c path="Array"><a>
	<paths><c path="Array"><c path="String"/></c></paths>
	<name><c path="String"/></name>
	<constName><c path="String"/></constName>
</a></c>
			</f>
			<meta><m n=":value"><e>{ dir : false }</e></m></meta>
		</getNames>
		<getLists public="1" set="method" line="177"><f a=""><a>
	<allDirsByName><t path="Map">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</t></allDirsByName>
	<allDirs><c path="Array"><c path="String"/></c></allDirs>
	<allByName><t path="Map">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</t></allByName>
	<all><c path="Array"><c path="String"/></c></all>
</a></f></getLists>
		<getEncodableLists public="1" set="method" line="228">
			<f a=""><a>
	<allDirsByName><d><c path="Array"><c path="String"/></c></d></allDirsByName>
	<allDirs><c path="Array"><c path="String"/></c></allDirs>
	<allByName><d><c path="Array"><c path="String"/></c></d></allByName>
	<all><c path="Array"><c path="String"/></c></all>
</a></f>
			<haxe_doc>* Same as getLists(), but will transform Maps into JSON-encodable raw objects.</haxe_doc>
		</getEncodableLists>
		<initData set="method" line="299"><f a=""><x path="Void"/></f></initData>
		<new public="1" set="method" line="41"><f a="allAssets:?path">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Runtime utilities to compute asset lists/names from raw (relative) file list.
 * Code is very similar to AssetsMacro, but for runtime execution, with any list of asset.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="ceramic.ScanCode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScanCode.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._ScanCode.ScanCode_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScanCode.hx" private="1" module="ceramic.ScanCode" final="1">
	<name public="1" set="method" line="16" static="1">
		<f a="scanCode">
			<x path="ceramic.ScanCode"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Convert a scanCode to a readable name</haxe_doc>
	</name>
	<toString set="method" line="28" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<MASK public="1" expr="(1 &lt;&lt; 30)" line="35" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e><![CDATA[(1 << 30)]]></e></m></meta>
	</MASK>
	<UNKNOWN public="1" get="inline" set="null" expr="cast 0" line="37" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNKNOWN>
	<KEY_A public="1" get="inline" set="null" expr="cast 4" line="42" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_A>
	<KEY_B public="1" get="inline" set="null" expr="cast 5" line="43" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_B>
	<KEY_C public="1" get="inline" set="null" expr="cast 6" line="44" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_C>
	<KEY_D public="1" get="inline" set="null" expr="cast 7" line="45" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_D>
	<KEY_E public="1" get="inline" set="null" expr="cast 8" line="46" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_E>
	<KEY_F public="1" get="inline" set="null" expr="cast 9" line="47" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_F>
	<KEY_G public="1" get="inline" set="null" expr="cast 10" line="48" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_G>
	<KEY_H public="1" get="inline" set="null" expr="cast 11" line="49" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_H>
	<KEY_I public="1" get="inline" set="null" expr="cast 12" line="50" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_I>
	<KEY_J public="1" get="inline" set="null" expr="cast 13" line="51" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_J>
	<KEY_K public="1" get="inline" set="null" expr="cast 14" line="52" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_K>
	<KEY_L public="1" get="inline" set="null" expr="cast 15" line="53" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_L>
	<KEY_M public="1" get="inline" set="null" expr="cast 16" line="54" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_M>
	<KEY_N public="1" get="inline" set="null" expr="cast 17" line="55" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 17</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_N>
	<KEY_O public="1" get="inline" set="null" expr="cast 18" line="56" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 18</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_O>
	<KEY_P public="1" get="inline" set="null" expr="cast 19" line="57" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 19</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_P>
	<KEY_Q public="1" get="inline" set="null" expr="cast 20" line="58" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_Q>
	<KEY_R public="1" get="inline" set="null" expr="cast 21" line="59" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 21</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_R>
	<KEY_S public="1" get="inline" set="null" expr="cast 22" line="60" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 22</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_S>
	<KEY_T public="1" get="inline" set="null" expr="cast 23" line="61" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 23</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_T>
	<KEY_U public="1" get="inline" set="null" expr="cast 24" line="62" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 24</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_U>
	<KEY_V public="1" get="inline" set="null" expr="cast 25" line="63" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 25</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_V>
	<KEY_W public="1" get="inline" set="null" expr="cast 26" line="64" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 26</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_W>
	<KEY_X public="1" get="inline" set="null" expr="cast 27" line="65" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 27</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_X>
	<KEY_Y public="1" get="inline" set="null" expr="cast 28" line="66" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 28</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_Y>
	<KEY_Z public="1" get="inline" set="null" expr="cast 29" line="67" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 29</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_Z>
	<KEY_1 public="1" get="inline" set="null" expr="cast 30" line="69" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 30</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_1>
	<KEY_2 public="1" get="inline" set="null" expr="cast 31" line="70" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 31</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_2>
	<KEY_3 public="1" get="inline" set="null" expr="cast 32" line="71" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 32</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_3>
	<KEY_4 public="1" get="inline" set="null" expr="cast 33" line="72" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 33</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_4>
	<KEY_5 public="1" get="inline" set="null" expr="cast 34" line="73" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 34</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_5>
	<KEY_6 public="1" get="inline" set="null" expr="cast 35" line="74" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 35</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_6>
	<KEY_7 public="1" get="inline" set="null" expr="cast 36" line="75" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 36</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_7>
	<KEY_8 public="1" get="inline" set="null" expr="cast 37" line="76" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 37</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_8>
	<KEY_9 public="1" get="inline" set="null" expr="cast 38" line="77" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 38</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_9>
	<KEY_0 public="1" get="inline" set="null" expr="cast 39" line="78" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 39</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_0>
	<ENTER public="1" get="inline" set="null" expr="cast 40" line="80" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 40</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ENTER>
	<ESCAPE public="1" get="inline" set="null" expr="cast 41" line="81" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 41</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ESCAPE>
	<BACKSPACE public="1" get="inline" set="null" expr="cast 42" line="82" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 42</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BACKSPACE>
	<TAB public="1" get="inline" set="null" expr="cast 43" line="83" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 43</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TAB>
	<SPACE public="1" get="inline" set="null" expr="cast 44" line="84" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 44</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SPACE>
	<MINUS public="1" get="inline" set="null" expr="cast 45" line="86" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 45</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MINUS>
	<EQUALS public="1" get="inline" set="null" expr="cast 46" line="87" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 46</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EQUALS>
	<LEFTBRACKET public="1" get="inline" set="null" expr="cast 47" line="88" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 47</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFTBRACKET>
	<RIGHTBRACKET public="1" get="inline" set="null" expr="cast 48" line="89" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 48</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHTBRACKET>
	<BACKSLASH public="1" get="inline" set="null" expr="cast 49" line="105" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 49</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BACKSLASH>
	<NONUSHASH public="1" get="inline" set="null" expr="cast 50" line="119" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 50</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONUSHASH>
	<SEMICOLON public="1" get="inline" set="null" expr="cast 51" line="120" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 51</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SEMICOLON>
	<APOSTROPHE public="1" get="inline" set="null" expr="cast 52" line="121" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 52</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</APOSTROPHE>
	<GRAVE public="1" get="inline" set="null" expr="cast 53" line="140" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 53</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</GRAVE>
	<COMMA public="1" get="inline" set="null" expr="cast 54" line="141" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 54</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COMMA>
	<PERIOD public="1" get="inline" set="null" expr="cast 55" line="142" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 55</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PERIOD>
	<SLASH public="1" get="inline" set="null" expr="cast 56" line="143" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 56</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SLASH>
	<CAPSLOCK public="1" get="inline" set="null" expr="cast 57" line="145" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 57</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CAPSLOCK>
	<F1 public="1" get="inline" set="null" expr="cast 58" line="147" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 58</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F1>
	<F2 public="1" get="inline" set="null" expr="cast 59" line="148" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 59</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F2>
	<F3 public="1" get="inline" set="null" expr="cast 60" line="149" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 60</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F3>
	<F4 public="1" get="inline" set="null" expr="cast 61" line="150" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 61</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F4>
	<F5 public="1" get="inline" set="null" expr="cast 62" line="151" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 62</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F5>
	<F6 public="1" get="inline" set="null" expr="cast 63" line="152" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 63</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F6>
	<F7 public="1" get="inline" set="null" expr="cast 64" line="153" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 64</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F7>
	<F8 public="1" get="inline" set="null" expr="cast 65" line="154" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 65</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F8>
	<F9 public="1" get="inline" set="null" expr="cast 66" line="155" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 66</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F9>
	<F10 public="1" get="inline" set="null" expr="cast 67" line="156" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 67</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F10>
	<F11 public="1" get="inline" set="null" expr="cast 68" line="157" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 68</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F11>
	<F12 public="1" get="inline" set="null" expr="cast 69" line="158" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 69</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F12>
	<PRINTSCREEN public="1" get="inline" set="null" expr="cast 70" line="160" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 70</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PRINTSCREEN>
	<SCROLLLOCK public="1" get="inline" set="null" expr="cast 71" line="161" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 71</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCROLLLOCK>
	<PAUSE public="1" get="inline" set="null" expr="cast 72" line="162" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 72</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAUSE>
	<INSERT public="1" get="inline" set="null" expr="cast 73" line="165" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 73</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INSERT>
	<HOME public="1" get="inline" set="null" expr="cast 74" line="166" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 74</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HOME>
	<PAGEUP public="1" get="inline" set="null" expr="cast 75" line="167" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 75</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAGEUP>
	<DELETE public="1" get="inline" set="null" expr="cast 76" line="168" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 76</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DELETE>
	<END public="1" get="inline" set="null" expr="cast 77" line="169" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 77</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</END>
	<PAGEDOWN public="1" get="inline" set="null" expr="cast 78" line="170" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 78</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAGEDOWN>
	<RIGHT public="1" get="inline" set="null" expr="cast 79" line="171" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 79</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT>
	<LEFT public="1" get="inline" set="null" expr="cast 80" line="172" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 80</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT>
	<DOWN public="1" get="inline" set="null" expr="cast 81" line="173" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 81</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DOWN>
	<UP public="1" get="inline" set="null" expr="cast 82" line="174" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 82</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UP>
	<NUMLOCKCLEAR public="1" get="inline" set="null" expr="cast 83" line="177" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 83</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NUMLOCKCLEAR>
	<KP_DIVIDE public="1" get="inline" set="null" expr="cast 84" line="178" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 84</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DIVIDE>
	<KP_MULTIPLY public="1" get="inline" set="null" expr="cast 85" line="179" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 85</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MULTIPLY>
	<KP_MINUS public="1" get="inline" set="null" expr="cast 86" line="180" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 86</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MINUS>
	<KP_PLUS public="1" get="inline" set="null" expr="cast 87" line="181" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 87</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PLUS>
	<KP_ENTER public="1" get="inline" set="null" expr="cast 88" line="182" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 88</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_ENTER>
	<KP_1 public="1" get="inline" set="null" expr="cast 89" line="183" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 89</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_1>
	<KP_2 public="1" get="inline" set="null" expr="cast 90" line="184" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 90</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_2>
	<KP_3 public="1" get="inline" set="null" expr="cast 91" line="185" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 91</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_3>
	<KP_4 public="1" get="inline" set="null" expr="cast 92" line="186" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 92</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_4>
	<KP_5 public="1" get="inline" set="null" expr="cast 93" line="187" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 93</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_5>
	<KP_6 public="1" get="inline" set="null" expr="cast 94" line="188" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 94</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_6>
	<KP_7 public="1" get="inline" set="null" expr="cast 95" line="189" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 95</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_7>
	<KP_8 public="1" get="inline" set="null" expr="cast 96" line="190" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 96</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_8>
	<KP_9 public="1" get="inline" set="null" expr="cast 97" line="191" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 97</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_9>
	<KP_0 public="1" get="inline" set="null" expr="cast 98" line="192" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 98</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_0>
	<KP_PERIOD public="1" get="inline" set="null" expr="cast 99" line="193" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 99</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PERIOD>
	<NONUSBACKSLASH public="1" get="inline" set="null" expr="cast 100" line="206" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 100</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONUSBACKSLASH>
	<APPLICATION public="1" get="inline" set="null" expr="cast 101" line="209" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 101</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</APPLICATION>
	<POWER public="1" get="inline" set="null" expr="cast 102" line="214" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 102</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</POWER>
	<KP_EQUALS public="1" get="inline" set="null" expr="cast 103" line="215" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 103</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_EQUALS>
	<F13 public="1" get="inline" set="null" expr="cast 104" line="216" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 104</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F13>
	<F14 public="1" get="inline" set="null" expr="cast 105" line="217" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 105</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F14>
	<F15 public="1" get="inline" set="null" expr="cast 106" line="218" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 106</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F15>
	<F16 public="1" get="inline" set="null" expr="cast 107" line="219" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 107</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F16>
	<F17 public="1" get="inline" set="null" expr="cast 108" line="220" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 108</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F17>
	<F18 public="1" get="inline" set="null" expr="cast 109" line="221" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 109</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F18>
	<F19 public="1" get="inline" set="null" expr="cast 110" line="222" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 110</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F19>
	<F20 public="1" get="inline" set="null" expr="cast 111" line="223" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 111</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F20>
	<F21 public="1" get="inline" set="null" expr="cast 112" line="224" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 112</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F21>
	<F22 public="1" get="inline" set="null" expr="cast 113" line="225" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 113</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F22>
	<F23 public="1" get="inline" set="null" expr="cast 114" line="226" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 114</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F23>
	<F24 public="1" get="inline" set="null" expr="cast 115" line="227" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 115</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F24>
	<EXECUTE public="1" get="inline" set="null" expr="cast 116" line="228" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 116</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EXECUTE>
	<HELP public="1" get="inline" set="null" expr="cast 117" line="229" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 117</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HELP>
	<MENU public="1" get="inline" set="null" expr="cast 118" line="230" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 118</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MENU>
	<SELECT public="1" get="inline" set="null" expr="cast 119" line="231" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 119</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SELECT>
	<STOP public="1" get="inline" set="null" expr="cast 120" line="232" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 120</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</STOP>
	<AGAIN public="1" get="inline" set="null" expr="cast 121" line="235" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 121</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AGAIN>
	<UNDO public="1" get="inline" set="null" expr="cast 122" line="236" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 122</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNDO>
	<CUT public="1" get="inline" set="null" expr="cast 123" line="237" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 123</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CUT>
	<COPY public="1" get="inline" set="null" expr="cast 124" line="238" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 124</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COPY>
	<PASTE public="1" get="inline" set="null" expr="cast 125" line="239" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 125</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PASTE>
	<FIND public="1" get="inline" set="null" expr="cast 126" line="240" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 126</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</FIND>
	<MUTE public="1" get="inline" set="null" expr="cast 127" line="241" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 127</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MUTE>
	<VOLUMEUP public="1" get="inline" set="null" expr="cast 128" line="242" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 128</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VOLUMEUP>
	<VOLUMEDOWN public="1" get="inline" set="null" expr="cast 129" line="243" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 129</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VOLUMEDOWN>
	<KP_COMMA public="1" get="inline" set="null" expr="cast 133" line="250" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 133</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_COMMA>
	<KP_EQUALSAS400 public="1" get="inline" set="null" expr="cast 134" line="251" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 134</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_EQUALSAS400>
	<INTERNATIONAL1 public="1" get="inline" set="null" expr="cast 135" line="254" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 135</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL1>
	<INTERNATIONAL2 public="1" get="inline" set="null" expr="cast 136" line="255" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 136</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL2>
	<INTERNATIONAL3 public="1" get="inline" set="null" expr="cast 137" line="258" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 137</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL3>
	<INTERNATIONAL4 public="1" get="inline" set="null" expr="cast 138" line="259" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 138</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL4>
	<INTERNATIONAL5 public="1" get="inline" set="null" expr="cast 139" line="260" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 139</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL5>
	<INTERNATIONAL6 public="1" get="inline" set="null" expr="cast 140" line="261" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 140</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL6>
	<INTERNATIONAL7 public="1" get="inline" set="null" expr="cast 141" line="262" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 141</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL7>
	<INTERNATIONAL8 public="1" get="inline" set="null" expr="cast 142" line="263" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 142</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL8>
	<INTERNATIONAL9 public="1" get="inline" set="null" expr="cast 143" line="264" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 143</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL9>
	<LANG1 public="1" get="inline" set="null" expr="cast 144" line="266" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 144</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG1>
	<LANG2 public="1" get="inline" set="null" expr="cast 145" line="268" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 145</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG2>
	<LANG3 public="1" get="inline" set="null" expr="cast 146" line="270" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 146</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG3>
	<LANG4 public="1" get="inline" set="null" expr="cast 147" line="272" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 147</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG4>
	<LANG5 public="1" get="inline" set="null" expr="cast 148" line="274" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 148</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG5>
	<LANG6 public="1" get="inline" set="null" expr="cast 149" line="276" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 149</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG6>
	<LANG7 public="1" get="inline" set="null" expr="cast 150" line="278" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 150</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG7>
	<LANG8 public="1" get="inline" set="null" expr="cast 151" line="280" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 151</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG8>
	<LANG9 public="1" get="inline" set="null" expr="cast 152" line="282" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 152</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG9>
	<ALTERASE public="1" get="inline" set="null" expr="cast 153" line="284" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 153</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ALTERASE>
	<SYSREQ public="1" get="inline" set="null" expr="cast 154" line="285" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 154</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SYSREQ>
	<CANCEL public="1" get="inline" set="null" expr="cast 155" line="286" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 155</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CANCEL>
	<CLEAR public="1" get="inline" set="null" expr="cast 156" line="287" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 156</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CLEAR>
	<PRIOR public="1" get="inline" set="null" expr="cast 157" line="288" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 157</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PRIOR>
	<RETURN2 public="1" get="inline" set="null" expr="cast 158" line="289" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 158</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RETURN2>
	<SEPARATOR public="1" get="inline" set="null" expr="cast 159" line="290" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 159</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SEPARATOR>
	<OUT public="1" get="inline" set="null" expr="cast 160" line="291" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 160</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OUT>
	<OPER public="1" get="inline" set="null" expr="cast 161" line="292" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 161</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OPER>
	<CLEARAGAIN public="1" get="inline" set="null" expr="cast 162" line="293" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 162</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CLEARAGAIN>
	<CRSEL public="1" get="inline" set="null" expr="cast 163" line="294" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 163</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CRSEL>
	<EXSEL public="1" get="inline" set="null" expr="cast 164" line="295" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 164</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EXSEL>
	<KP_00 public="1" get="inline" set="null" expr="cast 176" line="297" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 176</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_00>
	<KP_000 public="1" get="inline" set="null" expr="cast 177" line="298" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 177</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_000>
	<THOUSANDSSEPARATOR public="1" get="inline" set="null" expr="cast 178" line="299" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 178</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</THOUSANDSSEPARATOR>
	<DECIMALSEPARATOR public="1" get="inline" set="null" expr="cast 179" line="300" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 179</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DECIMALSEPARATOR>
	<CURRENCYUNIT public="1" get="inline" set="null" expr="cast 180" line="301" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 180</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CURRENCYUNIT>
	<CURRENCYSUBUNIT public="1" get="inline" set="null" expr="cast 181" line="302" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 181</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CURRENCYSUBUNIT>
	<KP_LEFTPAREN public="1" get="inline" set="null" expr="cast 182" line="303" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 182</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_LEFTPAREN>
	<KP_RIGHTPAREN public="1" get="inline" set="null" expr="cast 183" line="304" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 183</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_RIGHTPAREN>
	<KP_LEFTBRACE public="1" get="inline" set="null" expr="cast 184" line="305" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 184</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_LEFTBRACE>
	<KP_RIGHTBRACE public="1" get="inline" set="null" expr="cast 185" line="306" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 185</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_RIGHTBRACE>
	<KP_TAB public="1" get="inline" set="null" expr="cast 186" line="307" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 186</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_TAB>
	<KP_BACKSPACE public="1" get="inline" set="null" expr="cast 187" line="308" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 187</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_BACKSPACE>
	<KP_A public="1" get="inline" set="null" expr="cast 188" line="309" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 188</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_A>
	<KP_B public="1" get="inline" set="null" expr="cast 189" line="310" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 189</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_B>
	<KP_C public="1" get="inline" set="null" expr="cast 190" line="311" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 190</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_C>
	<KP_D public="1" get="inline" set="null" expr="cast 191" line="312" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 191</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_D>
	<KP_E public="1" get="inline" set="null" expr="cast 192" line="313" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 192</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_E>
	<KP_F public="1" get="inline" set="null" expr="cast 193" line="314" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 193</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_F>
	<KP_XOR public="1" get="inline" set="null" expr="cast 194" line="315" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 194</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_XOR>
	<KP_POWER public="1" get="inline" set="null" expr="cast 195" line="316" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 195</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_POWER>
	<KP_PERCENT public="1" get="inline" set="null" expr="cast 196" line="317" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 196</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PERCENT>
	<KP_LESS public="1" get="inline" set="null" expr="cast 197" line="318" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 197</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_LESS>
	<KP_GREATER public="1" get="inline" set="null" expr="cast 198" line="319" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 198</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_GREATER>
	<KP_AMPERSAND public="1" get="inline" set="null" expr="cast 199" line="320" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 199</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_AMPERSAND>
	<KP_DBLAMPERSAND public="1" get="inline" set="null" expr="cast 200" line="321" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 200</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DBLAMPERSAND>
	<KP_VERTICALBAR public="1" get="inline" set="null" expr="cast 201" line="322" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 201</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_VERTICALBAR>
	<KP_DBLVERTICALBAR public="1" get="inline" set="null" expr="cast 202" line="323" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 202</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DBLVERTICALBAR>
	<KP_COLON public="1" get="inline" set="null" expr="cast 203" line="324" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 203</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_COLON>
	<KP_HASH public="1" get="inline" set="null" expr="cast 204" line="325" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 204</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_HASH>
	<KP_SPACE public="1" get="inline" set="null" expr="cast 205" line="326" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 205</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_SPACE>
	<KP_AT public="1" get="inline" set="null" expr="cast 206" line="327" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 206</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_AT>
	<KP_EXCLAM public="1" get="inline" set="null" expr="cast 207" line="328" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 207</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_EXCLAM>
	<KP_MEMSTORE public="1" get="inline" set="null" expr="cast 208" line="329" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 208</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMSTORE>
	<KP_MEMRECALL public="1" get="inline" set="null" expr="cast 209" line="330" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 209</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMRECALL>
	<KP_MEMCLEAR public="1" get="inline" set="null" expr="cast 210" line="331" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 210</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMCLEAR>
	<KP_MEMADD public="1" get="inline" set="null" expr="cast 211" line="332" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 211</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMADD>
	<KP_MEMSUBTRACT public="1" get="inline" set="null" expr="cast 212" line="333" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 212</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMSUBTRACT>
	<KP_MEMMULTIPLY public="1" get="inline" set="null" expr="cast 213" line="334" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 213</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMMULTIPLY>
	<KP_MEMDIVIDE public="1" get="inline" set="null" expr="cast 214" line="335" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 214</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMDIVIDE>
	<KP_PLUSMINUS public="1" get="inline" set="null" expr="cast 215" line="336" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 215</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PLUSMINUS>
	<KP_CLEAR public="1" get="inline" set="null" expr="cast 216" line="337" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 216</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_CLEAR>
	<KP_CLEARENTRY public="1" get="inline" set="null" expr="cast 217" line="338" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 217</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_CLEARENTRY>
	<KP_BINARY public="1" get="inline" set="null" expr="cast 218" line="339" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 218</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_BINARY>
	<KP_OCTAL public="1" get="inline" set="null" expr="cast 219" line="340" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 219</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_OCTAL>
	<KP_DECIMAL public="1" get="inline" set="null" expr="cast 220" line="341" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 220</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DECIMAL>
	<KP_HEXADECIMAL public="1" get="inline" set="null" expr="cast 221" line="342" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 221</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_HEXADECIMAL>
	<LCTRL public="1" get="inline" set="null" expr="cast 224" line="344" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 224</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LCTRL>
	<LSHIFT public="1" get="inline" set="null" expr="cast 225" line="345" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 225</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LSHIFT>
	<LALT public="1" get="inline" set="null" expr="cast 226" line="347" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 226</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LALT>
	<LMETA public="1" get="inline" set="null" expr="cast 227" line="349" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 227</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LMETA>
	<RCTRL public="1" get="inline" set="null" expr="cast 228" line="350" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 228</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RCTRL>
	<RSHIFT public="1" get="inline" set="null" expr="cast 229" line="351" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 229</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RSHIFT>
	<RALT public="1" get="inline" set="null" expr="cast 230" line="353" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 230</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RALT>
	<RMETA public="1" get="inline" set="null" expr="cast 231" line="355" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 231</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RMETA>
	<MODE public="1" get="inline" set="null" expr="cast 257" line="360" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 257</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MODE>
	<AUDIONEXT public="1" get="inline" set="null" expr="cast 258" line="366" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 258</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIONEXT>
	<AUDIOPREV public="1" get="inline" set="null" expr="cast 259" line="367" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 259</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOPREV>
	<AUDIOSTOP public="1" get="inline" set="null" expr="cast 260" line="368" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 260</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOSTOP>
	<AUDIOPLAY public="1" get="inline" set="null" expr="cast 261" line="369" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 261</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOPLAY>
	<AUDIOMUTE public="1" get="inline" set="null" expr="cast 262" line="370" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 262</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOMUTE>
	<MEDIASELECT public="1" get="inline" set="null" expr="cast 263" line="371" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 263</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MEDIASELECT>
	<WWW public="1" get="inline" set="null" expr="cast 264" line="372" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 264</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WWW>
	<MAIL public="1" get="inline" set="null" expr="cast 265" line="373" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 265</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MAIL>
	<CALCULATOR public="1" get="inline" set="null" expr="cast 266" line="374" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 266</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CALCULATOR>
	<COMPUTER public="1" get="inline" set="null" expr="cast 267" line="375" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 267</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COMPUTER>
	<AC_SEARCH public="1" get="inline" set="null" expr="cast 268" line="376" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 268</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_SEARCH>
	<AC_HOME public="1" get="inline" set="null" expr="cast 269" line="377" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 269</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_HOME>
	<AC_BACK public="1" get="inline" set="null" expr="cast 270" line="378" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 270</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_BACK>
	<AC_FORWARD public="1" get="inline" set="null" expr="cast 271" line="379" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 271</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_FORWARD>
	<AC_STOP public="1" get="inline" set="null" expr="cast 272" line="380" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 272</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_STOP>
	<AC_REFRESH public="1" get="inline" set="null" expr="cast 273" line="381" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 273</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_REFRESH>
	<AC_BOOKMARKS public="1" get="inline" set="null" expr="cast 274" line="382" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 274</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_BOOKMARKS>
	<BRIGHTNESSDOWN public="1" get="inline" set="null" expr="cast 275" line="387" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 275</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BRIGHTNESSDOWN>
	<BRIGHTNESSUP public="1" get="inline" set="null" expr="cast 276" line="388" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 276</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BRIGHTNESSUP>
	<DISPLAYSWITCH public="1" get="inline" set="null" expr="cast 277" line="391" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 277</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DISPLAYSWITCH>
	<KBDILLUMTOGGLE public="1" get="inline" set="null" expr="cast 278" line="393" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 278</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KBDILLUMTOGGLE>
	<KBDILLUMDOWN public="1" get="inline" set="null" expr="cast 279" line="394" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 279</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KBDILLUMDOWN>
	<KBDILLUMUP public="1" get="inline" set="null" expr="cast 280" line="395" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 280</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KBDILLUMUP>
	<EJECT public="1" get="inline" set="null" expr="cast 281" line="396" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 281</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EJECT>
	<SLEEP public="1" get="inline" set="null" expr="cast 282" line="397" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 282</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SLEEP>
	<APP1 public="1" get="inline" set="null" expr="cast 283" line="399" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 283</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</APP1>
	<APP2 public="1" get="inline" set="null" expr="cast 284" line="400" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 284</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</APP2>
	<scanCodeNames expr="[null, null, null, null, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;0&quot;, &quot;Enter&quot;, &quot;Escape&quot;, &quot;Backspace&quot;, &quot;Tab&quot;, &quot;Space&quot;, &quot;-&quot;, &quot;=&quot;, &quot;[&quot;, &quot;]&quot;, &quot;\\&quot;, &quot;#&quot;, &quot;;&quot;, &quot;&apos;&quot;, &quot;`&quot;, &quot;,&quot;, &quot;.&quot;, &quot;/&quot;, &quot;CapsLock&quot;, &quot;F1&quot;, &quot;F2&quot;, &quot;F3&quot;, &quot;F4&quot;, &quot;F5&quot;, &quot;F6&quot;, &quot;F7&quot;, &quot;F8&quot;, &quot;F9&quot;, &quot;F10&quot;, &quot;F11&quot;, &quot;F12&quot;, &quot;PrintScreen&quot;, &quot;ScrollLock&quot;, &quot;Pause&quot;, &quot;Insert&quot;, &quot;Home&quot;, &quot;PageUp&quot;, &quot;Delete&quot;, &quot;End&quot;, &quot;PageDown&quot;, &quot;Right&quot;, &quot;Left&quot;, &quot;Down&quot;, &quot;Up&quot;, &quot;Numlock&quot;, &quot;Keypad /&quot;, &quot;Keypad *&quot;, &quot;Keypad -&quot;, &quot;Keypad +&quot;, &quot;Keypad Enter&quot;, &quot;Keypad 1&quot;, &quot;Keypad 2&quot;, &quot;Keypad 3&quot;, &quot;Keypad 4&quot;, &quot;Keypad 5&quot;, &quot;Keypad 6&quot;, &quot;Keypad 7&quot;, &quot;Keypad 8&quot;, &quot;Keypad 9&quot;, &quot;Keypad 0&quot;, &quot;Keypad .&quot;, null, &quot;Application&quot;, &quot;Power&quot;, &quot;Keypad =&quot;, &quot;F13&quot;, &quot;F14&quot;, &quot;F15&quot;, &quot;F16&quot;, &quot;F17&quot;, &quot;F18&quot;, &quot;F19&quot;, &quot;F20&quot;, &quot;F21&quot;, &quot;F22&quot;, &quot;F23&quot;, &quot;F24&quot;, &quot;Execute&quot;, &quot;Help&quot;, &quot;Menu&quot;, &quot;Select&quot;, &quot;Stop&quot;, &quot;Again&quot;, &quot;Undo&quot;, &quot;Cut&quot;, &quot;Copy&quot;, &quot;Paste&quot;, &quot;Find&quot;, &quot;Mute&quot;, &quot;VolumeUp&quot;, &quot;VolumeDown&quot;, null, null, null, &quot;Keypad ,&quot;, &quot;Keypad = (AS400)&quot;, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;AltErase&quot;, &quot;SysReq&quot;, &quot;Cancel&quot;, &quot;Clear&quot;, &quot;Prior&quot;, &quot;Enter&quot;, &quot;Separator&quot;, &quot;Out&quot;, &quot;Oper&quot;, &quot;Clear / Again&quot;, &quot;CrSel&quot;, &quot;ExSel&quot;, null, null, null, null, null, null, null, null, null, null, null, &quot;Keypad 00&quot;, &quot;Keypad 000&quot;, &quot;ThousandsSeparator&quot;, &quot;DecimalSeparator&quot;, &quot;CurrencyUnit&quot;, &quot;CurrencySubUnit&quot;, &quot;Keypad (&quot;, &quot;Keypad )&quot;, &quot;Keypad {&quot;, &quot;Keypad }&quot;, &quot;Keypad Tab&quot;, &quot;Keypad Backspace&quot;, &quot;Keypad A&quot;, &quot;Keypad B&quot;, &quot;Keypad C&quot;, &quot;Keypad D&quot;, &quot;Keypad E&quot;, &quot;Keypad F&quot;, &quot;Keypad XOR&quot;, &quot;Keypad ^&quot;, &quot;Keypad %&quot;, &quot;Keypad &lt;&quot;, &quot;Keypad &gt;&quot;, &quot;Keypad &amp;&quot;, &quot;Keypad &amp;&amp;&quot;, &quot;Keypad |&quot;, &quot;Keypad ||&quot;, &quot;Keypad :&quot;, &quot;Keypad #&quot;, &quot;Keypad Space&quot;, &quot;Keypad @&quot;, &quot;Keypad !&quot;, &quot;Keypad MemStore&quot;, &quot;Keypad MemRecall&quot;, &quot;Keypad MemClear&quot;, &quot;Keypad MemAdd&quot;, &quot;Keypad MemSubtract&quot;, &quot;Keypad MemMultiply&quot;, &quot;Keypad MemDivide&quot;, &quot;Keypad +/-&quot;, &quot;Keypad Clear&quot;, &quot;Keypad ClearEntry&quot;, &quot;Keypad Binary&quot;, &quot;Keypad Octal&quot;, &quot;Keypad Decimal&quot;, &quot;Keypad Hexadecimal&quot;, null, null, &quot;Left Ctrl&quot;, &quot;Left Shift&quot;, &quot;Left Alt&quot;, &quot;Left Meta&quot;, &quot;Right Ctrl&quot;, &quot;Right Shift&quot;, &quot;Right Alt&quot;, &quot;Right Meta&quot;, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;ModeSwitch&quot;, &quot;AudioNext&quot;, &quot;AudioPrev&quot;, &quot;AudioStop&quot;, &quot;AudioPlay&quot;, &quot;AudioMute&quot;, &quot;MediaSelect&quot;, &quot;WWW&quot;, &quot;Mail&quot;, &quot;Calculator&quot;, &quot;Computer&quot;, &quot;AC Search&quot;, &quot;AC Home&quot;, &quot;AC Back&quot;, &quot;AC Forward&quot;, &quot;AC Stop&quot;, &quot;AC Refresh&quot;, &quot;AC Bookmarks&quot;, &quot;BrightnessDown&quot;, &quot;BrightnessUp&quot;, &quot;DisplaySwitch&quot;, &quot;KBDIllumToggle&quot;, &quot;KBDIllumDown&quot;, &quot;KBDIllumUp&quot;, &quot;Eject&quot;, &quot;Sleep&quot;]" line="402" static="1">
		<c path="Array"><c path="String"/></c>
		<meta><m n=":value"><e><![CDATA[[null, null, null, null, "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "Enter", "Escape", "Backspace", "Tab", "Space", "-", "=", "[", "]", "\\", "#", ";", "'", "`", ",", ".", "/", "CapsLock", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "PrintScreen", "ScrollLock", "Pause", "Insert", "Home", "PageUp", "Delete", "End", "PageDown", "Right", "Left", "Down", "Up", "Numlock", "Keypad /", "Keypad *", "Keypad -", "Keypad +", "Keypad Enter", "Keypad 1", "Keypad 2", "Keypad 3", "Keypad 4", "Keypad 5", "Keypad 6", "Keypad 7", "Keypad 8", "Keypad 9", "Keypad 0", "Keypad .", null, "Application", "Power", "Keypad =", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "Execute", "Help", "Menu", "Select", "Stop", "Again", "Undo", "Cut", "Copy", "Paste", "Find", "Mute", "VolumeUp", "VolumeDown", null, null, null, "Keypad ,", "Keypad = (AS400)", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "AltErase", "SysReq", "Cancel", "Clear", "Prior", "Enter", "Separator", "Out", "Oper", "Clear / Again", "CrSel", "ExSel", null, null, null, null, null, null, null, null, null, null, null, "Keypad 00", "Keypad 000", "ThousandsSeparator", "DecimalSeparator", "CurrencyUnit", "CurrencySubUnit", "Keypad (", "Keypad )", "Keypad {", "Keypad }", "Keypad Tab", "Keypad Backspace", "Keypad A", "Keypad B", "Keypad C", "Keypad D", "Keypad E", "Keypad F", "Keypad XOR", "Keypad ^", "Keypad %", "Keypad <", "Keypad >", "Keypad &", "Keypad &&", "Keypad |", "Keypad ||", "Keypad :", "Keypad #", "Keypad Space", "Keypad @", "Keypad !", "Keypad MemStore", "Keypad MemRecall", "Keypad MemClear", "Keypad MemAdd", "Keypad MemSubtract", "Keypad MemMultiply", "Keypad MemDivide", "Keypad +/-", "Keypad Clear", "Keypad ClearEntry", "Keypad Binary", "Keypad Octal", "Keypad Decimal", "Keypad Hexadecimal", null, null, "Left Ctrl", "Left Shift", "Left Alt", "Left Meta", "Right Ctrl", "Right Shift", "Right Alt", "Right Meta", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "ModeSwitch", "AudioNext", "AudioPrev", "AudioStop", "AudioPlay", "AudioMute", "MediaSelect", "WWW", "Mail", "Calculator", "Computer", "AC Search", "AC Home", "AC Back", "AC Forward", "AC Stop", "AC Refresh", "AC Bookmarks", "BrightnessDown", "BrightnessUp", "DisplaySwitch", "KBDIllumToggle", "KBDIllumDown", "KBDIllumUp", "Eject", "Sleep"]]]></e></m></meta>
	</scanCodeNames>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._ScanCode.ScanCode_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScanCode.hx" private="1" module="ceramic.ScanCode" final="1">
		<name public="1" set="method" line="16" static="1">
			<f a="scanCode">
				<x path="ceramic.ScanCode"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Convert a scanCode to a readable name</haxe_doc>
		</name>
		<toString set="method" line="28" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<MASK public="1" expr="(1 &lt;&lt; 30)" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e><![CDATA[(1 << 30)]]></e></m></meta>
		</MASK>
		<UNKNOWN public="1" get="inline" set="null" expr="cast 0" line="37" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNKNOWN>
		<KEY_A public="1" get="inline" set="null" expr="cast 4" line="42" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_A>
		<KEY_B public="1" get="inline" set="null" expr="cast 5" line="43" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_B>
		<KEY_C public="1" get="inline" set="null" expr="cast 6" line="44" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_C>
		<KEY_D public="1" get="inline" set="null" expr="cast 7" line="45" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_D>
		<KEY_E public="1" get="inline" set="null" expr="cast 8" line="46" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_E>
		<KEY_F public="1" get="inline" set="null" expr="cast 9" line="47" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_F>
		<KEY_G public="1" get="inline" set="null" expr="cast 10" line="48" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_G>
		<KEY_H public="1" get="inline" set="null" expr="cast 11" line="49" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_H>
		<KEY_I public="1" get="inline" set="null" expr="cast 12" line="50" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_I>
		<KEY_J public="1" get="inline" set="null" expr="cast 13" line="51" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_J>
		<KEY_K public="1" get="inline" set="null" expr="cast 14" line="52" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_K>
		<KEY_L public="1" get="inline" set="null" expr="cast 15" line="53" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_L>
		<KEY_M public="1" get="inline" set="null" expr="cast 16" line="54" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_M>
		<KEY_N public="1" get="inline" set="null" expr="cast 17" line="55" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 17</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_N>
		<KEY_O public="1" get="inline" set="null" expr="cast 18" line="56" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 18</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_O>
		<KEY_P public="1" get="inline" set="null" expr="cast 19" line="57" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 19</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_P>
		<KEY_Q public="1" get="inline" set="null" expr="cast 20" line="58" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_Q>
		<KEY_R public="1" get="inline" set="null" expr="cast 21" line="59" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 21</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_R>
		<KEY_S public="1" get="inline" set="null" expr="cast 22" line="60" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 22</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_S>
		<KEY_T public="1" get="inline" set="null" expr="cast 23" line="61" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 23</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_T>
		<KEY_U public="1" get="inline" set="null" expr="cast 24" line="62" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 24</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_U>
		<KEY_V public="1" get="inline" set="null" expr="cast 25" line="63" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 25</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_V>
		<KEY_W public="1" get="inline" set="null" expr="cast 26" line="64" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 26</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_W>
		<KEY_X public="1" get="inline" set="null" expr="cast 27" line="65" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 27</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_X>
		<KEY_Y public="1" get="inline" set="null" expr="cast 28" line="66" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 28</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_Y>
		<KEY_Z public="1" get="inline" set="null" expr="cast 29" line="67" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 29</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_Z>
		<KEY_1 public="1" get="inline" set="null" expr="cast 30" line="69" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 30</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_1>
		<KEY_2 public="1" get="inline" set="null" expr="cast 31" line="70" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 31</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_2>
		<KEY_3 public="1" get="inline" set="null" expr="cast 32" line="71" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 32</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_3>
		<KEY_4 public="1" get="inline" set="null" expr="cast 33" line="72" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 33</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_4>
		<KEY_5 public="1" get="inline" set="null" expr="cast 34" line="73" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 34</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_5>
		<KEY_6 public="1" get="inline" set="null" expr="cast 35" line="74" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 35</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_6>
		<KEY_7 public="1" get="inline" set="null" expr="cast 36" line="75" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 36</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_7>
		<KEY_8 public="1" get="inline" set="null" expr="cast 37" line="76" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 37</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_8>
		<KEY_9 public="1" get="inline" set="null" expr="cast 38" line="77" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 38</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_9>
		<KEY_0 public="1" get="inline" set="null" expr="cast 39" line="78" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 39</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_0>
		<ENTER public="1" get="inline" set="null" expr="cast 40" line="80" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 40</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ENTER>
		<ESCAPE public="1" get="inline" set="null" expr="cast 41" line="81" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 41</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ESCAPE>
		<BACKSPACE public="1" get="inline" set="null" expr="cast 42" line="82" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 42</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BACKSPACE>
		<TAB public="1" get="inline" set="null" expr="cast 43" line="83" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 43</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TAB>
		<SPACE public="1" get="inline" set="null" expr="cast 44" line="84" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 44</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SPACE>
		<MINUS public="1" get="inline" set="null" expr="cast 45" line="86" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 45</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MINUS>
		<EQUALS public="1" get="inline" set="null" expr="cast 46" line="87" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 46</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EQUALS>
		<LEFTBRACKET public="1" get="inline" set="null" expr="cast 47" line="88" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 47</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFTBRACKET>
		<RIGHTBRACKET public="1" get="inline" set="null" expr="cast 48" line="89" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 48</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHTBRACKET>
		<BACKSLASH public="1" get="inline" set="null" expr="cast 49" line="105" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 49</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BACKSLASH>
		<NONUSHASH public="1" get="inline" set="null" expr="cast 50" line="119" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 50</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONUSHASH>
		<SEMICOLON public="1" get="inline" set="null" expr="cast 51" line="120" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 51</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SEMICOLON>
		<APOSTROPHE public="1" get="inline" set="null" expr="cast 52" line="121" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 52</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</APOSTROPHE>
		<GRAVE public="1" get="inline" set="null" expr="cast 53" line="140" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 53</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</GRAVE>
		<COMMA public="1" get="inline" set="null" expr="cast 54" line="141" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 54</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COMMA>
		<PERIOD public="1" get="inline" set="null" expr="cast 55" line="142" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 55</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" expr="cast 56" line="143" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 56</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SLASH>
		<CAPSLOCK public="1" get="inline" set="null" expr="cast 57" line="145" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 57</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CAPSLOCK>
		<F1 public="1" get="inline" set="null" expr="cast 58" line="147" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 58</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="cast 59" line="148" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 59</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="cast 60" line="149" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 60</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="cast 61" line="150" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 61</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="cast 62" line="151" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 62</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="cast 63" line="152" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 63</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="cast 64" line="153" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 64</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="cast 65" line="154" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 65</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="cast 66" line="155" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 66</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="cast 67" line="156" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 67</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="cast 68" line="157" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 68</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="cast 69" line="158" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 69</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F12>
		<PRINTSCREEN public="1" get="inline" set="null" expr="cast 70" line="160" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 70</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PRINTSCREEN>
		<SCROLLLOCK public="1" get="inline" set="null" expr="cast 71" line="161" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 71</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCROLLLOCK>
		<PAUSE public="1" get="inline" set="null" expr="cast 72" line="162" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 72</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAUSE>
		<INSERT public="1" get="inline" set="null" expr="cast 73" line="165" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 73</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INSERT>
		<HOME public="1" get="inline" set="null" expr="cast 74" line="166" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 74</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HOME>
		<PAGEUP public="1" get="inline" set="null" expr="cast 75" line="167" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 75</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAGEUP>
		<DELETE public="1" get="inline" set="null" expr="cast 76" line="168" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 76</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DELETE>
		<END public="1" get="inline" set="null" expr="cast 77" line="169" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 77</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</END>
		<PAGEDOWN public="1" get="inline" set="null" expr="cast 78" line="170" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 78</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAGEDOWN>
		<RIGHT public="1" get="inline" set="null" expr="cast 79" line="171" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 79</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT>
		<LEFT public="1" get="inline" set="null" expr="cast 80" line="172" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 80</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT>
		<DOWN public="1" get="inline" set="null" expr="cast 81" line="173" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 81</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DOWN>
		<UP public="1" get="inline" set="null" expr="cast 82" line="174" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 82</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UP>
		<NUMLOCKCLEAR public="1" get="inline" set="null" expr="cast 83" line="177" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 83</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NUMLOCKCLEAR>
		<KP_DIVIDE public="1" get="inline" set="null" expr="cast 84" line="178" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 84</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DIVIDE>
		<KP_MULTIPLY public="1" get="inline" set="null" expr="cast 85" line="179" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 85</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MULTIPLY>
		<KP_MINUS public="1" get="inline" set="null" expr="cast 86" line="180" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 86</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MINUS>
		<KP_PLUS public="1" get="inline" set="null" expr="cast 87" line="181" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 87</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PLUS>
		<KP_ENTER public="1" get="inline" set="null" expr="cast 88" line="182" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 88</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_ENTER>
		<KP_1 public="1" get="inline" set="null" expr="cast 89" line="183" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 89</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_1>
		<KP_2 public="1" get="inline" set="null" expr="cast 90" line="184" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 90</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_2>
		<KP_3 public="1" get="inline" set="null" expr="cast 91" line="185" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 91</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_3>
		<KP_4 public="1" get="inline" set="null" expr="cast 92" line="186" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 92</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_4>
		<KP_5 public="1" get="inline" set="null" expr="cast 93" line="187" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 93</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_5>
		<KP_6 public="1" get="inline" set="null" expr="cast 94" line="188" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 94</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_6>
		<KP_7 public="1" get="inline" set="null" expr="cast 95" line="189" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 95</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_7>
		<KP_8 public="1" get="inline" set="null" expr="cast 96" line="190" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 96</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_8>
		<KP_9 public="1" get="inline" set="null" expr="cast 97" line="191" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 97</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_9>
		<KP_0 public="1" get="inline" set="null" expr="cast 98" line="192" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 98</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_0>
		<KP_PERIOD public="1" get="inline" set="null" expr="cast 99" line="193" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 99</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PERIOD>
		<NONUSBACKSLASH public="1" get="inline" set="null" expr="cast 100" line="206" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 100</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONUSBACKSLASH>
		<APPLICATION public="1" get="inline" set="null" expr="cast 101" line="209" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 101</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</APPLICATION>
		<POWER public="1" get="inline" set="null" expr="cast 102" line="214" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 102</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</POWER>
		<KP_EQUALS public="1" get="inline" set="null" expr="cast 103" line="215" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 103</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_EQUALS>
		<F13 public="1" get="inline" set="null" expr="cast 104" line="216" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 104</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F13>
		<F14 public="1" get="inline" set="null" expr="cast 105" line="217" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 105</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F14>
		<F15 public="1" get="inline" set="null" expr="cast 106" line="218" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 106</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F15>
		<F16 public="1" get="inline" set="null" expr="cast 107" line="219" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 107</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F16>
		<F17 public="1" get="inline" set="null" expr="cast 108" line="220" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 108</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F17>
		<F18 public="1" get="inline" set="null" expr="cast 109" line="221" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 109</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F18>
		<F19 public="1" get="inline" set="null" expr="cast 110" line="222" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 110</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F19>
		<F20 public="1" get="inline" set="null" expr="cast 111" line="223" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 111</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F20>
		<F21 public="1" get="inline" set="null" expr="cast 112" line="224" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 112</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F21>
		<F22 public="1" get="inline" set="null" expr="cast 113" line="225" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 113</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F22>
		<F23 public="1" get="inline" set="null" expr="cast 114" line="226" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 114</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F23>
		<F24 public="1" get="inline" set="null" expr="cast 115" line="227" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 115</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F24>
		<EXECUTE public="1" get="inline" set="null" expr="cast 116" line="228" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 116</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EXECUTE>
		<HELP public="1" get="inline" set="null" expr="cast 117" line="229" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 117</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HELP>
		<MENU public="1" get="inline" set="null" expr="cast 118" line="230" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 118</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MENU>
		<SELECT public="1" get="inline" set="null" expr="cast 119" line="231" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 119</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SELECT>
		<STOP public="1" get="inline" set="null" expr="cast 120" line="232" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 120</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</STOP>
		<AGAIN public="1" get="inline" set="null" expr="cast 121" line="235" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 121</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AGAIN>
		<UNDO public="1" get="inline" set="null" expr="cast 122" line="236" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 122</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNDO>
		<CUT public="1" get="inline" set="null" expr="cast 123" line="237" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 123</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CUT>
		<COPY public="1" get="inline" set="null" expr="cast 124" line="238" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 124</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COPY>
		<PASTE public="1" get="inline" set="null" expr="cast 125" line="239" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 125</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PASTE>
		<FIND public="1" get="inline" set="null" expr="cast 126" line="240" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 126</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</FIND>
		<MUTE public="1" get="inline" set="null" expr="cast 127" line="241" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 127</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MUTE>
		<VOLUMEUP public="1" get="inline" set="null" expr="cast 128" line="242" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 128</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VOLUMEUP>
		<VOLUMEDOWN public="1" get="inline" set="null" expr="cast 129" line="243" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 129</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VOLUMEDOWN>
		<KP_COMMA public="1" get="inline" set="null" expr="cast 133" line="250" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 133</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_COMMA>
		<KP_EQUALSAS400 public="1" get="inline" set="null" expr="cast 134" line="251" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 134</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_EQUALSAS400>
		<INTERNATIONAL1 public="1" get="inline" set="null" expr="cast 135" line="254" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 135</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL1>
		<INTERNATIONAL2 public="1" get="inline" set="null" expr="cast 136" line="255" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 136</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL2>
		<INTERNATIONAL3 public="1" get="inline" set="null" expr="cast 137" line="258" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 137</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL3>
		<INTERNATIONAL4 public="1" get="inline" set="null" expr="cast 138" line="259" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 138</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL4>
		<INTERNATIONAL5 public="1" get="inline" set="null" expr="cast 139" line="260" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 139</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL5>
		<INTERNATIONAL6 public="1" get="inline" set="null" expr="cast 140" line="261" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 140</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL6>
		<INTERNATIONAL7 public="1" get="inline" set="null" expr="cast 141" line="262" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 141</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL7>
		<INTERNATIONAL8 public="1" get="inline" set="null" expr="cast 142" line="263" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 142</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL8>
		<INTERNATIONAL9 public="1" get="inline" set="null" expr="cast 143" line="264" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 143</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL9>
		<LANG1 public="1" get="inline" set="null" expr="cast 144" line="266" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 144</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG1>
		<LANG2 public="1" get="inline" set="null" expr="cast 145" line="268" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 145</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG2>
		<LANG3 public="1" get="inline" set="null" expr="cast 146" line="270" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 146</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG3>
		<LANG4 public="1" get="inline" set="null" expr="cast 147" line="272" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 147</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG4>
		<LANG5 public="1" get="inline" set="null" expr="cast 148" line="274" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 148</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG5>
		<LANG6 public="1" get="inline" set="null" expr="cast 149" line="276" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 149</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG6>
		<LANG7 public="1" get="inline" set="null" expr="cast 150" line="278" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 150</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG7>
		<LANG8 public="1" get="inline" set="null" expr="cast 151" line="280" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 151</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG8>
		<LANG9 public="1" get="inline" set="null" expr="cast 152" line="282" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 152</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG9>
		<ALTERASE public="1" get="inline" set="null" expr="cast 153" line="284" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 153</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ALTERASE>
		<SYSREQ public="1" get="inline" set="null" expr="cast 154" line="285" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 154</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SYSREQ>
		<CANCEL public="1" get="inline" set="null" expr="cast 155" line="286" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 155</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CANCEL>
		<CLEAR public="1" get="inline" set="null" expr="cast 156" line="287" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 156</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CLEAR>
		<PRIOR public="1" get="inline" set="null" expr="cast 157" line="288" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 157</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PRIOR>
		<RETURN2 public="1" get="inline" set="null" expr="cast 158" line="289" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 158</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RETURN2>
		<SEPARATOR public="1" get="inline" set="null" expr="cast 159" line="290" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 159</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SEPARATOR>
		<OUT public="1" get="inline" set="null" expr="cast 160" line="291" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 160</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OUT>
		<OPER public="1" get="inline" set="null" expr="cast 161" line="292" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 161</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OPER>
		<CLEARAGAIN public="1" get="inline" set="null" expr="cast 162" line="293" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 162</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CLEARAGAIN>
		<CRSEL public="1" get="inline" set="null" expr="cast 163" line="294" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 163</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CRSEL>
		<EXSEL public="1" get="inline" set="null" expr="cast 164" line="295" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 164</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EXSEL>
		<KP_00 public="1" get="inline" set="null" expr="cast 176" line="297" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 176</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_00>
		<KP_000 public="1" get="inline" set="null" expr="cast 177" line="298" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 177</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_000>
		<THOUSANDSSEPARATOR public="1" get="inline" set="null" expr="cast 178" line="299" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 178</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</THOUSANDSSEPARATOR>
		<DECIMALSEPARATOR public="1" get="inline" set="null" expr="cast 179" line="300" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 179</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DECIMALSEPARATOR>
		<CURRENCYUNIT public="1" get="inline" set="null" expr="cast 180" line="301" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 180</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CURRENCYUNIT>
		<CURRENCYSUBUNIT public="1" get="inline" set="null" expr="cast 181" line="302" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 181</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CURRENCYSUBUNIT>
		<KP_LEFTPAREN public="1" get="inline" set="null" expr="cast 182" line="303" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 182</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_LEFTPAREN>
		<KP_RIGHTPAREN public="1" get="inline" set="null" expr="cast 183" line="304" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 183</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_RIGHTPAREN>
		<KP_LEFTBRACE public="1" get="inline" set="null" expr="cast 184" line="305" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 184</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_LEFTBRACE>
		<KP_RIGHTBRACE public="1" get="inline" set="null" expr="cast 185" line="306" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 185</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_RIGHTBRACE>
		<KP_TAB public="1" get="inline" set="null" expr="cast 186" line="307" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 186</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_TAB>
		<KP_BACKSPACE public="1" get="inline" set="null" expr="cast 187" line="308" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 187</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_BACKSPACE>
		<KP_A public="1" get="inline" set="null" expr="cast 188" line="309" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 188</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_A>
		<KP_B public="1" get="inline" set="null" expr="cast 189" line="310" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 189</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_B>
		<KP_C public="1" get="inline" set="null" expr="cast 190" line="311" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 190</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_C>
		<KP_D public="1" get="inline" set="null" expr="cast 191" line="312" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 191</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_D>
		<KP_E public="1" get="inline" set="null" expr="cast 192" line="313" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 192</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_E>
		<KP_F public="1" get="inline" set="null" expr="cast 193" line="314" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 193</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_F>
		<KP_XOR public="1" get="inline" set="null" expr="cast 194" line="315" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 194</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_XOR>
		<KP_POWER public="1" get="inline" set="null" expr="cast 195" line="316" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 195</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_POWER>
		<KP_PERCENT public="1" get="inline" set="null" expr="cast 196" line="317" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 196</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PERCENT>
		<KP_LESS public="1" get="inline" set="null" expr="cast 197" line="318" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 197</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_LESS>
		<KP_GREATER public="1" get="inline" set="null" expr="cast 198" line="319" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 198</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_GREATER>
		<KP_AMPERSAND public="1" get="inline" set="null" expr="cast 199" line="320" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 199</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_AMPERSAND>
		<KP_DBLAMPERSAND public="1" get="inline" set="null" expr="cast 200" line="321" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 200</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DBLAMPERSAND>
		<KP_VERTICALBAR public="1" get="inline" set="null" expr="cast 201" line="322" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 201</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_VERTICALBAR>
		<KP_DBLVERTICALBAR public="1" get="inline" set="null" expr="cast 202" line="323" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 202</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DBLVERTICALBAR>
		<KP_COLON public="1" get="inline" set="null" expr="cast 203" line="324" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 203</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_COLON>
		<KP_HASH public="1" get="inline" set="null" expr="cast 204" line="325" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 204</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_HASH>
		<KP_SPACE public="1" get="inline" set="null" expr="cast 205" line="326" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 205</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_SPACE>
		<KP_AT public="1" get="inline" set="null" expr="cast 206" line="327" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 206</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_AT>
		<KP_EXCLAM public="1" get="inline" set="null" expr="cast 207" line="328" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 207</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_EXCLAM>
		<KP_MEMSTORE public="1" get="inline" set="null" expr="cast 208" line="329" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 208</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMSTORE>
		<KP_MEMRECALL public="1" get="inline" set="null" expr="cast 209" line="330" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 209</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMRECALL>
		<KP_MEMCLEAR public="1" get="inline" set="null" expr="cast 210" line="331" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 210</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMCLEAR>
		<KP_MEMADD public="1" get="inline" set="null" expr="cast 211" line="332" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 211</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMADD>
		<KP_MEMSUBTRACT public="1" get="inline" set="null" expr="cast 212" line="333" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 212</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMSUBTRACT>
		<KP_MEMMULTIPLY public="1" get="inline" set="null" expr="cast 213" line="334" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 213</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMMULTIPLY>
		<KP_MEMDIVIDE public="1" get="inline" set="null" expr="cast 214" line="335" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 214</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMDIVIDE>
		<KP_PLUSMINUS public="1" get="inline" set="null" expr="cast 215" line="336" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 215</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PLUSMINUS>
		<KP_CLEAR public="1" get="inline" set="null" expr="cast 216" line="337" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 216</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_CLEAR>
		<KP_CLEARENTRY public="1" get="inline" set="null" expr="cast 217" line="338" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 217</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_CLEARENTRY>
		<KP_BINARY public="1" get="inline" set="null" expr="cast 218" line="339" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 218</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_BINARY>
		<KP_OCTAL public="1" get="inline" set="null" expr="cast 219" line="340" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 219</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_OCTAL>
		<KP_DECIMAL public="1" get="inline" set="null" expr="cast 220" line="341" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 220</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DECIMAL>
		<KP_HEXADECIMAL public="1" get="inline" set="null" expr="cast 221" line="342" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 221</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_HEXADECIMAL>
		<LCTRL public="1" get="inline" set="null" expr="cast 224" line="344" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 224</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LCTRL>
		<LSHIFT public="1" get="inline" set="null" expr="cast 225" line="345" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 225</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LSHIFT>
		<LALT public="1" get="inline" set="null" expr="cast 226" line="347" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 226</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LALT>
		<LMETA public="1" get="inline" set="null" expr="cast 227" line="349" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 227</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LMETA>
		<RCTRL public="1" get="inline" set="null" expr="cast 228" line="350" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 228</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RCTRL>
		<RSHIFT public="1" get="inline" set="null" expr="cast 229" line="351" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 229</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RSHIFT>
		<RALT public="1" get="inline" set="null" expr="cast 230" line="353" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 230</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RALT>
		<RMETA public="1" get="inline" set="null" expr="cast 231" line="355" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 231</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RMETA>
		<MODE public="1" get="inline" set="null" expr="cast 257" line="360" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 257</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MODE>
		<AUDIONEXT public="1" get="inline" set="null" expr="cast 258" line="366" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 258</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIONEXT>
		<AUDIOPREV public="1" get="inline" set="null" expr="cast 259" line="367" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 259</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOPREV>
		<AUDIOSTOP public="1" get="inline" set="null" expr="cast 260" line="368" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 260</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOSTOP>
		<AUDIOPLAY public="1" get="inline" set="null" expr="cast 261" line="369" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 261</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOPLAY>
		<AUDIOMUTE public="1" get="inline" set="null" expr="cast 262" line="370" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 262</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOMUTE>
		<MEDIASELECT public="1" get="inline" set="null" expr="cast 263" line="371" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 263</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MEDIASELECT>
		<WWW public="1" get="inline" set="null" expr="cast 264" line="372" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 264</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WWW>
		<MAIL public="1" get="inline" set="null" expr="cast 265" line="373" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 265</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MAIL>
		<CALCULATOR public="1" get="inline" set="null" expr="cast 266" line="374" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 266</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CALCULATOR>
		<COMPUTER public="1" get="inline" set="null" expr="cast 267" line="375" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 267</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COMPUTER>
		<AC_SEARCH public="1" get="inline" set="null" expr="cast 268" line="376" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 268</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_SEARCH>
		<AC_HOME public="1" get="inline" set="null" expr="cast 269" line="377" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 269</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_HOME>
		<AC_BACK public="1" get="inline" set="null" expr="cast 270" line="378" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 270</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_BACK>
		<AC_FORWARD public="1" get="inline" set="null" expr="cast 271" line="379" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 271</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_FORWARD>
		<AC_STOP public="1" get="inline" set="null" expr="cast 272" line="380" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 272</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_STOP>
		<AC_REFRESH public="1" get="inline" set="null" expr="cast 273" line="381" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 273</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_REFRESH>
		<AC_BOOKMARKS public="1" get="inline" set="null" expr="cast 274" line="382" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 274</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_BOOKMARKS>
		<BRIGHTNESSDOWN public="1" get="inline" set="null" expr="cast 275" line="387" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 275</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BRIGHTNESSDOWN>
		<BRIGHTNESSUP public="1" get="inline" set="null" expr="cast 276" line="388" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 276</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BRIGHTNESSUP>
		<DISPLAYSWITCH public="1" get="inline" set="null" expr="cast 277" line="391" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 277</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DISPLAYSWITCH>
		<KBDILLUMTOGGLE public="1" get="inline" set="null" expr="cast 278" line="393" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 278</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KBDILLUMTOGGLE>
		<KBDILLUMDOWN public="1" get="inline" set="null" expr="cast 279" line="394" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 279</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KBDILLUMDOWN>
		<KBDILLUMUP public="1" get="inline" set="null" expr="cast 280" line="395" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 280</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KBDILLUMUP>
		<EJECT public="1" get="inline" set="null" expr="cast 281" line="396" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 281</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EJECT>
		<SLEEP public="1" get="inline" set="null" expr="cast 282" line="397" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 282</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SLEEP>
		<APP1 public="1" get="inline" set="null" expr="cast 283" line="399" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 283</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</APP1>
		<APP2 public="1" get="inline" set="null" expr="cast 284" line="400" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 284</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</APP2>
		<scanCodeNames expr="[null, null, null, null, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;0&quot;, &quot;Enter&quot;, &quot;Escape&quot;, &quot;Backspace&quot;, &quot;Tab&quot;, &quot;Space&quot;, &quot;-&quot;, &quot;=&quot;, &quot;[&quot;, &quot;]&quot;, &quot;\\&quot;, &quot;#&quot;, &quot;;&quot;, &quot;&apos;&quot;, &quot;`&quot;, &quot;,&quot;, &quot;.&quot;, &quot;/&quot;, &quot;CapsLock&quot;, &quot;F1&quot;, &quot;F2&quot;, &quot;F3&quot;, &quot;F4&quot;, &quot;F5&quot;, &quot;F6&quot;, &quot;F7&quot;, &quot;F8&quot;, &quot;F9&quot;, &quot;F10&quot;, &quot;F11&quot;, &quot;F12&quot;, &quot;PrintScreen&quot;, &quot;ScrollLock&quot;, &quot;Pause&quot;, &quot;Insert&quot;, &quot;Home&quot;, &quot;PageUp&quot;, &quot;Delete&quot;, &quot;End&quot;, &quot;PageDown&quot;, &quot;Right&quot;, &quot;Left&quot;, &quot;Down&quot;, &quot;Up&quot;, &quot;Numlock&quot;, &quot;Keypad /&quot;, &quot;Keypad *&quot;, &quot;Keypad -&quot;, &quot;Keypad +&quot;, &quot;Keypad Enter&quot;, &quot;Keypad 1&quot;, &quot;Keypad 2&quot;, &quot;Keypad 3&quot;, &quot;Keypad 4&quot;, &quot;Keypad 5&quot;, &quot;Keypad 6&quot;, &quot;Keypad 7&quot;, &quot;Keypad 8&quot;, &quot;Keypad 9&quot;, &quot;Keypad 0&quot;, &quot;Keypad .&quot;, null, &quot;Application&quot;, &quot;Power&quot;, &quot;Keypad =&quot;, &quot;F13&quot;, &quot;F14&quot;, &quot;F15&quot;, &quot;F16&quot;, &quot;F17&quot;, &quot;F18&quot;, &quot;F19&quot;, &quot;F20&quot;, &quot;F21&quot;, &quot;F22&quot;, &quot;F23&quot;, &quot;F24&quot;, &quot;Execute&quot;, &quot;Help&quot;, &quot;Menu&quot;, &quot;Select&quot;, &quot;Stop&quot;, &quot;Again&quot;, &quot;Undo&quot;, &quot;Cut&quot;, &quot;Copy&quot;, &quot;Paste&quot;, &quot;Find&quot;, &quot;Mute&quot;, &quot;VolumeUp&quot;, &quot;VolumeDown&quot;, null, null, null, &quot;Keypad ,&quot;, &quot;Keypad = (AS400)&quot;, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;AltErase&quot;, &quot;SysReq&quot;, &quot;Cancel&quot;, &quot;Clear&quot;, &quot;Prior&quot;, &quot;Enter&quot;, &quot;Separator&quot;, &quot;Out&quot;, &quot;Oper&quot;, &quot;Clear / Again&quot;, &quot;CrSel&quot;, &quot;ExSel&quot;, null, null, null, null, null, null, null, null, null, null, null, &quot;Keypad 00&quot;, &quot;Keypad 000&quot;, &quot;ThousandsSeparator&quot;, &quot;DecimalSeparator&quot;, &quot;CurrencyUnit&quot;, &quot;CurrencySubUnit&quot;, &quot;Keypad (&quot;, &quot;Keypad )&quot;, &quot;Keypad {&quot;, &quot;Keypad }&quot;, &quot;Keypad Tab&quot;, &quot;Keypad Backspace&quot;, &quot;Keypad A&quot;, &quot;Keypad B&quot;, &quot;Keypad C&quot;, &quot;Keypad D&quot;, &quot;Keypad E&quot;, &quot;Keypad F&quot;, &quot;Keypad XOR&quot;, &quot;Keypad ^&quot;, &quot;Keypad %&quot;, &quot;Keypad &lt;&quot;, &quot;Keypad &gt;&quot;, &quot;Keypad &amp;&quot;, &quot;Keypad &amp;&amp;&quot;, &quot;Keypad |&quot;, &quot;Keypad ||&quot;, &quot;Keypad :&quot;, &quot;Keypad #&quot;, &quot;Keypad Space&quot;, &quot;Keypad @&quot;, &quot;Keypad !&quot;, &quot;Keypad MemStore&quot;, &quot;Keypad MemRecall&quot;, &quot;Keypad MemClear&quot;, &quot;Keypad MemAdd&quot;, &quot;Keypad MemSubtract&quot;, &quot;Keypad MemMultiply&quot;, &quot;Keypad MemDivide&quot;, &quot;Keypad +/-&quot;, &quot;Keypad Clear&quot;, &quot;Keypad ClearEntry&quot;, &quot;Keypad Binary&quot;, &quot;Keypad Octal&quot;, &quot;Keypad Decimal&quot;, &quot;Keypad Hexadecimal&quot;, null, null, &quot;Left Ctrl&quot;, &quot;Left Shift&quot;, &quot;Left Alt&quot;, &quot;Left Meta&quot;, &quot;Right Ctrl&quot;, &quot;Right Shift&quot;, &quot;Right Alt&quot;, &quot;Right Meta&quot;, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;ModeSwitch&quot;, &quot;AudioNext&quot;, &quot;AudioPrev&quot;, &quot;AudioStop&quot;, &quot;AudioPlay&quot;, &quot;AudioMute&quot;, &quot;MediaSelect&quot;, &quot;WWW&quot;, &quot;Mail&quot;, &quot;Calculator&quot;, &quot;Computer&quot;, &quot;AC Search&quot;, &quot;AC Home&quot;, &quot;AC Back&quot;, &quot;AC Forward&quot;, &quot;AC Stop&quot;, &quot;AC Refresh&quot;, &quot;AC Bookmarks&quot;, &quot;BrightnessDown&quot;, &quot;BrightnessUp&quot;, &quot;DisplaySwitch&quot;, &quot;KBDIllumToggle&quot;, &quot;KBDIllumDown&quot;, &quot;KBDIllumUp&quot;, &quot;Eject&quot;, &quot;Sleep&quot;]" line="402" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[[null, null, null, null, "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "Enter", "Escape", "Backspace", "Tab", "Space", "-", "=", "[", "]", "\\", "#", ";", "'", "`", ",", ".", "/", "CapsLock", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "PrintScreen", "ScrollLock", "Pause", "Insert", "Home", "PageUp", "Delete", "End", "PageDown", "Right", "Left", "Down", "Up", "Numlock", "Keypad /", "Keypad *", "Keypad -", "Keypad +", "Keypad Enter", "Keypad 1", "Keypad 2", "Keypad 3", "Keypad 4", "Keypad 5", "Keypad 6", "Keypad 7", "Keypad 8", "Keypad 9", "Keypad 0", "Keypad .", null, "Application", "Power", "Keypad =", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "Execute", "Help", "Menu", "Select", "Stop", "Again", "Undo", "Cut", "Copy", "Paste", "Find", "Mute", "VolumeUp", "VolumeDown", null, null, null, "Keypad ,", "Keypad = (AS400)", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "AltErase", "SysReq", "Cancel", "Clear", "Prior", "Enter", "Separator", "Out", "Oper", "Clear / Again", "CrSel", "ExSel", null, null, null, null, null, null, null, null, null, null, null, "Keypad 00", "Keypad 000", "ThousandsSeparator", "DecimalSeparator", "CurrencyUnit", "CurrencySubUnit", "Keypad (", "Keypad )", "Keypad {", "Keypad }", "Keypad Tab", "Keypad Backspace", "Keypad A", "Keypad B", "Keypad C", "Keypad D", "Keypad E", "Keypad F", "Keypad XOR", "Keypad ^", "Keypad %", "Keypad <", "Keypad >", "Keypad &", "Keypad &&", "Keypad |", "Keypad ||", "Keypad :", "Keypad #", "Keypad Space", "Keypad @", "Keypad !", "Keypad MemStore", "Keypad MemRecall", "Keypad MemClear", "Keypad MemAdd", "Keypad MemSubtract", "Keypad MemMultiply", "Keypad MemDivide", "Keypad +/-", "Keypad Clear", "Keypad ClearEntry", "Keypad Binary", "Keypad Octal", "Keypad Decimal", "Keypad Hexadecimal", null, null, "Left Ctrl", "Left Shift", "Left Alt", "Left Meta", "Right Ctrl", "Right Shift", "Right Alt", "Right Meta", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "ModeSwitch", "AudioNext", "AudioPrev", "AudioStop", "AudioPlay", "AudioMute", "MediaSelect", "WWW", "Mail", "Calculator", "Computer", "AC Search", "AC Home", "AC Back", "AC Forward", "AC Stop", "AC Refresh", "AC Bookmarks", "BrightnessDown", "BrightnessUp", "DisplaySwitch", "KBDIllumToggle", "KBDIllumDown", "KBDIllumUp", "Eject", "Sleep"]]]></e></m></meta>
		</scanCodeNames>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="ceramic.Scene" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Scene.hx">
		<extends path="ceramic.Layer"/>
		<implements path="tracker.Observable"/>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Scene"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Scene"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Scene"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Scene"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.Scene"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<_assets expr="null">
			<c path="ceramic.Assets"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_assets>
		<invalidateStatus public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateStatus>
		<status expr="NONE">
			<x path="ceramic.SceneStatus"/>
			<meta>
				<m n=":value"><e>NONE</e></m>
				<m n="observe"/>
			</meta>
		</status>
		<unobservedStatus>
			<x path="ceramic.SceneStatus"/>
			<haxe_doc></haxe_doc>
		</unobservedStatus>
		<_dox_event_statusChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="ceramic.SceneStatus"/>
				<x path="ceramic.SceneStatus"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</_dox_event_statusChange>
		<emitStatusChange set="method" line="1095">
			<f a="current:previous">
				<x path="ceramic.SceneStatus"/>
				<x path="ceramic.SceneStatus"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</emitStatusChange>
		<onStatusChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="ceramic.SceneStatus"/>
					<x path="ceramic.SceneStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</onStatusChange>
		<onceStatusChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="ceramic.SceneStatus"/>
					<x path="ceramic.SceneStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</onceStatusChange>
		<offStatusChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="ceramic.SceneStatus"/>
					<x path="ceramic.SceneStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</offStatusChange>
		<listensStatusChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</listensStatusChange>
		<assets public="1" get="accessor" set="accessor"><c path="ceramic.Assets"/></assets>
		<get_assets set="method" line="17"><f a=""><c path="ceramic.Assets"/></f></get_assets>
		<set_assets set="method" line="23"><f a="assets">
	<c path="ceramic.Assets"/>
	<c path="ceramic.Assets"/>
</f></set_assets>
		<isRootScene public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this scene is a root scene</haxe_doc>
		</isRootScene>
		<autoUpdate public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Set to `false` if you want to disable auto update on this scene object.
     * If auto update is disabled, you become responsible to explicitly call
     * `update(delta)` at every frame yourself. Use this if you want to have control over
     * when the animation update is actually happening. Don't use it to pause animation.
     * (animation can be paused with `paused` property instead)</haxe_doc>
		</autoUpdate>
		<autoUpdateWhenInactive public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If `autoUpdate` is enabled, setting `autoUpdateWhenInactive` to `true`
     * will keep updating the scene even when inactive.</haxe_doc>
		</autoUpdateWhenInactive>
		<paused public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Is this scene paused?</haxe_doc>
		</paused>
		<_boot set="method" line="62"><f a=""><x path="Void"/></f></_boot>
		<internalCreate set="method" line="85"><f a=""><x path="Void"/></f></internalCreate>
		<_fadeInDone set="method" line="94"><f a=""><x path="Void"/></f></_fadeInDone>
		<_handleAssetsComplete set="method" line="100"><f a="successful">
	<x path="Bool"/>
	<x path="Void"/>
</f></_handleAssetsComplete>
		<internalLoad set="method" line="111"><f a=""><x path="Void"/></f></internalLoad>
		<willEmitResize set="method" line="117" override="1"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitResize>
		<preload set="method" line="130">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this method to configure the scene, add assets to it...
     * example: `assets.add(Images.SOME_IMAGE);`
     * Added assets will be loaded automatically</haxe_doc>
		</preload>
		<load set="method" line="142">
			<f a="next">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override this method to perform any additional asynchronous loading.
     * `next()` must be called once the loading has finished so that the scene
     * can continue its createialization process.
     * @param next The callback to call once asynchronous loading is done</haxe_doc>
		</load>
		<create set="method" line="156">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called once the scene has finished its loading.
     * At this point, and after `create()`, `update(delta)` will be called at every frame until the scene gets destroyed</haxe_doc>
		</create>
		<ready public="1" set="method" line="165">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the scene's status becomes `READY`</haxe_doc>
		</ready>
		<update public="1" set="method" line="175">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called at every frame, but only after create() has been called and when the scene is not paused
     * @param delta</haxe_doc>
		</update>
		<resize public="1" set="method" line="186">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called if the scene size has been changed during this frame.
     * @param width new width
     * @param height new height</haxe_doc>
		</resize>
		<_fadeIn set="method" line="192">
			<f a="done">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_fadeIn>
		<_fadeOut set="method" line="198">
			<f a="done">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_fadeOut>
		<fadeIn public="1" set="method" line="211">
			<f a="done">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Play **fade-in** transition of this scene. This is automatically called right after
     * the scene is ready to use, meaning after `create()` has been called.
     * Default implementation does nothing and calls `done()` right away.
     * Override in subclasses to perform custom transitions.
     * @param done Called when the fade-in transition has finished.</haxe_doc>
		</fadeIn>
		<fadeOut public="1" set="method" line="231">
			<f a="done">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Play **fade-out** transition of this scene. This is called manually on secondary scene
     * but will be called automatically if the scene is the **main scene** and is replaced
     * by a new scene or simply removed.
     * @param done Called when the fade-out transition has finished.</haxe_doc>
		</fadeOut>
		<isReady public="1" set="method" line="244"><f a=""><x path="Bool"/></f></isReady>
		<scheduleOnceReady public="1" set="method" line="259"><f a="owner:callback">
	<c path="ceramic.Entity"/>
	<f a=""><x path="Void"/></f>
	<x path="Bool"/>
</f></scheduleOnceReady>
		<destroy public="1" set="method" line="285" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="52"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":allow"><e>ceramic.SceneSystem</e></m>
		</meta>
	</class>
	<abstract path="ceramic.SceneStatus" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SceneStatus.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._SceneStatus.SceneStatus_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SceneStatus.hx" private="1" module="ceramic.SceneStatus" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="8" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* No status. The scene is likely not assigned to anything.</haxe_doc>
	</NONE>
	<PRELOAD public="1" get="inline" set="null" expr="cast 1" line="14" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* The scene is calling the `preload()` method.
     * That happens when the scene is added as root scene or is added as a child of another visual.</haxe_doc>
	</PRELOAD>
	<LOAD public="1" get="inline" set="null" expr="cast 2" line="21" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* The scene is actually loading. Any asset that was
     * added with `assets.add()` in the `preload()` method is
     * getting loaded.</haxe_doc>
	</LOAD>
	<CREATE public="1" get="inline" set="null" expr="cast 3" line="27" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* The scene has finished loading and is calling the `create()` method
     * to fill it with any object, visual needed etc...</haxe_doc>
	</CREATE>
	<FADE_IN public="1" get="inline" set="null" expr="cast 4" line="34" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* The `create()` method has finished running so the scene is now ready to **fade in**.
     * Default fade in implementation is _instant_, but this can be changed by overriding
     * the `fadeIn()` method.</haxe_doc>
	</FADE_IN>
	<READY public="1" get="inline" set="null" expr="cast 5" line="39" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* When **fade in** has finished, the scene is marked as **ready**.</haxe_doc>
	</READY>
	<FADE_OUT public="1" get="inline" set="null" expr="cast 6" line="45" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* The scene begins to **fade out**, likely because it was explicitly asked to do so,
     * or is being replaced by another scene.</haxe_doc>
	</FADE_OUT>
	<DISABLED public="1" get="inline" set="null" expr="cast 7" line="50" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Happens after **fade out**. When the scene has this status, it should not be used anymore.</haxe_doc>
	</DISABLED>
	<toString set="method" line="52" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._SceneStatus.SceneStatus_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SceneStatus.hx" private="1" module="ceramic.SceneStatus" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="8" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* No status. The scene is likely not assigned to anything.</haxe_doc>
		</NONE>
		<PRELOAD public="1" get="inline" set="null" expr="cast 1" line="14" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* The scene is calling the `preload()` method.
     * That happens when the scene is added as root scene or is added as a child of another visual.</haxe_doc>
		</PRELOAD>
		<LOAD public="1" get="inline" set="null" expr="cast 2" line="21" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* The scene is actually loading. Any asset that was
     * added with `assets.add()` in the `preload()` method is
     * getting loaded.</haxe_doc>
		</LOAD>
		<CREATE public="1" get="inline" set="null" expr="cast 3" line="27" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* The scene has finished loading and is calling the `create()` method
     * to fill it with any object, visual needed etc...</haxe_doc>
		</CREATE>
		<FADE_IN public="1" get="inline" set="null" expr="cast 4" line="34" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* The `create()` method has finished running so the scene is now ready to **fade in**.
     * Default fade in implementation is _instant_, but this can be changed by overriding
     * the `fadeIn()` method.</haxe_doc>
		</FADE_IN>
		<READY public="1" get="inline" set="null" expr="cast 5" line="39" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* When **fade in** has finished, the scene is marked as **ready**.</haxe_doc>
		</READY>
		<FADE_OUT public="1" get="inline" set="null" expr="cast 6" line="45" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* The scene begins to **fade out**, likely because it was explicitly asked to do so,
     * or is being replaced by another scene.</haxe_doc>
		</FADE_OUT>
		<DISABLED public="1" get="inline" set="null" expr="cast 7" line="50" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Happens after **fade out**. When the scene has this status, it should not be used anymore.</haxe_doc>
		</DISABLED>
		<toString set="method" line="52" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="ceramic.System" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/System.hx">
		<extends path="ceramic.Entity"/>
		<_dox_event_beginEarlyUpdate public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_beginEarlyUpdate>
		<emitBeginEarlyUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>beginEarlyUpdate event</haxe_doc>
		</emitBeginEarlyUpdate>
		<onBeginEarlyUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>beginEarlyUpdate event</haxe_doc>
		</onBeginEarlyUpdate>
		<onceBeginEarlyUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>beginEarlyUpdate event</haxe_doc>
		</onceBeginEarlyUpdate>
		<offBeginEarlyUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>beginEarlyUpdate event</haxe_doc>
		</offBeginEarlyUpdate>
		<listensBeginEarlyUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to beginEarlyUpdate event</haxe_doc>
		</listensBeginEarlyUpdate>
		<_dox_event_endEarlyUpdate public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_endEarlyUpdate>
		<emitEndEarlyUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>endEarlyUpdate event</haxe_doc>
		</emitEndEarlyUpdate>
		<onEndEarlyUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>endEarlyUpdate event</haxe_doc>
		</onEndEarlyUpdate>
		<onceEndEarlyUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>endEarlyUpdate event</haxe_doc>
		</onceEndEarlyUpdate>
		<offEndEarlyUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>endEarlyUpdate event</haxe_doc>
		</offEndEarlyUpdate>
		<listensEndEarlyUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to endEarlyUpdate event</haxe_doc>
		</listensEndEarlyUpdate>
		<_dox_event_beginLateUpdate public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_beginLateUpdate>
		<emitBeginLateUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>beginLateUpdate event</haxe_doc>
		</emitBeginLateUpdate>
		<onBeginLateUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>beginLateUpdate event</haxe_doc>
		</onBeginLateUpdate>
		<onceBeginLateUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>beginLateUpdate event</haxe_doc>
		</onceBeginLateUpdate>
		<offBeginLateUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>beginLateUpdate event</haxe_doc>
		</offBeginLateUpdate>
		<listensBeginLateUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to beginLateUpdate event</haxe_doc>
		</listensBeginLateUpdate>
		<_dox_event_endLateUpdate public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_endLateUpdate>
		<emitEndLateUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>endLateUpdate event</haxe_doc>
		</emitEndLateUpdate>
		<onEndLateUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>endLateUpdate event</haxe_doc>
		</onEndLateUpdate>
		<onceEndLateUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>endLateUpdate event</haxe_doc>
		</onceEndLateUpdate>
		<offEndLateUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>endLateUpdate event</haxe_doc>
		</offEndLateUpdate>
		<listensEndLateUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to endLateUpdate event</haxe_doc>
		</listensEndLateUpdate>
		<name public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* System name.
     * Useful to retrieve a system afterwards</haxe_doc>
		</name>
		<autoUpdate public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* When set to `true` (default). This system will be updated automatically.
     * If `false`, you'll need to call `earlyUpdate()` and `lateUpdate()` manually.</haxe_doc>
		</autoUpdate>
		<earlyUpdateOrder public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Order of earlyUpdate execution.
     * Given two systems, a system with a lower `earlyUpdateOrder` value will have
     * it's `earlyUpdate()` method called before another system's `earlyUpdate()`
     * method with a higher `order` value.</haxe_doc>
		</earlyUpdateOrder>
		<set_earlyUpdateOrder set="method" line="39"><f a="earlyUpdateOrder">
	<x path="Float"/>
	<x path="Float"/>
</f></set_earlyUpdateOrder>
		<lateUpdateOrder public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Order of lateUpdate execution.
     * Given two systems, a system with a lower `lateUpdateOrder` value will have
     * it's `lateUpdate()` method called before another system's `lateUpdate()`
     * method with a higher `order` value.</haxe_doc>
		</lateUpdateOrder>
		<set_lateUpdateOrder set="method" line="54"><f a="lateUpdateOrder">
	<x path="Float"/>
	<x path="Float"/>
</f></set_lateUpdateOrder>
		<destroy public="1" set="method" line="70" override="1"><f a=""><x path="Void"/></f></destroy>
		<earlyUpdate set="method" line="82">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Method automatically called right before app's `update` event
     * @param delta</haxe_doc>
		</earlyUpdate>
		<lateUpdate set="method" line="90">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Method automatically called right before app's right after `update` event
     * @param delta</haxe_doc>
		</lateUpdate>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="62"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A `System` is an object assigned to app lifecycle and used to
 * do some work such as dispatching events or manipulating entities.
 * Systems can be ordered with `order` properties</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":access"><e>ceramic.Systems</e></m>
			<m n=":allow"><e>ceramic.Systems</e></m>
		</meta>
	</class>
	<class path="ceramic.SceneSystem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SceneSystem.hx">
		<extends path="ceramic.System"/>
		<shared public="1" expr="new SceneSystem()" line="17" static="1">
			<c path="ceramic.SceneSystem"/>
			<meta>
				<m n=":value"><e>new SceneSystem()</e></m>
				<m n="lazy"/>
			</meta>
			<haxe_doc>* Shared scene system</haxe_doc>
		</shared>
		<all public="1" set="null" expr="[]">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.Scene"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
		</all>
		<_updatingScenes expr="[]">
			<c path="Array"><c path="ceramic.Scene"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_updatingScenes>
		<keepAssetsForNextMain public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If `true`, when assigning a new main scene, assets of the previous
     * main scene will be kept instead of being destroyed and can be
     * reused by the new main scene without having to reload these</haxe_doc>
		</keepAssetsForNextMain>
		<bindMainToScreenSize public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If `true`, main scene will be bound to screen size automatically</haxe_doc>
		</bindMainToScreenSize>
		<fadeOutWhenNextMainCanFadeIn public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If `true`, when assigning a new main scene, previous main
     * scene will wait until the next scene is properly loaded and can fade-in
     * before starting its own fade-out transition.</haxe_doc>
		</fadeOutWhenNextMainCanFadeIn>
		<main public="1" set="accessor" expr="null">
			<c path="ceramic.Scene"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The main scene to display on screen.</haxe_doc>
		</main>
		<autoDestroyFilter public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If set to `true` (default), any filter assigned to the system will be destroyed
     * if replaced by another filter, set to null, or if the system is destroyed.</haxe_doc>
		</autoDestroyFilter>
		<autoScaleFilter public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If set to `true` (default), a filter assigned to the system will
     * be auto-scaled to fit screen size.</haxe_doc>
		</autoScaleFilter>
		<filter public="1" set="accessor" expr="null">
			<c path="ceramic.Filter"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Assign a filter to the scene system, that will be used to render root scenes</haxe_doc>
		</filter>
		<set_filter set="method" line="63"><f a="filter">
	<c path="ceramic.Filter"/>
	<c path="ceramic.Filter"/>
</f></set_filter>
		<scaleFilter set="method" line="117"><f a=""><x path="Void"/></f></scaleFilter>
		<rootScenes public="1" set="null" expr="new Map()">
			<x path="ceramic.ReadOnlyMap">
				<c path="String"/>
				<c path="ceramic.Scene"/>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</rootScenes>
		<set_main set="method" line="126"><f a="main">
	<c path="ceramic.Scene"/>
	<c path="ceramic.Scene"/>
</f></set_main>
		<set public="1" set="method" line="146">
			<f a="name:scene:?bindToScreenSize:?keepAssets" v="::true:false">
				<c path="String"/>
				<c path="ceramic.Scene"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ keepAssets : false, bindToScreenSize : true }</e></m></meta>
			<haxe_doc>* Assign secondary scenes to display them directly on screen.
     * @param name The slot name of the scene
     * @param scene The scene to assign
     * @param bindToScreenSize (optional) Set to `false` if you don't want the scene to follow screen size
     * @param keepAssets
     *          (optional) Set to `true` if you want this scene to keep the same **assets**
     *          instance as the previous scene on the same slot.</haxe_doc>
		</set>
		<get public="1" set="method" line="256">
			<f a="name">
				<c path="String"/>
				<c path="ceramic.Scene"/>
			</f>
			<haxe_doc>* Retrieve a secondary scene from the given slot name
     * @param name The slot name of the scene to retrieve
     * @return A `Scene` instance or `null` if nothing was found</haxe_doc>
		</get>
		<setCurrentScene public="1" get="inline" set="null" line="263">
			<f a="scene:?keepAssets" v=":false">
				<c path="ceramic.Scene"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ keepAssets : false }</e></m>
				<m n=":deprecated"><e>"Deprecated: use `app.scenes.main = yourScene;` instead"</e></m>
			</meta>
		</setCurrentScene>
		<lateUpdate set="method" line="278" override="1"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></lateUpdate>
		<new set="method" line="270"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* System managing scenes display and lifecycle.
 * Use it to structure your app in different scenes.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":allow"><e>ceramic.Scene</e></m>
		</meta>
	</class>
	<class path="ceramic.Screen" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Screen.hx">
		<extends path="ceramic.Entity"/>
		<implements path="tracker.Observable"/>
		<matchedHitVisual public="1" expr="null" line="1179" static="1">
			<c path="ceramic.Visual"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Internal reference to a matched hit visual. This is used to let Visual.hit() return `false`
     * on every visual not related to the matched hit visual, if any is defined.</haxe_doc>
		</matchedHitVisual>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Screen"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Screen"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Screen"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Screen"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.Screen"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<density public="1" set="null" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Screen density computed from app's logical width/height
     * settings and native width/height.</haxe_doc>
		</density>
		<width public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Logical width used in app to position elements.
     * Updated when the screen is resized.</haxe_doc>
		</width>
		<height public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Logical height used in app to position elements.
     * Updated when the screen is resized.</haxe_doc>
		</height>
		<actualWidth public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The actual width available on screen, including offsets, in the same unit as `width`.
     * Updated when the screen is resized.</haxe_doc>
		</actualWidth>
		<actualHeight public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The actual height available on screen, including offsets, in the same unit as `width`.
     * Updated when the screen is resized.</haxe_doc>
		</actualHeight>
		<offsetX public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Logical x offset.
     * Updated when the screen is resized.</haxe_doc>
		</offsetX>
		<offsetY public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Logical y offset.
     * Updated when the screen is resized.</haxe_doc>
		</offsetY>
		<nativeWidth public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Native width</haxe_doc>
		</nativeWidth>
		<get_nativeWidth get="inline" set="null" line="65"><f a=""><x path="Float"/></f></get_nativeWidth>
		<nativeHeight public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Native height</haxe_doc>
		</nativeHeight>
		<get_nativeHeight get="inline" set="null" line="73"><f a=""><x path="Float"/></f></get_nativeHeight>
		<nativeDensity public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Native pixel ratio/density.</haxe_doc>
		</nativeDensity>
		<get_nativeDensity get="inline" set="null" line="81"><f a=""><x path="Float"/></f></get_nativeDensity>
		<pointerX public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Pointer x coordinate, computed from mouse and touch events.
     * When using multiple touch inputs at the same time, x will be
     * the mean value of all touches x value. Use this as a
     * convenience when you don't want to deal with multiple positions.</haxe_doc>
		</pointerX>
		<pointerY public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Pointer y coordinate, computed from mouse and touch events.
     * When using multiple touch inputs at the same time, y will be
     * the mean value of all touches y value. Use this as a
     * convenience when you don't want to deal with multiple positions.</haxe_doc>
		</pointerY>
		<pointerDeltaX public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Pointer x delta since last frame</haxe_doc>
		</pointerDeltaX>
		<pointerDeltaY public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Pointer y delta since last frame</haxe_doc>
		</pointerDeltaY>
		<mouseX public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Mouse x coordinate, computed from mouse events.</haxe_doc>
		</mouseX>
		<mouseY public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Mouse y coordinate, computed from mouse events.</haxe_doc>
		</mouseY>
		<mouseDeltaX public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Mouse x delta since last frame</haxe_doc>
		</mouseDeltaX>
		<mouseDeltaY public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Mouse y delta since last frame</haxe_doc>
		</mouseDeltaY>
		<mouseWheelDeltaX public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Mouse wheel x delta since last frame</haxe_doc>
		</mouseWheelDeltaX>
		<mouseWheelDeltaY public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Mouse wheel y delta since last frame</haxe_doc>
		</mouseWheelDeltaY>
		<touches public="1" set="null" expr="new Touches()">
			<x path="ceramic.Touches"/>
			<meta><m n=":value"><e>new Touches()</e></m></meta>
			<haxe_doc>* Touches x and y coordinates by touch index.</haxe_doc>
		</touches>
		<invalidateFocusedVisual public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateFocusedVisual>
		<focusedVisual public="1" set="accessor" expr="null">
			<c path="ceramic.Visual"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Focused visual</haxe_doc>
		</focusedVisual>
		<unobservedFocusedVisual>
			<c path="ceramic.Visual"/>
			<haxe_doc></haxe_doc>
		</unobservedFocusedVisual>
		<_dox_event_focusedVisualChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.Visual"/>
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when focusedVisual field changes.</haxe_doc>
		</_dox_event_focusedVisualChange>
		<emitFocusedVisualChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.Visual"/>
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when focusedVisual field changes.</haxe_doc>
		</emitFocusedVisualChange>
		<onFocusedVisualChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Visual"/>
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when focusedVisual field changes.</haxe_doc>
		</onFocusedVisualChange>
		<onceFocusedVisualChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Visual"/>
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when focusedVisual field changes.</haxe_doc>
		</onceFocusedVisualChange>
		<offFocusedVisualChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.Visual"/>
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when focusedVisual field changes.</haxe_doc>
		</offFocusedVisualChange>
		<listensFocusedVisualChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when focusedVisual field changes.</haxe_doc>
		</listensFocusedVisualChange>
		<set_focusedVisual set="method" line="150"><f a="focusedVisual">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
</f></set_focusedVisual>
		<invalidateTexturesDensity public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTexturesDensity>
		<texturesDensity public="1" expr="1.0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1.0</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Ideal textures density, computed from settings
     * targetDensity and current screen state.</haxe_doc>
		</texturesDensity>
		<unobservedTexturesDensity>
			<x path="Float"/>
			<haxe_doc></haxe_doc>
		</unobservedTexturesDensity>
		<_dox_event_texturesDensityChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when texturesDensity field changes.</haxe_doc>
		</_dox_event_texturesDensityChange>
		<emitTexturesDensityChange set="method" line="1095">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when texturesDensity field changes.</haxe_doc>
		</emitTexturesDensityChange>
		<onTexturesDensityChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texturesDensity field changes.</haxe_doc>
		</onTexturesDensityChange>
		<onceTexturesDensityChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texturesDensity field changes.</haxe_doc>
		</onceTexturesDensityChange>
		<offTexturesDensityChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texturesDensity field changes.</haxe_doc>
		</offTexturesDensityChange>
		<listensTexturesDensityChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texturesDensity field changes.</haxe_doc>
		</listensTexturesDensityChange>
		<matrix expr="new Transform()">
			<c path="ceramic.Transform"/>
			<meta>
				<m n=":value"><e>new Transform()</e></m>
				<m n=":allow"><e>ceramic.Visual</e></m>
			</meta>
			<haxe_doc>* Root matrix applied to every visual.
     * This is recomputed on screen resize but
     * can be changed otherwise.</haxe_doc>
		</matrix>
		<reverseMatrix expr="new Transform()">
			<c path="ceramic.Transform"/>
			<meta>
				<m n=":value"><e>new Transform()</e></m>
				<m n=":allow"><e>ceramic.Visual</e></m>
			</meta>
			<haxe_doc>* Internal inverted matrix computed from root matrix.</haxe_doc>
		</reverseMatrix>
		<resizing expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* In order to prevent nested resizes.</haxe_doc>
		</resizing>
		<isPointerDown public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether the screen is between a `pointer down` and an `pointer up` event or not.</haxe_doc>
		</isPointerDown>
		<_numPointerDown expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numPointerDown>
		<get_isPointerDown get="inline" set="null" line="199"><f a=""><x path="Bool"/></f></get_isPointerDown>
		<pressedMouseButtons expr="new IntIntMap(16, 0.5, false)">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</pressedMouseButtons>
		<pressedTouches expr="new IntIntMap(16, 0.5, false)">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</pressedTouches>
		<prevTouchPositions expr="new IntFloatMap(16, 0.5, false)">
			<c path="ceramic.IntFloatMap"/>
			<meta><m n=":value"><e>new IntFloatMap(16, 0.5, false)</e></m></meta>
		</prevTouchPositions>
		<prevMouseX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</prevMouseX>
		<prevMouseY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</prevMouseY>
		<maxTouchIndex expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</maxTouchIndex>
		<visualsListenPointerOver expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</visualsListenPointerOver>
		<_dox_event_resize public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Resize event occurs once at startup, then each time any
     * of native width, height or density changes.</haxe_doc>
		</_dox_event_resize>
		<emitResize set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resize event occurs once at startup, then each time any
     * of native width, height or density changes.</haxe_doc>
		</emitResize>
		<onResize public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Resize event occurs once at startup, then each time any
     * of native width, height or density changes.</haxe_doc>
		</onResize>
		<onceResize public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Resize event occurs once at startup, then each time any
     * of native width, height or density changes.</haxe_doc>
		</onceResize>
		<offResize public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Resize event occurs once at startup, then each time any
     * of native width, height or density changes.</haxe_doc>
		</offResize>
		<listensResize public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Resize event occurs once at startup, then each time any
     * of native width, height or density changes.</haxe_doc>
		</listensResize>
		<_dox_event_mouseDown public="1" set="method" line="637">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseDown>
		<emitMouseDown set="method" line="1095">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseDown event</haxe_doc>
		</emitMouseDown>
		<onMouseDown public="1" set="method" line="1199">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseDown event</haxe_doc>
		</onMouseDown>
		<onceMouseDown public="1" set="method" line="1298">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseDown event</haxe_doc>
		</onceMouseDown>
		<offMouseDown public="1" set="method" line="1368">
			<f a="?handleButtonIdXY">
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseDown event</haxe_doc>
		</offMouseDown>
		<listensMouseDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseDown event</haxe_doc>
		</listensMouseDown>
		<_dox_event_mouseUp public="1" set="method" line="637">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseUp>
		<emitMouseUp set="method" line="1095">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseUp event</haxe_doc>
		</emitMouseUp>
		<onMouseUp public="1" set="method" line="1199">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseUp event</haxe_doc>
		</onMouseUp>
		<onceMouseUp public="1" set="method" line="1298">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseUp event</haxe_doc>
		</onceMouseUp>
		<offMouseUp public="1" set="method" line="1368">
			<f a="?handleButtonIdXY">
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseUp event</haxe_doc>
		</offMouseUp>
		<listensMouseUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseUp event</haxe_doc>
		</listensMouseUp>
		<_dox_event_mouseWheel public="1" set="method" line="637">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseWheel>
		<emitMouseWheel set="method" line="1095">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseWheel event</haxe_doc>
		</emitMouseWheel>
		<onMouseWheel public="1" set="method" line="1199">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseWheel event</haxe_doc>
		</onMouseWheel>
		<onceMouseWheel public="1" set="method" line="1298">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseWheel event</haxe_doc>
		</onceMouseWheel>
		<offMouseWheel public="1" set="method" line="1368">
			<f a="?handleXY">
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseWheel event</haxe_doc>
		</offMouseWheel>
		<listensMouseWheel public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseWheel event</haxe_doc>
		</listensMouseWheel>
		<_dox_event_mouseMove public="1" set="method" line="637">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseMove>
		<emitMouseMove set="method" line="1095">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseMove event</haxe_doc>
		</emitMouseMove>
		<onMouseMove public="1" set="method" line="1199">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseMove event</haxe_doc>
		</onMouseMove>
		<onceMouseMove public="1" set="method" line="1298">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseMove event</haxe_doc>
		</onceMouseMove>
		<offMouseMove public="1" set="method" line="1368">
			<f a="?handleXY">
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseMove event</haxe_doc>
		</offMouseMove>
		<listensMouseMove public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseMove event</haxe_doc>
		</listensMouseMove>
		<_dox_event_touchDown public="1" set="method" line="637">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_touchDown>
		<emitTouchDown set="method" line="1095">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>touchDown event</haxe_doc>
		</emitTouchDown>
		<onTouchDown public="1" set="method" line="1199">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchDown event</haxe_doc>
		</onTouchDown>
		<onceTouchDown public="1" set="method" line="1298">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchDown event</haxe_doc>
		</onceTouchDown>
		<offTouchDown public="1" set="method" line="1368">
			<f a="?handleTouchIndexXY">
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchDown event</haxe_doc>
		</offTouchDown>
		<listensTouchDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to touchDown event</haxe_doc>
		</listensTouchDown>
		<_dox_event_touchUp public="1" set="method" line="637">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_touchUp>
		<emitTouchUp set="method" line="1095">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>touchUp event</haxe_doc>
		</emitTouchUp>
		<onTouchUp public="1" set="method" line="1199">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchUp event</haxe_doc>
		</onTouchUp>
		<onceTouchUp public="1" set="method" line="1298">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchUp event</haxe_doc>
		</onceTouchUp>
		<offTouchUp public="1" set="method" line="1368">
			<f a="?handleTouchIndexXY">
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchUp event</haxe_doc>
		</offTouchUp>
		<listensTouchUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to touchUp event</haxe_doc>
		</listensTouchUp>
		<_dox_event_touchMove public="1" set="method" line="637">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_touchMove>
		<emitTouchMove set="method" line="1095">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>touchMove event</haxe_doc>
		</emitTouchMove>
		<onTouchMove public="1" set="method" line="1199">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchMove event</haxe_doc>
		</onTouchMove>
		<onceTouchMove public="1" set="method" line="1298">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchMove event</haxe_doc>
		</onceTouchMove>
		<offTouchMove public="1" set="method" line="1368">
			<f a="?handleTouchIndexXY">
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchMove event</haxe_doc>
		</offTouchMove>
		<listensTouchMove public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to touchMove event</haxe_doc>
		</listensTouchMove>
		<_dox_event_pointerDown public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_pointerDown>
		<emitPointerDown set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>pointerDown event</haxe_doc>
		</emitPointerDown>
		<onPointerDown public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerDown event</haxe_doc>
		</onPointerDown>
		<oncePointerDown public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerDown event</haxe_doc>
		</oncePointerDown>
		<offPointerDown public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerDown event</haxe_doc>
		</offPointerDown>
		<listensPointerDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to pointerDown event</haxe_doc>
		</listensPointerDown>
		<_dox_event_pointerUp public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_pointerUp>
		<emitPointerUp set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>pointerUp event</haxe_doc>
		</emitPointerUp>
		<onPointerUp public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerUp event</haxe_doc>
		</onPointerUp>
		<oncePointerUp public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerUp event</haxe_doc>
		</oncePointerUp>
		<offPointerUp public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerUp event</haxe_doc>
		</offPointerUp>
		<listensPointerUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to pointerUp event</haxe_doc>
		</listensPointerUp>
		<_dox_event_pointerMove public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_pointerMove>
		<emitPointerMove set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>pointerMove event</haxe_doc>
		</emitPointerMove>
		<onPointerMove public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerMove event</haxe_doc>
		</onPointerMove>
		<oncePointerMove public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerMove event</haxe_doc>
		</oncePointerMove>
		<offPointerMove public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerMove event</haxe_doc>
		</offPointerMove>
		<listensPointerMove public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to pointerMove event</haxe_doc>
		</listensPointerMove>
		<_dox_event_multiTouchPointerDown public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_multiTouchPointerDown>
		<emitMultiTouchPointerDown set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>multiTouchPointerDown event</haxe_doc>
		</emitMultiTouchPointerDown>
		<onMultiTouchPointerDown public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerDown event</haxe_doc>
		</onMultiTouchPointerDown>
		<onceMultiTouchPointerDown public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerDown event</haxe_doc>
		</onceMultiTouchPointerDown>
		<offMultiTouchPointerDown public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerDown event</haxe_doc>
		</offMultiTouchPointerDown>
		<listensMultiTouchPointerDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to multiTouchPointerDown event</haxe_doc>
		</listensMultiTouchPointerDown>
		<_dox_event_multiTouchPointerUp public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_multiTouchPointerUp>
		<emitMultiTouchPointerUp set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>multiTouchPointerUp event</haxe_doc>
		</emitMultiTouchPointerUp>
		<onMultiTouchPointerUp public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerUp event</haxe_doc>
		</onMultiTouchPointerUp>
		<onceMultiTouchPointerUp public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerUp event</haxe_doc>
		</onceMultiTouchPointerUp>
		<offMultiTouchPointerUp public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerUp event</haxe_doc>
		</offMultiTouchPointerUp>
		<listensMultiTouchPointerUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to multiTouchPointerUp event</haxe_doc>
		</listensMultiTouchPointerUp>
		<_dox_event_multiTouchPointerMove public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_multiTouchPointerMove>
		<emitMultiTouchPointerMove set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>multiTouchPointerMove event</haxe_doc>
		</emitMultiTouchPointerMove>
		<onMultiTouchPointerMove public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerMove event</haxe_doc>
		</onMultiTouchPointerMove>
		<onceMultiTouchPointerMove public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerMove event</haxe_doc>
		</onceMultiTouchPointerMove>
		<offMultiTouchPointerMove public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerMove event</haxe_doc>
		</offMultiTouchPointerMove>
		<listensMultiTouchPointerMove public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to multiTouchPointerMove event</haxe_doc>
		</listensMultiTouchPointerMove>
		<_dox_event_focus public="1" set="method" line="637">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_focus>
		<emitFocus set="method" line="1095">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>focus event</haxe_doc>
		</emitFocus>
		<onFocus public="1" set="method" line="1199">
			<f a="owner:handleVisual">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="visual">
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>focus event</haxe_doc>
		</onFocus>
		<onceFocus public="1" set="method" line="1298">
			<f a="owner:handleVisual">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="visual">
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>focus event</haxe_doc>
		</onceFocus>
		<offFocus public="1" set="method" line="1368">
			<f a="?handleVisual">
				<f a="visual">
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>focus event</haxe_doc>
		</offFocus>
		<listensFocus public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to focus event</haxe_doc>
		</listensFocus>
		<_dox_event_blur public="1" set="method" line="637">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_blur>
		<emitBlur set="method" line="1095">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>blur event</haxe_doc>
		</emitBlur>
		<onBlur public="1" set="method" line="1199">
			<f a="owner:handleVisual">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="visual">
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>blur event</haxe_doc>
		</onBlur>
		<onceBlur public="1" set="method" line="1298">
			<f a="owner:handleVisual">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="visual">
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>blur event</haxe_doc>
		</onceBlur>
		<offBlur public="1" set="method" line="1368">
			<f a="?handleVisual">
				<f a="visual">
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>blur event</haxe_doc>
		</offBlur>
		<listensBlur public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to blur event</haxe_doc>
		</listensBlur>
		<backendReady set="method" line="261"><f a=""><x path="Void"/></f></backendReady>
		<updatePointerOverState set="method" line="474"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></updatePointerOverState>
		<resize set="method" line="488"><f a=""><x path="Void"/></f></resize>
		<updateTexturesDensity set="method" line="523"><f a=""><x path="Void"/></f></updateTexturesDensity>
		<updateScaling set="method" line="546">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Recompute screen width, height and density from settings and native state.</haxe_doc>
		</updateScaling>
		<updateTransform set="method" line="617">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Recompute transform from screen width, height and density.</haxe_doc>
		</updateTransform>
		<matchFirstDownListener set="method" line="651">
			<f a="x:y:?touchIndex:?buttonId" v="::-1:-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="ceramic.Visual"/>
			</f>
			<meta><m n=":value"><e>{ buttonId : -1, touchIndex : -1 }</e></m></meta>
		</matchFirstDownListener>
		<matchFirstOverListener set="method" line="734"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="ceramic.Visual"/>
</f></matchFirstOverListener>
		<prepareMultiTouchPointerDown get="inline" set="null" line="822"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></prepareMultiTouchPointerDown>
		<prepareMultiTouchPointerUp get="inline" set="null" line="846"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></prepareMultiTouchPointerUp>
		<prepareMultiTouchPointerMove get="inline" set="null" line="875"><f a="info:isMouse">
	<c path="ceramic.TouchInfo"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></prepareMultiTouchPointerMove>
		<updatePointer get="inline" set="null" line="899"><f a=""><x path="Void"/></f></updatePointer>
		<matchedDownListeners expr="new Map()">
			<t path="Map">
				<x path="Int"/>
				<c path="ceramic.Visual"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</matchedDownListeners>
		<matchedOverListeners expr="new Map()">
			<t path="Map">
				<x path="Int"/>
				<c path="ceramic.Visual"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</matchedOverListeners>
		<didEmitMouseDown get="inline" set="null" line="1012"><f a="buttonId:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></didEmitMouseDown>
		<didEmitMouseUp get="inline" set="null" line="1033"><f a="buttonId:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></didEmitMouseUp>
		<updateMouseOver get="inline" set="null" line="1053"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateMouseOver>
		<didEmitTouchDown get="inline" set="null" line="1092"><f a="touchIndex:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></didEmitTouchDown>
		<didEmitTouchUp get="inline" set="null" line="1113"><f a="touchIndex:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></didEmitTouchUp>
		<updateTouchOver get="inline" set="null" line="1133"><f a="touchIndex:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateTouchOver>
		<hitVisuals expr="[]">
			<c path="Array"><c path="ceramic.Visual"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</hitVisuals>
		<addHitVisual public="1" set="method" line="1183"><f a="visual">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></addHitVisual>
		<removeHitVisual public="1" set="method" line="1194"><f a="visual">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></removeHitVisual>
		<isHitVisual public="1" set="method" line="1209"><f a="visual">
	<c path="ceramic.Visual"/>
	<x path="Bool"/>
</f></isHitVisual>
		<resetDeltas set="method" line="1217"><f a=""><x path="Void"/></f></resetDeltas>
		<willEmitMouseMove set="method" line="1242"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitMouseMove>
		<willEmitMouseDown set="method" line="1251"><f a="buttonId:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitMouseDown>
		<willEmitMouseUp set="method" line="1289"><f a="buttonId:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitMouseUp>
		<willEmitMouseWheel set="method" line="1301"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitMouseWheel>
		<mouseAllowed public="1" get="inline" set="null" line="1323">
			<f a="owner">
				<c path="ceramic.Entity"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Return `true` if mouse events are currently allowed for the given owner.
     * This is only useful on very specific cases.</haxe_doc>
		</mouseAllowed>
		<mousePressed public="1" get="inline" set="null" line="1329">
			<f a="buttonId">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><mousePressed public="1" get="inline" set="null" line="1347"><f a="buttonId:owner">
	<x path="Int"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></mousePressed></overloads>
		</mousePressed>
		<mouseJustPressed public="1" get="inline" set="null" line="1335">
			<f a="buttonId">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><mouseJustPressed public="1" get="inline" set="null" line="1353"><f a="buttonId:owner">
	<x path="Int"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></mouseJustPressed></overloads>
		</mouseJustPressed>
		<mouseJustReleased public="1" get="inline" set="null" line="1341">
			<f a="buttonId">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><mouseJustReleased public="1" get="inline" set="null" line="1359"><f a="buttonId:owner">
	<x path="Int"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></mouseJustReleased></overloads>
		</mouseJustReleased>
		<_mousePressed set="method" line="1365"><f a="buttonId">
	<x path="Int"/>
	<x path="Bool"/>
</f></_mousePressed>
		<_mouseJustPressed set="method" line="1371"><f a="buttonId">
	<x path="Int"/>
	<x path="Bool"/>
</f></_mouseJustPressed>
		<_mouseJustReleased set="method" line="1377"><f a="buttonId">
	<x path="Int"/>
	<x path="Bool"/>
</f></_mouseJustReleased>
		<willEmitTouchMove set="method" line="1385"><f a="touchIndex:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitTouchMove>
		<willEmitTouchDown set="method" line="1402"><f a="touchIndex:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitTouchDown>
		<willEmitTouchUp set="method" line="1442"><f a="touchIndex:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitTouchUp>
		<touchPressed public="1" get="inline" set="null" line="1463">
			<f a="touchIndex">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><touchPressed public="1" get="inline" set="null" line="1481"><f a="touchIndex:owner">
	<x path="Int"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></touchPressed></overloads>
		</touchPressed>
		<touchJustPressed public="1" get="inline" set="null" line="1469">
			<f a="touchIndex">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><touchJustPressed public="1" get="inline" set="null" line="1487"><f a="touchIndex:owner">
	<x path="Int"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></touchJustPressed></overloads>
		</touchJustPressed>
		<touchJustReleased public="1" get="inline" set="null" line="1475">
			<f a="touchIndex">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><touchJustReleased public="1" get="inline" set="null" line="1493"><f a="touchIndex:owner">
	<x path="Int"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></touchJustReleased></overloads>
		</touchJustReleased>
		<_touchPressed set="method" line="1499"><f a="touchIndex">
	<x path="Int"/>
	<x path="Bool"/>
</f></_touchPressed>
		<_touchJustPressed set="method" line="1505"><f a="touchIndex">
	<x path="Int"/>
	<x path="Bool"/>
</f></_touchJustPressed>
		<_touchJustReleased set="method" line="1512"><f a="touchIndex">
	<x path="Int"/>
	<x path="Bool"/>
</f></_touchJustReleased>
		<touchDeltaX public="1" set="method" line="1519"><f a="touchIndex">
	<x path="Int"/>
	<x path="Float"/>
</f></touchDeltaX>
		<touchDeltaY public="1" set="method" line="1526"><f a="touchIndex">
	<x path="Int"/>
	<x path="Float"/>
</f></touchDeltaY>
		<toTexture public="1" set="method" line="1535"><f a="done">
	<f a="texture">
		<c path="ceramic.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></toTexture>
		<toPixels public="1" set="method" line="1551"><f a="done">
	<f a="pixels:width:height">
		<t path="ceramic.UInt8Array"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></toPixels>
		<toPng public="1" get="inline" set="null" line="1557">
			<f a="done">
				<f a="data">
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<overloads><toPng public="1" get="inline" set="null" line="1565"><f a="path:done">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></toPng></overloads>
		</toPng>
		<_toPng set="method" line="1573"><f a="?path:done">
	<c path="String"/>
	<f a="?data">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></_toPng>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new set="method" line="255"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<abstract path="ceramic.ScreenOrientation" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScreenOrientation.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._ScreenOrientation.ScreenOrientation_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScreenOrientation.hx" private="1" module="ceramic.ScreenOrientation" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<PORTRAIT_UPRIGHT public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 0" line="7" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 1 << 0]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PORTRAIT_UPRIGHT>
	<PORTRAIT_UPSIDE_DOWN public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 1" line="9" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 1 << 1]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PORTRAIT_UPSIDE_DOWN>
	<LANDSCAPE_LEFT public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 2" line="11" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 1 << 2]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANDSCAPE_LEFT>
	<LANDSCAPE_RIGHT public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 3" line="13" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 1 << 3]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANDSCAPE_RIGHT>
	<PORTRAIT public="1" get="inline" set="null" expr="cast (1 &lt;&lt; 0) | (1 &lt;&lt; 1)" line="18" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e><![CDATA[cast (1 << 0) | (1 << 1)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Both `PORTRAIT_UPRIGHT` and `PORTRAIT_UPSIDE_DOWN`</haxe_doc>
	</PORTRAIT>
	<LANDSCAPE public="1" get="inline" set="null" expr="cast (1 &lt;&lt; 2) | (1 &lt;&lt; 3)" line="23" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e><![CDATA[cast (1 << 2) | (1 << 3)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Both `LANDSCAPE_LEFT` and `LANDSCAPE_RIGHT`</haxe_doc>
	</LANDSCAPE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._ScreenOrientation.ScreenOrientation_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScreenOrientation.hx" private="1" module="ceramic.ScreenOrientation" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<PORTRAIT_UPRIGHT public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 0" line="7" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 1 << 0]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PORTRAIT_UPRIGHT>
		<PORTRAIT_UPSIDE_DOWN public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 1" line="9" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 1 << 1]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PORTRAIT_UPSIDE_DOWN>
		<LANDSCAPE_LEFT public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 2" line="11" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 1 << 2]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANDSCAPE_LEFT>
		<LANDSCAPE_RIGHT public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 3" line="13" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 1 << 3]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANDSCAPE_RIGHT>
		<PORTRAIT public="1" get="inline" set="null" expr="cast (1 &lt;&lt; 0) | (1 &lt;&lt; 1)" line="18" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e><![CDATA[cast (1 << 0) | (1 << 1)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Both `PORTRAIT_UPRIGHT` and `PORTRAIT_UPSIDE_DOWN`</haxe_doc>
		</PORTRAIT>
		<LANDSCAPE public="1" get="inline" set="null" expr="cast (1 &lt;&lt; 2) | (1 &lt;&lt; 3)" line="23" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e><![CDATA[cast (1 << 2) | (1 << 3)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Both `LANDSCAPE_LEFT` and `LANDSCAPE_RIGHT`</haxe_doc>
		</LANDSCAPE>
		<meta><m n=":enum"/></meta>
	</class>
	<enum path="ceramic.ScreenScaling" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScreenScaling.hx">
		<FIT><haxe_doc>* Screen width and height match target size in settings.
     * Result is scaled to fit into native screen bounds.</haxe_doc></FIT>
		<FILL><haxe_doc>* Screen width and height match target size in settings.
     * Result is scaled to fill native screen area.</haxe_doc></FILL>
		<RESIZE><haxe_doc>* Screen width and height are automatically resized
     * to exactly match native screen size.</haxe_doc></RESIZE>
		<FIT_RESIZE><haxe_doc>* Either width or height is increased so that aspect ratio
     * becomes the same as as native screen's aspect ratio.
     * Result is scaled to fit exactly into native screen bounds.</haxe_doc></FIT_RESIZE>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.Script" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Script.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<MAX_LOOP_ITERATIONS expr="1999999" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1999999</e></m></meta>
		</MAX_LOOP_ITERATIONS>
		<errorHandlers public="1" expr="[]" line="12" static="1">
			<c path="Array"><f a="error:line:char">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</errorHandlers>
		<traceHandlers public="1" expr="[]" line="14" static="1">
			<c path="Array"><f a="v:?pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</traceHandlers>
		<log public="1" set="null" expr="new Logger()" line="16" static="1">
			<c path="ceramic.Logger"/>
			<meta><m n=":value"><e>new Logger()</e></m></meta>
		</log>
		<parser expr="null" line="18" static="1">
			<c path="hscript.Parser"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</parser>
		<content public="1" set="null"><c path="String"/></content>
		<program public="1" set="null"><e path="hscript.Expr"/></program>
		<interp public="1" set="null"><c path="ceramic.Interp"/></interp>
		<module public="1" set="null"><c path="ceramic.ScriptModule"/></module>
		<ready expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</ready>
		<running expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</running>
		<broken expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</broken>
		<loopStates expr="null">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</loopStates>
		<destroy public="1" set="method" line="85" override="1"><f a=""><x path="Void"/></f></destroy>
		<bindAsComponent set="method" line="91"><f a=""><x path="Void"/></f></bindAsComponent>
		<run public="1" set="method" line="108"><f a=""><x path="Void"/></f></run>
		<getEntityById public="1" set="method" line="147"><f a="itemId">
	<c path="String"/>
	<c path="ceramic.Entity"/>
</f></getEntityById>
		<getModule public="1" set="method" line="177"><f a="itemId">
	<c path="String"/>
	<c path="ceramic.ScriptModule"/>
</f></getModule>
		<get public="1" set="method" line="194"><f a="name">
	<c path="String"/>
	<d/>
</f></get>
		<call public="1" set="method" line="200"><f a="name:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<callScriptMethod public="1" set="method" line="226"><f a="name:numArgs:?arg1:?arg2:?arg3">
	<c path="String"/>
	<x path="Int"/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></callScriptMethod>
		<checkLoop set="method" line="253"><f a="index">
	<x path="Int"/>
	<x path="Bool"/>
</f></checkLoop>
		<resetCheckLoop set="method" line="271"><f a="_">
	<x path="Float"/>
	<x path="Void"/>
</f></resetCheckLoop>
		<entity public="1">
			<c path="ceramic.Entity"/>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</entity>
		<setEntity set="method" line="8">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="8">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="36"><f a="content">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="hscript.Interp" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Interp.hx">
		<variables public="1"><t path="Map">
	<c path="String"/>
	<d/>
</t></variables>
		<locals><t path="Map">
	<c path="String"/>
	<a><r><d/></r></a>
</t></locals>
		<binops><t path="Map">
	<c path="String"/>
	<f a=":">
		<e path="hscript.Expr"/>
		<e path="hscript.Expr"/>
		<d/>
	</f>
</t></binops>
		<depth><x path="Int"/></depth>
		<inTry><x path="Bool"/></inTry>
		<declared><c path="Array"><a>
	<old><a><r><d/></r></a></old>
	<n><c path="String"/></n>
</a></c></declared>
		<returnValue><d/></returnValue>
		<resetVariables set="method" line="65"><f a=""><x path="Void"/></f></resetVariables>
		<posInfos public="1" set="method" line="83"><f a=""><t path="haxe.PosInfos"/></f></posInfos>
		<initOps set="method" line="91"><f a=""><x path="Void"/></f></initOps>
		<setVar set="method" line="132"><f a="name:v">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></setVar>
		<assign set="method" line="136"><f a="e1:e2">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<d/>
</f></assign>
		<assignOp set="method" line="163"><f a="op:fop">
	<c path="String"/>
	<f a=":">
		<d/>
		<d/>
		<d/>
	</f>
	<x path="Void"/>
</f></assignOp>
		<evalAssignOp set="method" line="168"><f a="op:fop:e1:e2">
	<c path="String"/>
	<f a=":">
		<d/>
		<d/>
		<d/>
	</f>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<d/>
</f></evalAssignOp>
		<increment set="method" line="199"><f a="e:prefix:delta">
	<e path="hscript.Expr"/>
	<x path="Bool"/>
	<x path="Int"/>
	<d/>
</f></increment>
		<execute public="1" set="method" line="251"><f a="expr">
	<e path="hscript.Expr"/>
	<d/>
</f></execute>
		<exprReturn set="method" line="262"><f a="e">
	<e path="hscript.Expr"/>
	<d/>
</f></exprReturn>
		<duplicate params="T" set="method" line="278"><f a="h">
	<t path="Map">
		<c path="String"/>
		<c path="duplicate.T"/>
	</t>
	<x path="haxe.ds.Map">
		<c path="String"/>
		<x path="Null"><c path="duplicate.T"/></x>
	</x>
</f></duplicate>
		<restore set="method" line="289"><f a="old">
	<x path="Int"/>
	<x path="Void"/>
</f></restore>
		<error get="inline" set="null" line="296">
			<f a="e:?rethrow" v=":false">
				<e path="hscript.Error"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ rethrow : false }</e></m></meta>
		</error>
		<rethrow get="inline" set="null" line="302"><f a="e">
	<d/>
	<x path="Void"/>
</f></rethrow>
		<resolve set="method" line="310"><f a="id">
	<c path="String"/>
	<d/>
</f></resolve>
		<expr public="1" set="method" line="320"><f a="e">
	<e path="hscript.Expr"/>
	<d/>
</f></expr>
		<doWhileLoop set="method" line="590"><f a="econd:e">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<x path="Void"/>
</f></doWhileLoop>
		<whileLoop set="method" line="607"><f a="econd:e">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<x path="Void"/>
</f></whileLoop>
		<makeIterator set="method" line="623"><f a="v">
	<d/>
	<t path="Iterator"><d/></t>
</f></makeIterator>
		<forLoop set="method" line="633"><f a="n:it:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<x path="Void"/>
</f></forLoop>
		<isMap get="inline" set="null" line="652"><f a="o">
	<d/>
	<x path="Bool"/>
</f></isMap>
		<getMapValue get="inline" set="null" line="656"><f a="map:key">
	<d/>
	<d/>
	<d/>
</f></getMapValue>
		<setMapValue get="inline" set="null" line="660"><f a="map:key:value">
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></setMapValue>
		<get set="method" line="664"><f a="o:f">
	<d/>
	<c path="String"/>
	<d/>
</f></get>
		<set set="method" line="680"><f a="o:f:v">
	<d/>
	<c path="String"/>
	<d/>
	<d/>
</f></set>
		<fcall set="method" line="686"><f a="o:f:args">
	<d/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></fcall>
		<call set="method" line="690"><f a="o:f:args">
	<d/>
	<d/>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<cnew set="method" line="694"><f a="cl:args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></cnew>
		<new public="1" set="method" line="54"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="ceramic.Interp" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Script.hx" module="ceramic.Script">
		<extends path="hscript.Interp"/>
		<owner><c path="ceramic.Script"/></owner>
		<fcall set="method" line="291" override="1"><f a="o:f:args">
	<d/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></fcall>
		<get set="method" line="303" override="1"><f a="o:f">
	<d/>
	<c path="String"/>
	<d/>
</f></get>
		<cnew set="method" line="323" override="1"><f a="cl:args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></cnew>
		<exprReturn set="method" line="342" override="1"><f a="e">
	<e path="hscript.Expr"/>
	<d/>
</f></exprReturn>
		<new public="1" set="method" line="283"><f a="owner">
	<c path="ceramic.Script"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="ceramic.ScriptContent" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScriptContent.hx"><c path="String"/></typedef>
	<class path="ceramic.ScriptModule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScriptModule.hx">
		<owner public="1" set="null"><c path="ceramic.Script"/></owner>
		<new public="1" set="method" line="11"><f a="owner">
	<c path="ceramic.Script"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* For now, just a way to identify a script module as a type, to resolve fields dynamically from scripts.
 * Might be extended later to link with "script converted to haxe compiled code"</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.ScriptUtils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScriptUtils.hx">
		<toHscript public="1" set="method" line="15" static="1">
			<f a="code">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts the given `inScript` to hscript.
     * This will take care of transforming a few idioms borrowed from js/ts to hscript equivalent.
     * @param inScript 
     * @return String</haxe_doc>
		</toHscript>
		<cleanCode set="method" line="169" static="1"><f a="code">
	<c path="String"/>
	<c path="String"/>
</f></cleanCode>
		<fail set="method" line="289" static="1"><f a="error:i:code">
	<d/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></fail>
		<RE_WORD expr="~/^[a-zA-Z0-9_]+/" line="297" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^[a-zA-Z0-9_]+/</e></m></meta>
		</RE_WORD>
		<RE_SEP_WORD expr="~/^[^a-zA-Z0-9_]([a-zA-Z0-9_]+)/" line="299" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^[^a-zA-Z0-9_]([a-zA-Z0-9_]+)/</e></m></meta>
		</RE_SEP_WORD>
		<RE_STRING expr="~/^(?:&quot;(?:[^&quot;\\]*(?:\\.[^&quot;\\]*)*)&quot;|&apos;(?:[^&apos;\\]*(?:\\.[^&apos;\\]*)*)&apos;|`(?:[^`\\]*(?:\\.[^`\\]*)*)`)/" line="301" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^(?:"(?:[^"\\]*(?:\\.[^"\\]*)*)"|'(?:[^'\\]*(?:\\.[^'\\]*)*)'|`(?:[^`\\]*(?:\\.[^`\\]*)*)`)/</e></m></meta>
		</RE_STRING>
		<RE_FOR_OF expr="~/^for\s*\(\s*(var\s+)?([a-zA-Z0-9_]+)\s*(of|in)\s+/" line="303" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^for\s*\(\s*(var\s+)?([a-zA-Z0-9_]+)\s*(of|in)\s+/</e></m></meta>
		</RE_FOR_OF>
		<RE_WHILE_START expr="~/^while\s*\(/" line="305" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^while\s*\(/</e></m></meta>
		</RE_WHILE_START>
		<RE_ARROW_FUNC_NO_ARG expr="~/^\(\s*\)\s*=&gt;/" line="307" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e><![CDATA[~/^\(\s*\)\s*=>/]]></e></m></meta>
		</RE_ARROW_FUNC_NO_ARG>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="ceramic.ScrollDirection" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScrollDirection.hx">
		<HORIZONTAL/>
		<VERTICAL/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.Scroller" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Scroller.hx">
		<extends path="ceramic.Visual"/>
		<_point expr="new Point(0, 0)" line="10" static="1">
			<c path="ceramic.Point"/>
			<meta><m n=":value"><e>new Point(0, 0)</e></m></meta>
		</_point>
		<threshold public="1" expr="4.0" line="97" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>4.0</e></m></meta>
		</threshold>
		<_dox_event_dragStart public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_dragStart>
		<emitDragStart set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>dragStart event</haxe_doc>
		</emitDragStart>
		<onDragStart public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dragStart event</haxe_doc>
		</onDragStart>
		<onceDragStart public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dragStart event</haxe_doc>
		</onceDragStart>
		<offDragStart public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dragStart event</haxe_doc>
		</offDragStart>
		<listensDragStart public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to dragStart event</haxe_doc>
		</listensDragStart>
		<_dox_event_dragEnd public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_dragEnd>
		<emitDragEnd set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>dragEnd event</haxe_doc>
		</emitDragEnd>
		<onDragEnd public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dragEnd event</haxe_doc>
		</onDragEnd>
		<onceDragEnd public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dragEnd event</haxe_doc>
		</onceDragEnd>
		<offDragEnd public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dragEnd event</haxe_doc>
		</offDragEnd>
		<listensDragEnd public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to dragEnd event</haxe_doc>
		</listensDragEnd>
		<_dox_event_wheelStart public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_wheelStart>
		<emitWheelStart set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>wheelStart event</haxe_doc>
		</emitWheelStart>
		<onWheelStart public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>wheelStart event</haxe_doc>
		</onWheelStart>
		<onceWheelStart public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>wheelStart event</haxe_doc>
		</onceWheelStart>
		<offWheelStart public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>wheelStart event</haxe_doc>
		</offWheelStart>
		<listensWheelStart public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to wheelStart event</haxe_doc>
		</listensWheelStart>
		<_dox_event_wheelEnd public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_wheelEnd>
		<emitWheelEnd set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>wheelEnd event</haxe_doc>
		</emitWheelEnd>
		<onWheelEnd public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>wheelEnd event</haxe_doc>
		</onWheelEnd>
		<onceWheelEnd public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>wheelEnd event</haxe_doc>
		</onceWheelEnd>
		<offWheelEnd public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>wheelEnd event</haxe_doc>
		</offWheelEnd>
		<listensWheelEnd public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to wheelEnd event</haxe_doc>
		</listensWheelEnd>
		<_dox_event_click public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_click>
		<emitClick set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>click event</haxe_doc>
		</emitClick>
		<onClick public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>click event</haxe_doc>
		</onClick>
		<onceClick public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>click event</haxe_doc>
		</onceClick>
		<offClick public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>click event</haxe_doc>
		</offClick>
		<listensClick public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to click event</haxe_doc>
		</listensClick>
		<_dox_event_scrollerPointerDown public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_scrollerPointerDown>
		<emitScrollerPointerDown set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>scrollerPointerDown event</haxe_doc>
		</emitScrollerPointerDown>
		<onScrollerPointerDown public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>scrollerPointerDown event</haxe_doc>
		</onScrollerPointerDown>
		<onceScrollerPointerDown public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>scrollerPointerDown event</haxe_doc>
		</onceScrollerPointerDown>
		<offScrollerPointerDown public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>scrollerPointerDown event</haxe_doc>
		</offScrollerPointerDown>
		<listensScrollerPointerDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to scrollerPointerDown event</haxe_doc>
		</listensScrollerPointerDown>
		<_dox_event_scrollerPointerUp public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_scrollerPointerUp>
		<emitScrollerPointerUp set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>scrollerPointerUp event</haxe_doc>
		</emitScrollerPointerUp>
		<onScrollerPointerUp public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>scrollerPointerUp event</haxe_doc>
		</onScrollerPointerUp>
		<onceScrollerPointerUp public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>scrollerPointerUp event</haxe_doc>
		</onceScrollerPointerUp>
		<offScrollerPointerUp public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>scrollerPointerUp event</haxe_doc>
		</offScrollerPointerUp>
		<listensScrollerPointerUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to scrollerPointerUp event</haxe_doc>
		</listensScrollerPointerUp>
		<content public="1" set="null" expr="null">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</content>
		<scrollbar public="1" set="accessor" expr="null">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scrollbar>
		<set_scrollbar set="method" line="33"><f a="scrollbar">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
</f></set_scrollbar>
		<direction public="1" expr="VERTICAL">
			<e path="ceramic.ScrollDirection"/>
			<meta><m n=":value"><e>VERTICAL</e></m></meta>
		</direction>
		<allowPointerOutside public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</allowPointerOutside>
		<scrollTransform public="1" set="null" expr="new Transform()">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</scrollTransform>
		<scrollEnabled public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</scrollEnabled>
		<dragEnabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</dragEnabled>
		<roundScrollWhenIdle public="1" set="accessor" expr="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* If set to a value above zero, scrollX and scrollY will be rounded when scroller is idle.
     *
     * ```haxe
     * roundScrollWhenIdle = 0; // No rounding (default)
     * roundScrollWhenIdle = 1; // Pixel perfect rounding
     * roundScrollWhenIdle = 2; // Half-pixel rounding
     * ```</haxe_doc>
		</roundScrollWhenIdle>
		<set_roundScrollWhenIdle set="method" line="68"><f a="roundScrollWhenIdle">
	<x path="Int"/>
	<x path="Int"/>
</f></set_roundScrollWhenIdle>
		<status public="1" set="accessor" expr="IDLE">
			<e path="ceramic.ScrollerStatus"/>
			<meta><m n=":value"><e>IDLE</e></m></meta>
		</status>
		<set_status set="method" line="79"><f a="status">
	<e path="ceramic.ScrollerStatus"/>
	<e path="ceramic.ScrollerStatus"/>
</f></set_status>
		<verticalToHorizontalWheel public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* When set to `true`, vertical mouse wheel event
     * will also work on horizontal scroller.</haxe_doc>
		</verticalToHorizontalWheel>
		<deceleration public="1" expr="300.0">
			<x path="Float"/>
			<meta><m n=":value"><e>300.0</e></m></meta>
		</deceleration>
		<wheelDeceleration public="1" expr="1600.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1600.0</e></m></meta>
		</wheelDeceleration>
		<wheelFactor public="1" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</wheelFactor>
		<wheelMomentum public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</wheelMomentum>
		<wheelEndDelay public="1" expr="0.25">
			<x path="Float"/>
			<meta><m n=":value"><e>0.25</e></m></meta>
		</wheelEndDelay>
		<overScrollResistance public="1" expr="5.0">
			<x path="Float"/>
			<meta><m n=":value"><e>5.0</e></m></meta>
		</overScrollResistance>
		<maxClickMomentum public="1" expr="100.0">
			<x path="Float"/>
			<meta><m n=":value"><e>100.0</e></m></meta>
		</maxClickMomentum>
		<bounceMomentumFactor public="1" expr="0.00075">
			<x path="Float"/>
			<meta><m n=":value"><e>0.00075</e></m></meta>
		</bounceMomentumFactor>
		<bounceMinDuration public="1" expr="0.08">
			<x path="Float"/>
			<meta><m n=":value"><e>0.08</e></m></meta>
		</bounceMinDuration>
		<bounceDurationFactor public="1" expr="0.00004">
			<x path="Float"/>
			<meta><m n=":value"><e>0.00004</e></m></meta>
		</bounceDurationFactor>
		<bounceNoMomentumDuration public="1" expr="0.1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.1</e></m></meta>
		</bounceNoMomentumDuration>
		<dragFactor public="1" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</dragFactor>
		<touchableStrictHierarchy public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</touchableStrictHierarchy>
		<prevPointerX expr="-999999">
			<x path="Float"/>
			<meta><m n=":value"><e>-999999</e></m></meta>
		</prevPointerX>
		<prevPointerY expr="-999999">
			<x path="Float"/>
			<meta><m n=":value"><e>-999999</e></m></meta>
		</prevPointerY>
		<destroy public="1" set="method" line="166" override="1"><f a=""><x path="Void"/></f></destroy>
		<set_scrollEnabled set="method" line="177"><f a="scrollEnabled">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_scrollEnabled>
		<set_width set="method" line="196" override="1"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="208" override="1"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<interceptPointerDown set="method" line="220" override="1"><f a="hittingVisual:x:y:touchIndex:buttonId">
	<c path="ceramic.Visual"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></interceptPointerDown>
		<interceptPointerOver set="method" line="230" override="1"><f a="hittingVisual:x:y">
	<c path="ceramic.Visual"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></interceptPointerOver>
		<scrollToBounds public="1" set="method" line="245"><f a=""><x path="Void"/></f></scrollToBounds>
		<isContentPositionInBounds public="1" set="method" line="266"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isContentPositionInBounds>
		<ensureContentPositionIsInBounds public="1" set="method" line="282"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></ensureContentPositionIsInBounds>
		<scrollX public="1" get="accessor" set="accessor"><x path="Float"/></scrollX>
		<get_scrollX get="inline" set="null" line="328"><f a=""><x path="Float"/></f></get_scrollX>
		<set_scrollX get="inline" set="null" line="331"><f a="scrollX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scrollX>
		<scrollY public="1" get="accessor" set="accessor"><x path="Float"/></scrollY>
		<get_scrollY get="inline" set="null" line="339"><f a=""><x path="Float"/></f></get_scrollY>
		<set_scrollY get="inline" set="null" line="342"><f a="scrollY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scrollY>
		<position expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</position>
		<contentStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</contentStart>
		<pointerStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pointerStart>
		<touchIndex expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</touchIndex>
		<scrollVelocity public="1" set="null" expr="null">
			<c path="ceramic.Velocity"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scrollVelocity>
		<momentum public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</momentum>
		<overScrollRelease expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</overScrollRelease>
		<fromWheel expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</fromWheel>
		<lastWheelEventTime expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</lastWheelEventTime>
		<canClick expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</canClick>
		<tweenX expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</tweenX>
		<tweenY expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</tweenY>
		<animating expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</animating>
		<snapping expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</snapping>
		<pointerOnScroller expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pointerOnScroller>
		<pointerOnScrollerChild expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pointerOnScrollerChild>
		<blockingDefaultScroll expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</blockingDefaultScroll>
		<startTracking set="method" line="387"><f a=""><x path="Void"/></f></startTracking>
		<stopTracking set="method" line="402"><f a=""><x path="Void"/></f></stopTracking>
		<pointerOver set="method" line="424"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></pointerOver>
		<pointerOut set="method" line="430"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></pointerOut>
		<mouseWheel set="method" line="436"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></mouseWheel>
		<pointerDown set="method" line="515"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></pointerDown>
		<pointerUp set="method" line="580"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></pointerUp>
		<screenFocus set="method" line="625"><f a="focusedVisual">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></screenFocus>
		<isOverScrollingTop public="1" get="inline" set="null" line="643"><f a=""><x path="Bool"/></f></isOverScrollingTop>
		<isOverScrollingBottom public="1" get="inline" set="null" line="649"><f a=""><x path="Bool"/></f></isOverScrollingBottom>
		<isOverScrollingLeft public="1" get="inline" set="null" line="655"><f a=""><x path="Bool"/></f></isOverScrollingLeft>
		<isOverScrollingRight public="1" get="inline" set="null" line="661"><f a=""><x path="Bool"/></f></isOverScrollingRight>
		<roundScrollIfNeeded set="method" line="669"><f a=""><x path="Void"/></f></roundScrollIfNeeded>
		<update set="method" line="686"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateScrollbar set="method" line="756"><f a=""><x path="Void"/></f></updateScrollbar>
		<scrollbarDownX expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</scrollbarDownX>
		<scrollbarDownY expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</scrollbarDownY>
		<scrollbarStartX expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</scrollbarStartX>
		<scrollbarStartY expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</scrollbarStartY>
		<bindScrollbar set="method" line="793"><f a="scrollbar">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></bindScrollbar>
		<handleScrollbarDown set="method" line="803"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handleScrollbarDown>
		<handleScrollbarUp set="method" line="820"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handleScrollbarUp>
		<handleScrollbarMove set="method" line="826"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handleScrollbarMove>
		<scrollUpdate set="method" line="843">
			<f a="pointerX:pointerY:delta:?minusDelta" v=":::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ minusDelta : 0 }</e></m></meta>
		</scrollUpdate>
		<stop public="1" set="method" line="1012" override="1"><f a=""><x path="Void"/></f></stop>
		<stopTweens public="1" get="inline" set="null" line="1023"><f a=""><x path="Void"/></f></stopTweens>
		<scrollTo public="1" set="method" line="1032"><f a="scrollX:scrollY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollTo>
		<smoothScrollTo public="1" set="method" line="1041">
			<f a="scrollX:scrollY:?duration:?easing" v="::0.15:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="ceramic.Easing"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ duration : 0.15 }</e></m></meta>
		</smoothScrollTo>
		<snapTo public="1" set="method" line="1088">
			<f a="scrollX:scrollY:?duration:?easing" v="::0.15:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="ceramic.Easing"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ duration : 0.15 }</e></m></meta>
		</snapTo>
		<bounceScroll public="1" set="method" line="1104"><f a=""><x path="Void"/></f></bounceScroll>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="141"><f a="?content">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<enum path="ceramic.ScrollerStatus" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScrollerStatus.hx">
		<IDLE><haxe_doc>* Nothing happening</haxe_doc></IDLE>
		<TOUCHING><haxe_doc>* Being touched, but not dragging yet</haxe_doc></TOUCHING>
		<DRAGGING><haxe_doc>* Being dragged by a touch/mouse event</haxe_doc></DRAGGING>
		<SCROLLING><haxe_doc>* Scrolling after dragging has ended</haxe_doc></SCROLLING>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.SeedRandom" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SeedRandom.hx">
		<seed public="1" set="null"><x path="Float"/></seed>
		<initialSeed public="1" set="null"><x path="Float"/></initialSeed>
		<random public="1" get="inline" set="null" line="60">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns a float number between [0,1)</haxe_doc>
		</random>
		<between public="1" get="inline" set="null" line="67">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Return an integer between [min, max).</haxe_doc>
		</between>
		<reset public="1" get="inline" set="null" line="74">
			<f a="?initialSeed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Reset the initial value to that of the current seed.</haxe_doc>
		</reset>
		<new public="1" get="inline" set="null" line="46"><f a="seed">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Seeded random number generator to get reproducible sequences of values.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.SelectText" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SelectText.hx">
		<extends path="ceramic.Entity"/>
		<implements path="tracker.Observable"/>
		<implements path="ceramic.Component"/>
		<_point expr="new Point()" line="15" static="1">
			<c path="ceramic.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
		</_point>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.SelectText"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.SelectText"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.SelectText"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.SelectText"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.SelectText"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<_dox_event_selection public="1" set="method" line="637">
			<f a="selectionStart:selectionEnd:inverted">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_selection>
		<emitSelection set="method" line="1095">
			<f a="selectionStart:selectionEnd:inverted">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>selection event</haxe_doc>
		</emitSelection>
		<onSelection public="1" set="method" line="1199">
			<f a="owner:handleSelectionStartSelectionEndInverted">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="selectionStart:selectionEnd:inverted">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>selection event</haxe_doc>
		</onSelection>
		<onceSelection public="1" set="method" line="1298">
			<f a="owner:handleSelectionStartSelectionEndInverted">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="selectionStart:selectionEnd:inverted">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>selection event</haxe_doc>
		</onceSelection>
		<offSelection public="1" set="method" line="1368">
			<f a="?handleSelectionStartSelectionEndInverted">
				<f a="selectionStart:selectionEnd:inverted">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>selection event</haxe_doc>
		</offSelection>
		<listensSelection public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to selection event</haxe_doc>
		</listensSelection>
		<entity public="1">
			<c path="ceramic.Text"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<selectionColor public="1"><x path="ceramic.Color"/></selectionColor>
		<textCursorColor public="1"><x path="ceramic.Color"/></textCursorColor>
		<textCursorOffsetX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</textCursorOffsetX>
		<textCursorOffsetY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</textCursorOffsetY>
		<textCursorHeightFactor public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</textCursorHeightFactor>
		<invalidateContainer public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateContainer>
		<container public="1" expr="null">
			<c path="ceramic.Visual"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Optional container on which pointer events are bound</haxe_doc>
		</container>
		<unobservedContainer>
			<c path="ceramic.Visual"/>
			<haxe_doc></haxe_doc>
		</unobservedContainer>
		<_dox_event_containerChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.Visual"/>
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when container field changes.</haxe_doc>
		</_dox_event_containerChange>
		<emitContainerChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.Visual"/>
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when container field changes.</haxe_doc>
		</emitContainerChange>
		<onContainerChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Visual"/>
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when container field changes.</haxe_doc>
		</onContainerChange>
		<onceContainerChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Visual"/>
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when container field changes.</haxe_doc>
		</onceContainerChange>
		<offContainerChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.Visual"/>
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when container field changes.</haxe_doc>
		</offContainerChange>
		<listensContainerChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when container field changes.</haxe_doc>
		</listensContainerChange>
		<invalidateAllowSelectingFromPointer public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateAllowSelectingFromPointer>
		<allowSelectingFromPointer public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="observe"/>
			</meta>
		</allowSelectingFromPointer>
		<unobservedAllowSelectingFromPointer>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedAllowSelectingFromPointer>
		<_dox_event_allowSelectingFromPointerChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when allowSelectingFromPointer field changes.</haxe_doc>
		</_dox_event_allowSelectingFromPointerChange>
		<emitAllowSelectingFromPointerChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when allowSelectingFromPointer field changes.</haxe_doc>
		</emitAllowSelectingFromPointerChange>
		<onAllowSelectingFromPointerChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when allowSelectingFromPointer field changes.</haxe_doc>
		</onAllowSelectingFromPointerChange>
		<onceAllowSelectingFromPointerChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when allowSelectingFromPointer field changes.</haxe_doc>
		</onceAllowSelectingFromPointerChange>
		<offAllowSelectingFromPointerChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when allowSelectingFromPointer field changes.</haxe_doc>
		</offAllowSelectingFromPointerChange>
		<listensAllowSelectingFromPointerChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when allowSelectingFromPointer field changes.</haxe_doc>
		</listensAllowSelectingFromPointerChange>
		<invalidateShowCursor public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateShowCursor>
		<showCursor public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="observe"/>
			</meta>
		</showCursor>
		<unobservedShowCursor>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedShowCursor>
		<_dox_event_showCursorChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when showCursor field changes.</haxe_doc>
		</_dox_event_showCursorChange>
		<emitShowCursorChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when showCursor field changes.</haxe_doc>
		</emitShowCursorChange>
		<onShowCursorChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when showCursor field changes.</haxe_doc>
		</onShowCursorChange>
		<onceShowCursorChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when showCursor field changes.</haxe_doc>
		</onceShowCursorChange>
		<offShowCursorChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when showCursor field changes.</haxe_doc>
		</offShowCursorChange>
		<listensShowCursorChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when showCursor field changes.</haxe_doc>
		</listensShowCursorChange>
		<invalidateSelectionStart public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateSelectionStart>
		<selectionStart public="1" expr="-1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="observe"/>
			</meta>
		</selectionStart>
		<unobservedSelectionStart>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedSelectionStart>
		<_dox_event_selectionStartChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when selectionStart field changes.</haxe_doc>
		</_dox_event_selectionStartChange>
		<emitSelectionStartChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when selectionStart field changes.</haxe_doc>
		</emitSelectionStartChange>
		<onSelectionStartChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionStart field changes.</haxe_doc>
		</onSelectionStartChange>
		<onceSelectionStartChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionStart field changes.</haxe_doc>
		</onceSelectionStartChange>
		<offSelectionStartChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionStart field changes.</haxe_doc>
		</offSelectionStartChange>
		<listensSelectionStartChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionStart field changes.</haxe_doc>
		</listensSelectionStartChange>
		<invalidateSelectionEnd public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateSelectionEnd>
		<selectionEnd public="1" expr="-1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="observe"/>
			</meta>
		</selectionEnd>
		<unobservedSelectionEnd>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedSelectionEnd>
		<_dox_event_selectionEndChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when selectionEnd field changes.</haxe_doc>
		</_dox_event_selectionEndChange>
		<emitSelectionEndChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when selectionEnd field changes.</haxe_doc>
		</emitSelectionEndChange>
		<onSelectionEndChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionEnd field changes.</haxe_doc>
		</onSelectionEndChange>
		<onceSelectionEndChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionEnd field changes.</haxe_doc>
		</onceSelectionEndChange>
		<offSelectionEndChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionEnd field changes.</haxe_doc>
		</offSelectionEndChange>
		<listensSelectionEndChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionEnd field changes.</haxe_doc>
		</listensSelectionEndChange>
		<invalidateInvertedSelection public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateInvertedSelection>
		<invertedSelection public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="observe"/>
			</meta>
		</invertedSelection>
		<unobservedInvertedSelection>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedInvertedSelection>
		<_dox_event_invertedSelectionChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when invertedSelection field changes.</haxe_doc>
		</_dox_event_invertedSelectionChange>
		<emitInvertedSelectionChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when invertedSelection field changes.</haxe_doc>
		</emitInvertedSelectionChange>
		<onInvertedSelectionChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when invertedSelection field changes.</haxe_doc>
		</onInvertedSelectionChange>
		<onceInvertedSelectionChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when invertedSelection field changes.</haxe_doc>
		</onceInvertedSelectionChange>
		<offInvertedSelectionChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when invertedSelection field changes.</haxe_doc>
		</offInvertedSelectionChange>
		<listensInvertedSelectionChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when invertedSelection field changes.</haxe_doc>
		</listensInvertedSelectionChange>
		<invalidatePointerIsDown public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidatePointerIsDown>
		<pointerIsDown public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="observe"/>
			</meta>
		</pointerIsDown>
		<unobservedPointerIsDown>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedPointerIsDown>
		<_dox_event_pointerIsDownChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when pointerIsDown field changes.</haxe_doc>
		</_dox_event_pointerIsDownChange>
		<emitPointerIsDownChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when pointerIsDown field changes.</haxe_doc>
		</emitPointerIsDownChange>
		<onPointerIsDownChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pointerIsDown field changes.</haxe_doc>
		</onPointerIsDownChange>
		<oncePointerIsDownChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pointerIsDown field changes.</haxe_doc>
		</oncePointerIsDownChange>
		<offPointerIsDownChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pointerIsDown field changes.</haxe_doc>
		</offPointerIsDownChange>
		<listensPointerIsDownChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pointerIsDown field changes.</haxe_doc>
		</listensPointerIsDownChange>
		<boundContainer expr="null">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</boundContainer>
		<doubleClick expr="null">
			<c path="ceramic.DoubleClick"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</doubleClick>
		<didDoubleClick expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</didDoubleClick>
		<selectionBackgrounds expr="[]">
			<c path="Array"><c path="ceramic.Quad"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</selectionBackgrounds>
		<willUpdateSelection expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</willUpdateSelection>
		<textCursor expr="null">
			<c path="ceramic.Quad"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</textCursor>
		<textCursorToggleVisibilityTime expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</textCursorToggleVisibilityTime>
		<bindAsComponent set="method" line="82"><f a=""><x path="Void"/></f></bindAsComponent>
		<updateFromSelection set="method" line="101"><f a=""><x path="Void"/></f></updateFromSelection>
		<updateSelectionGraphics set="method" line="117"><f a=""><x path="Void"/></f></updateSelectionGraphics>
		<doUpdateSelectionGraphics set="method" line="126"><f a=""><x path="Void"/></f></doUpdateSelectionGraphics>
		<clearSelectionGraphics set="method" line="333"><f a=""><x path="Void"/></f></clearSelectionGraphics>
		<handleShowCursorChange set="method" line="347"><f a="_:_">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></handleShowCursorChange>
		<updateCursorVisibility set="method" line="353"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></updateCursorVisibility>
		<resetCursorVisibility set="method" line="375"><f a=""><x path="Void"/></f></resetCursorVisibility>
		<updatePointerEventBindings set="method" line="386"><f a=""><x path="Void"/></f></updatePointerEventBindings>
		<indexFromScreenPosition set="method" line="428"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></indexFromScreenPosition>
		<handlePointerDown set="method" line="442"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerDown>
		<handlePointerMove set="method" line="460"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerMove>
		<handlePointerUp set="method" line="466"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerUp>
		<updateSelectionFromMovingPointer set="method" line="483"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateSelectionFromMovingPointer>
		<isSelectionBoundChararacter get="inline" set="null" line="512"><f a="c">
	<c path="String"/>
	<x path="Bool"/>
</f></isSelectionBoundChararacter>
		<handleDoubleClick set="method" line="520"><f a=""><x path="Void"/></f></handleDoubleClick>
		<bindKeyBindings set="method" line="562"><f a=""><x path="Void"/></f></bindKeyBindings>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<setEntity set="method" line="11">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="11">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="70">
			<f a="selectionColor:textCursorColor:?textCursorOffsetX:?textCursorOffsetY:?textCursorHeightFactor" v="::0:0:1">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ textCursorHeightFactor : 1, textCursorOffsetY : 0, textCursorOffsetX : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Settings" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Settings.hx">
		<implements path="tracker.Observable"/>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Settings"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Settings"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Settings"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Settings"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.Settings"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<invalidateTargetWidth public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTargetWidth>
		<targetWidth public="1" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Target width. Affects window size at startup (unless `windowWidth` is specified)
     * and affects screen scaling at any time.
     * Ignored if set to 0 (default)</haxe_doc>
		</targetWidth>
		<unobservedTargetWidth>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedTargetWidth>
		<_dox_event_targetWidthChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when targetWidth field changes.</haxe_doc>
		</_dox_event_targetWidthChange>
		<emitTargetWidthChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when targetWidth field changes.</haxe_doc>
		</emitTargetWidthChange>
		<onTargetWidthChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetWidth field changes.</haxe_doc>
		</onTargetWidthChange>
		<onceTargetWidthChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetWidth field changes.</haxe_doc>
		</onceTargetWidthChange>
		<offTargetWidthChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetWidth field changes.</haxe_doc>
		</offTargetWidthChange>
		<listensTargetWidthChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetWidth field changes.</haxe_doc>
		</listensTargetWidthChange>
		<invalidateTargetHeight public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTargetHeight>
		<targetHeight public="1" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Target height. Affects window size at startup (unless `windowHeight` is specified)
     * and affects screen scaling at any time.
     * Ignored if set to 0 (default)</haxe_doc>
		</targetHeight>
		<unobservedTargetHeight>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedTargetHeight>
		<_dox_event_targetHeightChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when targetHeight field changes.</haxe_doc>
		</_dox_event_targetHeightChange>
		<emitTargetHeightChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when targetHeight field changes.</haxe_doc>
		</emitTargetHeightChange>
		<onTargetHeightChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetHeight field changes.</haxe_doc>
		</onTargetHeightChange>
		<onceTargetHeightChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetHeight field changes.</haxe_doc>
		</onceTargetHeightChange>
		<offTargetHeightChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetHeight field changes.</haxe_doc>
		</offTargetHeightChange>
		<listensTargetHeightChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetHeight field changes.</haxe_doc>
		</listensTargetHeightChange>
		<targetSize public="1" get="inline" set="null" line="31">
			<f a="targetWidth:targetHeight">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Target width and height. Affects window size at startup
     * and affects screen scaling at any time.
     * Ignored if set to 0 (default)
     * @param targetWidth Target width
     * @param targetHeight Target height</haxe_doc>
		</targetSize>
		<invalidateWindowWidth public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateWindowWidth>
		<windowWidth public="1" set="null" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Target window width at startup
     * Uses `targetWidth` as fallback if set to 0 (default)</haxe_doc>
		</windowWidth>
		<unobservedWindowWidth>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedWindowWidth>
		<_dox_event_windowWidthChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when windowWidth field changes.</haxe_doc>
		</_dox_event_windowWidthChange>
		<emitWindowWidthChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when windowWidth field changes.</haxe_doc>
		</emitWindowWidthChange>
		<onWindowWidthChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowWidth field changes.</haxe_doc>
		</onWindowWidthChange>
		<onceWindowWidthChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowWidth field changes.</haxe_doc>
		</onceWindowWidthChange>
		<offWindowWidthChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowWidth field changes.</haxe_doc>
		</offWindowWidthChange>
		<listensWindowWidthChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowWidth field changes.</haxe_doc>
		</listensWindowWidthChange>
		<invalidateWindowHeight public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateWindowHeight>
		<windowHeight public="1" set="null" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Target window height at startup
     * Uses `targetHeight` as fallback if set to 0 (default)</haxe_doc>
		</windowHeight>
		<unobservedWindowHeight>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedWindowHeight>
		<_dox_event_windowHeightChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when windowHeight field changes.</haxe_doc>
		</_dox_event_windowHeightChange>
		<emitWindowHeightChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when windowHeight field changes.</haxe_doc>
		</emitWindowHeightChange>
		<onWindowHeightChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowHeight field changes.</haxe_doc>
		</onWindowHeightChange>
		<onceWindowHeightChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowHeight field changes.</haxe_doc>
		</onceWindowHeightChange>
		<offWindowHeightChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowHeight field changes.</haxe_doc>
		</offWindowHeightChange>
		<listensWindowHeightChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowHeight field changes.</haxe_doc>
		</listensWindowHeightChange>
		<invalidateTargetDensity public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTargetDensity>
		<targetDensity public="1" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Target density. Affects the quality of textures
     * being loaded. Changing it at runtime will update
     * texture quality if needed.
     * Ignored if set to 0 (default)</haxe_doc>
		</targetDensity>
		<unobservedTargetDensity>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedTargetDensity>
		<_dox_event_targetDensityChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when targetDensity field changes.</haxe_doc>
		</_dox_event_targetDensityChange>
		<emitTargetDensityChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when targetDensity field changes.</haxe_doc>
		</emitTargetDensityChange>
		<onTargetDensityChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetDensity field changes.</haxe_doc>
		</onTargetDensityChange>
		<onceTargetDensityChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetDensity field changes.</haxe_doc>
		</onceTargetDensityChange>
		<offTargetDensityChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetDensity field changes.</haxe_doc>
		</offTargetDensityChange>
		<listensTargetDensityChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetDensity field changes.</haxe_doc>
		</listensTargetDensityChange>
		<invalidateBackground public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateBackground>
		<background public="1" expr="Color.BLACK">
			<x path="ceramic.Color"/>
			<meta>
				<m n=":value"><e>Color.BLACK</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Background color.</haxe_doc>
		</background>
		<unobservedBackground>
			<x path="ceramic.Color"/>
			<haxe_doc></haxe_doc>
		</unobservedBackground>
		<_dox_event_backgroundChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when background field changes.</haxe_doc>
		</_dox_event_backgroundChange>
		<emitBackgroundChange set="method" line="1095">
			<f a="current:previous">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when background field changes.</haxe_doc>
		</emitBackgroundChange>
		<onBackgroundChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="ceramic.Color"/>
					<x path="ceramic.Color"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when background field changes.</haxe_doc>
		</onBackgroundChange>
		<onceBackgroundChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="ceramic.Color"/>
					<x path="ceramic.Color"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when background field changes.</haxe_doc>
		</onceBackgroundChange>
		<offBackgroundChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="ceramic.Color"/>
					<x path="ceramic.Color"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when background field changes.</haxe_doc>
		</offBackgroundChange>
		<listensBackgroundChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when background field changes.</haxe_doc>
		</listensBackgroundChange>
		<invalidateScaling public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateScaling>
		<scaling public="1" expr="FIT">
			<e path="ceramic.ScreenScaling"/>
			<meta>
				<m n=":value"><e>FIT</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Screen scaling (FIT, FILL, RESIZE or FIT_RESIZE).</haxe_doc>
		</scaling>
		<unobservedScaling>
			<e path="ceramic.ScreenScaling"/>
			<haxe_doc></haxe_doc>
		</unobservedScaling>
		<_dox_event_scalingChange public="1" set="method" line="637">
			<f a="current:previous">
				<e path="ceramic.ScreenScaling"/>
				<e path="ceramic.ScreenScaling"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when scaling field changes.</haxe_doc>
		</_dox_event_scalingChange>
		<emitScalingChange set="method" line="1095">
			<f a="current:previous">
				<e path="ceramic.ScreenScaling"/>
				<e path="ceramic.ScreenScaling"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when scaling field changes.</haxe_doc>
		</emitScalingChange>
		<onScalingChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.ScreenScaling"/>
					<e path="ceramic.ScreenScaling"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when scaling field changes.</haxe_doc>
		</onScalingChange>
		<onceScalingChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.ScreenScaling"/>
					<e path="ceramic.ScreenScaling"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when scaling field changes.</haxe_doc>
		</onceScalingChange>
		<offScalingChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<e path="ceramic.ScreenScaling"/>
					<e path="ceramic.ScreenScaling"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when scaling field changes.</haxe_doc>
		</offScalingChange>
		<listensScalingChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when scaling field changes.</haxe_doc>
		</listensScalingChange>
		<invalidateTitle public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTitle>
		<title public="1" expr="&quot;App&quot;">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"App"</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* App window title.</haxe_doc>
		</title>
		<unobservedTitle>
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</unobservedTitle>
		<_dox_event_titleChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when title field changes.</haxe_doc>
		</_dox_event_titleChange>
		<emitTitleChange set="method" line="1095">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when title field changes.</haxe_doc>
		</emitTitleChange>
		<onTitleChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when title field changes.</haxe_doc>
		</onTitleChange>
		<onceTitleChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when title field changes.</haxe_doc>
		</onceTitleChange>
		<offTitleChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when title field changes.</haxe_doc>
		</offTitleChange>
		<listensTitleChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when title field changes.</haxe_doc>
		</listensTitleChange>
		<invalidateFullscreen public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateFullscreen>
		<fullscreen public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Fullscreen enabled or not.</haxe_doc>
		</fullscreen>
		<unobservedFullscreen>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedFullscreen>
		<_dox_event_fullscreenChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when fullscreen field changes.</haxe_doc>
		</_dox_event_fullscreenChange>
		<emitFullscreenChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when fullscreen field changes.</haxe_doc>
		</emitFullscreenChange>
		<onFullscreenChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fullscreen field changes.</haxe_doc>
		</onFullscreenChange>
		<onceFullscreenChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fullscreen field changes.</haxe_doc>
		</onceFullscreenChange>
		<offFullscreenChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fullscreen field changes.</haxe_doc>
		</offFullscreenChange>
		<listensFullscreenChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fullscreen field changes.</haxe_doc>
		</listensFullscreenChange>
		<invalidateTargetFps public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTargetFps>
		<targetFps public="1" expr="-1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc><![CDATA[* Target FPS. Using default FPS if value < 1 or try to match the given value if >= 1.]]></haxe_doc>
		</targetFps>
		<unobservedTargetFps>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedTargetFps>
		<_dox_event_targetFpsChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when targetFps field changes.</haxe_doc>
		</_dox_event_targetFpsChange>
		<emitTargetFpsChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when targetFps field changes.</haxe_doc>
		</emitTargetFpsChange>
		<onTargetFpsChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetFps field changes.</haxe_doc>
		</onTargetFpsChange>
		<onceTargetFpsChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetFps field changes.</haxe_doc>
		</onceTargetFpsChange>
		<offTargetFpsChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetFps field changes.</haxe_doc>
		</offTargetFpsChange>
		<listensTargetFpsChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetFps field changes.</haxe_doc>
		</listensTargetFpsChange>
		<invalidateMaxDelta public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateMaxDelta>
		<maxDelta public="1" expr="0.1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.1</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Maximum app update delta time.
     * During app update (at each frame), `app.delta` will be capped to `maxDelta`
     * if its value is above `maxDelta`.
     * If needed, use `app.realDelta` to get real elapsed time since last frame.</haxe_doc>
		</maxDelta>
		<unobservedMaxDelta>
			<x path="Float"/>
			<haxe_doc></haxe_doc>
		</unobservedMaxDelta>
		<_dox_event_maxDeltaChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when maxDelta field changes.</haxe_doc>
		</_dox_event_maxDeltaChange>
		<emitMaxDeltaChange set="method" line="1095">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when maxDelta field changes.</haxe_doc>
		</emitMaxDeltaChange>
		<onMaxDeltaChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when maxDelta field changes.</haxe_doc>
		</onMaxDeltaChange>
		<onceMaxDeltaChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when maxDelta field changes.</haxe_doc>
		</onceMaxDeltaChange>
		<offMaxDeltaChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when maxDelta field changes.</haxe_doc>
		</offMaxDeltaChange>
		<listensMaxDeltaChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when maxDelta field changes.</haxe_doc>
		</listensMaxDeltaChange>
		<invalidateOverrideDelta public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateOverrideDelta>
		<overrideDelta public="1" expr="-1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Override app update delta time.
     * This can be used to ignore completely the actual elapsed time between frames
     * and replace it with an explicit delta time of your choice.
     * This will affect timers, tween, systems update etc...
     * Use with caution.</haxe_doc>
		</overrideDelta>
		<unobservedOverrideDelta>
			<x path="Float"/>
			<haxe_doc></haxe_doc>
		</unobservedOverrideDelta>
		<_dox_event_overrideDeltaChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when overrideDelta field changes.</haxe_doc>
		</_dox_event_overrideDeltaChange>
		<emitOverrideDeltaChange set="method" line="1095">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when overrideDelta field changes.</haxe_doc>
		</emitOverrideDeltaChange>
		<onOverrideDeltaChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when overrideDelta field changes.</haxe_doc>
		</onOverrideDeltaChange>
		<onceOverrideDeltaChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when overrideDelta field changes.</haxe_doc>
		</onceOverrideDeltaChange>
		<offOverrideDeltaChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when overrideDelta field changes.</haxe_doc>
		</offOverrideDeltaChange>
		<listensOverrideDeltaChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when overrideDelta field changes.</haxe_doc>
		</listensOverrideDeltaChange>
		<invalidatePreventDefaultMouseWheel public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidatePreventDefaultMouseWheel>
		<preventDefaultMouseWheel public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* If set to `true` (default). Default mouse wheel events
     * will be prevented. This is relevant when running the ceramic
     * app from an `iframe` inside a page that can scroll.</haxe_doc>
		</preventDefaultMouseWheel>
		<unobservedPreventDefaultMouseWheel>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedPreventDefaultMouseWheel>
		<_dox_event_preventDefaultMouseWheelChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when preventDefaultMouseWheel field changes.</haxe_doc>
		</_dox_event_preventDefaultMouseWheelChange>
		<emitPreventDefaultMouseWheelChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when preventDefaultMouseWheel field changes.</haxe_doc>
		</emitPreventDefaultMouseWheelChange>
		<onPreventDefaultMouseWheelChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultMouseWheel field changes.</haxe_doc>
		</onPreventDefaultMouseWheelChange>
		<oncePreventDefaultMouseWheelChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultMouseWheel field changes.</haxe_doc>
		</oncePreventDefaultMouseWheelChange>
		<offPreventDefaultMouseWheelChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultMouseWheel field changes.</haxe_doc>
		</offPreventDefaultMouseWheelChange>
		<listensPreventDefaultMouseWheelChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultMouseWheel field changes.</haxe_doc>
		</listensPreventDefaultMouseWheelChange>
		<invalidatePreventDefaultTouches public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidatePreventDefaultTouches>
		<preventDefaultTouches public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* If set to `true` (default). Default touch events
     * will be prevented. This is relevant when running the ceramic
     * app from an `iframe` inside a page that can scroll,
     * on a touchscreen device.</haxe_doc>
		</preventDefaultTouches>
		<unobservedPreventDefaultTouches>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedPreventDefaultTouches>
		<_dox_event_preventDefaultTouchesChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when preventDefaultTouches field changes.</haxe_doc>
		</_dox_event_preventDefaultTouchesChange>
		<emitPreventDefaultTouchesChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when preventDefaultTouches field changes.</haxe_doc>
		</emitPreventDefaultTouchesChange>
		<onPreventDefaultTouchesChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultTouches field changes.</haxe_doc>
		</onPreventDefaultTouchesChange>
		<oncePreventDefaultTouchesChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultTouches field changes.</haxe_doc>
		</oncePreventDefaultTouchesChange>
		<offPreventDefaultTouchesChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultTouches field changes.</haxe_doc>
		</offPreventDefaultTouchesChange>
		<listensPreventDefaultTouchesChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultTouches field changes.</haxe_doc>
		</listensPreventDefaultTouchesChange>
		<orientation public="1" set="null" expr="NONE">
			<x path="ceramic.ScreenOrientation"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
			<haxe_doc>* Setup screen orientation. Default is `NONE`,
     * meaning nothing is enforced and project defaults will be used.</haxe_doc>
		</orientation>
		<collections public="1" set="null" expr="null">
			<f a=""><c path="ceramic.AutoCollections"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* App collections.</haxe_doc>
		</collections>
		<appInfo public="1" set="null" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* App info (useful when dynamically loaded, not needed otherwise).</haxe_doc>
		</appInfo>
		<antialiasing public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Antialiasing value (0 means disabled).</haxe_doc>
		</antialiasing>
		<resizable public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether the window can be resized or not.</haxe_doc>
		</resizable>
		<assetsPath public="1" set="null" expr="&quot;assets&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"assets"</e></m></meta>
			<haxe_doc>* Assets path.</haxe_doc>
		</assetsPath>
		<backend public="1" set="null" expr="{ }">
			<d/>
			<meta><m n=":value"><e>{ }</e></m></meta>
			<haxe_doc>* Settings passed to backend.</haxe_doc>
		</backend>
		<defaultFont public="1" set="null" expr="&quot;font:RobotoMedium&quot;">
			<x path="ceramic.AssetId"><c path="String"/></x>
			<meta><m n=":value"><e>"font:RobotoMedium"</e></m></meta>
			<haxe_doc>* Default font</haxe_doc>
		</defaultFont>
		<defaultShader public="1" set="null" expr="&quot;shader:textured&quot;">
			<x path="ceramic.AssetId"><c path="String"/></x>
			<meta><m n=":value"><e>"shader:textured"</e></m></meta>
			<haxe_doc>* Default shader</haxe_doc>
		</defaultShader>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new set="method" line="8">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>ceramic.App</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Shader" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Shader.hx">
		<extends path="ceramic.Entity"/>
		<fromSource public="1" set="method" line="21" static="1">
			<f a="vertSource:fragSource">
				<c path="String"/>
				<c path="String"/>
				<c path="ceramic.Shader"/>
			</f>
			<haxe_doc>* Instanciates a shader from source.
     * Although it would expect `GLSL` code in default ceramic backends (luxe backend),
     * Expected shading language could be different in some future backend implementations.</haxe_doc>
		</fromSource>
		<backendItem public="1"><x path="backend.Shader"/></backendItem>
		<asset public="1"><c path="ceramic.ShaderAsset"/></asset>
		<attributes public="1"><x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x></attributes>
		<customAttributes public="1"><x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x></customAttributes>
		<customFloatAttributesSize public="1" set="null"><x path="Int"/></customFloatAttributesSize>
		<destroy public="1" set="method" line="71" override="1"><f a=""><x path="Void"/></f></destroy>
		<clone public="1" set="method" line="83"><f a=""><c path="ceramic.Shader"/></f></clone>
		<setInt public="1" get="inline" set="null" line="94"><f a="name:value">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setFloat public="1" get="inline" set="null" line="100"><f a="name:value">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setColor public="1" get="inline" set="null" line="106"><f a="name:color">
	<c path="String"/>
	<x path="ceramic.Color"/>
	<x path="Void"/>
</f></setColor>
		<setAlphaColor public="1" get="inline" set="null" line="112"><f a="name:color">
	<c path="String"/>
	<x path="ceramic.AlphaColor"/>
	<x path="Void"/>
</f></setAlphaColor>
		<setVec2 public="1" get="inline" set="null" line="118"><f a="name:x:y">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec2>
		<setVec3 public="1" get="inline" set="null" line="124"><f a="name:x:y:z">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec3>
		<setVec4 public="1" get="inline" set="null" line="130"><f a="name:x:y:z:w">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec4>
		<setFloatArray public="1" get="inline" set="null" line="136"><f a="name:array">
	<c path="String"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setFloatArray>
		<setTexture public="1" get="inline" set="null" line="142"><f a="name:slot:texture">
	<c path="String"/>
	<x path="Int"/>
	<c path="ceramic.Texture"/>
	<x path="Void"/>
</f></setTexture>
		<setMat4FromTransform public="1" get="inline" set="null" line="148"><f a="name:transform">
	<c path="String"/>
	<c path="ceramic.Transform"/>
	<x path="Void"/>
</f></setMat4FromTransform>
		<toString set="method" line="156" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="45"><f a="backendItem:?customAttributes">
	<x path="backend.Shader"/>
	<x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.ShaderAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ShaderAsset.hx">
		<extends path="ceramic.Asset"/>
		<invalidateShader public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateShader>
		<shader public="1" expr="null">
			<c path="ceramic.Shader"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</shader>
		<unobservedShader>
			<c path="ceramic.Shader"/>
			<haxe_doc></haxe_doc>
		</unobservedShader>
		<_dox_event_shaderChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.Shader"/>
				<c path="ceramic.Shader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when shader field changes.</haxe_doc>
		</_dox_event_shaderChange>
		<emitShaderChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.Shader"/>
				<c path="ceramic.Shader"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when shader field changes.</haxe_doc>
		</emitShaderChange>
		<onShaderChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Shader"/>
					<c path="ceramic.Shader"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when shader field changes.</haxe_doc>
		</onShaderChange>
		<onceShaderChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Shader"/>
					<c path="ceramic.Shader"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when shader field changes.</haxe_doc>
		</onceShaderChange>
		<offShaderChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.Shader"/>
					<c path="ceramic.Shader"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when shader field changes.</haxe_doc>
		</offShaderChange>
		<listensShaderChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when shader field changes.</haxe_doc>
		</listensShaderChange>
		<load public="1" set="method" line="19" override="1"><f a=""><x path="Void"/></f></load>
		<assetFilesDidChange set="method" line="177" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="221" override="1"><f a=""><x path="Void"/></f></destroy>
		<toString set="method" line="234" override="1"><f a=""><c path="String"/></f></toString>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="13"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.ShaderAttribute" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ShaderAttribute.hx">
		<size public="1"><x path="Int"/></size>
		<name public="1"><c path="String"/></name>
		<toString set="method" line="19"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="10"><f a="size:name">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.Shape" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Shape.hx">
		<extends path="ceramic.Mesh"/>
		<points public="1" get="accessor" set="accessor">
			<c path="Array"><x path="Float"/></c>
			<meta><m n="editable"><e>{ minItems : 6, points : true }</e></m></meta>
			<haxe_doc>* A flat array of vertex coordinates to describe the shape.
     * `points = ...` is identical to `vertices = ... ; contentDirty = true ;`
     * Note: when editing array content without reassigning it,
     * `contentDirty` must be set to `true` to let the shape being updated accordingly.</haxe_doc>
		</points>
		<get_points get="inline" set="null" line="33"><f a=""><c path="Array"><x path="Float"/></c></f></get_points>
		<set_points get="inline" set="null" line="36"><f a="points">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
</f></set_points>
		<triangulation public="1" set="accessor" expr="POLY2TRI">
			<e path="ceramic.TriangulateMethod"/>
			<meta>
				<m n=":value"><e>POLY2TRI</e></m>
				<m n="editable"/>
			</meta>
		</triangulation>
		<set_triangulation get="inline" set="null" line="44"><f a="triangulation">
	<e path="ceramic.TriangulateMethod"/>
	<e path="ceramic.TriangulateMethod"/>
</f></set_triangulation>
		<holes public="1" expr="null">
			<c path="Array"><x path="Int"/></c>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* An array of hole indices, if any.
     * (e.g. `[5, 8]` for a 12-vertex input would mean
     * one hole with vertices 57 and another with 811).
     * Note: when editing array content without reassigning it,
     * `contentDirty` must be set to `true` to let the shape being updated accordingly.</haxe_doc>
		</holes>
		<set_holes get="inline" set="null" line="61"><f a="holes">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></set_holes>
		<autoComputeSize public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="editable"><e>{ label : "Auto Size" }</e></m>
			</meta>
			<haxe_doc>* If set to `true`, width and heigh will be computed from shape points.</haxe_doc>
		</autoComputeSize>
		<set_autoComputeSize get="inline" set="null" line="72"><f a="autoComputeSize">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoComputeSize>
		<get_width set="method" line="80" override="1"><f a=""><x path="Float"/></f></get_width>
		<get_height set="method" line="87" override="1"><f a=""><x path="Float"/></f></get_height>
		<computeContent public="1" set="method" line="94" override="1"><f a=""><x path="Void"/></f></computeContent>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Draw shapes by triangulating vertices automatically, with optional holes in it.</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n="editable"><e>{ implicitSize : true, highlight : { points : "points", minPoints : 3, maxPoints : 999999999 }, disable : ["texture", "vertices", "indices", "uvs"] }</e></m>
		</meta>
	</class>
	<class path="ceramic.Shortcuts" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Shortcuts.hx">
		<app public="1" get="accessor" set="null" static="1">
			<c path="ceramic.App"/>
			<haxe_doc>* Shared app instance</haxe_doc>
		</app>
		<get_app get="inline" set="null" line="19" static="1"><f a=""><c path="ceramic.App"/></f></get_app>
		<screen public="1" get="accessor" set="null" static="1">
			<c path="ceramic.Screen"/>
			<haxe_doc>* Shared screen instance</haxe_doc>
		</screen>
		<get_screen get="inline" set="null" line="25" static="1"><f a=""><c path="ceramic.Screen"/></f></get_screen>
		<audio public="1" get="accessor" set="null" static="1">
			<c path="ceramic.Audio"/>
			<haxe_doc>* Shared audio instance</haxe_doc>
		</audio>
		<get_audio get="inline" set="null" line="31" static="1"><f a=""><c path="ceramic.Audio"/></f></get_audio>
		<input public="1" get="accessor" set="null" static="1">
			<c path="ceramic.Input"/>
			<haxe_doc>* Shared input instance</haxe_doc>
		</input>
		<get_input get="inline" set="null" line="37" static="1"><f a=""><c path="ceramic.Input"/></f></get_input>
		<settings public="1" get="accessor" set="null" static="1">
			<c path="ceramic.Settings"/>
			<haxe_doc>* Shared settings instance</haxe_doc>
		</settings>
		<get_settings get="inline" set="null" line="43" static="1"><f a=""><c path="ceramic.Settings"/></f></get_settings>
		<log public="1" get="accessor" set="null" static="1">
			<c path="ceramic.Logger"/>
			<haxe_doc>* Shared logger instance</haxe_doc>
		</log>
		<get_log get="inline" set="null" line="49" static="1"><f a=""><c path="ceramic.Logger"/></f></get_log>
		<systems public="1" get="accessor" set="null" static="1">
			<c path="ceramic.Systems"/>
			<haxe_doc>* Systems manager</haxe_doc>
		</systems>
		<get_systems get="inline" set="null" line="55" static="1"><f a=""><c path="ceramic.Systems"/></f></get_systems>
		<unobserve public="1" get="inline" set="null" line="61" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Ensures current `autorun` won't be affected by the code after this call.
     * `reobserve()` should be called to restore previous state.</haxe_doc>
		</unobserve>
		<reobserve public="1" get="inline" set="null" line="67" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resume observing values and resume affecting current `autorun` scope.
     * This should be called after an `unobserve()` call.</haxe_doc>
		</reobserve>
		<haxe_doc>* Shortcuts adds convenience identifiers to access ceramic app, screen, ...
 * Use it by adding `import ceramic.Shortcuts.*;` in your files.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.SlugOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Slug.hx" module="ceramic.Slug">
		<lower final="1" public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</lower>
		<remove final="1" public="1" expr="Slug.RE_SLUG_REMOVE_CHARS">
			<c path="EReg"/>
			<meta><m n=":value"><e>Slug.RE_SLUG_REMOVE_CHARS</e></m></meta>
		</remove>
		<replacement final="1" public="1" expr="&quot;-&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"-"</e></m></meta>
		</replacement>
		<new public="1" set="method" line="79">
			<f a="?lower:?remove:?replacement">
				<x path="Null"><x path="Bool"/></x>
				<x path="Null"><c path="EReg"/></x>
				<x path="Null"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.Slug" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Slug.hx">
		<RE_SLUG_REMOVE_CHARS final="1" public="1" set="null" expr="~/[$*+~.()&apos;&quot;!\\:@\?]/" line="10" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/[$*+~.()'"!\\:@\?]/</e></m></meta>
		</RE_SLUG_REMOVE_CHARS>
		<DEFAULT_OPTIONS final="1" public="1" set="null" expr="{ }" line="12" static="1">
			<c path="ceramic.SlugOptions"/>
			<meta><m n=":value"><e>{ }</e></m></meta>
		</DEFAULT_OPTIONS>
		<charMap public="1" expr="[36 =&gt; &quot;dollar&quot;, 37 =&gt; &quot;percent&quot;, 38 =&gt; &quot;and&quot;, 60 =&gt; &quot;less&quot;, 62 =&gt; &quot;greater&quot;, 124 =&gt; &quot;or&quot;, 162 =&gt; &quot;cent&quot;, 163 =&gt; &quot;pound&quot;, 164 =&gt; &quot;currency&quot;, 165 =&gt; &quot;yen&quot;, 169 =&gt; &quot;(c)&quot;, 170 =&gt; &quot;a&quot;, 174 =&gt; &quot;(r)&quot;, 186 =&gt; &quot;o&quot;, 192 =&gt; &quot;A&quot;, 193 =&gt; &quot;A&quot;, 194 =&gt; &quot;A&quot;, 195 =&gt; &quot;A&quot;, 196 =&gt; &quot;A&quot;, 197 =&gt; &quot;A&quot;, 198 =&gt; &quot;AE&quot;, 199 =&gt; &quot;C&quot;, 200 =&gt; &quot;E&quot;, 201 =&gt; &quot;E&quot;, 202 =&gt; &quot;E&quot;, 203 =&gt; &quot;E&quot;, 204 =&gt; &quot;I&quot;, 205 =&gt; &quot;I&quot;, 206 =&gt; &quot;I&quot;, 207 =&gt; &quot;I&quot;, 208 =&gt; &quot;D&quot;, 209 =&gt; &quot;N&quot;, 210 =&gt; &quot;O&quot;, 211 =&gt; &quot;O&quot;, 212 =&gt; &quot;O&quot;, 213 =&gt; &quot;O&quot;, 214 =&gt; &quot;O&quot;, 216 =&gt; &quot;O&quot;, 217 =&gt; &quot;U&quot;, 218 =&gt; &quot;U&quot;, 219 =&gt; &quot;U&quot;, 220 =&gt; &quot;U&quot;, 221 =&gt; &quot;Y&quot;, 222 =&gt; &quot;TH&quot;, 223 =&gt; &quot;ss&quot;, 224 =&gt; &quot;a&quot;, 225 =&gt; &quot;a&quot;, 226 =&gt; &quot;a&quot;, 227 =&gt; &quot;a&quot;, 228 =&gt; &quot;a&quot;, 229 =&gt; &quot;a&quot;, 230 =&gt; &quot;ae&quot;, 231 =&gt; &quot;c&quot;, 232 =&gt; &quot;e&quot;, 233 =&gt; &quot;e&quot;, 234 =&gt; &quot;e&quot;, 235 =&gt; &quot;e&quot;, 236 =&gt; &quot;i&quot;, 237 =&gt; &quot;i&quot;, 238 =&gt; &quot;i&quot;, 239 =&gt; &quot;i&quot;, 240 =&gt; &quot;d&quot;, 241 =&gt; &quot;n&quot;, 242 =&gt; &quot;o&quot;, 243 =&gt; &quot;o&quot;, 244 =&gt; &quot;o&quot;, 245 =&gt; &quot;o&quot;, 246 =&gt; &quot;o&quot;, 248 =&gt; &quot;o&quot;, 249 =&gt; &quot;u&quot;, 250 =&gt; &quot;u&quot;, 251 =&gt; &quot;u&quot;, 252 =&gt; &quot;u&quot;, 253 =&gt; &quot;y&quot;, 254 =&gt; &quot;th&quot;, 255 =&gt; &quot;y&quot;, 256 =&gt; &quot;A&quot;, 257 =&gt; &quot;a&quot;, 258 =&gt; &quot;A&quot;, 259 =&gt; &quot;a&quot;, 260 =&gt; &quot;A&quot;, 261 =&gt; &quot;a&quot;, 262 =&gt; &quot;C&quot;, 263 =&gt; &quot;c&quot;, 268 =&gt; &quot;C&quot;, 269 =&gt; &quot;c&quot;, 270 =&gt; &quot;D&quot;, 271 =&gt; &quot;d&quot;, 272 =&gt; &quot;DJ&quot;, 273 =&gt; &quot;dj&quot;, 274 =&gt; &quot;E&quot;, 275 =&gt; &quot;e&quot;, 278 =&gt; &quot;E&quot;, 279 =&gt; &quot;e&quot;, 280 =&gt; &quot;e&quot;, 281 =&gt; &quot;e&quot;, 282 =&gt; &quot;E&quot;, 283 =&gt; &quot;e&quot;, 286 =&gt; &quot;G&quot;, 287 =&gt; &quot;g&quot;, 290 =&gt; &quot;G&quot;, 291 =&gt; &quot;g&quot;, 296 =&gt; &quot;I&quot;, 297 =&gt; &quot;i&quot;, 298 =&gt; &quot;i&quot;, 299 =&gt; &quot;i&quot;, 302 =&gt; &quot;I&quot;, 303 =&gt; &quot;i&quot;, 304 =&gt; &quot;I&quot;, 305 =&gt; &quot;i&quot;, 310 =&gt; &quot;k&quot;, 311 =&gt; &quot;k&quot;, 315 =&gt; &quot;L&quot;, 316 =&gt; &quot;l&quot;, 317 =&gt; &quot;L&quot;, 318 =&gt; &quot;l&quot;, 321 =&gt; &quot;L&quot;, 322 =&gt; &quot;l&quot;, 323 =&gt; &quot;N&quot;, 324 =&gt; &quot;n&quot;, 325 =&gt; &quot;N&quot;, 326 =&gt; &quot;n&quot;, 327 =&gt; &quot;N&quot;, 328 =&gt; &quot;n&quot;, 336 =&gt; &quot;O&quot;, 337 =&gt; &quot;o&quot;, 338 =&gt; &quot;OE&quot;, 339 =&gt; &quot;oe&quot;, 340 =&gt; &quot;R&quot;, 341 =&gt; &quot;r&quot;, 344 =&gt; &quot;R&quot;, 345 =&gt; &quot;r&quot;, 346 =&gt; &quot;S&quot;, 347 =&gt; &quot;s&quot;, 350 =&gt; &quot;S&quot;, 351 =&gt; &quot;s&quot;, 352 =&gt; &quot;S&quot;, 353 =&gt; &quot;s&quot;, 354 =&gt; &quot;T&quot;, 355 =&gt; &quot;t&quot;, 356 =&gt; &quot;T&quot;, 357 =&gt; &quot;t&quot;, 360 =&gt; &quot;U&quot;, 361 =&gt; &quot;u&quot;, 362 =&gt; &quot;u&quot;, 363 =&gt; &quot;u&quot;, 366 =&gt; &quot;U&quot;, 367 =&gt; &quot;u&quot;, 368 =&gt; &quot;U&quot;, 369 =&gt; &quot;u&quot;, 370 =&gt; &quot;U&quot;, 371 =&gt; &quot;u&quot;, 377 =&gt; &quot;Z&quot;, 378 =&gt; &quot;z&quot;, 379 =&gt; &quot;Z&quot;, 380 =&gt; &quot;z&quot;, 381 =&gt; &quot;Z&quot;, 382 =&gt; &quot;z&quot;, 402 =&gt; &quot;f&quot;, 416 =&gt; &quot;O&quot;, 417 =&gt; &quot;o&quot;, 431 =&gt; &quot;U&quot;, 432 =&gt; &quot;u&quot;, 456 =&gt; &quot;LJ&quot;, 457 =&gt; &quot;lj&quot;, 459 =&gt; &quot;NJ&quot;, 460 =&gt; &quot;nj&quot;, 536 =&gt; &quot;S&quot;, 537 =&gt; &quot;s&quot;, 538 =&gt; &quot;T&quot;, 539 =&gt; &quot;t&quot;, 730 =&gt; &quot;o&quot;, 902 =&gt; &quot;A&quot;, 904 =&gt; &quot;E&quot;, 905 =&gt; &quot;H&quot;, 906 =&gt; &quot;I&quot;, 908 =&gt; &quot;O&quot;, 910 =&gt; &quot;Y&quot;, 911 =&gt; &quot;W&quot;, 912 =&gt; &quot;i&quot;, 913 =&gt; &quot;A&quot;, 914 =&gt; &quot;B&quot;, 915 =&gt; &quot;G&quot;, 916 =&gt; &quot;D&quot;, 917 =&gt; &quot;E&quot;, 918 =&gt; &quot;Z&quot;, 919 =&gt; &quot;H&quot;, 920 =&gt; &quot;8&quot;, 921 =&gt; &quot;I&quot;, 922 =&gt; &quot;K&quot;, 923 =&gt; &quot;L&quot;, 924 =&gt; &quot;M&quot;, 925 =&gt; &quot;N&quot;, 926 =&gt; &quot;3&quot;, 927 =&gt; &quot;O&quot;, 928 =&gt; &quot;P&quot;, 929 =&gt; &quot;R&quot;, 931 =&gt; &quot;S&quot;, 932 =&gt; &quot;T&quot;, 933 =&gt; &quot;Y&quot;, 934 =&gt; &quot;F&quot;, 935 =&gt; &quot;X&quot;, 936 =&gt; &quot;PS&quot;, 937 =&gt; &quot;W&quot;, 938 =&gt; &quot;I&quot;, 939 =&gt; &quot;Y&quot;, 940 =&gt; &quot;a&quot;, 941 =&gt; &quot;e&quot;, 942 =&gt; &quot;h&quot;, 943 =&gt; &quot;i&quot;, 944 =&gt; &quot;y&quot;, 945 =&gt; &quot;a&quot;, 946 =&gt; &quot;b&quot;, 947 =&gt; &quot;g&quot;, 948 =&gt; &quot;d&quot;, 949 =&gt; &quot;e&quot;, 950 =&gt; &quot;z&quot;, 951 =&gt; &quot;h&quot;, 952 =&gt; &quot;8&quot;, 953 =&gt; &quot;i&quot;, 954 =&gt; &quot;k&quot;, 955 =&gt; &quot;l&quot;, 956 =&gt; &quot;m&quot;, 957 =&gt; &quot;n&quot;, 958 =&gt; &quot;3&quot;, 959 =&gt; &quot;o&quot;, 960 =&gt; &quot;p&quot;, 961 =&gt; &quot;r&quot;, 962 =&gt; &quot;s&quot;, 963 =&gt; &quot;s&quot;, 964 =&gt; &quot;t&quot;, 965 =&gt; &quot;y&quot;, 966 =&gt; &quot;f&quot;, 967 =&gt; &quot;x&quot;, 968 =&gt; &quot;ps&quot;, 969 =&gt; &quot;w&quot;, 970 =&gt; &quot;i&quot;, 971 =&gt; &quot;y&quot;, 972 =&gt; &quot;o&quot;, 973 =&gt; &quot;y&quot;, 974 =&gt; &quot;w&quot;, 1025 =&gt; &quot;Yo&quot;, 1026 =&gt; &quot;DJ&quot;, 1028 =&gt; &quot;Ye&quot;, 1030 =&gt; &quot;I&quot;, 1031 =&gt; &quot;Yi&quot;, 1032 =&gt; &quot;J&quot;, 1033 =&gt; &quot;LJ&quot;, 1034 =&gt; &quot;NJ&quot;, 1035 =&gt; &quot;C&quot;, 1039 =&gt; &quot;DZ&quot;, 1040 =&gt; &quot;A&quot;, 1041 =&gt; &quot;B&quot;, 1042 =&gt; &quot;V&quot;, 1043 =&gt; &quot;G&quot;, 1044 =&gt; &quot;D&quot;, 1045 =&gt; &quot;E&quot;, 1046 =&gt; &quot;Zh&quot;, 1047 =&gt; &quot;Z&quot;, 1048 =&gt; &quot;I&quot;, 1049 =&gt; &quot;J&quot;, 1050 =&gt; &quot;K&quot;, 1051 =&gt; &quot;L&quot;, 1052 =&gt; &quot;M&quot;, 1053 =&gt; &quot;N&quot;, 1054 =&gt; &quot;O&quot;, 1055 =&gt; &quot;P&quot;, 1056 =&gt; &quot;R&quot;, 1057 =&gt; &quot;S&quot;, 1058 =&gt; &quot;T&quot;, 1059 =&gt; &quot;U&quot;, 1060 =&gt; &quot;F&quot;, 1061 =&gt; &quot;H&quot;, 1062 =&gt; &quot;C&quot;, 1063 =&gt; &quot;Ch&quot;, 1064 =&gt; &quot;Sh&quot;, 1065 =&gt; &quot;Sh&quot;, 1066 =&gt; &quot;U&quot;, 1067 =&gt; &quot;Y&quot;, 1068 =&gt; &quot;&quot;, 1069 =&gt; &quot;E&quot;, 1070 =&gt; &quot;Yu&quot;, 1071 =&gt; &quot;Ya&quot;, 1072 =&gt; &quot;a&quot;, 1073 =&gt; &quot;b&quot;, 1074 =&gt; &quot;v&quot;, 1075 =&gt; &quot;g&quot;, 1076 =&gt; &quot;d&quot;, 1077 =&gt; &quot;e&quot;, 1078 =&gt; &quot;zh&quot;, 1079 =&gt; &quot;z&quot;, 1080 =&gt; &quot;i&quot;, 1081 =&gt; &quot;j&quot;, 1082 =&gt; &quot;k&quot;, 1083 =&gt; &quot;l&quot;, 1084 =&gt; &quot;m&quot;, 1085 =&gt; &quot;n&quot;, 1086 =&gt; &quot;o&quot;, 1087 =&gt; &quot;p&quot;, 1088 =&gt; &quot;r&quot;, 1089 =&gt; &quot;s&quot;, 1090 =&gt; &quot;t&quot;, 1091 =&gt; &quot;u&quot;, 1092 =&gt; &quot;f&quot;, 1093 =&gt; &quot;h&quot;, 1094 =&gt; &quot;c&quot;, 1095 =&gt; &quot;ch&quot;, 1096 =&gt; &quot;sh&quot;, 1097 =&gt; &quot;sh&quot;, 1098 =&gt; &quot;u&quot;, 1099 =&gt; &quot;y&quot;, 1100 =&gt; &quot;&quot;, 1101 =&gt; &quot;e&quot;, 1102 =&gt; &quot;yu&quot;, 1103 =&gt; &quot;ya&quot;, 1105 =&gt; &quot;yo&quot;, 1106 =&gt; &quot;dj&quot;, 1108 =&gt; &quot;ye&quot;, 1110 =&gt; &quot;i&quot;, 1111 =&gt; &quot;yi&quot;, 1112 =&gt; &quot;j&quot;, 1113 =&gt; &quot;lj&quot;, 1114 =&gt; &quot;nj&quot;, 1115 =&gt; &quot;c&quot;, 1119 =&gt; &quot;dz&quot;, 1168 =&gt; &quot;G&quot;, 1169 =&gt; &quot;g&quot;, 3647 =&gt; &quot;baht&quot;, 4304 =&gt; &quot;a&quot;, 4305 =&gt; &quot;b&quot;, 4306 =&gt; &quot;g&quot;, 4307 =&gt; &quot;d&quot;, 4308 =&gt; &quot;e&quot;, 4309 =&gt; &quot;v&quot;, 4310 =&gt; &quot;z&quot;, 4311 =&gt; &quot;t&quot;, 4312 =&gt; &quot;i&quot;, 4313 =&gt; &quot;k&quot;, 4314 =&gt; &quot;l&quot;, 4315 =&gt; &quot;m&quot;, 4316 =&gt; &quot;n&quot;, 4317 =&gt; &quot;o&quot;, 4318 =&gt; &quot;p&quot;, 4319 =&gt; &quot;zh&quot;, 4320 =&gt; &quot;r&quot;, 4321 =&gt; &quot;s&quot;, 4322 =&gt; &quot;t&quot;, 4323 =&gt; &quot;u&quot;, 4324 =&gt; &quot;f&quot;, 4325 =&gt; &quot;k&quot;, 4326 =&gt; &quot;gh&quot;, 4327 =&gt; &quot;q&quot;, 4328 =&gt; &quot;sh&quot;, 4329 =&gt; &quot;ch&quot;, 4330 =&gt; &quot;ts&quot;, 4331 =&gt; &quot;dz&quot;, 4332 =&gt; &quot;ts&quot;, 4333 =&gt; &quot;ch&quot;, 4334 =&gt; &quot;kh&quot;, 4335 =&gt; &quot;j&quot;, 4336 =&gt; &quot;h&quot;, 7838 =&gt; &quot;SS&quot;, 7840 =&gt; &quot;A&quot;, 7841 =&gt; &quot;a&quot;, 7842 =&gt; &quot;A&quot;, 7843 =&gt; &quot;a&quot;, 7844 =&gt; &quot;A&quot;, 7845 =&gt; &quot;a&quot;, 7846 =&gt; &quot;A&quot;, 7847 =&gt; &quot;a&quot;, 7848 =&gt; &quot;A&quot;, 7849 =&gt; &quot;a&quot;, 7850 =&gt; &quot;A&quot;, 7851 =&gt; &quot;a&quot;, 7852 =&gt; &quot;A&quot;, 7853 =&gt; &quot;a&quot;, 7854 =&gt; &quot;A&quot;, 7855 =&gt; &quot;a&quot;, 7856 =&gt; &quot;A&quot;, 7857 =&gt; &quot;a&quot;, 7858 =&gt; &quot;A&quot;, 7859 =&gt; &quot;a&quot;, 7860 =&gt; &quot;A&quot;, 7861 =&gt; &quot;a&quot;, 7862 =&gt; &quot;A&quot;, 7863 =&gt; &quot;a&quot;, 7864 =&gt; &quot;E&quot;, 7865 =&gt; &quot;e&quot;, 7866 =&gt; &quot;E&quot;, 7867 =&gt; &quot;e&quot;, 7868 =&gt; &quot;E&quot;, 7869 =&gt; &quot;e&quot;, 7870 =&gt; &quot;E&quot;, 7871 =&gt; &quot;e&quot;, 7872 =&gt; &quot;E&quot;, 7873 =&gt; &quot;e&quot;, 7874 =&gt; &quot;E&quot;, 7875 =&gt; &quot;e&quot;, 7876 =&gt; &quot;E&quot;, 7877 =&gt; &quot;e&quot;, 7878 =&gt; &quot;E&quot;, 7879 =&gt; &quot;e&quot;, 7880 =&gt; &quot;I&quot;, 7881 =&gt; &quot;i&quot;, 7882 =&gt; &quot;I&quot;, 7883 =&gt; &quot;i&quot;, 7884 =&gt; &quot;O&quot;, 7885 =&gt; &quot;o&quot;, 7886 =&gt; &quot;O&quot;, 7887 =&gt; &quot;o&quot;, 7888 =&gt; &quot;O&quot;, 7889 =&gt; &quot;o&quot;, 7890 =&gt; &quot;O&quot;, 7891 =&gt; &quot;o&quot;, 7892 =&gt; &quot;O&quot;, 7893 =&gt; &quot;o&quot;, 7894 =&gt; &quot;O&quot;, 7895 =&gt; &quot;o&quot;, 7896 =&gt; &quot;O&quot;, 7897 =&gt; &quot;o&quot;, 7898 =&gt; &quot;O&quot;, 7899 =&gt; &quot;o&quot;, 7900 =&gt; &quot;O&quot;, 7901 =&gt; &quot;o&quot;, 7902 =&gt; &quot;O&quot;, 7903 =&gt; &quot;o&quot;, 7904 =&gt; &quot;O&quot;, 7905 =&gt; &quot;o&quot;, 7906 =&gt; &quot;O&quot;, 7907 =&gt; &quot;o&quot;, 7908 =&gt; &quot;U&quot;, 7909 =&gt; &quot;u&quot;, 7910 =&gt; &quot;U&quot;, 7911 =&gt; &quot;u&quot;, 7912 =&gt; &quot;U&quot;, 7913 =&gt; &quot;u&quot;, 7914 =&gt; &quot;U&quot;, 7915 =&gt; &quot;u&quot;, 7916 =&gt; &quot;U&quot;, 7917 =&gt; &quot;u&quot;, 7918 =&gt; &quot;U&quot;, 7919 =&gt; &quot;u&quot;, 7920 =&gt; &quot;U&quot;, 7921 =&gt; &quot;u&quot;, 7922 =&gt; &quot;Y&quot;, 7923 =&gt; &quot;y&quot;, 7924 =&gt; &quot;Y&quot;, 7925 =&gt; &quot;y&quot;, 7926 =&gt; &quot;Y&quot;, 7927 =&gt; &quot;y&quot;, 7928 =&gt; &quot;Y&quot;, 7929 =&gt; &quot;y&quot;, 8216 =&gt; &quot;&apos;&quot;, 8217 =&gt; &quot;&apos;&quot;, 8220 =&gt; &quot;\&quot;&quot;, 8221 =&gt; &quot;\&quot;&quot;, 8224 =&gt; &quot;+&quot;, 8226 =&gt; &quot;*&quot;, 8230 =&gt; &quot;...&quot;, 8352 =&gt; &quot;ecu&quot;, 8354 =&gt; &quot;cruzeiro&quot;, 8355 =&gt; &quot;french franc&quot;, 8356 =&gt; &quot;lira&quot;, 8357 =&gt; &quot;mill&quot;, 8358 =&gt; &quot;naira&quot;, 8359 =&gt; &quot;peseta&quot;, 8360 =&gt; &quot;rupee&quot;, 8361 =&gt; &quot;won&quot;, 8362 =&gt; &quot;new shequel&quot;, 8363 =&gt; &quot;dong&quot;, 8364 =&gt; &quot;euro&quot;, 8365 =&gt; &quot;kip&quot;, 8366 =&gt; &quot;tugrik&quot;, 8367 =&gt; &quot;drachma&quot;, 8368 =&gt; &quot;penny&quot;, 8369 =&gt; &quot;peso&quot;, 8370 =&gt; &quot;guarani&quot;, 8371 =&gt; &quot;austral&quot;, 8372 =&gt; &quot;hryvnia&quot;, 8373 =&gt; &quot;cedi&quot;, 8377 =&gt; &quot;indian rupee&quot;, 8381 =&gt; &quot;russian ruble&quot;, 8383 =&gt; &quot;bitcoin&quot;, 8480 =&gt; &quot;sm&quot;, 8482 =&gt; &quot;tm&quot;, 8706 =&gt; &quot;d&quot;, 8710 =&gt; &quot;delta&quot;, 8721 =&gt; &quot;sum&quot;, 8734 =&gt; &quot;infinity&quot;, 9829 =&gt; &quot;love&quot;, 20803 =&gt; &quot;yuan&quot;, 20870 =&gt; &quot;yen&quot;, 65020 =&gt; &quot;rial&quot;]" line="14" static="1">
			<t path="Map">
				<x path="Int"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e><![CDATA[[36 => "dollar", 37 => "percent", 38 => "and", 60 => "less", 62 => "greater", 124 => "or", 162 => "cent", 163 => "pound", 164 => "currency", 165 => "yen", 169 => "(c)", 170 => "a", 174 => "(r)", 186 => "o", 192 => "A", 193 => "A", 194 => "A", 195 => "A", 196 => "A", 197 => "A", 198 => "AE", 199 => "C", 200 => "E", 201 => "E", 202 => "E", 203 => "E", 204 => "I", 205 => "I", 206 => "I", 207 => "I", 208 => "D", 209 => "N", 210 => "O", 211 => "O", 212 => "O", 213 => "O", 214 => "O", 216 => "O", 217 => "U", 218 => "U", 219 => "U", 220 => "U", 221 => "Y", 222 => "TH", 223 => "ss", 224 => "a", 225 => "a", 226 => "a", 227 => "a", 228 => "a", 229 => "a", 230 => "ae", 231 => "c", 232 => "e", 233 => "e", 234 => "e", 235 => "e", 236 => "i", 237 => "i", 238 => "i", 239 => "i", 240 => "d", 241 => "n", 242 => "o", 243 => "o", 244 => "o", 245 => "o", 246 => "o", 248 => "o", 249 => "u", 250 => "u", 251 => "u", 252 => "u", 253 => "y", 254 => "th", 255 => "y", 256 => "A", 257 => "a", 258 => "A", 259 => "a", 260 => "A", 261 => "a", 262 => "C", 263 => "c", 268 => "C", 269 => "c", 270 => "D", 271 => "d", 272 => "DJ", 273 => "dj", 274 => "E", 275 => "e", 278 => "E", 279 => "e", 280 => "e", 281 => "e", 282 => "E", 283 => "e", 286 => "G", 287 => "g", 290 => "G", 291 => "g", 296 => "I", 297 => "i", 298 => "i", 299 => "i", 302 => "I", 303 => "i", 304 => "I", 305 => "i", 310 => "k", 311 => "k", 315 => "L", 316 => "l", 317 => "L", 318 => "l", 321 => "L", 322 => "l", 323 => "N", 324 => "n", 325 => "N", 326 => "n", 327 => "N", 328 => "n", 336 => "O", 337 => "o", 338 => "OE", 339 => "oe", 340 => "R", 341 => "r", 344 => "R", 345 => "r", 346 => "S", 347 => "s", 350 => "S", 351 => "s", 352 => "S", 353 => "s", 354 => "T", 355 => "t", 356 => "T", 357 => "t", 360 => "U", 361 => "u", 362 => "u", 363 => "u", 366 => "U", 367 => "u", 368 => "U", 369 => "u", 370 => "U", 371 => "u", 377 => "Z", 378 => "z", 379 => "Z", 380 => "z", 381 => "Z", 382 => "z", 402 => "f", 416 => "O", 417 => "o", 431 => "U", 432 => "u", 456 => "LJ", 457 => "lj", 459 => "NJ", 460 => "nj", 536 => "S", 537 => "s", 538 => "T", 539 => "t", 730 => "o", 902 => "A", 904 => "E", 905 => "H", 906 => "I", 908 => "O", 910 => "Y", 911 => "W", 912 => "i", 913 => "A", 914 => "B", 915 => "G", 916 => "D", 917 => "E", 918 => "Z", 919 => "H", 920 => "8", 921 => "I", 922 => "K", 923 => "L", 924 => "M", 925 => "N", 926 => "3", 927 => "O", 928 => "P", 929 => "R", 931 => "S", 932 => "T", 933 => "Y", 934 => "F", 935 => "X", 936 => "PS", 937 => "W", 938 => "I", 939 => "Y", 940 => "a", 941 => "e", 942 => "h", 943 => "i", 944 => "y", 945 => "a", 946 => "b", 947 => "g", 948 => "d", 949 => "e", 950 => "z", 951 => "h", 952 => "8", 953 => "i", 954 => "k", 955 => "l", 956 => "m", 957 => "n", 958 => "3", 959 => "o", 960 => "p", 961 => "r", 962 => "s", 963 => "s", 964 => "t", 965 => "y", 966 => "f", 967 => "x", 968 => "ps", 969 => "w", 970 => "i", 971 => "y", 972 => "o", 973 => "y", 974 => "w", 1025 => "Yo", 1026 => "DJ", 1028 => "Ye", 1030 => "I", 1031 => "Yi", 1032 => "J", 1033 => "LJ", 1034 => "NJ", 1035 => "C", 1039 => "DZ", 1040 => "A", 1041 => "B", 1042 => "V", 1043 => "G", 1044 => "D", 1045 => "E", 1046 => "Zh", 1047 => "Z", 1048 => "I", 1049 => "J", 1050 => "K", 1051 => "L", 1052 => "M", 1053 => "N", 1054 => "O", 1055 => "P", 1056 => "R", 1057 => "S", 1058 => "T", 1059 => "U", 1060 => "F", 1061 => "H", 1062 => "C", 1063 => "Ch", 1064 => "Sh", 1065 => "Sh", 1066 => "U", 1067 => "Y", 1068 => "", 1069 => "E", 1070 => "Yu", 1071 => "Ya", 1072 => "a", 1073 => "b", 1074 => "v", 1075 => "g", 1076 => "d", 1077 => "e", 1078 => "zh", 1079 => "z", 1080 => "i", 1081 => "j", 1082 => "k", 1083 => "l", 1084 => "m", 1085 => "n", 1086 => "o", 1087 => "p", 1088 => "r", 1089 => "s", 1090 => "t", 1091 => "u", 1092 => "f", 1093 => "h", 1094 => "c", 1095 => "ch", 1096 => "sh", 1097 => "sh", 1098 => "u", 1099 => "y", 1100 => "", 1101 => "e", 1102 => "yu", 1103 => "ya", 1105 => "yo", 1106 => "dj", 1108 => "ye", 1110 => "i", 1111 => "yi", 1112 => "j", 1113 => "lj", 1114 => "nj", 1115 => "c", 1119 => "dz", 1168 => "G", 1169 => "g", 3647 => "baht", 4304 => "a", 4305 => "b", 4306 => "g", 4307 => "d", 4308 => "e", 4309 => "v", 4310 => "z", 4311 => "t", 4312 => "i", 4313 => "k", 4314 => "l", 4315 => "m", 4316 => "n", 4317 => "o", 4318 => "p", 4319 => "zh", 4320 => "r", 4321 => "s", 4322 => "t", 4323 => "u", 4324 => "f", 4325 => "k", 4326 => "gh", 4327 => "q", 4328 => "sh", 4329 => "ch", 4330 => "ts", 4331 => "dz", 4332 => "ts", 4333 => "ch", 4334 => "kh", 4335 => "j", 4336 => "h", 7838 => "SS", 7840 => "A", 7841 => "a", 7842 => "A", 7843 => "a", 7844 => "A", 7845 => "a", 7846 => "A", 7847 => "a", 7848 => "A", 7849 => "a", 7850 => "A", 7851 => "a", 7852 => "A", 7853 => "a", 7854 => "A", 7855 => "a", 7856 => "A", 7857 => "a", 7858 => "A", 7859 => "a", 7860 => "A", 7861 => "a", 7862 => "A", 7863 => "a", 7864 => "E", 7865 => "e", 7866 => "E", 7867 => "e", 7868 => "E", 7869 => "e", 7870 => "E", 7871 => "e", 7872 => "E", 7873 => "e", 7874 => "E", 7875 => "e", 7876 => "E", 7877 => "e", 7878 => "E", 7879 => "e", 7880 => "I", 7881 => "i", 7882 => "I", 7883 => "i", 7884 => "O", 7885 => "o", 7886 => "O", 7887 => "o", 7888 => "O", 7889 => "o", 7890 => "O", 7891 => "o", 7892 => "O", 7893 => "o", 7894 => "O", 7895 => "o", 7896 => "O", 7897 => "o", 7898 => "O", 7899 => "o", 7900 => "O", 7901 => "o", 7902 => "O", 7903 => "o", 7904 => "O", 7905 => "o", 7906 => "O", 7907 => "o", 7908 => "U", 7909 => "u", 7910 => "U", 7911 => "u", 7912 => "U", 7913 => "u", 7914 => "U", 7915 => "u", 7916 => "U", 7917 => "u", 7918 => "U", 7919 => "u", 7920 => "U", 7921 => "u", 7922 => "Y", 7923 => "y", 7924 => "Y", 7925 => "y", 7926 => "Y", 7927 => "y", 7928 => "Y", 7929 => "y", 8216 => "'", 8217 => "'", 8220 => "\"", 8221 => "\"", 8224 => "+", 8226 => "*", 8230 => "...", 8352 => "ecu", 8354 => "cruzeiro", 8355 => "french franc", 8356 => "lira", 8357 => "mill", 8358 => "naira", 8359 => "peseta", 8360 => "rupee", 8361 => "won", 8362 => "new shequel", 8363 => "dong", 8364 => "euro", 8365 => "kip", 8366 => "tugrik", 8367 => "drachma", 8368 => "penny", 8369 => "peso", 8370 => "guarani", 8371 => "austral", 8372 => "hryvnia", 8373 => "cedi", 8377 => "indian rupee", 8381 => "russian ruble", 8383 => "bitcoin", 8480 => "sm", 8482 => "tm", 8706 => "d", 8710 => "delta", 8721 => "sum", 8734 => "infinity", 9829 => "love", 20803 => "yuan", 20870 => "yen", 65020 => "rial"]]]></e></m></meta>
		</charMap>
		<safe final="1" public="1" set="null" expr="~/[^\w\s$*_+~.()&apos;&quot;!\-:@]/" line="62" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/[^\w\s$*_+~.()'"!\-:@]/</e></m></meta>
		</safe>
		<encode public="1" set="method" line="64" static="1"><f a="str:?options">
	<c path="String"/>
	<c path="ceramic.SlugOptions"/>
	<c path="String"/>
</f></encode>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.SortVisuals" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SortVisuals.hx">
		<cmp get="inline" set="null" line="37" static="1"><f a="a:b">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
	<x path="Int"/>
</f></cmp>
		<sort public="1" get="inline" set="null" line="100" static="1">
			<f a="a">
				<c path="Array"><c path="ceramic.Visual"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
        `cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
        negative Int if `x < y`.

        This operation modifies Array `a` in place.

        This operation is stable: The order of equal elements is preserved.

        If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec set="method" line="104" static="1"><f a="a:from:to">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge set="method" line="125" static="1"><f a="a:from:pivot:to:len1:len2">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate get="inline" set="null" line="151" static="1"><f a="a:from:mid:to">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd get="inline" set="null" line="170" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper get="inline" set="null" line="179" static="1"><f a="a:from:to:val">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower get="inline" set="null" line="194" static="1"><f a="a:from:to:val">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap get="inline" set="null" line="208" static="1"><f a="a:i:j">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<compare get="inline" set="null" line="214" static="1"><f a="a:i:j">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></compare>
		<haxe_doc>SortVisuals provides a stable implementation of merge sort through its `sort`
    method. It should be used instead of `Array.sort` in cases where the order
    of equal elements has to be retained on all targets.

    This specific implementation has been modified to be exclusively used with array of `ceramic.Visual` instances.
    The compare function (and the rest of the implementation) are inlined to get the best performance out of it.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.SortVisualsByDepth" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SortVisualsByDepth.hx">
		<cmp get="inline" set="null" line="37" static="1"><f a="a:b">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
	<x path="Int"/>
</f></cmp>
		<sort public="1" get="inline" set="null" line="63" static="1">
			<f a="a">
				<c path="Array"><c path="ceramic.Visual"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
         `cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
         negative Int if `x < y`.
 
         This operation modifies Array `a` in place.
 
         This operation is stable: The order of equal elements is preserved.
 
         If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec set="method" line="67" static="1"><f a="a:from:to">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge set="method" line="88" static="1"><f a="a:from:pivot:to:len1:len2">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate get="inline" set="null" line="114" static="1"><f a="a:from:mid:to">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd get="inline" set="null" line="133" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper get="inline" set="null" line="142" static="1"><f a="a:from:to:val">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower get="inline" set="null" line="157" static="1"><f a="a:from:to:val">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap get="inline" set="null" line="171" static="1"><f a="a:i:j">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<compare get="inline" set="null" line="177" static="1"><f a="a:i:j">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></compare>
		<haxe_doc>SortVisuals provides a stable implementation of merge sort through its `sort`
     method. It should be used instead of `Array.sort` in cases where the order
     of equal elements has to be retained on all targets.
     
     This specific implementation has been modified to be exclusively used with array of `ceramic.Visual` instances and sort them by depth.
     The compare function (and the rest of the implementation) are inlined to get the best performance out of it.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Sound" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Sound.hx">
		<extends path="ceramic.Entity"/>
		<backendItem public="1"><t path="backend.AudioResource"/></backendItem>
		<asset public="1"><c path="ceramic.SoundAsset"/></asset>
		<group public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</group>
		<set_group set="method" line="13"><f a="group">
	<x path="Int"/>
	<x path="Int"/>
</f></set_group>
		<destroy public="1" set="method" line="30" override="1"><f a=""><x path="Void"/></f></destroy>
		<volume public="1" expr="0.5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
			<haxe_doc>* Default volume when playing this sound.</haxe_doc>
		</volume>
		<pan public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Default pan when playing this sound.</haxe_doc>
		</pan>
		<pitch public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Default pitch when playing this sound.</haxe_doc>
		</pitch>
		<duration public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Sound duration.</haxe_doc>
		</duration>
		<get_duration get="inline" set="null" line="62"><f a=""><x path="Float"/></f></get_duration>
		<play public="1" set="method" line="70">
			<f a="?position:?loop:?volume:?pan:?pitch" v="0:false:::">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.SoundPlayer"/>
			</f>
			<meta><m n=":value"><e>{ loop : false, position : 0 }</e></m></meta>
			<haxe_doc>* Play the sound at requested position. If volume/pan/pitch are not provided,
     * sound instance properties will be used instead.</haxe_doc>
		</play>
		<new public="1" set="method" line="22"><f a="backendItem">
	<t path="backend.AudioResource"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.SoundAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SoundAsset.hx">
		<extends path="ceramic.Asset"/>
		<_dox_event_replaceSound public="1" set="method" line="637">
			<f a="newSound:prevSound">
				<c path="ceramic.Sound"/>
				<c path="ceramic.Sound"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_replaceSound>
		<emitReplaceSound set="method" line="1095">
			<f a="newSound:prevSound">
				<c path="ceramic.Sound"/>
				<c path="ceramic.Sound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>replaceSound event</haxe_doc>
		</emitReplaceSound>
		<onReplaceSound public="1" set="method" line="1199">
			<f a="owner:handleNewSoundPrevSound">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newSound:prevSound">
					<c path="ceramic.Sound"/>
					<c path="ceramic.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceSound event</haxe_doc>
		</onReplaceSound>
		<onceReplaceSound public="1" set="method" line="1298">
			<f a="owner:handleNewSoundPrevSound">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newSound:prevSound">
					<c path="ceramic.Sound"/>
					<c path="ceramic.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceSound event</haxe_doc>
		</onceReplaceSound>
		<offReplaceSound public="1" set="method" line="1368">
			<f a="?handleNewSoundPrevSound">
				<f a="newSound:prevSound">
					<c path="ceramic.Sound"/>
					<c path="ceramic.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceSound event</haxe_doc>
		</offReplaceSound>
		<listensReplaceSound public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to replaceSound event</haxe_doc>
		</listensReplaceSound>
		<stream public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</stream>
		<invalidateSound public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateSound>
		<sound public="1" expr="null">
			<c path="ceramic.Sound"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</sound>
		<unobservedSound>
			<c path="ceramic.Sound"/>
			<haxe_doc></haxe_doc>
		</unobservedSound>
		<_dox_event_soundChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.Sound"/>
				<c path="ceramic.Sound"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when sound field changes.</haxe_doc>
		</_dox_event_soundChange>
		<emitSoundChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.Sound"/>
				<c path="ceramic.Sound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when sound field changes.</haxe_doc>
		</emitSoundChange>
		<onSoundChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Sound"/>
					<c path="ceramic.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when sound field changes.</haxe_doc>
		</onSoundChange>
		<onceSoundChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Sound"/>
					<c path="ceramic.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when sound field changes.</haxe_doc>
		</onceSoundChange>
		<offSoundChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.Sound"/>
					<c path="ceramic.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when sound field changes.</haxe_doc>
		</offSoundChange>
		<listensSoundChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when sound field changes.</haxe_doc>
		</listensSoundChange>
		<load public="1" set="method" line="22" override="1"><f a=""><x path="Void"/></f></load>
		<assetFilesDidChange set="method" line="118" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="139" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="16"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.SoundPlayer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SoundPlayer.hx">
		<this><t path="backend.AudioHandle"/></this>
		<impl><class path="ceramic._SoundPlayer.SoundPlayer_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SoundPlayer.hx" private="1" module="ceramic.SoundPlayer" final="1">
	<pause public="1" get="inline" set="null" line="10" static="1">
		<f a="this">
			<t path="backend.AudioHandle"/>
			<x path="Void"/>
		</f>
		<haxe_doc>* Pause the sound (for later resume).</haxe_doc>
	</pause>
	<resume public="1" get="inline" set="null" line="19" static="1">
		<f a="this">
			<t path="backend.AudioHandle"/>
			<x path="Void"/>
		</f>
		<haxe_doc>* Resume playing the sound.</haxe_doc>
	</resume>
	<stop public="1" get="inline" set="null" line="28" static="1">
		<f a="this">
			<t path="backend.AudioHandle"/>
			<x path="Void"/>
		</f>
		<haxe_doc>* Stop the sound.</haxe_doc>
	</stop>
	<volume public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The volume of the sound being played.</haxe_doc>
	</volume>
	<get_volume get="inline" set="null" line="38" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_volume>
	<set_volume get="inline" set="null" line="41" static="1"><f a="this:volume">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
	<pan public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The pan of the sound being played.</haxe_doc>
	</pan>
	<get_pan get="inline" set="null" line="50" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_pan>
	<set_pan get="inline" set="null" line="53" static="1"><f a="this:pan">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
	<pitch public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The pitch of the sound being played.</haxe_doc>
	</pitch>
	<get_pitch get="inline" set="null" line="62" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_pitch>
	<set_pitch get="inline" set="null" line="65" static="1"><f a="this:pitch">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_pitch>
	<position public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The position (in seconds) of the sound being played.</haxe_doc>
	</position>
	<get_position get="inline" set="null" line="74" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_position>
	<set_position get="inline" set="null" line="77" static="1"><f a="this:position">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
	<fadeOut public="1" set="method" line="84" static="1"><f a="this:duration">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fadeOut>
</class></impl>
	</abstract>
	<class path="ceramic._SoundPlayer.SoundPlayer_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SoundPlayer.hx" private="1" module="ceramic.SoundPlayer" final="1">
		<pause public="1" get="inline" set="null" line="10" static="1">
			<f a="this">
				<t path="backend.AudioHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pause the sound (for later resume).</haxe_doc>
		</pause>
		<resume public="1" get="inline" set="null" line="19" static="1">
			<f a="this">
				<t path="backend.AudioHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resume playing the sound.</haxe_doc>
		</resume>
		<stop public="1" get="inline" set="null" line="28" static="1">
			<f a="this">
				<t path="backend.AudioHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stop the sound.</haxe_doc>
		</stop>
		<volume public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The volume of the sound being played.</haxe_doc>
		</volume>
		<get_volume get="inline" set="null" line="38" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_volume>
		<set_volume get="inline" set="null" line="41" static="1"><f a="this:volume">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<pan public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The pan of the sound being played.</haxe_doc>
		</pan>
		<get_pan get="inline" set="null" line="50" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_pan>
		<set_pan get="inline" set="null" line="53" static="1"><f a="this:pan">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
		<pitch public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The pitch of the sound being played.</haxe_doc>
		</pitch>
		<get_pitch get="inline" set="null" line="62" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_pitch>
		<set_pitch get="inline" set="null" line="65" static="1"><f a="this:pitch">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_pitch>
		<position public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The position (in seconds) of the sound being played.</haxe_doc>
		</position>
		<get_position get="inline" set="null" line="74" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_position>
		<set_position get="inline" set="null" line="77" static="1"><f a="this:position">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
		<fadeOut public="1" set="method" line="84" static="1"><f a="this:duration">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fadeOut>
	</class>
	<class path="ceramic.State" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/State.hx">
		<extends path="ceramic.Entity"/>
		<machine public="1" set="null" expr="null">
			<c path="ceramic.StateMachine"><x path="Any"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</machine>
		<enter public="1" set="method" line="14"><f a=""><x path="Void"/></f></enter>
		<update public="1" set="method" line="20"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<exit public="1" set="method" line="26"><f a=""><x path="Void"/></f></exit>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.StateMachineImpl</e></m>
		</meta>
	</class>
	<class path="ceramic.StateMachineBase" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/StateMachineBase.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<implements path="tracker.Observable"/>
		<NO_STATE final="1" set="null" expr="null" line="10" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* A way to assign null state to generic classes and let final target do what is best as a cast</haxe_doc>
		</NO_STATE>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.StateMachineBase"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.StateMachineBase"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.StateMachineBase"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.StateMachineBase"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.StateMachineBase"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<rawEntity public="1">
			<c path="ceramic.Entity"/>
			<meta>
				<m n=":noCompletion"/>
				<m n="entity"/>
				<m n=":keep"/>
			</meta>
		</rawEntity>
		<paused public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* When set to `true`, the state machine will stop calling `update()` on current state and related.</haxe_doc>
		</paused>
		<autoUpdate public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* When set to `true` (default). This state machine will be updated automatically.
     * If `false`, you'll need to call `update()` manually.</haxe_doc>
		</autoUpdate>
		<stateDefined public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Is `true` if a state has been assigned, `false` otherwise.</haxe_doc>
		</stateDefined>
		<nextStateDefined public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Is `true` if a nextState has been assigned, `false` otherwise.</haxe_doc>
		</nextStateDefined>
		<locked public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If set to `true`, changing state will be forbidden and trigger an error.</haxe_doc>
		</locked>
		<stateInstances expr="null">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.State"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</stateInstances>
		<currentStateInstance expr="null">
			<c path="ceramic.State"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</currentStateInstance>
		<update public="1" set="method" line="54"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<bindAsComponent set="method" line="60"><f a=""><x path="Void"/></f></bindAsComponent>
		<destroy public="1" set="method" line="66" override="1"><f a=""><x path="Void"/></f></destroy>
		<setEntity set="method" line="5">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="5">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="46"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.StateMachineImpl" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/StateMachineImpl.hx">
		<extends path="ceramic.StateMachineBase"/>
		<invalidateState public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateState>
		<state public="1" set="accessor" expr="StateMachineBase.NO_STATE">
			<c path="ceramic.StateMachineImpl.T"/>
			<meta>
				<m n=":value"><e>StateMachineBase.NO_STATE</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* The current state</haxe_doc>
		</state>
		<unobservedState>
			<c path="ceramic.StateMachineImpl.T"/>
			<haxe_doc></haxe_doc>
		</unobservedState>
		<_dox_event_stateChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.StateMachineImpl.T"/>
				<c path="ceramic.StateMachineImpl.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when state field changes.</haxe_doc>
		</_dox_event_stateChange>
		<emitStateChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.StateMachineImpl.T"/>
				<c path="ceramic.StateMachineImpl.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when state field changes.</haxe_doc>
		</emitStateChange>
		<onStateChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.StateMachineImpl.T"/>
					<c path="ceramic.StateMachineImpl.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when state field changes.</haxe_doc>
		</onStateChange>
		<onceStateChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.StateMachineImpl.T"/>
					<c path="ceramic.StateMachineImpl.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when state field changes.</haxe_doc>
		</onceStateChange>
		<offStateChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.StateMachineImpl.T"/>
					<c path="ceramic.StateMachineImpl.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when state field changes.</haxe_doc>
		</offStateChange>
		<listensStateChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when state field changes.</haxe_doc>
		</listensStateChange>
		<nextState public="1" set="null" expr="StateMachineBase.NO_STATE">
			<c path="ceramic.StateMachineImpl.T"/>
			<meta><m n=":value"><e>StateMachineBase.NO_STATE</e></m></meta>
			<haxe_doc>* When transitioning from one state to another,
     * this will be set to the next incoming state</haxe_doc>
		</nextState>
		<set_state set="method" line="17"><f a="state">
	<c path="ceramic.StateMachineImpl.T"/>
	<c path="ceramic.StateMachineImpl.T"/>
</f></set_state>
		<computeStateDefined set="method" line="54"><f a="state">
	<c path="ceramic.StateMachineImpl.T"/>
	<x path="Bool"/>
</f></computeStateDefined>
		<keyToString set="method" line="60"><f a="key">
	<c path="ceramic.StateMachineImpl.T"/>
	<c path="String"/>
</f></keyToString>
		<set public="1" set="method" line="67"><f a="key:stateInstance">
	<c path="ceramic.StateMachineImpl.T"/>
	<c path="ceramic.State"/>
	<x path="Void"/>
</f></set>
		<get public="1" set="method" line="102"><f a="key">
	<c path="ceramic.StateMachineImpl.T"/>
	<c path="ceramic.State"/>
</f></get>
		<update public="1" set="method" line="114" override="1"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<scheduleOnceEnterState public="1" set="method" line="120"><f a="owner:state:callback">
	<c path="ceramic.Entity"/>
	<c path="ceramic.StateMachineImpl.T"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></scheduleOnceEnterState>
		<scheduleOnceExitState public="1" set="method" line="134"><f a="owner:state:callback">
	<c path="ceramic.Entity"/>
	<c path="ceramic.StateMachineImpl.T"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></scheduleOnceExitState>
		<_enterState set="method" line="148"><f a=""><x path="Void"/></f></_enterState>
		<_updateState set="method" line="158"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></_updateState>
		<_exitState set="method" line="168"><f a=""><x path="Void"/></f></_exitState>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="4"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.StateMachine" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/StateMachine.hx">
		<extends path="ceramic.StateMachineImpl"><c path="ceramic.StateMachine.T"/></extends>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.StateMachineComponent" params="T:E" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/StateMachineComponent.hx">
		<extends path="ceramic.StateMachineImpl"><c path="ceramic.StateMachineComponent.T"/></extends>
		<entity public="1" set="null">
			<c path="ceramic.StateMachineComponent.E"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<setEntity set="method" line="8" override="1">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="8" override="1">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.StateMachineSystem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/StateMachineSystem.hx">
		<extends path="ceramic.System"/>
		<shared public="1" expr="new StateMachineSystem()" line="11" static="1">
			<c path="ceramic.StateMachineSystem"/>
			<meta>
				<m n=":value"><e>new StateMachineSystem()</e></m>
				<m n="lazy"/>
			</meta>
			<haxe_doc>* Shared state machine system</haxe_doc>
		</shared>
		<stateMachines expr="[]">
			<c path="Array"><c path="ceramic.StateMachineBase"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</stateMachines>
		<_updatingStateMachines expr="[]">
			<c path="Array"><c path="ceramic.StateMachineBase"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_updatingStateMachines>
		<lateUpdate set="method" line="25" override="1"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></lateUpdate>
		<new set="method" line="17"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":allow"><e>ceramic.StateMachineBase</e></m>
		</meta>
	</class>
	<class path="ceramic.Systems" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Systems.hx">
		<extends path="ceramic.Entity"/>
		<sortSystemsByEarlyUpdateOrder set="method" line="146" static="1"><f a="a:b">
	<c path="ceramic.System"/>
	<c path="ceramic.System"/>
	<x path="Int"/>
</f></sortSystemsByEarlyUpdateOrder>
		<sortSystemsByLateUpdateOrder set="method" line="157" static="1"><f a="a:b">
	<c path="ceramic.System"/>
	<c path="ceramic.System"/>
	<x path="Int"/>
</f></sortSystemsByLateUpdateOrder>
		<earlyUpdateOrderDirty expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If `true`, `earlyUpdateOrdered` list needs to be sorted</haxe_doc>
		</earlyUpdateOrderDirty>
		<lateUpdateOrderDirty expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If `true`, `lateUpdateOrdered` list needs to be sorted</haxe_doc>
		</lateUpdateOrderDirty>
		<earlyUpdateOrdered expr="[]">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.System"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* List of systems, ordered ascending according to their `earlyUpdateOrder` property</haxe_doc>
		</earlyUpdateOrdered>
		<lateUpdateOrdered expr="[]">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.System"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* List of systems, ordered ascending according to their `lateUpdateOrder` property</haxe_doc>
		</lateUpdateOrdered>
		<_udpatingSystems expr="[]">
			<c path="Array"><c path="ceramic.System"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal pre-allocated array used for iteration</haxe_doc>
		</_udpatingSystems>
		<addSystem set="method" line="43"><f a="system">
	<c path="ceramic.System"/>
	<x path="Void"/>
</f></addSystem>
		<removeSystem set="method" line="53"><f a="system">
	<c path="ceramic.System"/>
	<x path="Void"/>
</f></removeSystem>
		<earlyUpdate set="method" line="63"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></earlyUpdate>
		<lateUpdate set="method" line="96"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></lateUpdate>
		<get public="1" set="method" line="131"><f a="name">
	<c path="String"/>
	<c path="ceramic.System"/>
</f></get>
		<new set="method" line="37"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<class path="ceramic.Task" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Task.hx">
		<extends path="ceramic.Entity"/>
		<_dox_event_done public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_done>
		<emitDone set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>done event</haxe_doc>
		</emitDone>
		<onDone public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>done event</haxe_doc>
		</onDone>
		<onceDone public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>done event</haxe_doc>
		</onceDone>
		<offDone public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>done event</haxe_doc>
		</offDone>
		<listensDone public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to done event</haxe_doc>
		</listensDone>
		<_dox_event_fail public="1" set="method" line="637">
			<f a="reason">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_fail>
		<emitFail set="method" line="1095">
			<f a="reason">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>fail event</haxe_doc>
		</emitFail>
		<onFail public="1" set="method" line="1199">
			<f a="owner:handleReason">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="reason">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>fail event</haxe_doc>
		</onFail>
		<onceFail public="1" set="method" line="1298">
			<f a="owner:handleReason">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="reason">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>fail event</haxe_doc>
		</onceFail>
		<offFail public="1" set="method" line="1368">
			<f a="?handleReason">
				<f a="reason">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>fail event</haxe_doc>
		</offFail>
		<listensFail public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to fail event</haxe_doc>
		</listensFail>
		<done public="1" set="method" line="12"><f a=""><x path="Void"/></f></done>
		<fail public="1" set="method" line="18"><f a="reason">
	<c path="String"/>
	<x path="Void"/>
</f></fail>
		<run public="1" set="method" line="26"><f a=""><x path="Void"/></f></run>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Tasks" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Tasks.hx">
		<runFromArgs public="1" set="method" line="8" static="1"><f a=""><x path="Void"/></f></runFromArgs>
		<run public="1" set="method" line="32" static="1"><f a="taskName">
	<c path="String"/>
	<x path="Void"/>
</f></run>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Text" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Text.hx">
		<extends path="ceramic.Visual"/>
		<_dox_event_glyphQuadsChange public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_glyphQuadsChange>
		<emitGlyphQuadsChange set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>glyphQuadsChange event</haxe_doc>
		</emitGlyphQuadsChange>
		<onGlyphQuadsChange public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>glyphQuadsChange event</haxe_doc>
		</onGlyphQuadsChange>
		<onceGlyphQuadsChange public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>glyphQuadsChange event</haxe_doc>
		</onceGlyphQuadsChange>
		<offGlyphQuadsChange public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>glyphQuadsChange event</haxe_doc>
		</offGlyphQuadsChange>
		<listensGlyphQuadsChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to glyphQuadsChange event</haxe_doc>
		</listensGlyphQuadsChange>
		<glyphQuads public="1" set="null" expr="[]">
			<c path="Array"><c path="ceramic.GlyphQuad"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</glyphQuads>
		<numLines public="1" get="accessor" set="null" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</numLines>
		<get_numLines set="method" line="21"><f a=""><x path="Int"/></f></get_numLines>
		<color public="1" set="accessor" expr="Color.WHITE">
			<x path="ceramic.Color"/>
			<meta>
				<m n=":value"><e>Color.WHITE</e></m>
				<m n="editable"/>
			</meta>
		</color>
		<set_color set="method" line="28"><f a="color">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
		<content public="1" set="accessor" expr="&quot;&quot;">
			<c path="String"/>
			<meta>
				<m n=":value"><e>""</e></m>
				<m n="editable"><e>{ multiline : true }</e></m>
			</meta>
		</content>
		<set_content set="method" line="45"><f a="content">
	<c path="String"/>
	<c path="String"/>
</f></set_content>
		<pointSize public="1" set="accessor" expr="20">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>20</e></m>
				<m n="editable"><e>{ slider : [6, 600] }</e></m>
			</meta>
		</pointSize>
		<set_pointSize set="method" line="55"><f a="pointSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pointSize>
		<lineHeight public="1" set="accessor" expr="1.0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1.0</e></m>
				<m n="editable"><e>{ slider : [0, 10] }</e></m>
			</meta>
		</lineHeight>
		<set_lineHeight set="method" line="64"><f a="lineHeight">
	<x path="Float"/>
	<x path="Float"/>
</f></set_lineHeight>
		<letterSpacing public="1" set="accessor" expr="0.0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.0</e></m>
				<m n="editable"><e>{ slider : [-100, 100] }</e></m>
			</meta>
		</letterSpacing>
		<set_letterSpacing set="method" line="73"><f a="letterSpacing">
	<x path="Float"/>
	<x path="Float"/>
</f></set_letterSpacing>
		<font public="1" set="accessor">
			<c path="ceramic.BitmapFont"/>
			<meta><m n="editable"/></meta>
		</font>
		<set_font set="method" line="82"><f a="font">
	<c path="ceramic.BitmapFont"/>
	<c path="ceramic.BitmapFont"/>
</f></set_font>
		<clipTextX public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</clipTextX>
		<set_clipTextX set="method" line="109"><f a="clipTextX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_clipTextX>
		<clipTextY public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</clipTextY>
		<set_clipTextY set="method" line="117"><f a="clipTextY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_clipTextY>
		<clipTextWidth public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</clipTextWidth>
		<set_clipTextWidth set="method" line="125"><f a="clipTextWidth">
	<x path="Float"/>
	<x path="Float"/>
</f></set_clipTextWidth>
		<clipTextHeight public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</clipTextHeight>
		<set_clipTextHeight set="method" line="133"><f a="clipTextHeight">
	<x path="Float"/>
	<x path="Float"/>
</f></set_clipTextHeight>
		<clipText public="1" set="method" line="140"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clipText>
		<preRenderedSize public="1" set="accessor" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</preRenderedSize>
		<set_preRenderedSize set="method" line="148"><f a="preRenderedSize">
	<x path="Int"/>
	<x path="Int"/>
</f></set_preRenderedSize>
		<handleTexturesDensityChange set="method" line="161"><f a="_:_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></handleTexturesDensityChange>
		<align public="1" set="accessor" expr="LEFT">
			<e path="ceramic.TextAlign"/>
			<meta>
				<m n=":value"><e>LEFT</e></m>
				<m n="editable"/>
			</meta>
		</align>
		<set_align set="method" line="167"><f a="align">
	<e path="ceramic.TextAlign"/>
	<e path="ceramic.TextAlign"/>
</f></set_align>
		<fitWidth public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* If set to `true`, text will be displayed with line breaks
     * as needed so that it fits in the requested width.</haxe_doc>
		</fitWidth>
		<set_fitWidth set="method" line="180"><f a="fitWidth">
	<x path="Float"/>
	<x path="Float"/>
</f></set_fitWidth>
		<maxLineDiff public="1" set="accessor" expr="-1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="editable"/>
			</meta>
		</maxLineDiff>
		<set_maxLineDiff set="method" line="189"><f a="maxLineDiff">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxLineDiff>
		<set_depth set="method" line="198" override="1"><f a="depth">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depth>
		<get_width set="method" line="212" override="1"><f a=""><x path="Float"/></f></get_width>
		<scaleWidth set="method" line="217"><f a="targetWidth">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleWidth>
		<get_height set="method" line="224" override="1"><f a=""><x path="Float"/></f></get_height>
		<scaleHeight set="method" line="229"><f a="targetHeight">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleHeight>
		<set_blending set="method" line="236" override="1"><f a="blending">
	<x path="ceramic.Blending"/>
	<x path="ceramic.Blending"/>
</f></set_blending>
		<destroy public="1" set="method" line="259" override="1"><f a=""><x path="Void"/></f></destroy>
		<computeContent public="1" set="method" line="274" override="1"><f a=""><x path="Void"/></f></computeContent>
		<computeGlyphQuads set="method" line="299">
			<f a="fitWidth:maxLineDiff:?fixedNumLines" v="::-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ fixedNumLines : -1 }</e></m></meta>
		</computeGlyphQuads>
		<lineForYPosition public="1" set="method" line="653">
			<f a="y">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the line number matching the given `y` position.
     * `y` is relative this `Text` visual.</haxe_doc>
		</lineForYPosition>
		<posInLineForX public="1" set="method" line="679">
			<f a="line:x">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the character index position relative to `line` at the requested `x` value.
     * `x` is relative this `Text` visual.</haxe_doc>
		</posInLineForX>
		<indexForPosInLine public="1" set="method" line="713">
			<f a="line:posInLine">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the _global_ character index from the given `line` and `posInLine` index position relative to `line`</haxe_doc>
		</indexForPosInLine>
		<xPositionAtIndex public="1" set="method" line="738">
			<f a="index">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get an `x` position from the given character `index`.
     * `x` is relative to this `Text` visual.</haxe_doc>
		</xPositionAtIndex>
		<lineForIndex public="1" set="method" line="774">
			<f a="index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the line number (starting from zero) of the character at the given `index`</haxe_doc>
		</lineForIndex>
		<posInLineForIndex public="1" set="method" line="806">
			<f a="index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get a character index position relative to its line from its _global_ `index` position.</haxe_doc>
		</posInLineForIndex>
		<fontDestroyed set="method" line="848"><f a="_">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></fontDestroyed>
		<toString set="method" line="857" override="1"><f a=""><c path="String"/></f></toString>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="250"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A visual to layout and display text.
 * Works with UTF-8 strings.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n="editable"><e>{ implicitSize : true }</e></m>
		</meta>
	</class>
	<enum path="ceramic.TextAlign" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextAlign.hx">
		<LEFT/>
		<RIGHT/>
		<CENTER/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.TextAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextAsset.hx">
		<extends path="ceramic.Asset"/>
		<invalidateText public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateText>
		<text public="1" expr="null">
			<c path="String"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</text>
		<unobservedText>
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</unobservedText>
		<_dox_event_textChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</_dox_event_textChange>
		<emitTextChange set="method" line="1095">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</emitTextChange>
		<onTextChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</onTextChange>
		<onceTextChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</onceTextChange>
		<offTextChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</offTextChange>
		<listensTextChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</listensTextChange>
		<load public="1" set="method" line="15" override="1"><f a=""><x path="Void"/></f></load>
		<assetFilesDidChange set="method" line="64" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="85" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="9"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.TextInput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextInput.hx">
		<implements path="tracker.Events"/>
		<_dox_event__update public="1" set="method" line="637">
			<f a="text">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__update>
		<emitUpdate set="method" line="1095">
			<f a="text">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>update event</haxe_doc>
		</emitUpdate>
		<onUpdate public="1" set="method" line="1199">
			<f a="owner:handleText">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="text">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onUpdate>
		<onceUpdate public="1" set="method" line="1298">
			<f a="owner:handleText">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="text">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onceUpdate>
		<offUpdate public="1" set="method" line="1368">
			<f a="?handleText">
				<f a="text">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</offUpdate>
		<listensUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to update event</haxe_doc>
		</listensUpdate>
		<_dox_event__enter public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__enter>
		<emitEnter set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>enter event</haxe_doc>
		</emitEnter>
		<onEnter public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>enter event</haxe_doc>
		</onEnter>
		<onceEnter public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>enter event</haxe_doc>
		</onceEnter>
		<offEnter public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>enter event</haxe_doc>
		</offEnter>
		<listensEnter public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to enter event</haxe_doc>
		</listensEnter>
		<_dox_event__escape public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__escape>
		<emitEscape set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>escape event</haxe_doc>
		</emitEscape>
		<onEscape public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>escape event</haxe_doc>
		</onEscape>
		<onceEscape public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>escape event</haxe_doc>
		</onceEscape>
		<offEscape public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>escape event</haxe_doc>
		</offEscape>
		<listensEscape public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to escape event</haxe_doc>
		</listensEscape>
		<_dox_event__selection public="1" set="method" line="637">
			<f a="selectionStart:selectionEnd">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__selection>
		<emitSelection set="method" line="1095">
			<f a="selectionStart:selectionEnd">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>selection event</haxe_doc>
		</emitSelection>
		<onSelection public="1" set="method" line="1199">
			<f a="owner:handleSelectionStartSelectionEnd">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="selectionStart:selectionEnd">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>selection event</haxe_doc>
		</onSelection>
		<onceSelection public="1" set="method" line="1298">
			<f a="owner:handleSelectionStartSelectionEnd">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="selectionStart:selectionEnd">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>selection event</haxe_doc>
		</onceSelection>
		<offSelection public="1" set="method" line="1368">
			<f a="?handleSelectionStartSelectionEnd">
				<f a="selectionStart:selectionEnd">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>selection event</haxe_doc>
		</offSelection>
		<listensSelection public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to selection event</haxe_doc>
		</listensSelection>
		<_dox_event__stop public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__stop>
		<emitStop set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>stop event</haxe_doc>
		</emitStop>
		<onStop public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>stop event</haxe_doc>
		</onStop>
		<onceStop public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>stop event</haxe_doc>
		</onceStop>
		<offStop public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>stop event</haxe_doc>
		</offStop>
		<listensStop public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to stop event</haxe_doc>
		</listensStop>
		<inputActive expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</inputActive>
		<explicitPosInLine expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</explicitPosInLine>
		<explicitPosLine expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</explicitPosLine>
		<lshiftPressed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lshiftPressed>
		<rshiftPressed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rshiftPressed>
		<lctrlPressed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lctrlPressed>
		<rctrlPressed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rctrlPressed>
		<lmetaPressed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lmetaPressed>
		<rmetaPressed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rmetaPressed>
		<invertedSelection expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</invertedSelection>
		<allowMovingCursor public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</allowMovingCursor>
		<multiline public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</multiline>
		<text public="1" set="accessor" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</text>
		<selectionStart public="1" set="null" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</selectionStart>
		<selectionEnd public="1" set="null" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</selectionEnd>
		<delegate public="1" set="null" expr="null">
			<c path="ceramic.TextInputDelegate"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</delegate>
		<start public="1" set="method" line="74">
			<f a="text:x:y:w:h:?multiline:?selectionStart:?selectionEnd:?allowMovingCursor:?delegate" v=":::::false:-1:-1:false:null">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="ceramic.TextInputDelegate"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ delegate : null, allowMovingCursor : false, selectionEnd : -1, selectionStart : -1, multiline : false }</e></m></meta>
		</start>
		<stop public="1" set="method" line="99"><f a=""><x path="Void"/></f></stop>
		<updateSelection public="1" set="method" line="114"><f a="selectionStart:selectionEnd:?inverted">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></updateSelection>
		<appendText public="1" set="method" line="125"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<space public="1" set="method" line="157"><f a=""><x path="Void"/></f></space>
		<backspace public="1" set="method" line="163"><f a=""><x path="Void"/></f></backspace>
		<moveLeft public="1" set="method" line="187"><f a=""><x path="Void"/></f></moveLeft>
		<moveRight public="1" set="method" line="241"><f a=""><x path="Void"/></f></moveRight>
		<moveUp public="1" set="method" line="298"><f a=""><x path="Void"/></f></moveUp>
		<moveDown public="1" set="method" line="358"><f a=""><x path="Void"/></f></moveDown>
		<enter public="1" set="method" line="449"><f a=""><x path="Void"/></f></enter>
		<escape public="1" set="method" line="462"><f a=""><x path="Void"/></f></escape>
		<lshiftDown public="1" set="method" line="469"><f a=""><x path="Void"/></f></lshiftDown>
		<lshiftUp public="1" set="method" line="475"><f a=""><x path="Void"/></f></lshiftUp>
		<rshiftDown public="1" set="method" line="481"><f a=""><x path="Void"/></f></rshiftDown>
		<rshiftUp public="1" set="method" line="487"><f a=""><x path="Void"/></f></rshiftUp>
		<lctrlDown public="1" set="method" line="493"><f a=""><x path="Void"/></f></lctrlDown>
		<lctrlUp public="1" set="method" line="499"><f a=""><x path="Void"/></f></lctrlUp>
		<rctrlDown public="1" set="method" line="505"><f a=""><x path="Void"/></f></rctrlDown>
		<rctrlUp public="1" set="method" line="511"><f a=""><x path="Void"/></f></rctrlUp>
		<lmetaDown public="1" set="method" line="517"><f a=""><x path="Void"/></f></lmetaDown>
		<lmetaUp public="1" set="method" line="523"><f a=""><x path="Void"/></f></lmetaUp>
		<rmetaDown public="1" set="method" line="529"><f a=""><x path="Void"/></f></rmetaDown>
		<rmetaUp public="1" set="method" line="535"><f a=""><x path="Void"/></f></rmetaUp>
		<posInCurrentLine set="method" line="546">
			<f a="globalPos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the position in the current line, from the given global position in text</haxe_doc>
		</posInCurrentLine>
		<lineForPos set="method" line="570">
			<f a="globalPos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the current line (starts from 0) from the given global position in text</haxe_doc>
		</lineForPos>
		<numLines set="method" line="588"><f a=""><x path="Int"/></f></numLines>
		<globalPosForLine set="method" line="596"><f a="lineNumber:lineOffset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></globalPosForLine>
		<set_text set="method" line="625"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new set="method" line="59"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<class path="ceramic.TextureAtlas" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlas.hx">
		<extends path="ceramic.Entity"/>
		<pages public="1" expr="[]">
			<c path="Array"><c path="ceramic.TextureAtlasPage"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The pages of this atlas.</haxe_doc>
		</pages>
		<regions public="1" expr="[]">
			<c path="Array"><c path="ceramic.TextureAtlasRegion"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The texture regions of this atlas</haxe_doc>
		</regions>
		<asset public="1" expr="null">
			<c path="ceramic.AtlasAsset"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The asset related to this atlas (if any)</haxe_doc>
		</asset>
		<region public="1" set="method" line="28"><f a="name">
	<c path="String"/>
	<c path="ceramic.TextureAtlasRegion"/>
</f></region>
		<computeFrames public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Expected to be called when every page got their texture loaded,
     * in order to compute the actual frames of each region</haxe_doc>
		</computeFrames>
		<destroy public="1" set="method" line="53" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.TextureAtlasPacker" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasPacker.hx">
		<extends path="ceramic.Entity"/>
		<MIN_TEXTURE_SIZE final="1" set="null" expr="32" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</MIN_TEXTURE_SIZE>
		<MAX_TEXTURE_SIZE final="1" set="null" expr="2048" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2048</e></m></meta>
		</MAX_TEXTURE_SIZE>
		<_dox_event_finishPack public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_finishPack>
		<emitFinishPack set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>finishPack event</haxe_doc>
		</emitFinishPack>
		<onFinishPack public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>finishPack event</haxe_doc>
		</onFinishPack>
		<onceFinishPack public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>finishPack event</haxe_doc>
		</onceFinishPack>
		<offFinishPack public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>finishPack event</haxe_doc>
		</offFinishPack>
		<listensFinishPack public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to finishPack event</haxe_doc>
		</listensFinishPack>
		<atlas public="1" set="null" expr="null">
			<c path="ceramic.TextureAtlas"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</atlas>
		<spacing public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</spacing>
		<filter public="1" expr="LINEAR">
			<e path="ceramic.TextureFilter"/>
			<meta><m n=":value"><e>LINEAR</e></m></meta>
		</filter>
		<pendingRegions expr="[]">
			<c path="Array"><c path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pendingRegions>
		<pages expr="[]">
			<c path="Array"><c path="ceramic._TextureAtlasPacker.TextureAtlasPackerPage"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pages>
		<hasPendingRegions public="1" set="method" line="32"><f a=""><x path="Bool"/></f></hasPendingRegions>
		<region public="1" set="method" line="38"><f a="name">
	<c path="String"/>
	<c path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion"/>
</f></region>
		<removeRegionsWithMatcher public="1" set="method" line="65">
			<f a="?removeAtlasRegions:matcher" v="true:">
				<x path="Bool"/>
				<f a="regionName">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ removeAtlasRegions : true }</e></m></meta>
		</removeRegionsWithMatcher>
		<removeRegionsWithPrefix public="1" set="method" line="143">
			<f a="?removeAtlasRegions:prefix" v="true:">
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ removeAtlasRegions : true }</e></m></meta>
		</removeRegionsWithPrefix>
		<destroy public="1" set="method" line="149" override="1"><f a=""><x path="Void"/></f></destroy>
		<add public="1" get="inline" set="null" line="191">
			<f a="name:pixels:originalWidth:originalHeight:packedWidth:?packedHeight:?offsetX:?offsetY" v=":::::-1:0:0">
				<c path="String"/>
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offsetY : 0, offsetX : 0, packedHeight : -1 }</e></m></meta>
			<haxe_doc><![CDATA[* Add a region to this atlas packer from the given pixels.
     * Example usage:
     *
     * ```haxe
     * atlas.add(region1, pixels1);
     * atlas.add(region2, pixels2);
     * atlas.pack(() -> {
     *     // Done packing new regions
     * });
     * ```]]></haxe_doc>
			<overloads><add public="1" get="inline" set="null" line="233">
	<f a="variantName:sourceName:originalWidth:originalHeight:?offsetX:?offsetY" v="::::0:0">
		<c path="String"/>
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{ offsetY : 0, offsetX : 0 }</e></m></meta>
	<haxe_doc>* Add a region to this atlas packer that is a variant of
     * another existing region: it has the same packed size in pixels
     * but can have different offsets and original size.</haxe_doc>
</add></overloads>
		</add>
		<_addRegionFromPixels set="method" line="205"><f a="name:pixels:originalWidth:originalHeight:packedWidth:packedHeight:offsetX:offsetY">
	<c path="String"/>
	<t path="ceramic.UInt8Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_addRegionFromPixels>
		<_addVariantRegion set="method" line="245"><f a="variantName:sourceName:originalWidth:originalHeight:offsetX:offsetY">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_addVariantRegion>
		<pack public="1" set="method" line="268">
			<f a="done">
				<f a="atlas">
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pack new regions added with `add()` to the texture atlas.
     * If no texture atlas exists yet, it will be created.</haxe_doc>
		</pack>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasPacker.hx" private="1" module="ceramic.TextureAtlasPacker">
		<name public="1">
			<c path="String"/>
			<haxe_doc>* Region name</haxe_doc>
		</name>
		<originalWidth public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Original region width (including margins / transparent pixels)</haxe_doc>
		</originalWidth>
		<originalHeight public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Original region height (including margins / transparent pixels)</haxe_doc>
		</originalHeight>
		<packedWidth public="1">
			<x path="Int"/>
			<haxe_doc>* Packed region width (without margins / transparent pixels)</haxe_doc>
		</packedWidth>
		<packedHeight public="1">
			<x path="Int"/>
			<haxe_doc>* Packed region height (without margins / transparent pixels)</haxe_doc>
		</packedHeight>
		<offsetX public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* X offset to position the region to its original size</haxe_doc>
		</offsetX>
		<offsetY public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Y offset to position the region to its original size</haxe_doc>
		</offsetY>
		<pixels public="1" expr="null">
			<t path="ceramic.UInt8Array"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If the region comes from a pixels buffer, this is the buffer</haxe_doc>
		</pixels>
		<sourceRegion public="1" expr="null">
			<c path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If the region is a variant of another region,
     * this is the other region used as source</haxe_doc>
		</sourceRegion>
		<rect public="1" expr="null">
			<c path="binpacking.Rect"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The rect describing how this region should be packed</haxe_doc>
		</rect>
		<rendered public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this region has been rendered to a page texture or not</haxe_doc>
		</rendered>
		<new public="1" set="method" line="530">
			<f a="name:?originalWidth:?originalHeight:packedWidth:packedHeight:?offsetX:?offsetY:?pixels:?sourceRegion:?rect:?rendered">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><x path="Int"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><t path="ceramic.UInt8Array"/></x>
				<x path="Null"><c path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion"/></x>
				<x path="Null"><c path="binpacking.Rect"/></x>
				<x path="Null"><x path="Bool"/></x>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc>@param rendered * Whether this region has been rendered to a page texture or not
@param rect * The rect describing how this region should be packed
@param sourceRegion * If the region is a variant of another region,
     * this is the other region used as source
@param pixels * If the region comes from a pixels buffer, this is the buffer
@param offsetY * Y offset to position the region to its original size
@param offsetX * X offset to position the region to its original size
@param packedHeight * Packed region height (without margins / transparent pixels)
@param packedWidth * Packed region width (without margins / transparent pixels)
@param originalHeight * Original region height (including margins / transparent pixels)
@param originalWidth * Original region width (including margins / transparent pixels)
@param name * Region name</haxe_doc>
		</new>
		<haxe_doc>* A region for a texture atlas packer. Not to be confused
 * with `TextureAtlasRegion` which is to be used with `TextureAtlas`,
 * while `TextureAtlasPackerRegion` is holding information to
 * pack a region with `TextureAtlasPacker` and is not a region
 * usable with an atlas yet.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
			<m n=":allow"><e>ceramic.TextureAtlasPacker</e></m>
			<m n=":allow"><e>ceramic.TextureAtlasPackerPage</e></m>
		</meta>
	</class>
	<class path="ceramic._TextureAtlasPacker.TextureAtlasPackerPage" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasPacker.hx" private="1" module="ceramic.TextureAtlasPacker">
		<spacing public="1"><x path="Int"/></spacing>
		<name public="1"><c path="String"/></name>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<regions public="1"><c path="Array"><c path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion"/></c></regions>
		<binPacker public="1"><c path="binpacking.MaxRectsPacker"/></binPacker>
		<shouldResetTexture public="1"><x path="Bool"/></shouldResetTexture>
		<new public="1" set="method" line="593">
			<f a="spacing:name:width:height:regions:binPacker:shouldResetTexture">
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion"/></c>
				<c path="binpacking.MaxRectsPacker"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
			<m n=":allow"><e>ceramic.TextureAtlasPacker</e></m>
			<m n=":allow"><e>ceramic.TextureAtlasPackerRegion</e></m>
		</meta>
	</class>
	<class path="ceramic.TextureAtlasPage" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasPage.hx">
		<implements path="tracker.Observable"/>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.TextureAtlasPage"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.TextureAtlasPage"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.TextureAtlasPage"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.TextureAtlasPage"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.TextureAtlasPage"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<invalidateName public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateName>
		<name public="1">
			<c path="String"/>
			<meta><m n="observe"/></meta>
		</name>
		<unobservedName>
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</unobservedName>
		<_dox_event_nameChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when name field changes.</haxe_doc>
		</_dox_event_nameChange>
		<emitNameChange set="method" line="1095">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when name field changes.</haxe_doc>
		</emitNameChange>
		<onNameChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when name field changes.</haxe_doc>
		</onNameChange>
		<onceNameChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when name field changes.</haxe_doc>
		</onceNameChange>
		<offNameChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when name field changes.</haxe_doc>
		</offNameChange>
		<listensNameChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when name field changes.</haxe_doc>
		</listensNameChange>
		<invalidateWidth public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateWidth>
		<width public="1" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
		</width>
		<unobservedWidth>
			<x path="Float"/>
			<haxe_doc></haxe_doc>
		</unobservedWidth>
		<_dox_event_widthChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when width field changes.</haxe_doc>
		</_dox_event_widthChange>
		<emitWidthChange set="method" line="1095">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when width field changes.</haxe_doc>
		</emitWidthChange>
		<onWidthChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when width field changes.</haxe_doc>
		</onWidthChange>
		<onceWidthChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when width field changes.</haxe_doc>
		</onceWidthChange>
		<offWidthChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when width field changes.</haxe_doc>
		</offWidthChange>
		<listensWidthChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when width field changes.</haxe_doc>
		</listensWidthChange>
		<invalidateHeight public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateHeight>
		<height public="1" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
		</height>
		<unobservedHeight>
			<x path="Float"/>
			<haxe_doc></haxe_doc>
		</unobservedHeight>
		<_dox_event_heightChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when height field changes.</haxe_doc>
		</_dox_event_heightChange>
		<emitHeightChange set="method" line="1095">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when height field changes.</haxe_doc>
		</emitHeightChange>
		<onHeightChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when height field changes.</haxe_doc>
		</onHeightChange>
		<onceHeightChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when height field changes.</haxe_doc>
		</onceHeightChange>
		<offHeightChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when height field changes.</haxe_doc>
		</offHeightChange>
		<listensHeightChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when height field changes.</haxe_doc>
		</listensHeightChange>
		<invalidateFilter public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateFilter>
		<filter public="1" set="accessor" expr="LINEAR">
			<e path="ceramic.TextureFilter"/>
			<meta>
				<m n=":value"><e>LINEAR</e></m>
				<m n="observe"/>
			</meta>
		</filter>
		<unobservedFilter>
			<e path="ceramic.TextureFilter"/>
			<haxe_doc></haxe_doc>
		</unobservedFilter>
		<_dox_event_filterChange public="1" set="method" line="637">
			<f a="current:previous">
				<e path="ceramic.TextureFilter"/>
				<e path="ceramic.TextureFilter"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when filter field changes.</haxe_doc>
		</_dox_event_filterChange>
		<emitFilterChange set="method" line="1095">
			<f a="current:previous">
				<e path="ceramic.TextureFilter"/>
				<e path="ceramic.TextureFilter"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when filter field changes.</haxe_doc>
		</emitFilterChange>
		<onFilterChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.TextureFilter"/>
					<e path="ceramic.TextureFilter"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when filter field changes.</haxe_doc>
		</onFilterChange>
		<onceFilterChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.TextureFilter"/>
					<e path="ceramic.TextureFilter"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when filter field changes.</haxe_doc>
		</onceFilterChange>
		<offFilterChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<e path="ceramic.TextureFilter"/>
					<e path="ceramic.TextureFilter"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when filter field changes.</haxe_doc>
		</offFilterChange>
		<listensFilterChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when filter field changes.</haxe_doc>
		</listensFilterChange>
		<set_filter set="method" line="14"><f a="filter">
	<e path="ceramic.TextureFilter"/>
	<e path="ceramic.TextureFilter"/>
</f></set_filter>
		<invalidateTexture public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTexture>
		<texture public="1" set="accessor" expr="null">
			<c path="ceramic.Texture"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</texture>
		<unobservedTexture>
			<c path="ceramic.Texture"/>
			<haxe_doc></haxe_doc>
		</unobservedTexture>
		<_dox_event_textureChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.Texture"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</_dox_event_textureChange>
		<emitTextureChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.Texture"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</emitTextureChange>
		<onTextureChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</onTextureChange>
		<onceTextureChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</onceTextureChange>
		<offTextureChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</offTextureChange>
		<listensTextureChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</listensTextureChange>
		<set_texture set="method" line="26"><f a="texture">
	<c path="ceramic.Texture"/>
	<c path="ceramic.Texture"/>
</f></set_texture>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="39">
			<f a="name:?width:?height:?filter:?texture" v=":0:0:LINEAR:null">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="ceramic.TextureFilter"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ texture : null, filter : LINEAR, height : 0, width : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.TextureAtlasParser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasParser.hx">
		<parse public="1" set="method" line="7" static="1"><f a="rawTextureAtlas">
	<c path="String"/>
	<c path="ceramic.TextureAtlas"/>
</f></parse>
		<convertXmlTextureAtlas set="method" line="158" static="1"><f a="rawTextureAtlas">
	<c path="String"/>
	<c path="String"/>
</f></convertXmlTextureAtlas>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic._TextureAtlasParser.TextureAtlasReader" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasParser.hx" private="1" module="ceramic.TextureAtlasParser">
		<lines><c path="Array"><c path="String"/></c></lines>
		<index><x path="Int"/></index>
		<trim public="1" set="method" line="229"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></trim>
		<readLine public="1" set="method" line="234"><f a=""><c path="String"/></f></readLine>
		<nextLineKey public="1" set="method" line="242"><f a=""><c path="String"/></f></nextLineKey>
		<readValue public="1" set="method" line="261"><f a=""><c path="String"/></f></readValue>
		<readTuple public="1" set="method" line="273">
			<f a="tuple">
				<c path="Array"><d/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of tuple values read (1, 2 or 4).</haxe_doc>
		</readTuple>
		<new public="1" set="method" line="223"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.TextureAtlasParser</e></m>
		</meta>
	</class>
	<class path="ceramic.TextureTile" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureTile.hx">
		<texture public="1"><c path="ceramic.Texture"/></texture>
		<frameX public="1"><x path="Float"/></frameX>
		<frameY public="1"><x path="Float"/></frameY>
		<frameWidth public="1"><x path="Float"/></frameWidth>
		<frameHeight public="1"><x path="Float"/></frameHeight>
		<rotateFrame public="1"><x path="Bool"/></rotateFrame>
		<edgeInset public="1">
			<x path="Float"/>
			<haxe_doc>* When assigning the file to a quad, edge uvs will be adjusted by this inset.
     * Can be useful to set it to values like `0.5` in some situations like
     * preventing atlas regions from displaying bleed from siblings.</haxe_doc>
		</edgeInset>
		<frame public="1" get="inline" set="null" line="37"><f a="frameX:frameY:frameWidth:frameHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></frame>
		<toString set="method" line="46"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="25">
			<f a="texture:frameX:frameY:frameWidth:frameHeight:?rotateFrame:?edgeInset" v=":::::false:0">
				<c path="ceramic.Texture"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ edgeInset : 0, rotateFrame : false }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="ceramic.TextureAtlasRegion" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasRegion.hx">
		<extends path="ceramic.TextureTile"/>
		<name public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</name>
		<atlas public="1" expr="null">
			<c path="ceramic.TextureAtlas"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</atlas>
		<page public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</page>
		<packedWidth public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Width in actual pixels after rotation (if any)</haxe_doc>
		</packedWidth>
		<packedHeight public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Height in actual pixels after rotation (if any)</haxe_doc>
		</packedHeight>
		<x public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<width public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</width>
		<height public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</height>
		<offsetX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetX>
		<offsetY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetY>
		<originalWidth public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Original width, white margins included</haxe_doc>
		</originalWidth>
		<originalHeight public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Original height, white margins included</haxe_doc>
		</originalHeight>
		<computeFrame public="1" set="method" line="68"><f a=""><x path="Void"/></f></computeFrame>
		<toString set="method" line="94" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="50"><f a="name:atlas:page">
	<c path="String"/>
	<c path="ceramic.TextureAtlas"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A texture atlas region is part of a texture atlas.
 * It is also a `TextureTile` subclass so that it can be assigned
 * to `Quad`'s `tile` property.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="ceramic.TextureFilter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureFilter.hx">
		<LINEAR/>
		<NEAREST/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.TextureTilePacker" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureTilePacker.hx">
		<extends path="ceramic.Entity"/>
		<texture public="1" set="null"><c path="ceramic.RenderTexture"/></texture>
		<padWidth public="1" set="null"><x path="Int"/></padWidth>
		<padHeight public="1" set="null"><x path="Int"/></padHeight>
		<margin public="1" set="null"><x path="Int"/></margin>
		<nextPacker public="1" expr="null">
			<c path="ceramic.TextureTilePacker"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</nextPacker>
		<areas><c path="Array"><c path="ceramic.TextureTile"/></c></areas>
		<numCols expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numCols>
		<numRows expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numRows>
		<maxPixelTextureWidth expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</maxPixelTextureWidth>
		<maxPixelTextureHeight expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</maxPixelTextureHeight>
		<destroy public="1" set="method" line="81" override="1"><f a=""><x path="Void"/></f></destroy>
		<getTileAtPosition get="inline" set="null" line="97"><f a="col:row">
	<x path="Int"/>
	<x path="Int"/>
	<c path="ceramic.TextureTile"/>
</f></getTileAtPosition>
		<setTileAtPosition get="inline" set="null" line="103"><f a="col:row:tile">
	<x path="Int"/>
	<x path="Int"/>
	<c path="ceramic.TextureTile"/>
	<x path="Void"/>
</f></setTileAtPosition>
		<allocTile public="1" set="method" line="111"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<c path="ceramic.TextureTile"/>
</f></allocTile>
		<releaseTile public="1" set="method" line="196"><f a="tile">
	<c path="ceramic.TextureTile"/>
	<x path="Void"/>
</f></releaseTile>
		<stamp public="1" set="method" line="241"><f a="tile:visual:done">
	<c path="ceramic.TextureTile"/>
	<c path="ceramic.Visual"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></stamp>
		<managesTexture public="1" set="method" line="283"><f a="texture">
	<c path="ceramic.Texture"/>
	<x path="Bool"/>
</f></managesTexture>
		<new public="1" set="method" line="30">
			<f a="autoRender:?maxPixelTextureWidth:?maxPixelTextureHeight:?padWidth:?padHeight:?margin" v=":-1:-1:16:16:1">
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ margin : 1, padHeight : 16, padWidth : 16, maxPixelTextureHeight : -1, maxPixelTextureWidth : -1 }</e></m></meta>
		</new>
		<haxe_doc>* Incremental texture tile packer that allows to alloc, release and reuse tiles as needed.</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic._TextureTilePacker.PackedTextureTile" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureTilePacker.hx" private="1" module="ceramic.TextureTilePacker">
		<extends path="ceramic.TextureTile"/>
		<col public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The column index of this tile</haxe_doc>
		</col>
		<row public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The row index of this tile</haxe_doc>
		</row>
		<usedCols public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* The number of column blocks used by this packed texture tile (starting from column index)</haxe_doc>
		</usedCols>
		<usedRows public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* The number of row blocks used by this packed texture tile (starting from row index)</haxe_doc>
		</usedRows>
		<new public="1" set="method" line="317"><f a="texture:frameX:frameY:frameWidth:frameHeight">
	<c path="ceramic.Texture"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Private class used internally to store additional texture tile data.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.TextureTilePacker</e></m>
		</meta>
	</class>
	<abstract path="ceramic.TextureWrap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureWrap.hx">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._TextureWrap.TextureWrap_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureWrap.hx" private="1" module="ceramic.TextureWrap" extern="1" final="1">
	<CLAMP public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="ceramic.TextureWrap"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CLAMP>
	<REPEAT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="ceramic.TextureWrap"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</REPEAT>
	<MIRROR public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="ceramic.TextureWrap"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MIRROR>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._TextureWrap.TextureWrap_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureWrap.hx" private="1" module="ceramic.TextureWrap" extern="1" final="1">
		<CLAMP public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="ceramic.TextureWrap"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CLAMP>
		<REPEAT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="ceramic.TextureWrap"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</REPEAT>
		<MIRROR public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="ceramic.TextureWrap"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MIRROR>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="ceramic.Timeline" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Timeline.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<_dox_event_startLabel public="1" set="method" line="637">
			<f a="index:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Triggered when position reaches an existing label
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</_dox_event_startLabel>
		<emitStartLabel set="method" line="1095">
			<f a="index:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Triggered when position reaches an existing label
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</emitStartLabel>
		<onStartLabel public="1" set="method" line="1199">
			<f a="owner:handleIndexName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="index:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches an existing label
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</onStartLabel>
		<onceStartLabel public="1" set="method" line="1298">
			<f a="owner:handleIndexName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="index:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches an existing label
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</onceStartLabel>
		<offStartLabel public="1" set="method" line="1368">
			<f a="?handleIndexName">
				<f a="index:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches an existing label
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</offStartLabel>
		<listensStartLabel public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches an existing label
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</listensStartLabel>
		<_dox_event_endLabel public="1" set="method" line="637">
			<f a="index:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Triggered when position reaches the end of an area following the given label.
     * Either when a new label was reached or when end of timeline was reached
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</_dox_event_endLabel>
		<emitEndLabel set="method" line="1095">
			<f a="index:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Triggered when position reaches the end of an area following the given label.
     * Either when a new label was reached or when end of timeline was reached
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</emitEndLabel>
		<onEndLabel public="1" set="method" line="1199">
			<f a="owner:handleIndexName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="index:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches the end of an area following the given label.
     * Either when a new label was reached or when end of timeline was reached
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</onEndLabel>
		<onceEndLabel public="1" set="method" line="1298">
			<f a="owner:handleIndexName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="index:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches the end of an area following the given label.
     * Either when a new label was reached or when end of timeline was reached
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</onceEndLabel>
		<offEndLabel public="1" set="method" line="1368">
			<f a="?handleIndexName">
				<f a="index:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches the end of an area following the given label.
     * Either when a new label was reached or when end of timeline was reached
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</offEndLabel>
		<listensEndLabel public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches the end of an area following the given label.
     * Either when a new label was reached or when end of timeline was reached
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</listensEndLabel>
		<size public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Timeline size. Default `0`, meaning this timeline won't do anything.
     * By default, because `autoFitSize` is `true`, adding or updating tracks on this
     * timeline will update timeline `size` accordingly so it may not be needed to update `size` explicitly.
     * Setting `size` to `-1` means the timeline will never finish.</haxe_doc>
		</size>
		<autoFitSize public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If set to `true` (default), adding or updating tracks on this timeline will update
     * timeline size accordingly to match longest track size.</haxe_doc>
		</autoFitSize>
		<loop public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether this timeline should loop. Ignored if timeline's `size` is `-1` (not defined).</haxe_doc>
		</loop>
		<autoUpdate public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether this timeline should bind itself to update cycle automatically or not (default `true`).</haxe_doc>
		</autoUpdate>
		<set_autoUpdate set="method" line="47"><f a="autoUpdate">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoUpdate>
		<fps public="1" expr="30">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
			<haxe_doc>* Frames per second on this timeline.
     * Note: a lower fps doesn't mean animations won't be interpolated between frames.
     * Thus using 30 fps is still fine even if screen refreshes at 60 fps.</haxe_doc>
		</fps>
		<position public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Position on this timeline.
     * Gets back to zero when `loop=true` and position reaches a defined `size`.</haxe_doc>
		</position>
		<tracks public="1" set="null" expr="[]">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></x>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The tracks updated by this timeline</haxe_doc>
		</tracks>
		<paused public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this timeline is paused or not.</haxe_doc>
		</paused>
		<set_paused set="method" line="77"><f a="paused">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_paused>
		<labels public="1" set="null" expr="null">
			<x path="ceramic.ReadOnlyArray"><c path="String"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Used in pair with `labelIndexes` to manage timeline labels</haxe_doc>
		</labels>
		<labelIndexes expr="null">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Used in pair with `labels` to manage timeline labels</haxe_doc>
		</labelIndexes>
		<startPosition public="1" set="accessor" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc><![CDATA[* If >= 0, timeline will start from this index.
     * When timeline is looping, it will reset to this index as well at each iteration.]]></haxe_doc>
		</startPosition>
		<set_startPosition set="method" line="99"><f a="startPosition">
	<x path="Int"/>
	<x path="Int"/>
</f></set_startPosition>
		<endPosition public="1" set="accessor" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc><![CDATA[* If provided, timeline will stop at this index.
     * When timeline is looping, it will reset to startIndex (if >= 0).]]></haxe_doc>
		</endPosition>
		<set_endPosition set="method" line="112"><f a="endPosition">
	<x path="Int"/>
	<x path="Int"/>
</f></set_endPosition>
		<completeHandlers expr="null">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Internal array of complete handlers</haxe_doc>
		</completeHandlers>
		<completeHandlerIndexes expr="null">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Internal array of complete handler label indexes</haxe_doc>
		</completeHandlerIndexes>
		<bindAsComponent set="method" line="139"><f a=""><x path="Void"/></f></bindAsComponent>
		<bindOrUnbindUpdateIfNeeded get="inline" set="null" line="149">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function to bind or update to app
     * update event depending on current settings</haxe_doc>
		</bindOrUnbindUpdateIfNeeded>
		<update public="1" set="method" line="159"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<seek final="1" public="1" set="method" line="169">
			<f a="targetPosition">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Seek the given position (in frames) in the timeline.
     * Will take care of clamping `position` or looping it depending on `size` and `loop` properties.</haxe_doc>
		</seek>
		<animate public="1" set="method" line="183">
			<f a="name:complete">
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Animate starting from the given label name and calls complete when
     * reaching the end of label area (= when animation finishes).
     * If animation is interrupted (by playing another animation, seeking another position...),
     * complete won't be called.
     * @param name Label name
     * @param complete callback fired when animation finishes.</haxe_doc>
		</animate>
		<seekLabel public="1" set="method" line="210">
			<f a="name">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Seek position to match the given label
     * @param name Label name
     * @return The index (position) of the looping label, or -1 if no label was found</haxe_doc>
		</seekLabel>
		<resetStartAndEndPositions public="1" set="method" line="228">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Reset `startPosition` and `endPosition`</haxe_doc>
		</resetStartAndEndPositions>
		<loopLabel public="1" set="method" line="242">
			<f a="name">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Seek position to match the given label and set startPosition and endPosition
     * so that it will loop through the whole area following this label, up to the
     * position of the next label or the end of the timeline.
     * @param name Label name
     * @return The index (position) of the looping label, or -1 if no label was found</haxe_doc>
		</loopLabel>
		<apply final="1" public="1" set="method" line="268">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
			<haxe_doc>* Apply (or re-apply) every track of this timeline at the current position</haxe_doc>
		</apply>
		<inlineSeek get="inline" set="null" line="274">
			<f a="targetPosition:?forceSeek:?forceChange" v=":false:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false, forceSeek : false }</e></m></meta>
		</inlineSeek>
		<clearCompleteHandlers get="inline" set="null" line="342"><f a=""><x path="Void"/></f></clearCompleteHandlers>
		<didEmitEndLabel set="method" line="352"><f a="index:name">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></didEmitEndLabel>
		<add public="1" set="method" line="398">
			<f a="track">
				<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a track to this timeline</haxe_doc>
		</add>
		<get public="1" set="method" line="414"><f a="trackId">
	<c path="String"/>
	<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
</f></get>
		<remove public="1" set="method" line="430">
			<f a="track">
				<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a track from this timeline</haxe_doc>
		</remove>
		<fitSize public="1" set="method" line="447">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update `size` property to make it fit
     * the size of the longuest track.</haxe_doc>
		</fitSize>
		<indexOfLabelBeforeIndex public="1" set="method" line="462"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></indexOfLabelBeforeIndex>
		<labelAtIndex public="1" set="method" line="487"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></labelAtIndex>
		<indexOfLabel public="1" set="method" line="508"><f a="name">
	<c path="String"/>
	<x path="Int"/>
</f></indexOfLabel>
		<setLabel public="1" set="method" line="523"><f a="index:name">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></setLabel>
		<removeLabelAtIndex public="1" set="method" line="539"><f a="index">
	<x path="Int"/>
	<x path="Bool"/>
</f></removeLabelAtIndex>
		<removeLabel public="1" set="method" line="556"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></removeLabel>
		<sortLabels set="method" line="573"><f a=""><x path="Void"/></f></sortLabels>
		<compareLabelIndexes set="method" line="582"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></compareLabelIndexes>
		<compareLabelNames set="method" line="593"><f a="nameA:nameB">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
</f></compareLabelNames>
		<entity public="1">
			<c path="ceramic.Entity"/>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</entity>
		<setEntity set="method" line="7">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="7">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="131"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.TimelineKeyframe" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineKeyframe.hx">
		<index public="1"><x path="Int"/></index>
		<easing public="1" expr="NONE">
			<e path="ceramic.Easing"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
		</easing>
		<new public="1" set="method" line="10"><f a="index:easing">
	<x path="Int"/>
	<e path="ceramic.Easing"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="ceramic.TimelineBoolKeyframe" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineBoolKeyframe.hx">
		<extends path="ceramic.TimelineKeyframe"/>
		<value public="1"><x path="Bool"/></value>
		<new public="1" set="method" line="8"><f a="value:index:easing">
	<x path="Bool"/>
	<x path="Int"/>
	<e path="ceramic.Easing"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.TimelineTrack" params="K" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineTrack.hx">
		<extends path="ceramic.Entity"/>
		<size public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Track size. Default `0`, meaning this track won't do anything.
     * By default, because `autoFitSize` is `true`, adding new keyframes to this
     * track will update `size` accordingly so it may not be needed to update `size` explicitly.
     * Setting `size` to `-1` means the track will never finish.</haxe_doc>
		</size>
		<autoFitSize public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If set to `true` (default), adding keyframes to this track will update
     * its size accordingly to match last keyframe time.</haxe_doc>
		</autoFitSize>
		<loop public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this track should loop. Ignored if track's `size` is `-1` (not defined).</haxe_doc>
		</loop>
		<locked public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this track is locked or not.
     * A locked track doesn't get updated by the timeline it is attached to, if any.</haxe_doc>
		</locked>
		<timeline public="1" set="null" expr="null">
			<c path="ceramic.Timeline"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":allow"><e>ceramic.Timeline</e></m>
			</meta>
			<haxe_doc>* Timeline on which this track is added to</haxe_doc>
		</timeline>
		<position public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Position on this track.
     * Gets back to zero when `loop=true` and position reaches a defined `size`.</haxe_doc>
		</position>
		<keyframes public="1" set="null" expr="[]">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.TimelineTrack.K"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The key frames on this track.</haxe_doc>
		</keyframes>
		<before public="1" set="null" expr="null">
			<c path="ceramic.TimelineTrack.K"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The keyframe right before or equal to current time, if any.</haxe_doc>
		</before>
		<after public="1" set="null" expr="null">
			<c path="ceramic.TimelineTrack.K"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The keyframe right after current time, if any.</haxe_doc>
		</after>
		<keyframeBeforeIndex expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The index of the last resolved `key index before`. Used internally.</haxe_doc>
		</keyframeBeforeIndex>
		<keyframeAfterIndex expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The index of the last resolved `key index after`. Used internally.</haxe_doc>
		</keyframeAfterIndex>
		<destroy public="1" set="method" line="82" override="1"><f a=""><x path="Void"/></f></destroy>
		<seek final="1" public="1" set="method" line="96">
			<f a="targetPosition">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Seek the given position (in frames) in the track.
     * Will take care of clamping `position` or looping it depending on `size` and `loop` properties.</haxe_doc>
		</seek>
		<inlineSeek get="inline" set="null" line="103">
			<f a="targetPosition:?forceSeek:?forceChange" v=":false:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ forceChange : false, forceSeek : false }</e></m>
				<m n=":allow"><e>ceramic.Timeline</e></m>
			</meta>
		</inlineSeek>
		<add public="1" set="method" line="144">
			<f a="keyframe">
				<c path="ceramic.TimelineTrack.K"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a keyframe to this track</haxe_doc>
		</add>
		<remove public="1" set="method" line="192">
			<f a="keyframe">
				<c path="ceramic.TimelineTrack.K"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a keyframe from this track</haxe_doc>
		</remove>
		<fitSize public="1" set="method" line="225">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update `size` property to make it fit
     * the index of the last keyframe on this track.</haxe_doc>
		</fitSize>
		<apply public="1" set="method" line="239">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
			<haxe_doc>* Apply changes that this track is responsible of. Usually called after `update(delta)` or `seek(time)`.</haxe_doc>
		</apply>
		<findKeyframeAtIndex public="1" set="method" line="245"><f a="index">
	<x path="Int"/>
	<x path="Null"><c path="ceramic.TimelineTrack.K"/></x>
</f></findKeyframeAtIndex>
		<findKeyframeBefore public="1" set="method" line="258">
			<f a="position">
				<x path="Float"/>
				<x path="Null"><c path="ceramic.TimelineTrack.K"/></x>
			</f>
			<haxe_doc>* Find the keyframe right before or equal to given `position`</haxe_doc>
		</findKeyframeBefore>
		<findKeyframeAfter public="1" set="method" line="283">
			<f a="position">
				<x path="Float"/>
				<x path="Null"><c path="ceramic.TimelineTrack.K"/></x>
			</f>
			<haxe_doc>* Find the keyframe right after given `position`</haxe_doc>
		</findKeyframeAfter>
		<computeKeyframeBefore get="inline" set="null" line="308">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal. Compute `before` keyframe, if any matching.</haxe_doc>
		</computeKeyframeBefore>
		<computeKeyframeAfter get="inline" set="null" line="358">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal. Compute `after` keyframe, if any matching.</haxe_doc>
		</computeKeyframeAfter>
		<new public="1" set="method" line="76"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A track meant to be updated by a timeline.
 * Base implementation doesn't do much by itself.
 * Create subclasses to implement details</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.TimelineBoolTrack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineBoolTrack.hx">
		<extends path="ceramic.TimelineTrack"><c path="ceramic.TimelineBoolKeyframe"/></extends>
		<_dox_event_change public="1" set="method" line="637">
			<f a="track">
				<c path="ceramic.TimelineBoolTrack"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_change>
		<emitChange set="method" line="1095">
			<f a="track">
				<c path="ceramic.TimelineBoolTrack"/>
				<x path="Void"/>
			</f>
			<haxe_doc>change event</haxe_doc>
		</emitChange>
		<onChange public="1" set="method" line="1199">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineBoolTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onChange>
		<onceChange public="1" set="method" line="1298">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineBoolTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onceChange>
		<offChange public="1" set="method" line="1368">
			<f a="?handleTrack">
				<f a="track">
					<c path="ceramic.TimelineBoolTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</offChange>
		<listensChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to change event</haxe_doc>
		</listensChange>
		<value public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</value>
		<apply public="1" set="method" line="9" override="1">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
		</apply>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<class path="ceramic.TimelineColorKeyframe" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineColorKeyframe.hx">
		<extends path="ceramic.TimelineKeyframe"/>
		<value public="1"><x path="ceramic.Color"/></value>
		<new public="1" set="method" line="8"><f a="value:index:easing">
	<x path="ceramic.Color"/>
	<x path="Int"/>
	<e path="ceramic.Easing"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.TimelineColorTrack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineColorTrack.hx">
		<extends path="ceramic.TimelineTrack"><c path="ceramic.TimelineColorKeyframe"/></extends>
		<_dox_event_change public="1" set="method" line="637">
			<f a="track">
				<c path="ceramic.TimelineColorTrack"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_change>
		<emitChange set="method" line="1095">
			<f a="track">
				<c path="ceramic.TimelineColorTrack"/>
				<x path="Void"/>
			</f>
			<haxe_doc>change event</haxe_doc>
		</emitChange>
		<onChange public="1" set="method" line="1199">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineColorTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onChange>
		<onceChange public="1" set="method" line="1298">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineColorTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onceChange>
		<offChange public="1" set="method" line="1368">
			<f a="?handleTrack">
				<f a="track">
					<c path="ceramic.TimelineColorTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</offChange>
		<listensChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to change event</haxe_doc>
		</listensChange>
		<value public="1" expr="Color.WHITE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
		</value>
		<apply public="1" set="method" line="9" override="1">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
		</apply>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<class path="ceramic.TimelineDegreesTrack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineDegreesTrack.hx">
		<extends path="ceramic.TimelineTrack"><c path="ceramic.TimelineFloatKeyframe"/></extends>
		<_dox_event_change public="1" set="method" line="637">
			<f a="track">
				<c path="ceramic.TimelineDegreesTrack"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_change>
		<emitChange set="method" line="1095">
			<f a="track">
				<c path="ceramic.TimelineDegreesTrack"/>
				<x path="Void"/>
			</f>
			<haxe_doc>change event</haxe_doc>
		</emitChange>
		<onChange public="1" set="method" line="1199">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineDegreesTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onChange>
		<onceChange public="1" set="method" line="1298">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineDegreesTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onceChange>
		<offChange public="1" set="method" line="1368">
			<f a="?handleTrack">
				<f a="track">
					<c path="ceramic.TimelineDegreesTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</offChange>
		<listensChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to change event</haxe_doc>
		</listensChange>
		<value public="1" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</value>
		<apply public="1" set="method" line="9" override="1">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
		</apply>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<class path="ceramic.TimelineFloatArrayKeyframe" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineFloatArrayKeyframe.hx">
		<extends path="ceramic.TimelineKeyframe"/>
		<value public="1"><c path="Array"><x path="Float"/></c></value>
		<new public="1" set="method" line="8"><f a="value:index:easing">
	<c path="Array"><x path="Float"/></c>
	<x path="Int"/>
	<e path="ceramic.Easing"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.TimelineFloatArrayTrack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineFloatArrayTrack.hx">
		<extends path="ceramic.TimelineTrack"><c path="ceramic.TimelineFloatArrayKeyframe"/></extends>
		<_dox_event_change public="1" set="method" line="637">
			<f a="track">
				<c path="ceramic.TimelineFloatArrayTrack"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_change>
		<emitChange set="method" line="1095">
			<f a="track">
				<c path="ceramic.TimelineFloatArrayTrack"/>
				<x path="Void"/>
			</f>
			<haxe_doc>change event</haxe_doc>
		</emitChange>
		<onChange public="1" set="method" line="1199">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineFloatArrayTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onChange>
		<onceChange public="1" set="method" line="1298">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineFloatArrayTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onceChange>
		<offChange public="1" set="method" line="1368">
			<f a="?handleTrack">
				<f a="track">
					<c path="ceramic.TimelineFloatArrayTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</offChange>
		<listensChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to change event</haxe_doc>
		</listensChange>
		<value public="1" expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</value>
		<apply public="1" set="method" line="11" override="1">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
		</apply>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<class path="ceramic.TimelineFloatKeyframe" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineFloatKeyframe.hx">
		<extends path="ceramic.TimelineKeyframe"/>
		<value public="1"><x path="Float"/></value>
		<new public="1" set="method" line="8"><f a="value:index:easing">
	<x path="Float"/>
	<x path="Int"/>
	<e path="ceramic.Easing"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.TimelineFloatTrack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineFloatTrack.hx">
		<extends path="ceramic.TimelineTrack"><c path="ceramic.TimelineFloatKeyframe"/></extends>
		<_dox_event_change public="1" set="method" line="637">
			<f a="track">
				<c path="ceramic.TimelineFloatTrack"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_change>
		<emitChange set="method" line="1095">
			<f a="track">
				<c path="ceramic.TimelineFloatTrack"/>
				<x path="Void"/>
			</f>
			<haxe_doc>change event</haxe_doc>
		</emitChange>
		<onChange public="1" set="method" line="1199">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineFloatTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onChange>
		<onceChange public="1" set="method" line="1298">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineFloatTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onceChange>
		<offChange public="1" set="method" line="1368">
			<f a="?handleTrack">
				<f a="track">
					<c path="ceramic.TimelineFloatTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</offChange>
		<listensChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to change event</haxe_doc>
		</listensChange>
		<value public="1" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</value>
		<apply public="1" set="method" line="9" override="1">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
		</apply>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<typedef path="ceramic.TimelineKeyframeData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineKeyframeData.hx"><a>
	<value><d/></value>
	<index><x path="Int"/></index>
	<easing><c path="String"/></easing>
</a></typedef>
	<typedef path="ceramic.TimelineTrackData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineTrackData.hx"><a>
	<options>
		<x path="Null"><d><d/></d></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Track options</haxe_doc>
	</options>
	<loop>
		<x path="Bool"/>
		<haxe_doc>* Whether this track should loop or not</haxe_doc>
	</loop>
	<keyframes>
		<c path="Array"><t path="ceramic.TimelineKeyframeData"/></c>
		<haxe_doc>* Track keyframes. They should be sorted by frame index in ascending order</haxe_doc>
	</keyframes>
	<field>
		<c path="String"/>
		<haxe_doc>* Entity field name this track targets</haxe_doc>
	</field>
	<entity>
		<c path="String"/>
		<haxe_doc>* Entity id this track targets</haxe_doc>
	</entity>
</a></typedef>
	<class path="ceramic.Timelines" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Timelines.hx">
		<extends path="ceramic.Entity"/>
		<_dox_event_createTrack public="1" set="method" line="637">
			<f a="type:options:result">
				<c path="String"/>
				<d><d/></d>
				<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track creation
     * @param result The object that will hold the resulting track.</haxe_doc>
		</_dox_event_createTrack>
		<emitCreateTrack public="1" set="method" line="1095">
			<f a="type:options:result">
				<c path="String"/>
				<d><d/></d>
				<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to expand how timeline tracks are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track creation
     * @param result The object that will hold the resulting track.</haxe_doc>
		</emitCreateTrack>
		<onCreateTrack public="1" set="method" line="1199">
			<f a="owner:handleTypeOptionsResult">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="type:options:result">
					<c path="String"/>
					<d><d/></d>
					<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track creation
     * @param result The object that will hold the resulting track.</haxe_doc>
		</onCreateTrack>
		<onceCreateTrack public="1" set="method" line="1298">
			<f a="owner:handleTypeOptionsResult">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="type:options:result">
					<c path="String"/>
					<d><d/></d>
					<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track creation
     * @param result The object that will hold the resulting track.</haxe_doc>
		</onceCreateTrack>
		<offCreateTrack public="1" set="method" line="1368">
			<f a="?handleTypeOptionsResult">
				<f a="type:options:result">
					<c path="String"/>
					<d><d/></d>
					<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track creation
     * @param result The object that will hold the resulting track.</haxe_doc>
		</offCreateTrack>
		<listensCreateTrack public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track creation
     * @param result The object that will hold the resulting track.</haxe_doc>
		</listensCreateTrack>
		<_dox_event_bindTrack public="1" set="method" line="637">
			<f a="type:options:track:entity:field">
				<c path="String"/>
				<d><d/></d>
				<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
				<c path="ceramic.Entity"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are bound to objects.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track binding
     * @param track The track on which we bind the entity
     * @param entity The entity to bind to this track
     * @param field The entity field that should be updated by this track</haxe_doc>
		</_dox_event_bindTrack>
		<emitBindTrack public="1" set="method" line="1095">
			<f a="type:options:track:entity:field">
				<c path="String"/>
				<d><d/></d>
				<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
				<c path="ceramic.Entity"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to expand how timeline tracks are bound to objects.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track binding
     * @param track The track on which we bind the entity
     * @param entity The entity to bind to this track
     * @param field The entity field that should be updated by this track</haxe_doc>
		</emitBindTrack>
		<onBindTrack public="1" set="method" line="1199">
			<f a="owner:handleTypeOptionsTrackEntityField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="type:options:track:entity:field">
					<c path="String"/>
					<d><d/></d>
					<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
					<c path="ceramic.Entity"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are bound to objects.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track binding
     * @param track The track on which we bind the entity
     * @param entity The entity to bind to this track
     * @param field The entity field that should be updated by this track</haxe_doc>
		</onBindTrack>
		<onceBindTrack public="1" set="method" line="1298">
			<f a="owner:handleTypeOptionsTrackEntityField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="type:options:track:entity:field">
					<c path="String"/>
					<d><d/></d>
					<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
					<c path="ceramic.Entity"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are bound to objects.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track binding
     * @param track The track on which we bind the entity
     * @param entity The entity to bind to this track
     * @param field The entity field that should be updated by this track</haxe_doc>
		</onceBindTrack>
		<offBindTrack public="1" set="method" line="1368">
			<f a="?handleTypeOptionsTrackEntityField">
				<f a="type:options:track:entity:field">
					<c path="String"/>
					<d><d/></d>
					<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
					<c path="ceramic.Entity"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are bound to objects.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track binding
     * @param track The track on which we bind the entity
     * @param entity The entity to bind to this track
     * @param field The entity field that should be updated by this track</haxe_doc>
		</offBindTrack>
		<listensBindTrack public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are bound to objects.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track binding
     * @param track The track on which we bind the entity
     * @param entity The entity to bind to this track
     * @param field The entity field that should be updated by this track</haxe_doc>
		</listensBindTrack>
		<_dox_event_createKeyframe public="1" set="method" line="637">
			<f a="type:options:value:index:easing:existing:result">
				<c path="String"/>
				<d><d/></d>
				<d/>
				<x path="Int"/>
				<e path="ceramic.Easing"/>
				<x path="Null"><c path="ceramic.TimelineKeyframe"/></x>
				<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Used to expand how timeline keyframes are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the keyframe
     * @param options Can be used to configure timeline keyframe creation
     * @param value Value of the keyframe
     * @param time Time (in seconds) of the keyframe
     * @param easing Easing of the keyframe
     * @param existing Existing keyframe instance at the same position/time. Can be reused to prevent new allocation of keyframe instance
     * @param result The object that will hold the resulting keyframe.</haxe_doc>
		</_dox_event_createKeyframe>
		<emitCreateKeyframe public="1" set="method" line="1095">
			<f a="type:options:value:index:easing:existing:result">
				<c path="String"/>
				<d><d/></d>
				<d/>
				<x path="Int"/>
				<e path="ceramic.Easing"/>
				<x path="Null"><c path="ceramic.TimelineKeyframe"/></x>
				<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to expand how timeline keyframes are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the keyframe
     * @param options Can be used to configure timeline keyframe creation
     * @param value Value of the keyframe
     * @param time Time (in seconds) of the keyframe
     * @param easing Easing of the keyframe
     * @param existing Existing keyframe instance at the same position/time. Can be reused to prevent new allocation of keyframe instance
     * @param result The object that will hold the resulting keyframe.</haxe_doc>
		</emitCreateKeyframe>
		<onCreateKeyframe public="1" set="method" line="1199">
			<f a="owner:handleTypeOptionsValueIndexEasingExistingResult">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="type:options:value:index:easing:existing:result">
					<c path="String"/>
					<d><d/></d>
					<d/>
					<x path="Int"/>
					<e path="ceramic.Easing"/>
					<x path="Null"><c path="ceramic.TimelineKeyframe"/></x>
					<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline keyframes are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the keyframe
     * @param options Can be used to configure timeline keyframe creation
     * @param value Value of the keyframe
     * @param time Time (in seconds) of the keyframe
     * @param easing Easing of the keyframe
     * @param existing Existing keyframe instance at the same position/time. Can be reused to prevent new allocation of keyframe instance
     * @param result The object that will hold the resulting keyframe.</haxe_doc>
		</onCreateKeyframe>
		<onceCreateKeyframe public="1" set="method" line="1298">
			<f a="owner:handleTypeOptionsValueIndexEasingExistingResult">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="type:options:value:index:easing:existing:result">
					<c path="String"/>
					<d><d/></d>
					<d/>
					<x path="Int"/>
					<e path="ceramic.Easing"/>
					<x path="Null"><c path="ceramic.TimelineKeyframe"/></x>
					<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline keyframes are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the keyframe
     * @param options Can be used to configure timeline keyframe creation
     * @param value Value of the keyframe
     * @param time Time (in seconds) of the keyframe
     * @param easing Easing of the keyframe
     * @param existing Existing keyframe instance at the same position/time. Can be reused to prevent new allocation of keyframe instance
     * @param result The object that will hold the resulting keyframe.</haxe_doc>
		</onceCreateKeyframe>
		<offCreateKeyframe public="1" set="method" line="1368">
			<f a="?handleTypeOptionsValueIndexEasingExistingResult">
				<f a="type:options:value:index:easing:existing:result">
					<c path="String"/>
					<d><d/></d>
					<d/>
					<x path="Int"/>
					<e path="ceramic.Easing"/>
					<x path="Null"><c path="ceramic.TimelineKeyframe"/></x>
					<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline keyframes are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the keyframe
     * @param options Can be used to configure timeline keyframe creation
     * @param value Value of the keyframe
     * @param time Time (in seconds) of the keyframe
     * @param easing Easing of the keyframe
     * @param existing Existing keyframe instance at the same position/time. Can be reused to prevent new allocation of keyframe instance
     * @param result The object that will hold the resulting keyframe.</haxe_doc>
		</offCreateKeyframe>
		<listensCreateKeyframe public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline keyframes are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the keyframe
     * @param options Can be used to configure timeline keyframe creation
     * @param value Value of the keyframe
     * @param time Time (in seconds) of the keyframe
     * @param easing Easing of the keyframe
     * @param existing Existing keyframe instance at the same position/time. Can be reused to prevent new allocation of keyframe instance
     * @param result The object that will hold the resulting keyframe.</haxe_doc>
		</listensCreateKeyframe>
		<handleCreateTrack set="method" line="57"><f a="type:options:result">
	<c path="String"/>
	<d><d/></d>
	<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
	<x path="Void"/>
</f></handleCreateTrack>
		<handleBindTrack set="method" line="81"><f a="type:options:track:entity:field">
	<c path="String"/>
	<d><d/></d>
	<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<x path="Void"/>
</f></handleBindTrack>
		<handleCreateKeyframe set="method" line="141"><f a="type:options:value:index:easing:existing:result">
	<c path="String"/>
	<d><d/></d>
	<d/>
	<x path="Int"/>
	<e path="ceramic.Easing"/>
	<x path="Null"><c path="ceramic.TimelineKeyframe"/></x>
	<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
	<x path="Void"/>
</f></handleCreateKeyframe>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="47"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* App-level timeline related events.
 * You'll only need to track these events if you want to add new types of timeline tracks & keyframes
 * that can be created from raw data in `Fragment` instances.]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Timer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Timer.hx">
		<callbacks expr="[]" line="9" static="1">
			<c path="Array"><c path="ceramic.TimerCallback"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</callbacks>
		<next expr="999999999" line="10" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>999999999</e></m></meta>
		</next>
		<now public="1" set="null" expr="0" line="16" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current time, relative to app.
     * (number of active seconds since app was started)</haxe_doc>
		</now>
		<timestamp public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Current unix time synchronized with ceramic Timer.
     * `Timer.now` and `Timer.timestamp` are garanteed to get incremented
     * exactly at the same rate, except when app frame real delta > 1s
     * (number of seconds since January 1st, 1970)]]></haxe_doc>
		</timestamp>
		<get_timestamp get="inline" set="null" line="25" static="1"><f a=""><x path="Float"/></f></get_timestamp>
		<startTimestamp public="1" set="null" expr="Date.now().getTime() / 1000.0" line="29" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Date.now().getTime() / 1000.0</e></m></meta>
		</startTimestamp>
		<update set="method" line="32" static="1">
			<f a="delta:realDelta">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>ceramic.App</e></m></meta>
		</update>
		<flush set="method" line="43" static="1"><f a=""><x path="Void"/></f></flush>
		<delay public="1" get="inline" set="null" line="112" static="1">
			<f a="owner:seconds:callback">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
			</f>
			<haxe_doc>* Execute a callback after the given delay in seconds.
     * @return a function to cancel this timer delay</haxe_doc>
		</delay>
		<interval public="1" get="inline" set="null" line="122" static="1">
			<f a="owner:seconds:callback">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
			</f>
			<haxe_doc>* Execute a callback periodically at the given interval in seconds.
     * @return a function to cancel this timer interval</haxe_doc>
		</interval>
		<schedule set="method" line="128" static="1"><f a="owner:seconds:callback:interval">
	<c path="ceramic.Entity"/>
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
</f></schedule>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.TimerCallback" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Timer.hx" module="ceramic.Timer">
		<owner public="1" expr="null">
			<c path="ceramic.Entity"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</owner>
		<callback public="1" expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</callback>
		<time public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</time>
		<interval public="1" expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</interval>
		<cleared public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</cleared>
		<clear public="1" set="method" line="198"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="196"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Touch" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Touch.hx">
		<index public="1" set="null"><x path="Int"/></index>
		<x public="1" set="null"><x path="Float"/></x>
		<y public="1" set="null"><x path="Float"/></y>
		<deltaX public="1" set="null"><x path="Float"/></deltaX>
		<deltaY public="1" set="null"><x path="Float"/></deltaY>
		<toString set="method" line="19"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="5">
			<f a="index:x:y:deltaX:deltaY">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
			<m n=":allow"><e>ceramic.Screen</e></m>
		</meta>
	</class>
	<class path="ceramic.TouchInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TouchInfo.hx">
		<touchIndex public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* If the input is a touch input, this is the index of the touch.
     * Otherwise it will be -1.</haxe_doc>
		</touchIndex>
		<buttonId public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* If the input is a mouse input, this is the id of the mouse button.
     * Otherwise it will be -1.</haxe_doc>
		</buttonId>
		<x public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* X coordinate of the input (relative to screen).</haxe_doc>
		</x>
		<y public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Y coordinate of the input (relative to screen).</haxe_doc>
		</y>
		<hits public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether these info do hit the related visual. This is usually `true`,
     * Except when we have touch/mouse up events outside of a visual that
     * initially received a down event.</haxe_doc>
		</hits>
		<toString set="method" line="37"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="4">
			<f a="touchIndex:buttonId:x:y:hits">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc>@param hits * Whether these info do hit the related visual. This is usually `true`,
     * Except when we have touch/mouse up events outside of a visual that
     * initially received a down event.
@param y * Y coordinate of the input (relative to screen).
@param x * X coordinate of the input (relative to screen).
@param buttonId * If the input is a mouse input, this is the id of the mouse button.
     * Otherwise it will be -1.
@param touchIndex * If the input is a touch input, this is the index of the touch.
     * Otherwise it will be -1.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="ceramic.Touches" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Touches.hx">
		<this><c path="ceramic.IntMap"><c path="ceramic.Touch"/></c></this>
		<impl><class path="ceramic._Touches.Touches_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Touches.hx" private="1" module="ceramic.Touches" final="1">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a=""><x path="ceramic.Touches"/></f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<get public="1" get="inline" set="null" line="11" static="1"><f a="this:touchIndex">
	<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
	<x path="Int"/>
	<c path="ceramic.Touch"/>
</f></get>
	<set public="1" get="inline" set="null" line="17" static="1"><f a="this:touchIndex:touch">
	<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
	<x path="Int"/>
	<c path="ceramic.Touch"/>
	<x path="Void"/>
</f></set>
	<iterator public="1" get="inline" set="null" line="23" static="1"><f a="this">
	<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
	<c path="ceramic.TouchesIterator"/>
</f></iterator>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._Touches.Touches_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Touches.hx" private="1" module="ceramic.Touches" final="1">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a=""><x path="ceramic.Touches"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<get public="1" get="inline" set="null" line="11" static="1"><f a="this:touchIndex">
	<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
	<x path="Int"/>
	<c path="ceramic.Touch"/>
</f></get>
		<set public="1" get="inline" set="null" line="17" static="1"><f a="this:touchIndex:touch">
	<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
	<x path="Int"/>
	<c path="ceramic.Touch"/>
	<x path="Void"/>
</f></set>
		<iterator public="1" get="inline" set="null" line="23" static="1"><f a="this">
	<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
	<c path="ceramic.TouchesIterator"/>
</f></iterator>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.TouchesIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TouchesIterator.hx">
		<intMap><c path="ceramic.IntMap"><c path="ceramic.Touch"/></c></intMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="22"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="32"><f a=""><c path="ceramic.Touch"/></f></next>
		<new get="inline" set="null" line="14">
			<f a="intMap">
				<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>ceramic.Touches</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.TrackerBackend" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TrackerBackend.hx">
		<backgroundQueue><c path="ceramic.BackgroundQueue"/></backgroundQueue>
		<onceImmediate public="1" get="inline" set="null" line="21">
			<f a="handleImmediate">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Schedule immediate callback. These callbacks need to be flushed at some point by the backend
     * @param handleImmediate the callback to schedule</haxe_doc>
		</onceImmediate>
		<readString public="1" get="inline" set="null" line="32">
			<f a="key">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Read a string for the given key
     * @param key the key to use
     * @return String or null of no string was found</haxe_doc>
		</readString>
		<saveString public="1" get="inline" set="null" line="44">
			<f a="key:str">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Save a string for the given key
     * @param key the key to use
     * @param str the string to save
     * @return Bool `true` if the save was successful</haxe_doc>
		</saveString>
		<appendString public="1" get="inline" set="null" line="57">
			<f a="key:str">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Append a string on the given key. If the key doesn't exist,
     * creates a new one with the string to append.
     * @param key the key to use
     * @param str the string to append
     * @return Bool `true` if the save was successful</haxe_doc>
		</appendString>
		<warning public="1" get="inline" set="null" line="67">
			<f a="message:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Log a warning message
     * @param message the warning message</haxe_doc>
		</warning>
		<error public="1" get="inline" set="null" line="77">
			<f a="error:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Log an error message
     * @param error the error message</haxe_doc>
		</error>
		<success public="1" get="inline" set="null" line="87">
			<f a="message:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Log a success message
     * @param message the success message</haxe_doc>
		</success>
		<runInBackground public="1" get="inline" set="null" line="98">
			<f a="callback">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Run the given callback in background, if there is any background thread available
     * on this backend. Run it on the main thread otherwise like any other code
     * @param callback</haxe_doc>
		</runInBackground>
		<runInMain public="1" get="inline" set="null" line="108">
			<f a="callback">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Run the given callback in main thread
     * @param callback</haxe_doc>
		</runInMain>
		<interval public="1" get="inline" set="null" line="121">
			<f a="owner:seconds:callback">
				<c path="ceramic.Entity"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
			</f>
			<haxe_doc><![CDATA[* Execute a callback periodically at the given interval in seconds.
     * @param owner The entity that owns this interval
     * @param seconds The time in seconds between each call
     * @param callback The callback to call
     * @return Void->Void A callback to cancel the interval]]></haxe_doc>
		</interval>
		<delay public="1" get="inline" set="null" line="134">
			<f a="owner:seconds:callback">
				<c path="ceramic.Entity"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
			</f>
			<haxe_doc><![CDATA[* Execute a callback after the given delay in seconds.
     * @param owner The entity that owns this delayed call
     * @param seconds The time in seconds of delay before the call
     * @param callback The callback to call
     * @return Void->Void A callback to cancel the delayed call]]></haxe_doc>
		</delay>
		<storageDirectory public="1" get="inline" set="null" line="144">
			<f a=""><x path="Null"><c path="String"/></x></f>
			<haxe_doc>* Get storage directory (if any available)
     * @return directory as string or null if nothing available</haxe_doc>
		</storageDirectory>
		<pathJoin public="1" get="inline" set="null" line="154">
			<f a="paths">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Joins all paths in `paths` together.
     * @return joined paths as string</haxe_doc>
		</pathJoin>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.TransformPool" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TransformPool.hx">
		<availableTransforms expr="[]" line="10" static="1">
			<c path="Array"><c path="ceramic.Transform"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</availableTransforms>
		<get public="1" get="inline" set="null" line="15" static="1">
			<f a=""><c path="ceramic.Transform"/></f>
			<haxe_doc>* Get or create a transform. The transform object is ready to be used.</haxe_doc>
		</get>
		<recycle public="1" set="method" line="24" static="1">
			<f a="transform">
				<c path="ceramic.Transform"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Recycle an existing transform. The transform will be cleaned up.</haxe_doc>
		</recycle>
		<clear public="1" set="method" line="48" static="1"><f a=""><x path="Void"/></f></clear>
		<haxe_doc>* An utility to reuse transform matrix object at application level.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Triangle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Triangle.hx">
		<extends path="ceramic.Mesh"/>
		<set_width set="method" line="13" override="1"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="21" override="1"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<updateVertices get="inline" set="null" line="45"><f a=""><x path="Void"/></f></updateVertices>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A simple colored triangle, to fulfill all your triangle-shaped needs.
 * The triangle is facing top and fits exactly in `width` and `height`</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Triangulate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Triangulate.hx">
		<poly2triPointsPool expr="[]" line="18" static="1">
			<c path="Array"><t path="poly2tri._Point.Poly2TriPoint"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</poly2triPointsPool>
		<poly2triPoints expr="[]" line="19" static="1">
			<c path="Array"><t path="poly2tri._Point.Poly2TriPoint"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</poly2triPoints>
		<poly2triSweepContext static="1"><c path="poly2tri.SweepContext"/></poly2triSweepContext>
		<poly2triSweep static="1"><c path="poly2tri.Sweep"/></poly2triSweep>
		<triangulate public="1" set="method" line="26" static="1">
			<f a="vertices:indices:?holes:?method" v=":::POLY2TRI">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
				<e path="ceramic.TriangulateMethod"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ method : POLY2TRI }</e></m></meta>
			<haxe_doc>* Triangulate the given vertices and fills the indices array accordingly</haxe_doc>
		</triangulate>
		<haxe_doc>* An utility to triangulate indices from a set of vertices</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="ceramic.TriangulateMethod" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TriangulateMethod.hx">
		<EARCUT><haxe_doc>* Fast, but sometimes approximate</haxe_doc></EARCUT>
		<POLY2TRI><haxe_doc>* A bit slower, usually more precise</haxe_doc></POLY2TRI>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.Tween" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Tween.hx">
		<extends path="ceramic.Entity"/>
		<_tweens expr="[]" line="123" static="1">
			<c path="Array"><c path="ceramic.Tween"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_tweens>
		<_iteratedTweens expr="[]" line="124" static="1">
			<c path="Array"><c path="ceramic.Tween"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_iteratedTweens>
		<start public="1" set="method" line="126" static="1"><f a="owner:?easing:duration:fromValue:toValue:handleValueTime">
	<x path="Null"><c path="ceramic.Entity"/></x>
	<e path="ceramic.Easing"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<f a=":">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<c path="ceramic.Tween"/>
</f></start>
		<tick set="method" line="137" static="1"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></tick>
		<_computedEasingFunction expr="null" line="155" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</_computedEasingFunction>
		<_computedCustomEasing expr="null" line="156" static="1">
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</_computedCustomEasing>
		<computeEasing get="inline" set="null" line="158" static="1"><f a="easing">
	<e path="ceramic.Easing"/>
	<x path="Void"/>
</f></computeEasing>
		<ease public="1" set="method" line="243" static="1"><f a="easing:value">
	<e path="ceramic.Easing"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<easingFunction public="1" set="method" line="337" static="1">
			<f a="easing">
				<e path="ceramic.Easing"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
			</f>
			<haxe_doc><![CDATA[* Get a tween easing function as a plain Float->Float function.]]></haxe_doc>
		</easingFunction>
		<_dox_event_update public="1" set="method" line="637">
			<f a="value:time">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_update>
		<emitUpdate set="method" line="1095">
			<f a="value:time">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>update event</haxe_doc>
		</emitUpdate>
		<onUpdate public="1" set="method" line="1199">
			<f a="owner:handleValueTime">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:time">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onUpdate>
		<onceUpdate public="1" set="method" line="1298">
			<f a="owner:handleValueTime">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:time">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onceUpdate>
		<offUpdate public="1" set="method" line="1368">
			<f a="?handleValueTime">
				<f a="value:time">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</offUpdate>
		<listensUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to update event</haxe_doc>
		</listensUpdate>
		<_dox_event_complete public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_complete>
		<emitComplete set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>complete event</haxe_doc>
		</emitComplete>
		<onComplete public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</onComplete>
		<onceComplete public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</onceComplete>
		<offComplete public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</offComplete>
		<listensComplete public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to complete event</haxe_doc>
		</listensComplete>
		<owner><c path="ceramic.Entity"/></owner>
		<easing><e path="ceramic.Easing"/></easing>
		<duration><x path="Float"/></duration>
		<remaining><x path="Float"/></remaining>
		<fromValue><x path="Float"/></fromValue>
		<toValue><x path="Float"/></toValue>
		<computedEasing><f a=""><x path="Void"/></f></computedEasing>
		<customEasing expr="null">
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</customEasing>
		<init set="method" line="48"><f a=""><x path="Void"/></f></init>
		<updateFromTick get="inline" set="null" line="69"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></updateFromTick>
		<immediateComplete set="method" line="94"><f a=""><x path="Void"/></f></immediateComplete>
		<immediateStart set="method" line="102"><f a=""><x path="Void"/></f></immediateStart>
		<destroy public="1" set="method" line="108" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new set="method" line="34"><f a="owner:easing:duration:fromValue:toValue">
	<x path="Null"><c path="ceramic.Entity"/></x>
	<e path="ceramic.Easing"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<class path="ceramic._Tween.TweenEasingFunction" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Tween.hx" private="1" module="ceramic.Tween">
		<k public="1" expr="0" line="364" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Using `k` as static variable allows us to call easing function dynamically
     * without needing boxing of float type on c++ target when it is passed as arg.
     * (boxing of primitive types on c++ creates trash object references that give pressure to GC.
     * When we can, we try to avoid it.)</haxe_doc>
		</k>
		<customEasing public="1" expr="null" line="366" static="1">
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</customEasing>
		<custom public="1" set="method" line="370" static="1"><f a=""><x path="Void"/></f></custom>
		<none public="1" set="method" line="376" static="1"><f a=""><x path="Void"/></f></none>
		<linear public="1" set="method" line="382" static="1"><f a=""><x path="Void"/></f></linear>
		<backEaseIn public="1" set="method" line="388" static="1"><f a=""><x path="Void"/></f></backEaseIn>
		<backEaseInOut public="1" set="method" line="392" static="1"><f a=""><x path="Void"/></f></backEaseInOut>
		<backEaseOut public="1" set="method" line="398" static="1"><f a=""><x path="Void"/></f></backEaseOut>
		<quadEaseIn public="1" set="method" line="404" static="1"><f a=""><x path="Void"/></f></quadEaseIn>
		<quadEaseInOut public="1" set="method" line="408" static="1"><f a=""><x path="Void"/></f></quadEaseInOut>
		<quadEaseOut public="1" set="method" line="415" static="1"><f a=""><x path="Void"/></f></quadEaseOut>
		<cubicEaseIn public="1" set="method" line="421" static="1"><f a=""><x path="Void"/></f></cubicEaseIn>
		<cubicEaseInOut public="1" set="method" line="425" static="1"><f a=""><x path="Void"/></f></cubicEaseInOut>
		<cubicEaseOut public="1" set="method" line="429" static="1"><f a=""><x path="Void"/></f></cubicEaseOut>
		<quartEaseIn public="1" set="method" line="435" static="1"><f a=""><x path="Void"/></f></quartEaseIn>
		<quartEaseInOut public="1" set="method" line="439" static="1"><f a=""><x path="Void"/></f></quartEaseInOut>
		<quartEaseOut public="1" set="method" line="444" static="1"><f a=""><x path="Void"/></f></quartEaseOut>
		<quintEaseIn public="1" set="method" line="450" static="1"><f a=""><x path="Void"/></f></quintEaseIn>
		<quintEaseInOut public="1" set="method" line="454" static="1"><f a=""><x path="Void"/></f></quintEaseInOut>
		<quintEaseOut public="1" set="method" line="459" static="1"><f a=""><x path="Void"/></f></quintEaseOut>
		<bounceEaseIn public="1" set="method" line="465" static="1"><f a=""><x path="Void"/></f></bounceEaseIn>
		<bounceEaseInOut public="1" set="method" line="469" static="1"><f a=""><x path="Void"/></f></bounceEaseInOut>
		<bounceEaseOut public="1" set="method" line="477" static="1"><f a=""><x path="Void"/></f></bounceEaseOut>
		<_bounceEaseIn get="inline" set="null" line="481" static="1"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></_bounceEaseIn>
		<_bounceEaseOut get="inline" set="null" line="485" static="1"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></_bounceEaseOut>
		<elasticEaseIn public="1" set="method" line="504" static="1"><f a=""><x path="Void"/></f></elasticEaseIn>
		<elasticEaseInOut public="1" set="method" line="520" static="1"><f a=""><x path="Void"/></f></elasticEaseInOut>
		<elasticEaseOut public="1" set="method" line="536" static="1"><f a=""><x path="Void"/></f></elasticEaseOut>
		<expoEaseIn public="1" set="method" line="554" static="1"><f a=""><x path="Void"/></f></expoEaseIn>
		<expoEaseInOut public="1" set="method" line="558" static="1"><f a=""><x path="Void"/></f></expoEaseInOut>
		<expoEaseOut public="1" set="method" line="567" static="1"><f a=""><x path="Void"/></f></expoEaseOut>
		<sineEaseIn public="1" set="method" line="573" static="1"><f a=""><x path="Void"/></f></sineEaseIn>
		<sineEaseInOut public="1" set="method" line="577" static="1"><f a=""><x path="Void"/></f></sineEaseInOut>
		<sineEaseOut public="1" set="method" line="581" static="1"><f a=""><x path="Void"/></f></sineEaseOut>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>ceramic.Tween</e></m>
		</meta>
	</class>
	<typedef path="ceramic.UInt8Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/UInt8Array.hx"><t path="backend.UInt8Array"/></typedef>
	<class path="ceramic.Utils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Utils.hx">
		<RE_ASCII_CHAR expr="~/^[a-zA-Z0-9]$/" line="18" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^[a-zA-Z0-9]$/</e></m></meta>
		</RE_ASCII_CHAR>
		<realPath public="1" set="method" line="20" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></realPath>
		<getRtti public="1" params="T" get="inline" set="null" line="31" static="1"><f a="c">
	<x path="Class"><c path="getRtti.T"/></x>
	<t path="haxe.rtti.Classdef"/>
</f></getRtti>
		<_nextUniqueIntCursor expr="0" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_nextUniqueIntCursor>
		<_nextUniqueInt0 expr="Std.int(Math.random() * 0x7ffffffe)" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 0x7ffffffe)</e></m></meta>
		</_nextUniqueInt0>
		<_nextUniqueInt1 expr="Std.int(Date.now().getTime() * 0.0001)" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Date.now().getTime() * 0.0001)</e></m></meta>
		</_nextUniqueInt1>
		<_nextUniqueInt2 expr="Std.int(Math.random() * 0x7ffffffe)" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 0x7ffffffe)</e></m></meta>
		</_nextUniqueInt2>
		<_nextUniqueInt3 expr="Std.int(Math.random() * 0x7ffffffe)" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 0x7ffffffe)</e></m></meta>
		</_nextUniqueInt3>
		<uniqueId public="1" set="method" line="51" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Provides an identifier which is garanteed to be unique on this local device.
     * It however doesn't garantee that this identifier is not predictable.</haxe_doc>
		</uniqueId>
		<randomId public="1" set="method" line="83" static="1">
			<f a="?size" v="32">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ size : 32 }</e></m></meta>
			<haxe_doc>* Provides a random identifier which should be fairly unpredictable and
     * should have an extremely low chance to provide the same identifier twice.</haxe_doc>
		</randomId>
		<_persistentIds expr="null" line="97" static="1">
			<t path="Map">
				<x path="Int"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</_persistentIds>
		<persistentId public="1" set="method" line="106" static="1">
			<f a="?slot:?size" v="0:32">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ size : 32, slot : 0 }</e></m></meta>
			<haxe_doc>* Return a persistent identifier for this device. The identifier is expected
     * to stay the same as long as the user keeps the app installed.
     * Multiple identifiers can be generated/retrieved by using different slots (default 0).
     * Size of the persistent identifier can be provided, but will only have effect when
     * generating a new identifier.</haxe_doc>
		</persistentId>
		<resetPersistentId public="1" set="method" line="135" static="1">
			<f a="?slot" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ slot : 0 }</e></m></meta>
		</resetPersistentId>
		<base62Id public="1" get="inline" set="null" line="142" static="1"><f a="?val">
	<x path="Int"/>
	<c path="String"/>
</f></base62Id>
		<println public="1" set="method" line="166" static="1"><f a="data">
	<c path="String"/>
	<x path="Void"/>
</f></println>
		<printStackTrace public="1" set="method" line="196" static="1">
			<f a="?returnOnly" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ returnOnly : false }</e></m></meta>
		</printStackTrace>
		<stackItemToString public="1" set="method" line="284" static="1"><f a="item">
	<e path="haxe.StackItem"/>
	<c path="String"/>
</f></stackItemToString>
		<radToDeg public="1" get="inline" set="null" line="319" static="1"><f a="rad">
	<x path="Float"/>
	<x path="Float"/>
</f></radToDeg>
		<degToRad public="1" get="inline" set="null" line="323" static="1"><f a="deg">
	<x path="Float"/>
	<x path="Float"/>
</f></degToRad>
		<round public="1" get="inline" set="null" line="327" static="1">
			<f a="value:?decimals" v=":0">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ decimals : 0 }</e></m></meta>
		</round>
		<hashCode public="1" get="inline" set="null" line="344" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Java's String.hashCode() method implemented in Haxe.
     * source: https://github.com/rjanicek/janicek-core-haxe/blob/master/src/co/janicek/core/math/HashCore.hx</haxe_doc>
		</hashCode>
		<uniformFrequencyList public="1" set="method" line="361" static="1">
			<f a="values:frequencies:size">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Generate an uniform list of the requested size,
     * containing values uniformly repartited from frequencies.
     * @param values the values to put in list
     * @param probabilities the corresponding probability for each value
     * @param size the size of the final list</haxe_doc>
		</uniformFrequencyList>
		<upperCaseToCamelCase public="1" set="method" line="404" static="1">
			<f a="input:?firstLetterUppercase" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ firstLetterUppercase : true }</e></m></meta>
			<haxe_doc>* Transforms `SOME_IDENTIFIER` to `SomeIdentifier`</haxe_doc>
		</upperCaseToCamelCase>
		<camelCaseToUpperCase public="1" set="method" line="435" static="1">
			<f a="input:?firstLetterUppercase" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ firstLetterUppercase : true }</e></m></meta>
			<haxe_doc>* Transforms `SomeIdentifier`/`someIdentifier`/`some identifier` to `SOME_IDENTIFIER`</haxe_doc>
		</camelCaseToUpperCase>
		<functionEquals public="1" get="inline" set="null" line="477" static="1"><f a="functionA:functionB">
	<d/>
	<d/>
	<x path="Bool"/>
</f></functionEquals>
		<decodeUriParams public="1" set="method" line="487" static="1"><f a="raw">
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
</f></decodeUriParams>
		<sinRatio public="1" set="method" line="511" static="1">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Transforms a value between 0 and 1 to another value between 0 and 1 following a sinusoidal curve
     * @param value a value between 0 and 1. If giving a value > 1, its modulo 1 will be used.
     * @return Float]]></haxe_doc>
		</sinRatio>
		<cosRatio public="1" set="method" line="524" static="1">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Transforms a value between 0 and 1 to another value between 0 and 1 following a cosinusoidal curve
     * @param value a value between 0 and 1. If giving a value > 1, its modulo 1 will be used.
     * @return Float]]></haxe_doc>
		</cosRatio>
		<valueFromInterpolatedKey public="1" set="method" line="539" static="1">
			<f a="keys:values:interpolatedKey">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Given an array of keys and an array of matching values, interpolate a new value from interpolatedKey
     * @param keys A list of keys
     * @param values A list of values
     * @param interpolatedKey The interpolated key, used to find a matching interpolated value
     * @return Interpolated value</haxe_doc>
		</valueFromInterpolatedKey>
		<yFromInterpolatedX public="1" set="method" line="576" static="1">
			<f a="points:interpolatedX">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Given an array of X and Y values, interpolate a new Y value from interpolated X
     * @param points A list of X and Y values
     * @param interpolatedX The interpolated X key, used to find a matching interpolated Y
     * @return Interpolated Y value</haxe_doc>
		</yFromInterpolatedX>
		<command public="1" set="method" line="609" static="1"><f a="cmd:?args:?options:result">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<a>
		<detached>
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":optional"/></meta>
		</detached>
		<cwd>
			<x path="Null"><c path="String"/></x>
			<meta><m n=":optional"/></meta>
		</cwd>
	</a>
	<f a="code:out:err">
		<x path="Int"/>
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></command>
		<replaceIdentifier public="1" set="method" line="676" static="1"><f a="str:word:replacement">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></replaceIdentifier>
		<imageTypeFromBytes public="1" set="method" line="693" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="ceramic.ImageType"/>
</f></imageTypeFromBytes>
		<lerp public="1" get="inline" set="null" line="719" static="1"><f a="a:b:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></lerp>
		<haxe_doc>* Various utilities. Some of them are used by ceramic itself or its backends.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.ValueEntry" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ValueEntry.hx">
		<extends path="ceramic.CollectionEntry"/>
		<value public="1"><c path="ceramic.ValueEntry.T"/></value>
		<new public="1" set="method" line="10"><f a="value:?id:?name">
	<c path="ceramic.ValueEntry.T"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A collection entry that can hold any value</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.Velocity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Velocity.hx">
		<positions expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</positions>
		<times expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</times>
		<reset public="1" set="method" line="13"><f a=""><x path="Void"/></f></reset>
		<add public="1" set="method" line="25">
			<f a="position:?minusDelta" v=":0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ minusDelta : 0 }</e></m></meta>
		</add>
		<get public="1" set="method" line="36"><f a=""><x path="Float"/></f></get>
		<prune set="method" line="56"><f a="expireTime">
	<x path="Float"/>
	<x path="Void"/>
</f></prune>
		<toString set="method" line="70"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ceramic.VisibleBounds" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/VisibleBounds.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<entity public="1">
			<c path="ceramic.Visual"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<bounds expr="null">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</bounds>
		<bindAsComponent set="method" line="24"><f a=""><x path="Void"/></f></bindAsComponent>
		<updateBounds set="method" line="32"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></updateBounds>
		<setEntity set="method" line="8">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="8">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="16"><f a="bounds">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* An utility to display visible bounds on any visual</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.VisualTransition" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/VisualTransition.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<_currentTransform expr="new Transform()" line="12" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</_currentTransform>
		<_targetTransform expr="new Transform()" line="14" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</_targetTransform>
		<_identityTransform expr="new Transform()" line="16" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</_identityTransform>
		<transition public="1" set="method" line="585" static="1"><f a="visual:?easing:duration:cb">
	<c path="ceramic.Visual"/>
	<e path="ceramic.Easing"/>
	<x path="Float"/>
	<f a="">
		<x path="ceramic.VisualTransitionProperties"/>
		<x path="Void"/>
	</f>
	<x path="Null"><c path="ceramic.Tween"/></x>
</f></transition>
		<entity public="1">
			<c path="ceramic.Visual"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<easing public="1"><e path="ceramic.Easing"/></easing>
		<duration public="1"><x path="Float"/></duration>
		<anyPropertyChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</anyPropertyChanged>
		<xChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</xChanged>
		<xTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</xTween>
		<xTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</xTarget>
		<xStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</xStart>
		<xEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</xEnd>
		<yChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</yChanged>
		<yTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</yTween>
		<yTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</yTarget>
		<yStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</yStart>
		<yEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</yEnd>
		<scaleXChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</scaleXChanged>
		<scaleXTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scaleXTween>
		<scaleXTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scaleXTarget>
		<scaleXStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scaleXStart>
		<scaleXEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scaleXEnd>
		<scaleYChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</scaleYChanged>
		<scaleYTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scaleYTween>
		<scaleYTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scaleYTarget>
		<scaleYStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scaleYStart>
		<scaleYEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scaleYEnd>
		<skewXChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skewXChanged>
		<skewXTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</skewXTween>
		<skewXTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewXTarget>
		<skewXStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewXStart>
		<skewXEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewXEnd>
		<skewYChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skewYChanged>
		<skewYTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</skewYTween>
		<skewYTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewYTarget>
		<skewYStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewYStart>
		<skewYEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewYEnd>
		<anchorXChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</anchorXChanged>
		<anchorXTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</anchorXTween>
		<anchorXTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</anchorXTarget>
		<anchorXStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</anchorXStart>
		<anchorXEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</anchorXEnd>
		<anchorYChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</anchorYChanged>
		<anchorYTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</anchorYTween>
		<anchorYTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</anchorYTarget>
		<anchorYStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</anchorYStart>
		<anchorYEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</anchorYEnd>
		<rotationChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rotationChanged>
		<rotationTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</rotationTween>
		<rotationTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</rotationTarget>
		<rotationStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</rotationStart>
		<rotationEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</rotationEnd>
		<widthChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</widthChanged>
		<widthTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</widthTween>
		<widthTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</widthTarget>
		<widthStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</widthStart>
		<widthEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</widthEnd>
		<heightChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</heightChanged>
		<heightTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</heightTween>
		<heightTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</heightTarget>
		<heightStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</heightStart>
		<heightEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</heightEnd>
		<colorChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</colorChanged>
		<colorTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</colorTween>
		<colorTarget expr="Color.NONE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</colorTarget>
		<colorStart expr="Color.NONE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</colorStart>
		<colorEnd expr="Color.NONE">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</colorEnd>
		<alphaChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</alphaChanged>
		<alphaTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</alphaTween>
		<alphaTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</alphaTarget>
		<alphaStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</alphaStart>
		<alphaEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</alphaEnd>
		<translateXChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</translateXChanged>
		<translateXTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</translateXTween>
		<translateXTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</translateXTarget>
		<translateXStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</translateXStart>
		<translateXEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</translateXEnd>
		<translateYChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</translateYChanged>
		<translateYTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</translateYTween>
		<translateYTarget expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</translateYTarget>
		<translateYStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</translateYStart>
		<translateYEnd expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</translateYEnd>
		<transformChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transformChanged>
		<transformAssigned expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transformAssigned>
		<transformAssignedInstance expr="null">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformAssignedInstance>
		<transformTween expr="null">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformTween>
		<transformTarget expr="null">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformTarget>
		<transformStart expr="null">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformStart>
		<transformEnd expr="null">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformEnd>
		<transformEndToNull expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transformEndToNull>
		<transformInTransition expr="null">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformInTransition>
		<bindAsComponent set="method" line="163"><f a=""><x path="Void"/></f></bindAsComponent>
		<run public="1" set="method" line="173"><f a="?easing:duration:cb">
	<e path="ceramic.Easing"/>
	<x path="Float"/>
	<f a="">
		<x path="ceramic.VisualTransitionProperties"/>
		<x path="Void"/>
	</f>
	<x path="Null"><c path="ceramic.Tween"/></x>
</f></run>
		<destroy public="1" set="method" line="562" override="1"><f a=""><x path="Void"/></f></destroy>
		<setEntity set="method" line="10">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="10">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="154">
			<f a="?easing:?duration" v=":0.3">
				<e path="ceramic.Easing"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ duration : 0.3 }</e></m></meta>
		</new>
		<meta>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.VisualTransitionProperties</e></m>
		</meta>
	</class>
	<abstract path="ceramic.VisualTransitionProperties" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/VisualTransition.hx" module="ceramic.VisualTransition">
		<from><icast><c path="ceramic.VisualTransition"/></icast></from>
		<this><c path="ceramic.VisualTransition"/></this>
		<impl><class path="ceramic._VisualTransition.VisualTransitionProperties_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/VisualTransition.hx" private="1" module="ceramic.VisualTransition" final="1">
	<x public="1" get="accessor" set="accessor" static="1"><x path="Float"/></x>
	<get_x set="method" line="602" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_x>
	<set_x set="method" line="603" static="1"><f a="this:x">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
	<y public="1" get="accessor" set="accessor" static="1"><x path="Float"/></y>
	<get_y set="method" line="613" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_y>
	<set_y set="method" line="614" static="1"><f a="this:y">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
	<pos public="1" set="method" line="623" static="1"><f a="this:x:y">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pos>
	<scaleX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></scaleX>
	<get_scaleX set="method" line="629" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_scaleX>
	<set_scaleX set="method" line="630" static="1"><f a="this:scaleX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
	<scaleY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></scaleY>
	<get_scaleY set="method" line="640" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_scaleY>
	<set_scaleY set="method" line="641" static="1"><f a="this:scaleY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
	<scale public="1" set="method" line="650" static="1">
		<f a="this:scaleX:?scaleY" v="::-1">
			<c path="ceramic.VisualTransition"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ scaleY : -1 }</e></m></meta>
	</scale>
	<translateX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></translateX>
	<get_translateX set="method" line="656" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_translateX>
	<set_translateX set="method" line="657" static="1"><f a="this:translateX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_translateX>
	<translateY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></translateY>
	<get_translateY set="method" line="667" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_translateY>
	<set_translateY set="method" line="668" static="1"><f a="this:translateY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_translateY>
	<translate public="1" set="method" line="677" static="1">
		<f a="this:translateX:?translateY" v="::-1">
			<c path="ceramic.VisualTransition"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ translateY : -1 }</e></m></meta>
	</translate>
	<skewX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></skewX>
	<get_skewX set="method" line="683" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_skewX>
	<set_skewX set="method" line="684" static="1"><f a="this:skewX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_skewX>
	<skewY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></skewY>
	<get_skewY set="method" line="694" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_skewY>
	<set_skewY set="method" line="695" static="1"><f a="this:skewY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_skewY>
	<skew public="1" set="method" line="704" static="1"><f a="this:skewX:skewY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></skew>
	<anchorX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></anchorX>
	<get_anchorX set="method" line="710" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_anchorX>
	<set_anchorX set="method" line="711" static="1"><f a="this:anchorX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_anchorX>
	<anchorY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></anchorY>
	<get_anchorY set="method" line="721" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_anchorY>
	<set_anchorY set="method" line="722" static="1"><f a="this:anchorY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_anchorY>
	<anchor public="1" set="method" line="731" static="1"><f a="this:anchorX:anchorY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></anchor>
	<rotation public="1" get="accessor" set="accessor" static="1"><x path="Float"/></rotation>
	<get_rotation set="method" line="737" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_rotation>
	<set_rotation set="method" line="738" static="1"><f a="this:rotation">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
	<width public="1" get="accessor" set="accessor" static="1"><x path="Float"/></width>
	<get_width set="method" line="748" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_width>
	<set_width set="method" line="749" static="1"><f a="this:width">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
	<height public="1" get="accessor" set="accessor" static="1"><x path="Float"/></height>
	<get_height set="method" line="759" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_height>
	<set_height set="method" line="760" static="1"><f a="this:height">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
	<size public="1" set="method" line="769" static="1"><f a="this:width:height">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></size>
	<color public="1" get="accessor" set="accessor" static="1"><x path="ceramic.Color"/></color>
	<get_color set="method" line="775" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="ceramic.Color"/>
</f></get_color>
	<set_color set="method" line="776" static="1"><f a="this:color">
	<c path="ceramic.VisualTransition"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
	<alpha public="1" get="accessor" set="accessor" static="1"><x path="Float"/></alpha>
	<get_alpha set="method" line="786" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_alpha>
	<set_alpha set="method" line="787" static="1"><f a="this:alpha">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
	<transform public="1" get="accessor" set="accessor" static="1"><c path="ceramic.Transform"/></transform>
	<get_transform set="method" line="797" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<c path="ceramic.Transform"/>
</f></get_transform>
	<set_transform set="method" line="798" static="1"><f a="this:transform">
	<c path="ceramic.VisualTransition"/>
	<c path="ceramic.Transform"/>
	<c path="ceramic.Transform"/>
</f></set_transform>
</class></impl>
	</abstract>
	<class path="ceramic._VisualTransition.VisualTransitionProperties_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/VisualTransition.hx" private="1" module="ceramic.VisualTransition" final="1">
		<x public="1" get="accessor" set="accessor" static="1"><x path="Float"/></x>
		<get_x set="method" line="602" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_x>
		<set_x set="method" line="603" static="1"><f a="this:x">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<y public="1" get="accessor" set="accessor" static="1"><x path="Float"/></y>
		<get_y set="method" line="613" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_y>
		<set_y set="method" line="614" static="1"><f a="this:y">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<pos public="1" set="method" line="623" static="1"><f a="this:x:y">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pos>
		<scaleX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></scaleX>
		<get_scaleX set="method" line="629" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_scaleX>
		<set_scaleX set="method" line="630" static="1"><f a="this:scaleX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<scaleY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></scaleY>
		<get_scaleY set="method" line="640" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_scaleY>
		<set_scaleY set="method" line="641" static="1"><f a="this:scaleY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<scale public="1" set="method" line="650" static="1">
			<f a="this:scaleX:?scaleY" v="::-1">
				<c path="ceramic.VisualTransition"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scaleY : -1 }</e></m></meta>
		</scale>
		<translateX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></translateX>
		<get_translateX set="method" line="656" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_translateX>
		<set_translateX set="method" line="657" static="1"><f a="this:translateX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_translateX>
		<translateY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></translateY>
		<get_translateY set="method" line="667" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_translateY>
		<set_translateY set="method" line="668" static="1"><f a="this:translateY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_translateY>
		<translate public="1" set="method" line="677" static="1">
			<f a="this:translateX:?translateY" v="::-1">
				<c path="ceramic.VisualTransition"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ translateY : -1 }</e></m></meta>
		</translate>
		<skewX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></skewX>
		<get_skewX set="method" line="683" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_skewX>
		<set_skewX set="method" line="684" static="1"><f a="this:skewX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_skewX>
		<skewY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></skewY>
		<get_skewY set="method" line="694" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_skewY>
		<set_skewY set="method" line="695" static="1"><f a="this:skewY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_skewY>
		<skew public="1" set="method" line="704" static="1"><f a="this:skewX:skewY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></skew>
		<anchorX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></anchorX>
		<get_anchorX set="method" line="710" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_anchorX>
		<set_anchorX set="method" line="711" static="1"><f a="this:anchorX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_anchorX>
		<anchorY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></anchorY>
		<get_anchorY set="method" line="721" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_anchorY>
		<set_anchorY set="method" line="722" static="1"><f a="this:anchorY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_anchorY>
		<anchor public="1" set="method" line="731" static="1"><f a="this:anchorX:anchorY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></anchor>
		<rotation public="1" get="accessor" set="accessor" static="1"><x path="Float"/></rotation>
		<get_rotation set="method" line="737" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_rotation>
		<set_rotation set="method" line="738" static="1"><f a="this:rotation">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<width public="1" get="accessor" set="accessor" static="1"><x path="Float"/></width>
		<get_width set="method" line="748" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_width>
		<set_width set="method" line="749" static="1"><f a="this:width">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<height public="1" get="accessor" set="accessor" static="1"><x path="Float"/></height>
		<get_height set="method" line="759" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_height>
		<set_height set="method" line="760" static="1"><f a="this:height">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<size public="1" set="method" line="769" static="1"><f a="this:width:height">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></size>
		<color public="1" get="accessor" set="accessor" static="1"><x path="ceramic.Color"/></color>
		<get_color set="method" line="775" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="ceramic.Color"/>
</f></get_color>
		<set_color set="method" line="776" static="1"><f a="this:color">
	<c path="ceramic.VisualTransition"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
		<alpha public="1" get="accessor" set="accessor" static="1"><x path="Float"/></alpha>
		<get_alpha set="method" line="786" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_alpha>
		<set_alpha set="method" line="787" static="1"><f a="this:alpha">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<transform public="1" get="accessor" set="accessor" static="1"><c path="ceramic.Transform"/></transform>
		<get_transform set="method" line="797" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<c path="ceramic.Transform"/>
</f></get_transform>
		<set_transform set="method" line="798" static="1"><f a="this:transform">
	<c path="ceramic.VisualTransition"/>
	<c path="ceramic.Transform"/>
	<c path="ceramic.Transform"/>
</f></set_transform>
	</class>
	<class path="ceramic.WatchDirectory" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/WatchDirectory.hx">
		<extends path="ceramic.Entity"/>
		<didTryRequireChokidar expr="false" line="17" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</didTryRequireChokidar>
		<chokidar expr="null" line="18" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</chokidar>
		<fs expr="null" line="19" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</fs>
		<_dox_event_directoryChange public="1" set="method" line="637">
			<f a="path:newFiles:previousFiles">
				<c path="String"/>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_directoryChange>
		<emitDirectoryChange set="method" line="1095">
			<f a="path:newFiles:previousFiles">
				<c path="String"/>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>directoryChange event</haxe_doc>
		</emitDirectoryChange>
		<onDirectoryChange public="1" set="method" line="1199">
			<f a="owner:handlePathNewFilesPreviousFiles">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="path:newFiles:previousFiles">
					<c path="String"/>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>directoryChange event</haxe_doc>
		</onDirectoryChange>
		<onceDirectoryChange public="1" set="method" line="1298">
			<f a="owner:handlePathNewFilesPreviousFiles">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="path:newFiles:previousFiles">
					<c path="String"/>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>directoryChange event</haxe_doc>
		</onceDirectoryChange>
		<offDirectoryChange public="1" set="method" line="1368">
			<f a="?handlePathNewFilesPreviousFiles">
				<f a="path:newFiles:previousFiles">
					<c path="String"/>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>directoryChange event</haxe_doc>
		</offDirectoryChange>
		<listensDirectoryChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to directoryChange event</haxe_doc>
		</listensDirectoryChange>
		<updateInterval public="1" set="null"><x path="Float"/></updateInterval>
		<watchedDirectories public="1" set="null" expr="null">
			<x path="ceramic.ReadOnlyMap">
				<c path="String"/>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
			</x>
			<meta><m n=":value"><e>null</e></m></meta>
		</watchedDirectories>
		<startingToWatchDirectories expr="null">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</startingToWatchDirectories>
		<chokidarUpdatedFilesByWatchedDirectory expr="null">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><a>
	<status><x path="ceramic.ChokidarWatchedFileStatus"/></status>
	<name><c path="String"/></name>
	<lastModified><x path="Float"/></lastModified>
</a></c>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</chokidarUpdatedFilesByWatchedDirectory>
		<chokidarWatchers expr="null">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</chokidarWatchers>
		<watchDirectory public="1" set="method" line="49"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></watchDirectory>
		<watchWithChokidar set="method" line="84"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></watchWithChokidar>
		<stopWatchingDirectory public="1" set="method" line="135"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></stopWatchingDirectory>
		<tick set="method" line="163"><f a=""><x path="Void"/></f></tick>
		<checkWatchedDirectory set="method" line="177"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></checkWatchedDirectory>
		<computeFilesModificationTime set="method" line="258"><f a="path">
	<c path="String"/>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
</f></computeFilesModificationTime>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="30">
			<f a="?updateInterval" v="1.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ updateInterval : 1.0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.ChokidarWatchedFileStatus" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/WatchDirectory.hx" module="ceramic.WatchDirectory">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="ceramic._WatchDirectory.ChokidarWatchedFileStatus_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/WatchDirectory.hx" private="1" module="ceramic.WatchDirectory" extern="1" final="1">
	<ADD public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="ceramic.ChokidarWatchedFileStatus"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ADD>
	<CHANGE public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="ceramic.ChokidarWatchedFileStatus"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CHANGE>
	<UNLINK public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="ceramic.ChokidarWatchedFileStatus"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNLINK>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._WatchDirectory.ChokidarWatchedFileStatus_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/WatchDirectory.hx" private="1" module="ceramic.WatchDirectory" extern="1" final="1">
		<ADD public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="ceramic.ChokidarWatchedFileStatus"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ADD>
		<CHANGE public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="ceramic.ChokidarWatchedFileStatus"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CHANGE>
		<UNLINK public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="ceramic.ChokidarWatchedFileStatus"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNLINK>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="ceramic.macros.DefinesMacro" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/macros/DefinesMacro.hx">
		<getDefine public="1" set="method" static="1">
			<f a="key">
				<d/>
				<d/>
			</f>
			<haxe_doc>* Shorthand for retrieving compiler flag values.</haxe_doc>
		</getDefine>
		<getFloatDefine public="1" set="method" static="1">
			<f a="key">
				<d/>
				<d/>
			</f>
			<haxe_doc>* Shorthand for retrieving compiler flag values as `Float`.</haxe_doc>
		</getFloatDefine>
		<getIntDefine public="1" set="method" static="1">
			<f a="key">
				<d/>
				<d/>
			</f>
			<haxe_doc>* Shorthand for retrieving compiler flag values as `Int`.</haxe_doc>
		</getIntDefine>
		<getBoolDefine public="1" set="method" static="1">
			<f a="key">
				<d/>
				<d/>
			</f>
			<haxe_doc>* Shorthand for retrieving compiler flag values as `Bool`.</haxe_doc>
		</getBoolDefine>
		<_stringToBool set="method" line="37" static="1"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></_stringToBool>
		<isDefined public="1" set="method" static="1">
			<f a="key">
				<d/>
				<d/>
			</f>
			<haxe_doc>* Shorthand for checking if a compiler flag is defined.</haxe_doc>
		</isDefined>
		<getDefines public="1" set="method" static="1">
			<f a=""><d/></f>
			<haxe_doc>* Shorthand for retrieving a map of all defined compiler flags.</haxe_doc>
		</getDefines>
		<haxe_doc>* Utilities to access defines from code.
 * Original source: https://code.haxe.org/category/macros/get-compiler-define-value.html</haxe_doc>
	</class>
	<class path="ceramic.macros.PluginsMacro" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/macros/PluginsMacro.hx"><initPlugins public="1" set="method" static="1">
	<f a=""><d/></f>
	<haxe_doc>* Resolves plugin classes and calls pluginInit() for each of them.</haxe_doc>
</initPlugins></class>
	<class path="ceramic.scriptable.ScriptableColor" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/scriptable/ScriptableColor.hx">
		<NONE final="1" public="1" set="null" expr="-1" line="15" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</NONE>
		<WHITE final="1" public="1" set="null" expr="0xFFFFFF" line="17" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFFFF</e></m></meta>
		</WHITE>
		<GRAY final="1" public="1" set="null" expr="0x808080" line="18" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x808080</e></m></meta>
		</GRAY>
		<BLACK final="1" public="1" set="null" expr="0x000000" line="19" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x000000</e></m></meta>
		</BLACK>
		<GREEN final="1" public="1" set="null" expr="0x008000" line="21" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x008000</e></m></meta>
		</GREEN>
		<LIME final="1" public="1" set="null" expr="0x00FF00" line="22" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x00FF00</e></m></meta>
		</LIME>
		<YELLOW final="1" public="1" set="null" expr="0xFFFF00" line="23" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFF00</e></m></meta>
		</YELLOW>
		<ORANGE final="1" public="1" set="null" expr="0xFFA500" line="24" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFA500</e></m></meta>
		</ORANGE>
		<RED final="1" public="1" set="null" expr="0xFF0000" line="25" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF0000</e></m></meta>
		</RED>
		<PURPLE final="1" public="1" set="null" expr="0x800080" line="26" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x800080</e></m></meta>
		</PURPLE>
		<BLUE final="1" public="1" set="null" expr="0x0000FF" line="27" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x0000FF</e></m></meta>
		</BLUE>
		<BROWN final="1" public="1" set="null" expr="0x8B4513" line="28" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x8B4513</e></m></meta>
		</BROWN>
		<PINK final="1" public="1" set="null" expr="0xFFC0CB" line="29" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFC0CB</e></m></meta>
		</PINK>
		<MAGENTA final="1" public="1" set="null" expr="0xFF00FF" line="30" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF00FF</e></m></meta>
		</MAGENTA>
		<CYAN final="1" public="1" set="null" expr="0x00FFFF" line="31" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x00FFFF</e></m></meta>
		</CYAN>
		<random public="1" set="method" line="38" static="1">
			<f a="?minSatutation:?minBrightness" v="0.5:0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ minBrightness : 0.5, minSatutation : 0.5 }</e></m></meta>
			<haxe_doc>* Generate a random color (away from white or black)
     * @return The color as a Color</haxe_doc>
		</random>
		<fromInt public="1" set="method" line="49" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Create a color from the least significant four bytes of an Int
     *
     * @param    value And Int with bytes in the format 0xRRGGBB
     * @return    The color as a Color</haxe_doc>
		</fromInt>
		<fromRGB public="1" set="method" line="62" static="1">
			<f a="red:green:blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from integer RGB values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return The color as a Color</haxe_doc>
		</fromRGB>
		<fromRGBFloat public="1" set="method" line="75" static="1">
			<f a="red:green:blue">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from float RGB values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return The color as a Color</haxe_doc>
		</fromRGBFloat>
		<fromCMYK public="1" set="method" line="89" static="1">
			<f a="cyan:magenta:yellow:black">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from CMYK values (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return The color as a Color</haxe_doc>
		</fromCMYK>
		<fromHSB public="1" set="method" line="102" static="1">
			<f a="hue:saturation:brightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from HSB (aka HSV) components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    The color as a Color</haxe_doc>
		</fromHSB>
		<fromHSL public="1" set="method" line="115" static="1">
			<f a="hue:saturation:lightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a Color</haxe_doc>
		</fromHSL>
		<fromString public="1" set="method" line="133" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Null"><x path="ceramic.Color"/></x>
			</f>
			<haxe_doc><![CDATA[* Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.
     *
     * Examples (input -> output in hex):
     *
     * - `0x00FF00`    -> `0x00FF00`
     * - `#0000FF`     -> `0x0000FF`
     * - `GRAY`        -> `0x808080`
     * - `blue`        -> `0x0000FF`
     *
     * @param    str     The string to be parsed
     * @return    A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
		</fromString>
		<getHSBColorWheel public="1" set="method" line="143" static="1">
			<f a=""><c path="Array"><x path="ceramic.Color"/></c></f>
			<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
     *
     * @return    HSB color wheel as Array of Colors</haxe_doc>
		</getHSBColorWheel>
		<interpolate public="1" get="inline" set="null" line="156" static="1">
			<f a="color1:color2:?factor" v="::0.5">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.5 }</e></m></meta>
			<haxe_doc>* Get an interpolated color based on two different colors.
     *
     * @param     color1 The first color
     * @param     color2 The second color
     * @param     factor value from 0 to 1 representing how much to shift color1 toward color2
     * @return    The interpolated color</haxe_doc>
		</interpolate>
		<gradient public="1" set="method" line="170" static="1">
			<f a="color1:color2:steps:?ease">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Int"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<c path="Array"><x path="ceramic.Color"/></c>
			</f>
			<haxe_doc>* Create a gradient from one color to another
     *
     * @param color1 The color to shift from
     * @param color2 The color to shift to
     * @param steps How many colors the gradient should have
     * @param ease An optional easing function, such as those provided in FlxEase
     * @return An array of colors of length steps, shifting from color1 to color2</haxe_doc>
		</gradient>
		<multiply public="1" set="method" line="178" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Multiply the RGB channels of two Colors</haxe_doc>
		</multiply>
		<add public="1" set="method" line="186" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Add the RGB channels of two Colors</haxe_doc>
		</add>
		<subtract public="1" set="method" line="194" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Subtract the RGB channels of one Color from another</haxe_doc>
		</subtract>
		<toHexString public="1" set="method" line="205" static="1">
			<f a="color:?prefix" v=":true">
				<x path="ceramic.Color"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ prefix : true }</e></m></meta>
			<haxe_doc>* Return a String representation of the color in the format
     *
     * @param prefix Whether to include "0x" prefix at start of string
     * @return    A string of length 10 in the format 0xAARRGGBB</haxe_doc>
		</toHexString>
		<toWebString public="1" set="method" line="215" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a String representation of the color in the format #RRGGBB
     *
     * @return    A string of length 7 in the format #RRGGBB</haxe_doc>
		</toWebString>
		<getColorInfo public="1" set="method" line="225" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Get a string of color information about this color
     *
     * @return A string containing information about this color</haxe_doc>
		</getColorInfo>
		<getDarkened public="1" set="method" line="236" static="1">
			<f a="color:?factor" v=":0.2">
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
			<haxe_doc>* Get a darkened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward black.
     * @return     A darkened version of this color</haxe_doc>
		</getDarkened>
		<getLightened public="1" set="method" line="247" static="1">
			<f a="color:?factor" v=":0.2">
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
			<haxe_doc>* Get a lightened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward white.
     * @return     A lightened version of this color</haxe_doc>
		</getLightened>
		<getInverted public="1" set="method" line="257" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Get the inversion of this color
     *
     * @return The inversion of this color</haxe_doc>
		</getInverted>
		<hue public="1" set="method" line="265" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get the hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hue>
		<saturation public="1" set="method" line="273" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get the saturation of the color (from 0 to 1)</haxe_doc>
		</saturation>
		<brightness public="1" set="method" line="281" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get the brightness (aka value) of the color (from 0 to 1)</haxe_doc>
		</brightness>
		<lightness public="1" set="method" line="289" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get the lightness of the color (from 0 to 1)</haxe_doc>
		</lightness>
		<red public="1" set="method" line="294" static="1"><f a="color">
	<x path="ceramic.Color"/>
	<x path="Int"/>
</f></red>
		<green public="1" set="method" line="299" static="1"><f a="color">
	<x path="ceramic.Color"/>
	<x path="Int"/>
</f></green>
		<blue public="1" set="method" line="304" static="1"><f a="color">
	<x path="ceramic.Color"/>
	<x path="Int"/>
</f></blue>
		<redFloat public="1" set="method" line="309" static="1"><f a="color">
	<x path="ceramic.Color"/>
	<x path="Float"/>
</f></redFloat>
		<greenFloat public="1" set="method" line="314" static="1"><f a="color">
	<x path="ceramic.Color"/>
	<x path="Float"/>
</f></greenFloat>
		<blueFloat public="1" set="method" line="319" static="1"><f a="color">
	<x path="ceramic.Color"/>
	<x path="Float"/>
</f></blueFloat>
		<fromHSLuv public="1" set="method" line="333" static="1">
			<f a="hue:saturation:lightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a Color</haxe_doc>
		</fromHSLuv>
		<getHSLuv public="1" set="method" line="344" static="1">
			<f a="color:?result">
				<x path="ceramic.Color"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Get HSLuv components from the color instance.
     *
     * @param result A pre-allocated array to store the result into.
     * @return    The HSLuv components as a float array</haxe_doc>
		</getHSLuv>
		<haxe_doc>* Class representing a color, based on Int. Provides a variety of methods for creating and converting colors.
 *
 * Colors can be written as Ints. This means you can pass a hex value such as
 * 0x123456 to a function expecting a Color, and it will automatically become a Color "object".
 * Similarly, Colors may be treated as Ints.
 *
 * Note that when using properties of a Color other than RGB, the values are ultimately stored as
 * RGB values, so repeatedly manipulating HSB/HSL/CMYK values may result in a gradual loss of precision.</haxe_doc>
	</class>
	<class path="ceramic.scriptable.ScriptableFlags" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/scriptable/ScriptableFlags.hx">
		<getBool public="1" set="method" line="5" static="1"><f a="flags:bit">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getBool>
		<setBoolAndGetFlags public="1" set="method" line="12" static="1"><f a="flags:bit:bool">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></setBoolAndGetFlags>
	</class>
	<class path="ceramic.scriptable.ScriptableMeshColorMapping" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/scriptable/ScriptableMeshColorMapping.hx">
		<MESH public="1" expr="0" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Map a single color to the whole mesh.</haxe_doc>
		</MESH>
		<INDICES public="1" expr="1" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Map a color to each indice.</haxe_doc>
		</INDICES>
		<VERTICES public="1" expr="2" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
			<haxe_doc>* Map a color to each vertex.</haxe_doc>
		</VERTICES>
	</class>
	<class path="earcut.Earcut" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/earcut/earcut/Earcut.hx">
		<earcut public="1" set="method" line="8" static="1">
			<f a="data:?holeIndices:?dim:?triangles" v="::2:">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ dim : 2 }</e></m></meta>
		</earcut>
		<linkedList set="method" line="80" static="1">
			<f a="data:start:end:dim:clockwise">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Create a circular doubly linked list from polygon points in the specified winding order</haxe_doc>
		</linkedList>
		<filterPoints set="method" line="110" static="1">
			<f a="?start:?end">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Eliminate colinear or duplicate points</haxe_doc>
		</filterPoints>
		<earcutLinked set="method" line="143" static="1">
			<f a="ear:triangles:dim:?minX:?minY:?invSize:?pass">
				<c path="earcut.Node"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Main ear slicing loop which triangulates a polygon (given as a linked list)</haxe_doc>
		</earcutLinked>
		<isEar set="method" line="203" static="1">
			<f a="ear">
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check whether a polygon node forms a valid ear with adjacent nodes</haxe_doc>
		</isEar>
		<isEarHashed set="method" line="225" static="1"><f a="ear:minX:minY:invSize">
	<c path="earcut.Node"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isEarHashed>
		<cureLocalIntersections set="method" line="283" static="1">
			<f a="start:triangles:dim">
				<c path="earcut.Node"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Float"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Go through all polygon nodes and cure small local self-intersections</haxe_doc>
		</cureLocalIntersections>
		<splitEarcut set="method" line="310" static="1">
			<f a="start:triangles:dim:minX:minY:invSize">
				<c path="earcut.Node"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Try splitting polygon into two and triangulate them independently</haxe_doc>
		</splitEarcut>
		<eliminateHoles set="method" line="342" static="1">
			<f a="data:holeIndices:outerNode:dim">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="earcut.Node"/>
				<x path="Int"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Link every hole into the outer loop, producing a single-ring polygon without holes</haxe_doc>
		</eliminateHoles>
		<compareX get="inline" set="null" line="371" static="1"><f a="a:b">
	<c path="earcut.Node"/>
	<c path="earcut.Node"/>
	<x path="Int"/>
</f></compareX>
		<eliminateHole get="inline" set="null" line="378" static="1">
			<f a="hole:outerNode">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Find a bridge between vertices that connects hole with an outer ring and and link it</haxe_doc>
		</eliminateHole>
		<findHoleBridge set="method" line="392" static="1">
			<f a="hole:outerNode">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* David Eberly's algorithm for finding a bridge between hole and outer polygon</haxe_doc>
		</findHoleBridge>
		<sectorContainsSector get="inline" set="null" line="465" static="1">
			<f a="m:p">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Whether sector in vertex m contains sector in vertex p in the same coordinates</haxe_doc>
		</sectorContainsSector>
		<indexCurve set="method" line="472" static="1">
			<f a="start:minX:minY:invSize">
				<c path="earcut.Node"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Interlink polygon nodes in z-order</haxe_doc>
		</indexCurve>
		<sortLinked set="method" line="496" static="1">
			<f a="list">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Simon Tatham's linked list merge sort algorithm
     * http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html</haxe_doc>
		</sortLinked>
		<zOrder set="method" line="564" static="1">
			<f a="x:y:minX:minY:invSize">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* z-order of a point given coords and size of the data bounding box</haxe_doc>
		</zOrder>
		<getLeftmost set="method" line="585" static="1">
			<f a="start">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Find the leftmost node of a polygon ring</haxe_doc>
		</getLeftmost>
		<pointInTriangle get="inline" set="null" line="601" static="1">
			<f a="ax:ay:bx:by:cx:cy:px:py">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a point lies within a convex triangle</haxe_doc>
		</pointInTriangle>
		<isValidDiagonal get="inline" set="null" line="610" static="1">
			<f a="a:b">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a diagonal between two polygon nodes is valid (lies in polygon interior)</haxe_doc>
		</isValidDiagonal>
		<area get="inline" set="null" line="620" static="1">
			<f a="p:q:r">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Signed area of a triangle</haxe_doc>
		</area>
		<equals get="inline" set="null" line="627" static="1">
			<f a="p1:p2">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if two points are equal</haxe_doc>
		</equals>
		<intersects get="inline" set="null" line="634" static="1">
			<f a="p1:q1:p2:q2">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if two segments intersect</haxe_doc>
		</intersects>
		<onSegment get="inline" set="null" line="653" static="1">
			<f a="p:q:r">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* For collinear points p, q, r, check if point q lies on segment pr</haxe_doc>
		</onSegment>
		<sign get="inline" set="null" line="657" static="1"><f a="num">
	<x path="Float"/>
	<x path="Int"/>
</f></sign>
		<intersectsPolygon set="method" line="664" static="1">
			<f a="a:b">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a polygon diagonal intersects any polygon segments</haxe_doc>
		</intersectsPolygon>
		<locallyInside get="inline" set="null" line="680" static="1">
			<f a="a:b">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a polygon diagonal is locally inside the polygon</haxe_doc>
		</locallyInside>
		<middleInside set="method" line="689" static="1">
			<f a="a:b">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if the middle point of a polygon diagonal is inside the polygon</haxe_doc>
		</middleInside>
		<splitPolygon set="method" line="710" static="1">
			<f a="a:b">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
     * If one belongs to the outer ring and another to a hole, it merges it into a single ring</haxe_doc>
		</splitPolygon>
		<insertNode set="method" line="734" static="1">
			<f a="i:x:y:?last">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Create a node and optionally link it with previous one (in a circular doubly linked list)</haxe_doc>
		</insertNode>
		<removeNode set="method" line="751" static="1"><f a="p">
	<c path="earcut.Node"/>
	<x path="Void"/>
</f></removeNode>
		<signedArea set="method" line="763" static="1"><f a="data:start:end:dim">
	<c path="Array"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></signedArea>
		<deviation set="method" line="778" static="1"><f a="data:holeIndices:dim:triangles">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Float"/>
</f></deviation>
		<flatten public="1" set="method" line="809" static="1"><f a="data">
	<c path="Array"><c path="Array"><c path="Array"><x path="Float"/></c></c></c>
	<d/>
</f></flatten>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="earcut.Node" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/earcut/earcut/Earcut.hx" module="earcut.Earcut">
		<recyclingEnabled public="1" expr="true" line="887" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</recyclingEnabled>
		<nextPoolIndex expr="0" line="889" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextPoolIndex>
		<pool expr="[]" line="891" static="1">
			<c path="Array"><c path="earcut.Node"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pool>
		<clearPool public="1" set="method" line="893" static="1"><f a=""><x path="Void"/></f></clearPool>
		<recycleAllNodes public="1" set="method" line="900" static="1"><f a=""><x path="Void"/></f></recycleAllNodes>
		<get public="1" set="method" line="906" static="1"><f a="i:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="earcut.Node"/>
</f></get>
		<i public="1"><x path="Int"/></i>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<prev public="1"><c path="earcut.Node"/></prev>
		<next public="1"><c path="earcut.Node"/></next>
		<z public="1" expr="-99999999">
			<x path="Int"/>
			<meta><m n=":value"><e>-99999999</e></m></meta>
		</z>
		<prevZ public="1"><c path="earcut.Node"/></prevZ>
		<nextZ public="1"><c path="earcut.Node"/></nextZ>
		<steiner public="1"><x path="Bool"/></steiner>
		<reset get="inline" set="null" line="860"><f a="i:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></reset>
		<new public="1" set="method" line="854"><f a="i:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="haxe.StackItem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line:?column">
			<x path="Null"><e path="haxe.StackItem"/></x>
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<x path="Null"><c path="String"/></x>
			<c path="String"/>
		</Method>
		<LocalFunction a="?v"><x path="Int"/></LocalFunction>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<abstract path="haxe.CallStack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>The length of this stack.</haxe_doc>
	</length>
	<get_length get="inline" set="null" line="46" static="1"><f a="this">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<x path="Int"/>
</f></get_length>
	<callStack public="1" set="method" line="51" static="1">
		<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
		<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
	</callStack>
	<exceptionStack public="1" set="method" line="63" static="1">
		<f a="?fullStack" v="false">
			<x path="Bool"/>
			<c path="Array"><e path="haxe.StackItem"/></c>
		</f>
		<meta><m n=":value"><e>{ fullStack : false }</e></m></meta>
		<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.
		Set `fullStack` parameter to true in order to return the full exception stack.

		May not work if catch type was a derivative from `haxe.Exception`.</haxe_doc>
	</exceptionStack>
	<subtract public="1" set="method" line="84" static="1">
		<f a="this:stack">
			<c path="Array"><e path="haxe.StackItem"/></c>
			<x path="haxe.CallStack"/>
			<x path="haxe.CallStack"/>
		</f>
		<haxe_doc>Returns a range of entries of current stack from the beginning to the the
		common part of this and `stack`.</haxe_doc>
	</subtract>
	<get public="1" get="inline" set="null" line="111" static="1">
		<f a="this:index">
			<c path="Array"><e path="haxe.StackItem"/></c>
			<x path="Int"/>
			<e path="haxe.StackItem"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</get>
	<asArray get="inline" set="null" line="115" static="1"><f a="this">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<c path="Array"><e path="haxe.StackItem"/></c>
</f></asArray>
	<equalItems set="method" line="119" static="1"><f a="item1:item2">
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Bool"/>
</f></equalItems>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":using"><e>haxe.CallStack</e></m>
		<m n=":allow"><e>haxe.Exception</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe._CallStack.CallStack_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1">
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>The length of this stack.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="46" static="1"><f a="this">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<x path="Int"/>
</f></get_length>
		<callStack public="1" set="method" line="51" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="63" static="1">
			<f a="?fullStack" v="false">
				<x path="Bool"/>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":value"><e>{ fullStack : false }</e></m></meta>
			<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.
		Set `fullStack` parameter to true in order to return the full exception stack.

		May not work if catch type was a derivative from `haxe.Exception`.</haxe_doc>
		</exceptionStack>
		<subtract public="1" set="method" line="84" static="1">
			<f a="this:stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="haxe.CallStack"/>
				<x path="haxe.CallStack"/>
			</f>
			<haxe_doc>Returns a range of entries of current stack from the beginning to the the
		common part of this and `stack`.</haxe_doc>
		</subtract>
		<get public="1" get="inline" set="null" line="111" static="1">
			<f a="this:index">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="Int"/>
				<e path="haxe.StackItem"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</get>
		<asArray get="inline" set="null" line="115" static="1"><f a="this">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<c path="Array"><e path="haxe.StackItem"/></c>
</f></asArray>
		<equalItems set="method" line="119" static="1"><f a="item1:item2">
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Bool"/>
</f></equalItems>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":using"><e>haxe.CallStack</e></m>
			<m n=":allow"><e>haxe.Exception</e></m>
		</meta>
	</class>
	<abstract path="haxe.Function" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Null"><c path="haxe.IMap.V"/></x>
</f></get>
		<set public="1" set="method"><f a="k:v">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
	<x path="Void"/>
</f></set>
		<exists public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></exists>
		<remove public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<keys public="1" set="method"><f a=""><t path="Iterator"><c path="haxe.IMap.K"/></t></f></keys>
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="haxe.IMap.V"/></t></f></iterator>
		<keyValueIterator public="1" set="method"><f a=""><t path="KeyValueIterator">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
</t></f></keyValueIterator>
		<copy public="1" set="method"><f a=""><c path="haxe.IMap">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
</c></f></copy>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.DynamicAccess" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/DynamicAccess.hx">
		<from><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></from>
		<this><d><c path="haxe.DynamicAccess.T"/></d></this>
		<to><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></to>
		<haxe_doc>DynamicAccess is an abstract type for working with anonymous structures
	that are intended to hold collections of objects by the string key.

	For example, these types of structures are often created from JSON.

	Basically, it wraps `Reflect` calls in a `Map`-like interface.</haxe_doc>
		<impl><class path="haxe._DynamicAccess.DynamicAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/DynamicAccess.hx" private="1" module="haxe.DynamicAccess" final="1">
	<get public="1" get="inline" set="null" line="51" static="1">
		<f a="this:key">
			<d><c path="haxe.DynamicAccess.T"/></d>
			<c path="String"/>
			<x path="Null"><c path="haxe.DynamicAccess.T"/></x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":arrayAccess"/>
		</meta>
		<haxe_doc>Returns a value by specified `key`.

		If the structure does not contain the given key, `null` is returned.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</get>
	<set public="1" get="inline" set="null" line="69" static="1">
		<f a="this:key:value">
			<d><c path="haxe.DynamicAccess.T"/></d>
			<c path="String"/>
			<c path="haxe.DynamicAccess.T"/>
			<c path="haxe.DynamicAccess.T"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":arrayAccess"/>
		</meta>
		<haxe_doc>Sets a `value` for a specified `key`.

		If the structure contains the given key, its value will be overwritten.

		Returns the given value.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</set>
	<exists public="1" get="inline" set="null" line="84" static="1">
		<f a="this:key">
			<d><c path="haxe.DynamicAccess.T"/></d>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Tells if the structure contains a specified `key`.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</exists>
	<remove public="1" get="inline" set="null" line="94" static="1">
		<f a="this:key">
			<d><c path="haxe.DynamicAccess.T"/></d>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Removes a specified `key` from the structure.

		Returns true, if `key` was present in structure, or false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</remove>
	<keys public="1" get="inline" set="null" line="100" static="1">
		<f a="this">
			<d><c path="haxe.DynamicAccess.T"/></d>
			<c path="Array"><c path="String"/></c>
		</f>
		<haxe_doc>Returns an array of `keys` in a structure.</haxe_doc>
	</keys>
	<keyValueIterator public="1" get="inline" set="null" line="122" static="1">
		<f a="this">
			<d><c path="haxe.DynamicAccess.T"/></d>
			<c path="haxe.iterators.DynamicAccessKeyValueIterator"><c path="haxe.DynamicAccess.T"/></c>
		</f>
		<haxe_doc>Returns an Iterator over the keys and values of this `DynamicAccess`.

		The order of values is undefined.</haxe_doc>
	</keyValueIterator>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe._DynamicAccess.DynamicAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/DynamicAccess.hx" private="1" module="haxe.DynamicAccess" final="1">
		<get public="1" get="inline" set="null" line="51" static="1">
			<f a="this:key">
				<d><c path="haxe.DynamicAccess.T"/></d>
				<c path="String"/>
				<x path="Null"><c path="haxe.DynamicAccess.T"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":arrayAccess"/>
			</meta>
			<haxe_doc>Returns a value by specified `key`.

		If the structure does not contain the given key, `null` is returned.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="69" static="1">
			<f a="this:key:value">
				<d><c path="haxe.DynamicAccess.T"/></d>
				<c path="String"/>
				<c path="haxe.DynamicAccess.T"/>
				<c path="haxe.DynamicAccess.T"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":arrayAccess"/>
			</meta>
			<haxe_doc>Sets a `value` for a specified `key`.

		If the structure contains the given key, its value will be overwritten.

		Returns the given value.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</set>
		<exists public="1" get="inline" set="null" line="84" static="1">
			<f a="this:key">
				<d><c path="haxe.DynamicAccess.T"/></d>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the structure contains a specified `key`.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</exists>
		<remove public="1" get="inline" set="null" line="94" static="1">
			<f a="this:key">
				<d><c path="haxe.DynamicAccess.T"/></d>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a specified `key` from the structure.

		Returns true, if `key` was present in structure, or false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="100" static="1">
			<f a="this">
				<d><c path="haxe.DynamicAccess.T"/></d>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns an array of `keys` in a structure.</haxe_doc>
		</keys>
		<keyValueIterator public="1" get="inline" set="null" line="122" static="1">
			<f a="this">
				<d><c path="haxe.DynamicAccess.T"/></d>
				<c path="haxe.iterators.DynamicAccessKeyValueIterator"><c path="haxe.DynamicAccess.T"/></c>
			</f>
			<haxe_doc>Returns an Iterator over the keys and values of this `DynamicAccess`.

		The order of values is undefined.</haxe_doc>
		</keyValueIterator>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:

			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="138" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="149" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="163" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="175" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe._Exception.NativeException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/Exception.hx" private="1" module="haxe.Exception" extern="1">
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":native"><e>"Error"</e></m>
		</meta>
	</class>
	<class path="haxe.Exception" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/Exception.hx">
		<extends path="haxe._Exception.NativeException"/>
		<caught set="method" line="18" static="1"><f a="value">
	<x path="Any"/>
	<c path="haxe.Exception"/>
</f></caught>
		<thrown set="method" line="28" static="1">
			<f a="value">
				<x path="Any"/>
				<x path="Any"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</thrown>
		<message public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>Exception message.</haxe_doc>
		</message>
		<stack public="1" get="accessor" set="null">
			<x path="haxe.CallStack"/>
			<haxe_doc>The call stack at the moment of the exception creation.</haxe_doc>
		</stack>
		<native public="1" get="accessor" set="null">
			<x path="Any"/>
			<haxe_doc>Native exception, which caused this exception.</haxe_doc>
		</native>
		<__skipStack>
			<x path="Int"/>
			<meta>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__skipStack>
		<__exceptionStack get="accessor" set="accessor">
			<x path="Null"><x path="haxe.CallStack"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__exceptionStack>
		<__nativeException>
			<x path="Any"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<unwrap set="method" line="70"><f a=""><x path="Any"/></f></unwrap>
		<toString public="1" set="method" line="74">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<__shiftStack get="inline" set="null" line="84">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__shiftStack>
		<get_message set="method" line="88"><f a=""><c path="String"/></f></get_message>
		<get_native final="1" set="method" line="96"><f a=""><x path="Any"/></f></get_native>
		<get_stack set="method" line="101">
			<f a=""><x path="haxe.CallStack"/></f>
			<meta><m n=":ifFeature"><e>"haxe.NativeStackTrace.exceptionStack"</e></m></meta>
		</get_stack>
		<setProperty set="method" line="110">
			<f a="name:value">
				<c path="String"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setProperty>
		<get___exceptionStack get="inline" set="null" line="119">
			<f a=""><x path="haxe.CallStack"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get___exceptionStack>
		<set___exceptionStack get="inline" set="null" line="124">
			<f a="value">
				<x path="haxe.CallStack"/>
				<x path="haxe.CallStack"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set___exceptionStack>
		<new public="1" set="method" line="40">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.Int32" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>This typedef will fool `@:coreApi` into thinking that we are using
	the same underlying type, even though it might be different on
	specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe.Json" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/Json.hx" extern="1">
		<parse public="1" set="method" static="1">
			<f a="text">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[Parses given JSON-encoded `text` and returns the resulting object.

		JSON objects are parsed into anonymous structures and JSON arrays
		are parsed into `Array<Dynamic>`.

		If given `text` is not valid JSON, an exception will be thrown.

		@see https://haxe.org/manual/std-Json-parsing.html]]></haxe_doc>
		</parse>
		<stringify public="1" set="method" static="1">
			<f a="value:?replacer:?space">
				<d/>
				<f a="key:value">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes the given `value` and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve the
		actual object to be encoded. The `replacer` function takes two parameters,
		the key and the value being encoded. Initial key value is an empty string.

		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.

		@see https://haxe.org/manual/std-Json-encoding.html</haxe_doc>
		</stringify>
		<haxe_doc>Cross-platform JSON API: it will automatically use the optimized native API if available.
	Use `-D haxeJSON` to force usage of the Haxe implementation even if a native API is found:
	This will provide extra encoding (but not decoding) features such as enums (replaced by their index) and StringMaps.

	@see https://haxe.org/manual/std-Json.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":native"><e>"JSON"</e></m>
		</meta>
	</class>
	<class path="haxe.Log" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Log.hx">
		<formatOutput public="1" set="method" line="33" static="1">
			<f a="v:infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format the output of `trace` before printing it.</haxe_doc>
		</formatOutput>
		<trace public="1" set="dynamic" line="62" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:

			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe._NativeStackTrace.V8Error" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/NativeStackTrace.hx" private="1" module="haxe.NativeStackTrace" extern="1">
		<prepareStackTrace public="1" static="1"><f a="error:structuredStackTrace">
	<c path="js.lib.Error"/>
	<c path="Array"><t path="haxe.V8CallSite"/></c>
	<x path="Any"/>
</f></prepareStackTrace>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Error"</e></m>
		</meta>
	</class>
	<typedef path="haxe.V8CallSite" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/NativeStackTrace.hx" module="haxe.NativeStackTrace"><a>
	<getLineNumber set="method"><f a=""><x path="Int"/></f></getLineNumber>
	<getFunctionName set="method"><f a=""><c path="String"/></f></getFunctionName>
	<getFileName set="method"><f a=""><c path="String"/></f></getFileName>
	<getColumnNumber set="method"><f a=""><x path="Int"/></f></getColumnNumber>
</a></typedef>
	<class path="haxe.NativeStackTrace" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/NativeStackTrace.hx">
		<lastError static="1"><c path="js.lib.Error"/></lastError>
		<wrapCallSite public="1" static="1">
			<f a="">
				<t path="haxe.V8CallSite"/>
				<t path="haxe.V8CallSite"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</wrapCallSite>
		<saveStack public="1" get="inline" set="null" line="34" static="1">
			<f a="e">
				<c path="js.lib.Error"/>
				<x path="Void"/>
			</f>
			<meta><m n=":ifFeature"><e>"haxe.NativeStackTrace.exceptionStack"</e></m></meta>
		</saveStack>
		<callStack public="1" set="method" line="38" static="1"><f a=""><x path="Any"/></f></callStack>
		<exceptionStack public="1" set="method" line="49" static="1"><f a=""><x path="Any"/></f></exceptionStack>
		<toHaxe public="1" set="method" line="53" static="1">
			<f a="s:?skip" v=":0">
				<x path="Null"><x path="Any"/></x>
				<x path="Int"/>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":value"><e>{ skip : 0 }</e></m></meta>
		</toHaxe>
		<tryHaxeStack set="method" line="89" static="1"><f a="e">
	<x path="Null"><c path="js.lib.Error"/></x>
	<x path="Any"/>
</f></tryHaxeStack>
		<prepareHxStackTrace set="method" line="101" static="1"><f a="e:callsites">
	<c path="js.lib.Error"/>
	<c path="Array"><t path="haxe.V8CallSite"/></c>
	<x path="Any"/>
</f></prepareHxStackTrace>
		<normalize set="method" line="127" static="1">
			<f a="stack:?skipItems" v=":0">
				<x path="Any"/>
				<x path="Int"/>
				<x path="Any"/>
			</f>
			<meta><m n=":value"><e>{ skipItems : 0 }</e></m></meta>
		</normalize>
		<skipLines set="method" line="142" static="1">
			<f a="stack:skip:?pos" v="::0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ pos : 0 }</e></m></meta>
		</skipLines>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":allow"><e>haxe.Exception</e></m>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<typedef path="haxe._Rest.NativeRest" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Rest.hx" private="1" module="haxe.Rest"><c path="Array"><c path="haxe._Rest.NativeRest.T"/></c></typedef>
	<abstract path="haxe.Rest" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Rest.hx">
		<from><icast field="of"><c path="Array"><c path="of.T"/></c></icast></from>
		<this><t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t></this>
		<to><icast field="toArray"><c path="Array"><c path="haxe.Rest.T"/></c></icast></to>
		<haxe_doc><![CDATA[A special type that represents a "rest" function argument.

	The special `...` syntax can be used for convenience and improved readability:

	```haxe
	function f(...rest:Int) {
		$type(rest); // haxe.Rest<Int>
	}

	f(1, 2, 3);

	final array = [1, 2, 3];
	f(...array);
	```

	Should be used as a type for the last argument of a method, indicating that
	an arbitrary number of arguments of the given type can be passed to that method.

	Allows to use array access by index to get values of rest arguments.
	If the index exceeds the amount of rest arguments passed, the result is unspecified.]]></haxe_doc>
		<meta><m n=":coreApi"/></meta>
		<impl><class path="haxe._Rest.Rest_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Rest.hx" private="1" module="haxe.Rest" final="1"><meta>
	<m n=":keep"/>
	<m n=":coreApi"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.Serializer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" expr="false" line="57" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set `USE_CACHE` to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of `Serializer` by
		setting their `useCache` field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" expr="false" line="69" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of `Serializer` by
		setting their `useEnumIndex` field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="71" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<BASE64_CODES expr="null" line="72" static="1">
			<x path="Null"><x path="Null"><x path="haxe.ds.Vector"><x path="Null"><x path="Int"/></x></x></x></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</BASE64_CODES>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See `USE_CACHE` for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See `USE_ENUM_INDEX` for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="118">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		https://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="154"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="174"><f a="v">
	<d/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="211"><f a="v">
	<a/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="229">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

	All haxe-defined values and objects with the exception of functions can
	be serialized. Serialization of external/native objects is not
	guaranteed to work.

	The values of `this.useCache` and `this.useEnumIndex` may affect
	serialization output.</haxe_doc>
		</serialize>
		<__getField get="inline" set="null" line="557"><f a="o:f">
	<d/>
	<c path="String"/>
	<d/>
</f></__getField>
		<new public="1" set="method" line="103">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each `Serializer` instance maintains its own cache if `this.useCache` is
		`true`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The Serializer class can be used to encode values and objects into a `String`,
	from which the `Unserializer` class can recreate the original representation.

	This class can be used in two ways:

	- create a `new Serializer()` instance, call its `serialize()` method with
		any argument and finally retrieve the String representation from
		`toString()`
	- call `Serializer.run()` to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/std-serialization-format.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe._Unserializer.DefaultResolver" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Unserializer.hx" private="1" module="haxe.Unserializer">
		<resolveClass public="1" get="inline" set="null" line="515"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></resolveClass>
		<resolveEnum public="1" get="inline" set="null" line="518"><f a="name">
	<c path="String"/>
	<x path="Enum"><d/></x>
</f></resolveEnum>
		<new public="1" set="method" line="512"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Unserializer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" expr="new DefaultResolver()" line="67" static="1">
			<t path="haxe.TypeResolver"/>
			<meta><m n=":value"><e>new DefaultResolver()</e></m></meta>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a `Class` or `Enum` instance from a given `String`.
		By default, the Haxe `Type` Api is used.

		A type resolver must provide two methods:

		1. `resolveClass(name:String):Class<Dynamic>` is called to determine a
				`Class` from a class name
		2. `resolveEnum(name:String):Enum<Dynamic>` is called to determine an
				`Enum` from an enum name

		This value is applied when a new `Unserializer` instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="69" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<CODES expr="null" line="72" static="1">
			<x path="Null"><x path="Null"><c path="Array"><x path="Int"/></c></x></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</CODES>
		<initCodes set="method" line="74" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<fastLength get="inline" set="null" line="478" static="1"><f a="s">
	<c path="String"/>
	<x path="Int"/>
</f></fastLength>
		<fastCharAt get="inline" set="null" line="494" static="1"><f a="s:pos">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></fastCharAt>
		<fastSubstr get="inline" set="null" line="502" static="1"><f a="s:pos:length">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></fastSubstr>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<get get="inline" set="null" line="142"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<readDigits set="method" line="150"><f a=""><x path="Int"/></f></readDigits>
		<readFloat set="method" line="175"><f a=""><x path="Float"/></f></readFloat>
		<unserializeObject set="method" line="190"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum params="T" set="method" line="205"><f a="edecl:tag">
	<x path="Enum"><c path="unserializeEnum.T"/></x>
	<c path="String"/>
	<c path="unserializeEnum.T"/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="237">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different Haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from `Type.createEmptyInstance`, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="101">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The `Unserializer` class is the complement to the `Serializer` class. It parses
	a serialization `String` and creates objects from the contained data.

	This class can be used in two ways:

	- create a `new Unserializer()` instance with a given serialization
		String, then call its `unserialize()` method until all values are
		extracted
	- call `Unserializer.run()`  to unserialize a single value from a given
		String

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/serialization/format>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ValueException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<unwrap set="method" line="35" override="1">
			<f a=""><x path="Any"/></f>
			<haxe_doc>Extract an originally thrown value.

		This method must return the same value on subsequent calls.
		Used internally for catching non-native exceptions.
		Do _not_ override unless you know what you are doing.</haxe_doc>
		</unwrap>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Md5" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/crypto/Md5.hx">
		<encode public="1" set="method" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<str2blks set="method" line="120" static="1"><f a="str">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<bitOR set="method" line="57"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitOR>
		<bitXOR set="method" line="63"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitXOR>
		<bitAND set="method" line="69"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitAND>
		<addme set="method" line="75"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></addme>
		<hex set="method" line="81"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<rol set="method" line="154"><f a="num:cnt">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></rol>
		<cmn set="method" line="158"><f a="q:a:b:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></cmn>
		<ff set="method" line="162"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ff>
		<gg set="method" line="166"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gg>
		<hh set="method" line="170"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hh>
		<ii set="method" line="174"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ii>
		<doEncode set="method" line="178"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<new set="method" line="55"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a MD5 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.ArraySort" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/ArraySort.hx">
		<sort public="1" params="T" set="method" line="42" static="1">
			<f a="a:cmp">
				<c path="Array"><c path="sort.T"/></c>
				<f a=":">
					<c path="sort.T"/>
					<c path="sort.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
		`cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
		negative Int if `x < y`.

		This operation modifies Array `a` in place.

		This operation is stable: The order of equal elements is preserved.

		If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec params="T" set="method" line="46" static="1"><f a="a:cmp:from:to">
	<c path="Array"><c path="rec.T"/></c>
	<f a=":">
		<c path="rec.T"/>
		<c path="rec.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge params="T" set="method" line="68" static="1"><f a="a:cmp:from:pivot:to:len1:len2">
	<c path="Array"><c path="doMerge.T"/></c>
	<f a=":">
		<c path="doMerge.T"/>
		<c path="doMerge.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate params="T" set="method" line="94" static="1"><f a="a:cmp:from:mid:to">
	<c path="Array"><c path="rotate.T"/></c>
	<f a=":">
		<c path="rotate.T"/>
		<c path="rotate.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd set="method" line="115" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper params="T" set="method" line="124" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="upper.T"/></c>
	<f a=":">
		<c path="upper.T"/>
		<c path="upper.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower params="T" set="method" line="139" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="lower.T"/></c>
	<f a=":">
		<c path="lower.T"/>
		<c path="lower.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap params="T" set="method" line="153" static="1"><f a="a:i:j">
	<c path="Array"><c path="swap.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<compare params="T" get="inline" set="null" line="159" static="1"><f a="a:cmp:i:j">
	<c path="Array"><c path="compare.T"/></c>
	<f a=":">
		<c path="compare.T"/>
		<c path="compare.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></compare>
		<haxe_doc>ArraySort provides a stable implementation of merge sort through its `sort`
	method. It should be used instead of `Array.sort` in cases where the order
	of equal elements has to be retained on all targets.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/BalancedTree.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.BalancedTree.K"/>
			<c path="haxe.ds.BalancedTree.V"/>
		</implements>
		<iteratorLoop params="K:V" set="method" line="172" static="1"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="iteratorLoop.K"/>
		<c path="iteratorLoop.V"/>
	</c>
	<c path="Array"><c path="iteratorLoop.V"/></c>
	<x path="Void"/>
</f></iteratorLoop>
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.

		If `key` is already bound to a value, that binding disappears.

		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Null"><c path="haxe.ds.BalancedTree.V"/></x>
			</f>
			<haxe_doc>Returns the value `key` is bound to.

		If `key` is not bound to any value, `null` is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<remove public="1" set="method" line="85">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the current binding of `key`.

		If `key` has no binding, `this` BalancedTree is unchanged and false is
		returned.

		Otherwise the binding of `key` is removed and true is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="101">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `key` is bound to a value.

		This method returns true even if `key` is bound to null.

		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<iterator public="1" set="method" line="120">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.V"/></t></f>
			<haxe_doc>Iterates over the bound values of `this` BalancedTree.

		This operation is performed in-order.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="129">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<keys public="1" set="method" line="138">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.K"/></t></f>
			<haxe_doc>Iterates over the keys of `this` BalancedTree.

		This operation is performed in-order.</haxe_doc>
		</keys>
		<copy public="1" set="method" line="144"><f a=""><c path="haxe.ds.BalancedTree">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></f></copy>
		<setLoop set="method" line="150"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<removeLoop set="method" line="163"><f a="k:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeLoop>
		<keysLoop set="method" line="180"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.K"/></c>
	<x path="Void"/>
</f></keysLoop>
		<merge set="method" line="188"><f a="t1:t2">
	<x path="Null"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></x>
	<x path="Null"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></x>
	<x path="Null"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></x>
</f></merge>
		<minBinding set="method" line="197"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></minBinding>
		<removeMinBinding set="method" line="201"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeMinBinding>
		<balance set="method" line="205"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="225"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<clear public="1" set="method" line="236">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all keys from `this` BalancedTree.</haxe_doc>
		</clear>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.

	Operations have a logarithmic average and worst-case cost.

	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<get_height public="1" get="inline" set="null" line="264"><f a=""><x path="Int"/></f></get_height>
		<new public="1" set="method" line="252">
			<f a="l:k:v:r:?h" v="::::-1">
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<c path="haxe.ds.TreeNode.K"/>
				<c path="haxe.ds.TreeNode.V"/>
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1 }</e></m></meta>
		</new>
		<haxe_doc>A tree node of `haxe.ds.BalancedTree`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="haxe.IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="32" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="57"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compareArg set="method" line="69"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compareArg>
		<copy public="1" set="method" line="79" override="1"><f a=""><c path="haxe.ds.EnumValueMap">
	<c path="haxe.ds.EnumValueMap.K"/>
	<c path="haxe.ds.EnumValueMap.V"/>
</c></f></copy>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.

	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.GenericCell" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/GenericStack.hx" module="haxe.ds.GenericStack">
		<elt public="1"><c path="haxe.ds.GenericCell.T"/></elt>
		<next public="1"><c path="haxe.ds.GenericCell"><c path="haxe.ds.GenericCell.T"/></c></next>
		<new public="1" set="method" line="37"><f a="elt:next">
	<c path="haxe.ds.GenericCell.T"/>
	<c path="haxe.ds.GenericCell"><c path="haxe.ds.GenericCell.T"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>A cell of `haxe.ds.GenericStack`.

	@see https://haxe.org/manual/std-GenericStack.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.GenericStack" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/GenericStack.hx">
		<head public="1"><c path="haxe.ds.GenericCell"><c path="haxe.ds.GenericStack.T"/></c></head>
		<add public="1" get="inline" set="null" line="112">
			<f a="item">
				<c path="haxe.ds.GenericStack.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Pushes element `item` onto the stack.</haxe_doc>
		</add>
		<pop public="1" get="inline" set="null" line="130">
			<f a=""><x path="Null"><c path="haxe.ds.GenericStack.T"/></x></f>
			<haxe_doc>Returns the topmost stack element and removes it.

		If the stack is empty, null is returned.</haxe_doc>
		</pop>
		<isEmpty public="1" get="inline" set="null" line="143">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tells if the stack is empty.</haxe_doc>
		</isEmpty>
		<new public="1" set="method" line="107">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty GenericStack.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[A stack of elements.

	This class is generic, which means one type is generated for each type
	parameter T on static targets. For example:

	- `new GenericStack<Int>()` generates `GenericStack_Int`
	- `new GenericStack<String>()` generates `GenericStack_String`

	The generated name is an implementation detail and should not be relied
	upon.

	@see https://haxe.org/manual/std-GenericStack.html]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.IntMap" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/ds/IntMap.hx">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h><d/></h>
		<set public="1" get="inline" set="null" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="36">
			<f a="key">
				<x path="Int"/>
				<x path="Null"><c path="haxe.ds.IntMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="40">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="44">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="51">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="57">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="71">
			<f a=""><t path="KeyValueIterator">
	<x path="Int"/>
	<c path="haxe.ds.IntMap.T"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method" line="75">
			<f a=""><c path="haxe.ds.IntMap"><c path="haxe.ds.IntMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<clear public="1" get="inline" set="null" line="97">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" get="inline" set="null" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.List" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/List.hx">
		<h><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></h>
		<q><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="53">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<iterator public="1" get="inline" set="null" line="160">
			<f a=""><c path="haxe.ds._List.ListIterator"><c path="haxe.ds.List.T"/></c></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<new public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds._List.ListNode" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<create public="1" params="T" get="inline" set="null" line="271" static="1"><f a="item:next">
	<c path="create.T"/>
	<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
	<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
</f></create>
		<item public="1"><c path="haxe.ds._List.ListNode.T"/></item>
		<next public="1"><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></next>
		<new public="1" set="method" line="266"><f a="item:next">
	<c path="haxe.ds._List.ListNode.T"/>
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds._List.ListIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<head><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListIterator.T"/></c></head>
		<hasNext public="1" get="inline" set="null" line="284"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="288"><f a=""><c path="haxe.ds._List.ListIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="280"><f a="head">
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta>
			<m n=":transitive"/>
			<m n=":multiType"><e>@:followWithAbstracts K</e></m>
		</meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
	<_new public="1" set="method" static="1">
		<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
	</_new>
	<set public="1" get="inline" set="null" line="74" static="1">
		<f a="this:key:value">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<c path="haxe.ds.Map.V"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Maps `key` to `value`.

		If `key` already has a mapping, the previous value disappears.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</set>
	<get public="1" get="inline" set="null" line="92" static="1">
		<f a="this:key">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<x path="Null"><c path="haxe.ds.Map.V"/></x>
		</f>
		<meta><m n=":arrayAccess"/></meta>
		<haxe_doc>Returns the current mapping of `key`.

		If no such mapping exists, `null` is returned.

		Note that a check like `map.get(key) == null` can hold for two reasons:

		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`

		If it is important to distinguish these cases, `exists()` should be
		used.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</get>
	<exists public="1" get="inline" set="null" line="100" static="1">
		<f a="this:key">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Returns true if `key` has a mapping, false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</exists>
	<remove public="1" get="inline" set="null" line="109" static="1">
		<f a="this:key">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</remove>
	<keys public="1" get="inline" set="null" line="116" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<t path="Iterator"><c path="haxe.ds.Map.K"/></t>
		</f>
		<haxe_doc>Returns an Iterator over the keys of `this` Map.

		The order of keys is undefined.</haxe_doc>
	</keys>
	<iterator public="1" get="inline" set="null" line="125" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<t path="Iterator"><c path="haxe.ds.Map.V"/></t>
		</f>
		<haxe_doc>Returns an Iterator over the values of `this` Map.

		The order of values is undefined.</haxe_doc>
	</iterator>
	<keyValueIterator public="1" get="inline" set="null" line="134" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<t path="KeyValueIterator">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</t>
		</f>
		<haxe_doc>Returns an Iterator over the keys and values of `this` Map.

		The order of values is undefined.</haxe_doc>
	</keyValueIterator>
	<copy public="1" get="inline" set="null" line="143" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<x path="haxe.ds.Map">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</x>
		</f>
		<haxe_doc>Returns a shallow copy of `this` map.

		The order of values is undefined.</haxe_doc>
	</copy>
	<clear public="1" get="inline" set="null" line="159" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<x path="Void"/>
		</f>
		<haxe_doc>Removes all keys from `this` Map.</haxe_doc>
	</clear>
	<toStringMap params="K:V" get="inline" set="null" line="168" static="1">
		<f a="t">
			<c path="haxe.IMap">
				<c path="toStringMap.K"/>
				<c path="toStringMap.V"/>
			</c>
			<c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c>
		</f>
		<meta>
			<m n=":multiType"/>
			<m n=":to"/>
		</meta>
	</toStringMap>
	<toIntMap params="K:V" get="inline" set="null" line="172" static="1">
		<f a="t">
			<c path="haxe.IMap">
				<c path="toIntMap.K"/>
				<c path="toIntMap.V"/>
			</c>
			<c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c>
		</f>
		<meta>
			<m n=":multiType"/>
			<m n=":to"/>
		</meta>
	</toIntMap>
	<fromStringMap params="V" get="inline" set="null" line="184" static="1">
		<f a="map">
			<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="fromStringMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromStringMap>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/ds/ObjectMap.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<assignId get="inline" set="null" line="31" static="1"><f a="obj">
	<a/>
	<x path="Int"/>
</f></assignId>
		<getId get="inline" set="null" line="35" static="1">
			<f a="obj">
				<a/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getId>
		<h><a><__keys__><a/></__keys__></a></h>
		<set public="1" set="method" line="45">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="54">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.V"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="58">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="62">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="71">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="82">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="96">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method" line="100">
			<f a=""><c path="haxe.ds.ObjectMap">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<clear public="1" get="inline" set="null" line="122">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<createCopy params="T" set="method" line="82" static="1"><f a="h">
	<d/>
	<c path="haxe.ds.StringMap"><c path="createCopy.T"/></c>
</f></createCopy>
		<h><d/></h>
		<exists public="1" get="inline" set="null" line="37">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<get public="1" get="inline" set="null" line="41">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="45">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<remove public="1" get="inline" set="null" line="49">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="57">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" get="inline" set="null" line="61">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="65">
			<f a=""><t path="KeyValueIterator">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" get="inline" set="null" line="69">
			<f a=""><c path="haxe.ds.StringMap"><c path="haxe.ds.StringMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<clear public="1" get="inline" set="null" line="73">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" get="inline" set="null" line="33">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds._StringMap.StringMapKeyIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap">
		<h final="1"><d/></h>
		<keys final="1"><c path="Array"><c path="String"/></c></keys>
		<length final="1"><x path="Int"/></length>
		<current><x path="Int"/></current>
		<hasNext public="1" get="inline" set="null" line="112"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="116"><f a=""><c path="String"/></f></next>
		<new public="1" get="inline" set="null" line="105"><f a="h">
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds._StringMap.StringMapValueIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap">
		<h final="1"><d/></h>
		<keys final="1"><c path="Array"><c path="String"/></c></keys>
		<length final="1"><x path="Int"/></length>
		<current><x path="Int"/></current>
		<hasNext public="1" get="inline" set="null" line="134"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="138"><f a=""><c path="haxe.ds._StringMap.StringMapValueIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="127"><f a="h">
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds._StringMap.StringMapKeyValueIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap">
		<h final="1"><d/></h>
		<keys final="1"><c path="Array"><c path="String"/></c></keys>
		<length final="1"><x path="Int"/></length>
		<current><x path="Int"/></current>
		<hasNext public="1" get="inline" set="null" line="156"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="160"><f a=""><a>
	<value><c path="haxe.ds._StringMap.StringMapKeyValueIterator.T"/></value>
	<key><c path="String"/></key>
</a></f></next>
		<new public="1" get="inline" set="null" line="149"><f a="h">
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="Array"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1">
	<_new public="1" get="inline" set="null" line="64" static="1">
		<f a="length">
			<x path="Int"/>
			<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
		</f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new Vector of length `length`.

		Initially `this` Vector contains `length` neutral elements:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
		<overloads><_new public="1" get="inline" set="null" line="96">
	<f a="length:defaultValue">
		<x path="Int"/>
		<c path="haxe.ds.Vector.T"/>
		<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
	</f>
	<meta><m n=":noCompletion"/></meta>
	<haxe_doc>Creates a new Vector of length `length` filled with `defaultValue` elements.

		Can be faster than `new Vector(length)` for iteration on some targets for non-nullable elements.

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
</_new></overloads>
	</_new>
	<get public="1" get="inline" set="null" line="132" static="1">
		<f a="this:index">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<x path="Int"/>
			<c path="haxe.ds.Vector.T"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
		<haxe_doc>Returns the value at index `index`.

		If `index` is negative or exceeds `this.length`, the result is
		unspecified.</haxe_doc>
	</get>
	<set public="1" get="inline" set="null" line="150" static="1">
		<f a="this:index:val">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<x path="Int"/>
			<c path="haxe.ds.Vector.T"/>
			<c path="haxe.ds.Vector.T"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
		<haxe_doc>Sets the value at index `index` to `val`.

		If `index` is negative or exceeds `this.length`, the result is
		unspecified.</haxe_doc>
	</set>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
	</length>
	<get_length get="inline" set="null" line="167" static="1">
		<f a="this">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<x path="Int"/>
		</f>
		<meta><m n=":has_untyped"/></meta>
	</get_length>
	<blit public="1" params="T" set="method" line="194" static="1">
		<f a="src:srcPos:dest:destPos:len">
			<x path="haxe.ds.Vector"><c path="blit.T"/></x>
			<x path="Int"/>
			<x path="haxe.ds.Vector"><c path="blit.T"/></x>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Copies `length` of elements from `src` Vector, beginning at `srcPos` to
		`dest` Vector, beginning at `destPos`

		The results are unspecified if `length` results in out-of-bounds access,
		or if `src` or `dest` are null</haxe_doc>
	</blit>
	<copy public="1" params="T" get="inline" set="null" line="318" static="1">
		<f a="this">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<x path="haxe.ds.Vector"><c path="copy.T"/></x>
		</f>
		<haxe_doc>Returns a shallow copy of `this` Vector.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
	</copy>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.ds._Vector.Vector_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1">
		<_new public="1" get="inline" set="null" line="64" static="1">
			<f a="length">
				<x path="Int"/>
				<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new Vector of length `length`.

		Initially `this` Vector contains `length` neutral elements:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
			<overloads><_new public="1" get="inline" set="null" line="96">
	<f a="length:defaultValue">
		<x path="Int"/>
		<c path="haxe.ds.Vector.T"/>
		<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
	</f>
	<meta><m n=":noCompletion"/></meta>
	<haxe_doc>Creates a new Vector of length `length` filled with `defaultValue` elements.

		Can be faster than `new Vector(length)` for iteration on some targets for non-nullable elements.

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
</_new></overloads>
		</_new>
		<get public="1" get="inline" set="null" line="132" static="1">
			<f a="this:index">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<x path="Int"/>
				<c path="haxe.ds.Vector.T"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
			<haxe_doc>Returns the value at index `index`.

		If `index` is negative or exceeds `this.length`, the result is
		unspecified.</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="150" static="1">
			<f a="this:index:val">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<x path="Int"/>
				<c path="haxe.ds.Vector.T"/>
				<c path="haxe.ds.Vector.T"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
			<haxe_doc>Sets the value at index `index` to `val`.

		If `index` is negative or exceeds `this.length`, the result is
		unspecified.</haxe_doc>
		</set>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="167" static="1">
			<f a="this">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</get_length>
		<blit public="1" params="T" set="method" line="194" static="1">
			<f a="src:srcPos:dest:destPos:len">
				<x path="haxe.ds.Vector"><c path="blit.T"/></x>
				<x path="Int"/>
				<x path="haxe.ds.Vector"><c path="blit.T"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies `length` of elements from `src` Vector, beginning at `srcPos` to
		`dest` Vector, beginning at `destPos`

		The results are unspecified if `length` results in out-of-bounds access,
		or if `src` or `dest` are null</haxe_doc>
		</blit>
		<copy public="1" params="T" get="inline" set="null" line="318" static="1">
			<f a="this">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<x path="haxe.ds.Vector"><c path="copy.T"/></x>
			</f>
			<haxe_doc>Returns a shallow copy of `this` Vector.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.exceptions.PosException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/exceptions/PosException.hx">
		<extends path="haxe.Exception"/>
		<posInfos final="1" public="1">
			<t path="haxe.PosInfos"/>
			<haxe_doc>Position where this exception was created.</haxe_doc>
		</posInfos>
		<toString public="1" set="method" line="24" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<new public="1" set="method" line="12"><f a="message:?previous:?pos">
	<c path="String"/>
	<c path="haxe.Exception"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception that carry position information of a place where it was created.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.exceptions.NotImplementedException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/exceptions/NotImplementedException.hx">
		<extends path="haxe.exceptions.PosException"/>
		<new public="1" set="method" line="7">
			<f a="?message:?previous:?pos" v="&quot;Not implemented&quot;::">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : "Not implemented" }</e></m></meta>
		</new>
		<haxe_doc>An exception that is thrown when requested function or operation does not have an implementation.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</to>
		<haxe_doc><![CDATA[An abstract type allowing values to be either of `T1` or `T2` type.
	Supports implicit casts from/to either types.

	It is useful for interfacing with external code on dynamic platforms
	such as JavaScript or Python.

	Otherwise, use of this type is discouraged.

	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.extern.Rest" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/extern/Rest.hx">
		<x path="haxe.Rest"><c path="haxe.extern.Rest.T"/></x>
		<haxe_doc><![CDATA[DEPRECATED: use haxe.Rest instead.
	
	A special type that represents "rest" function argument.
	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.
	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
	</typedef>
	<typedef path="haxe.io.ArrayBufferViewData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView"><c path="js.lib.ArrayBufferView"/></typedef>
	<abstract path="haxe.io.ArrayBufferView" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/io/ArrayBufferView.hx">
		<this><t path="haxe.io.ArrayBufferViewData"/></this>
		<impl><class path="haxe.io._ArrayBufferView.ArrayBufferView_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/io/ArrayBufferView.hx" private="1" module="haxe.io.ArrayBufferView" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.io.Bytes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/io/Bytes.hx">
		<alloc public="1" get="inline" set="null" line="202" static="1">
			<f a="length">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns a new `Bytes` instance with the given `length`. The values of the
		bytes are not initialized and may not be zero.</haxe_doc>
		</alloc>
		<ofString public="1" set="method" line="206" static="1">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns the `Bytes` representation of the given `String`, using the
		specified encoding (UTF-8 by default).</haxe_doc>
		</ofString>
		<ofHex public="1" set="method" line="250" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Converts the given hexadecimal `String` to `Bytes`. `s` must be a string of
		even length consisting only of hexadecimal digits. For example:
		`"0FDA14058916052309"`.</haxe_doc>
		</ofHex>
		<length public="1" set="null"><x path="Int"/></length>
		<b><c path="js.lib.Uint8Array"/></b>
		<get public="1" get="inline" set="null" line="42">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the byte at index `pos`.</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="46">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores the given byte `v` at the given position `pos`.</haxe_doc>
		</set>
		<getString public="1" set="method" line="134">
			<f a="pos:len:?encoding">
				<x path="Int"/>
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the `len`-bytes long string stored at the given position `pos`,
		interpreted with the given `encoding` (UTF-8 by default).</haxe_doc>
		</getString>
		<toString public="1" set="method" line="180">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a `String` representation of the bytes interpreted as UTF-8.</haxe_doc>
		</toString>
		<getData public="1" get="inline" set="null" line="198">
			<f a=""><t path="haxe.io.BytesData"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the bytes of `this` instance as `BytesData`.</haxe_doc>
		</getData>
		<new set="method" line="32">
			<f a="data">
				<t path="haxe.io.BytesData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/io/BytesBuffer.hx">
		<buffer><c path="js.lib.ArrayBuffer"/></buffer>
		<view><c path="js.lib.DataView"/></view>
		<u8><c path="js.lib.Uint8Array"/></u8>
		<pos><x path="Int"/></pos>
		<size><x path="Int"/></size>
		<addBytes public="1" set="method" line="93"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<grow set="method" line="105"><f a="delta">
	<x path="Int"/>
	<x path="Void"/>
</f></grow>
		<getBytes public="1" set="method" line="120">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer should no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/BytesData.hx"><c path="js.lib.ArrayBuffer"/></typedef>
	<enum path="haxe.io.Encoding" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Encoding.hx">
		<UTF8/>
		<RawNative><haxe_doc>Output the string the way the platform represent it in memory. This is the most efficient but is platform-specific</haxe_doc></RawNative>
		<haxe_doc>String binary encoding supported by Haxe I/O</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.io.Eof" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="32">
			<f a=""><c path="String"/></f>
			<meta><m n=":ifFeature"><e>"haxe.io.Eof.*"</e></m></meta>
		</toString>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="js.lib.ArrayBuffer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/ArrayBuffer.hx" extern="1">
		<isView public="1" set="method" static="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></isView>
		<byteLength final="1" public="1"><x path="Int"/></byteLength>
		<slice public="1" set="method"><f a="begin:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.lib.ArrayBuffer"/>
</f></slice>
		<new public="1" set="method">
			<f a="length">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"ArrayBuffer"</e></m>
		</meta>
	</class>
	<class path="js.lib.ArrayBufferView" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/ArrayBufferView.hx" extern="1" interface="1">
		<buffer final="1" public="1"><c path="js.lib.ArrayBuffer"/></buffer>
		<byteOffset final="1" public="1"><x path="Int"/></byteOffset>
		<byteLength final="1" public="1"><x path="Int"/></byteLength>
		<haxe_doc><![CDATA[`ArrayBufferView` is a helper type representing any of the following JavaScript `TypedArray` types:

	Documentation [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).

	@see <https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView>]]></haxe_doc>
	</class>
	<class path="js.lib.DataView" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/DataView.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<buffer final="1" public="1"><c path="js.lib.ArrayBuffer"/></buffer>
		<byteOffset final="1" public="1"><x path="Int"/></byteOffset>
		<byteLength final="1" public="1"><x path="Int"/></byteLength>
		<getInt8 public="1" set="method"><f a="byteOffset">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt8>
		<getUint8 public="1" set="method"><f a="byteOffset">
	<x path="Int"/>
	<x path="Int"/>
</f></getUint8>
		<getInt16 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getInt16>
		<getUint16 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getUint16>
		<getInt32 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getInt32>
		<getUint32 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getUint32>
		<getFloat32 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></getFloat32>
		<getFloat64 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></getFloat64>
		<setInt8 public="1" set="method"><f a="byteOffset:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt8>
		<setUint8 public="1" set="method"><f a="byteOffset:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setUint8>
		<setInt16 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setInt16>
		<setUint16 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setUint16>
		<setInt32 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setInt32>
		<setUint32 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setUint32>
		<setFloat32 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setFloat32>
		<setFloat64 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setFloat64>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?byteLength">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"DataView"</e></m>
		</meta>
	</class>
	<class path="haxe.io.Path" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Path.hx">
		<addTrailingSlash public="1" set="method" line="271" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

		If the last slash in `path` is a backslash, a backslash is appended to
		`path`.

		If the last slash in `path` is a slash, or if no slash is found, a slash
		is appended to `path`. In particular, this applies to the empty String
		`""`.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- `directory1/directory2/filename.extension`
	- `directory1\directory2\filename.extension`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.UInt8ArrayData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/io/UInt8Array.hx" module="haxe.io.UInt8Array"><c path="js.lib.Uint8Array"/></typedef>
	<abstract path="haxe.io.UInt8Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/io/UInt8Array.hx">
		<this><t path="haxe.io.UInt8ArrayData"/></this>
		<meta><m n=":coreApi"/></meta>
		<impl><class path="haxe.io._UInt8Array.UInt8Array_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/_std/haxe/io/UInt8Array.hx" private="1" module="haxe.io.UInt8Array" final="1"><meta>
	<m n=":keep"/>
	<m n=":coreApi"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.iterators.ArrayIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="44">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.iterators.DynamicAccessKeyValueIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/iterators/DynamicAccessKeyValueIterator.hx">
		<access final="1"><x path="haxe.DynamicAccess"><c path="haxe.iterators.DynamicAccessKeyValueIterator.T"/></x></access>
		<keys final="1"><c path="Array"><c path="String"/></c></keys>
		<index><x path="Int"/></index>
		<hasNext public="1" get="inline" set="null" line="42">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="49">
			<f a=""><a>
	<value><c path="haxe.iterators.DynamicAccessKeyValueIterator.T"/></value>
	<key><c path="String"/></key>
</a></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="33"><f a="access">
	<x path="haxe.DynamicAccess"><c path="haxe.iterators.DynamicAccessKeyValueIterator.T"/></x>
	<x path="Void"/>
</f></new>
		<haxe_doc>This Key/Value iterator can be used to iterate over `haxe.DynamicAccess`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.iterators.MapKeyValueIterator" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/iterators/MapKeyValueIterator.hx">
		<map><c path="haxe.IMap">
	<c path="haxe.iterators.MapKeyValueIterator.K"/>
	<c path="haxe.iterators.MapKeyValueIterator.V"/>
</c></map>
		<keys><t path="Iterator"><c path="haxe.iterators.MapKeyValueIterator.K"/></t></keys>
		<hasNext public="1" get="inline" set="null" line="43">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="50">
			<f a=""><a>
	<value><c path="haxe.iterators.MapKeyValueIterator.V"/></value>
	<key><c path="haxe.iterators.MapKeyValueIterator.K"/></key>
</a></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35"><f a="map">
	<c path="haxe.IMap">
		<c path="haxe.iterators.MapKeyValueIterator.K"/>
		<c path="haxe.iterators.MapKeyValueIterator.V"/>
	</c>
	<x path="Void"/>
</f></new>
		<haxe_doc>This Key/Value iterator can be used to iterate across maps.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":ifFeature">
				<e>"anon_read.keyValueIterator"</e>
				<e>"dynamic_read.keyValueIterator"</e>
			</m>
		</meta>
	</class>
	<class path="haxe.iterators.StringIteratorUnicode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/iterators/StringIteratorUnicode.hx">
		<offset expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offset>
		<s><c path="String"/></s>
		<hasNext public="1" get="inline" set="null" line="47">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="55">
			<f a=""><x path="Int"/></f>
			<meta><m n=":access"><e>StringTools</e></m></meta>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="40">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `StringIteratorUnicode` over String `s`.</haxe_doc>
		</new>
		<haxe_doc>This iterator can be used to iterate across strings in a cross-platform
	way. It handles surrogate pairs on platforms that require it. On each
	iteration, it returns the next character code.

	Note that this has different semantics than a standard for-loop over the
	String's length due to the fact that it deals with surrogate pairs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.macro.Position" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<min>
				<x path="Int"/>
				<haxe_doc>Position of the first character.</haxe_doc>
			</min>
			<max>
				<x path="Int"/>
				<haxe_doc>Position of the last character.</haxe_doc>
			</max>
			<file>
				<c path="String"/>
				<haxe_doc>Reference to the filename.</haxe_doc>
			</file>
		</a>
		<haxe_doc>Represents a position in a file.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Expr" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.ExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a node in the AST.
	@see https://haxe.org/manual/macro-reification-expression.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<t path="haxe.macro.Expr"/>
		<haxe_doc>Represents a AST node identical to `Expr`, but it allows constraining the
	type of accepted expressions.
	@see https://haxe.org/manual/macro-ExprOf.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Case" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<values>
				<c path="Array"><t path="haxe.macro.Expr"/></c>
				<haxe_doc>The value expressions of the case.</haxe_doc>
			</values>
			<guard>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional guard expressions of the case, if available.</haxe_doc>
			</guard>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the case, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a switch case.
	@see https://haxe.org/manual/expression-switch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Var" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type-hint of the variable, if available.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Metadata associatied with the variable, if available.</haxe_doc>
			</meta>
			<isStatic>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the variable is static.</haxe_doc>
			</isStatic>
			<isFinal>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the variable can be assigned to.</haxe_doc>
			</isFinal>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the variable, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a variable in the AST.
	@see https://haxe.org/manual/expression-var.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Catch" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type of the catch.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the catch variable.</haxe_doc>
			</name>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The expression of the catch.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a catch in the AST.
	@see https://haxe.org/manual/expression-try-catch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ObjectField" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<quotes>
				<x path="Null"><e path="haxe.macro.QuoteStatus"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>How the field name is quoted.</haxe_doc>
			</quotes>
			<field>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</field>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The field expression.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents the field of an object declaration.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypePath" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<sub>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sub is set on module sub-type access:
		`pack.Module.Type` has `name = "Module"`, `sub = "Type"`, if available.</haxe_doc>
			</sub>
			<params>
				<x path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional parameters of the type path.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Represents the package of the type path.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type path.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a type path in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the type parameter.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the type parameter.</haxe_doc>
			</meta>
			<defaultType>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional default type of the type parameter.</haxe_doc>
			</defaultType>
			<constraints>
				<x path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional constraints of the type parameter.</haxe_doc>
			</constraints>
		</a>
		<haxe_doc>Represents a type parameter declaration in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Function" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<ret>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The return type-hint of the function, if available.</haxe_doc>
			</ret>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of function parameter type declarations.</haxe_doc>
			</params>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the function body, if available.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><t path="haxe.macro.FunctionArg"/></c>
				<haxe_doc>A list of function arguments.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<value>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional value of the function argument, if available.</haxe_doc>
			</value>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type-hint of the function argument, if available.</haxe_doc>
			</type>
			<opt>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the function argument is optional.</haxe_doc>
			</opt>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function argument.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the function argument.</haxe_doc>
			</meta>
		</a>
		<haxe_doc>Represents a function argument in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the metadata entry.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the metadata entry.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the metadata entry.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a metadata entry in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
		<haxe_doc>Represents metadata in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Field" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the field.</haxe_doc>
			</pos>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldType"/>
				<haxe_doc>The kind of the field.</haxe_doc>
			</kind>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the field, if available. If the field has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
			<access>
				<x path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access modifiers of the field. By default fields have private access.
		@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
			</access>
		</a>
		<haxe_doc>Represents a field in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position to the type definition.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The parameter type declarations of the type definition.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type definition.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type definition.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the type definition.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.TypeDefKind"/>
				<haxe_doc>The kind of the type definition.</haxe_doc>
			</kind>
			<isExtern>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<fields>
				<c path="Array"><t path="haxe.macro.Field"/></c>
				<haxe_doc>The fields of the type definition.</haxe_doc>
			</fields>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the type, if available. If the type has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a type definition.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<path>
				<c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c>
				<haxe_doc>The path to the import expression.</haxe_doc>
			</path>
			<mode>
				<e path="haxe.macro.ImportMode"/>
				<haxe_doc>The mode of the import expression.</haxe_doc>
			</mode>
		</a>
		<haxe_doc>Represents the import expression.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Ref" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<toString set="method"><f a=""><c path="String"/></f></toString>
			<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
		</a>
		<haxe_doc>Represents a reference to internal compiler structure. It exists to avoid
	expensive encoding if it is not required and to ensure that physical
	equality remains intact.

	A structure is only encoded when user requests it through `ref.get()`.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.AnonType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<status>
				<e path="haxe.macro.AnonStatus"/>
				<haxe_doc>The status/kind of the structure.</haxe_doc>
			</status>
			<fields>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The class fields of the structure.</haxe_doc>
			</fields>
		</a>
		<haxe_doc>Represents information for anonymous structure types.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParameter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the type parameter. It is guaranteed to be a `TInst` with a
		`KTypeParameter` kind.</haxe_doc>
			</t>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<defaultType>
				<x path="Null"><e path="haxe.macro.Type"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The default type for this type parameter.</haxe_doc>
			</defaultType>
		</a>
		<haxe_doc>Represents the declaration of type parameters.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ClassField" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the class field.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the class field.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the class field.</haxe_doc>
			</params>
			<overloads>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The overload fields of the class field.</haxe_doc>
			</overloads>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the class field.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the class field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldKind"/>
				<haxe_doc>The class field kind.</haxe_doc>
			</kind>
			<isPublic>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is public.</haxe_doc>
			</isPublic>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is final.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is extern.</haxe_doc>
			</isExtern>
			<isAbstract>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is abstract.</haxe_doc>
			</isAbstract>
			<expr set="method">
				<f a=""><x path="Null"><t path="haxe.macro.TypedExpr"/></x></f>
				<haxe_doc>Returns the typed expression of the class field.</haxe_doc>
			</expr>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a class field.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.EnumField" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the enum constructor.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the enum constructor.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the enum constructor.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the enum constructor.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the enum constructor.</haxe_doc>
			</meta>
			<index>
				<x path="Int"/>
				<haxe_doc>The index of the enum constructor, i.e. in which position it appears
		in the syntax.</haxe_doc>
			</index>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the enum constructor.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents an enum constructor.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.BaseType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The information that all types (`ClassType`, `EnumType`, `DefType`,
	`AbstractType`) have in common.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ClassType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<superClass>
				<x path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></x>
				<haxe_doc>The parent class and its type parameters, if available.</haxe_doc>
			</superClass>
			<statics>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The static fields of the class.</haxe_doc>
			</statics>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<overrides>
				<c path="Array"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></c>
				<haxe_doc>The list of fields that have override status.</haxe_doc>
			</overrides>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.ClassKind"/>
				<haxe_doc>The kind of the class.</haxe_doc>
			</kind>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isInterface>
				<x path="Bool"/>
				<haxe_doc>If true the type is an interface, otherwise it is a class.</haxe_doc>
			</isInterface>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>If true the class is final and cannot be extended.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<isAbstract>
				<x path="Bool"/>
				<haxe_doc>If true the class is abstract and cannot be instantiated directly.</haxe_doc>
			</isAbstract>
			<interfaces>
				<c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c>
				<haxe_doc>The implemented interfaces and their type parameters.</haxe_doc>
			</interfaces>
			<init>
				<x path="Null"><t path="haxe.macro.TypedExpr"/></x>
				<haxe_doc>The `__init__` expression of the class, if available.</haxe_doc>
			</init>
			<fields>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The member fields of the class.</haxe_doc>
			</fields>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructor>
				<x path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></x>
				<haxe_doc>The constructor of the class, if available.</haxe_doc>
			</constructor>
		</a>
		<haxe_doc>Represents a class type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.EnumType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<names>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>An ordered list of enum constructor names.</haxe_doc>
			</names>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructs>
				<t path="Map">
					<c path="String"/>
					<t path="haxe.macro.EnumField"/>
				</t>
				<haxe_doc>The available enum constructors.</haxe_doc>
			</constructs>
		</a>
		<haxe_doc>Represents an enum type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.DefType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The target type of the typedef.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a typedef.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.AbstractType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<unops>
				<c path="Array"><a>
	<postFix><x path="Bool"/></postFix>
	<op><e path="haxe.macro.Unop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined unary operators of the abstract.</haxe_doc>
			</unops>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The underlying type of the abstract.</haxe_doc>
			</type>
			<to>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><x path="Null"><t path="haxe.macro.ClassField"/></x></field>
</a></c>
				<haxe_doc>The available implicit to-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</to>
			<resolveWrite>
				<x path="Null"><t path="haxe.macro.ClassField"/></x>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolveWrite>
			<resolve>
				<x path="Null"><t path="haxe.macro.ClassField"/></x>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolve>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<impl>
				<x path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></x>
				<haxe_doc>The implementation class of the abstract, if available.</haxe_doc>
			</impl>
			<from>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><x path="Null"><t path="haxe.macro.ClassField"/></x></field>
</a></c>
				<haxe_doc>The available implicit from-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</from>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<binops>
				<c path="Array"><a>
	<op><e path="haxe.macro.Binop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined binary operators of the abstract.</haxe_doc>
			</binops>
			<array>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The defined array-access fields of the abstract.</haxe_doc>
			</array>
		</a>
		<haxe_doc>Represents an abstract type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<remove set="method">
				<f a="name">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Removes all `name` metadata entries from the origin of `this`
		MetaAccess.

		This method might clear several metadata entries of the same name.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `remove` has no effect on that array.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</remove>
			<has set="method">
				<f a="name">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<haxe_doc>Tells if the origin of `this` MetaAccess has a `name` metadata entry.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</has>
			<get set="method">
				<f a=""><t path="haxe.macro.Metadata"/></f>
				<haxe_doc>Return the wrapped `Metadata` array.

		Modifying this array has no effect on the origin of `this` MetaAccess.
		The `add` and `remove` methods can be used for that.</haxe_doc>
			</get>
			<extract set="method">
				<f a="name">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
				</f>
				<haxe_doc>Extract metadata entries by given `name`.

		If there's no metadata with such name, empty array `[]` is returned.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</extract>
			<add set="method">
				<f a="name:params:pos">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.Expr"/></c>
					<t path="haxe.macro.Position"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Adds the metadata specified by `name`, `params` and `pos` to the origin
		of `this` MetaAccess.

		Metadata names are not unique during compilation, so this method never
		overwrites a previous metadata.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `add` has no effect on that array.

		If any argument is null, compilation fails with an error.</haxe_doc>
			</add>
		</a>
		<haxe_doc>MetaAccess is a wrapper for the `Metadata` array. It can be used to add
	metadata to and remove metadata from its origin.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TVar" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t set="null">
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the variable.</haxe_doc>
			</t>
			<name set="null">
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta set="null">
				<x path="Null"><t path="haxe.macro.MetaAccess"/></x>
				<haxe_doc>The metadata of the variable.</haxe_doc>
			</meta>
			<id set="null">
				<x path="Int"/>
				<haxe_doc>The unique ID of the variable.</haxe_doc>
			</id>
			<extra set="null">
				<x path="Null"><a>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<expr><x path="Null"><t path="haxe.macro.TypedExpr"/></x></expr>
</a></x>
				<haxe_doc>Special information which is internally used to keep track of closure.
		information</haxe_doc>
			</extra>
			<capture set="null">
				<x path="Bool"/>
				<haxe_doc>Whether or not the variable has been captured by a closure.</haxe_doc>
			</capture>
		</a>
		<haxe_doc>Represents a variable in the typed AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TFunc" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The return type of the function.</haxe_doc>
			</t>
			<expr>
				<t path="haxe.macro.TypedExpr"/>
				<haxe_doc>The expression of the function body.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><a>
	<value><x path="Null"><t path="haxe.macro.TypedExpr"/></x></value>
	<v><t path="haxe.macro.TVar"/></v>
</a></c>
				<haxe_doc>A list of function arguments identified by an argument variable `v` and
		an optional initialization `value`.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the typed AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypedExpr" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the expression.</haxe_doc>
			</t>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.TypedExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a typed AST node.</haxe_doc>
	</typedef>
	<typedef path="haxe.rtti.Path" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<c path="String"/>
		<haxe_doc>The (dot-)path of the runtime type.</haxe_doc>
	</typedef>
	<typedef path="haxe.rtti.Platforms" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<c path="Array"><c path="String"/></c>
		<haxe_doc>A list of strings representing the targets where the type is available.</haxe_doc>
	</typedef>
	<typedef path="haxe.rtti.FunctionArgument" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<value>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
			</value>
			<t><e path="haxe.rtti.CType"/></t>
			<opt><x path="Bool"/></opt>
			<name><c path="String"/></name>
		</a>
		<haxe_doc>The function argument runtime type information.</haxe_doc>
	</typedef>
	<enum path="haxe.rtti.CType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx">
		<CUnknown/>
		<CEnum a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="Array"><e path="haxe.rtti.CType"/></c>
		</CEnum>
		<CClass a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="Array"><e path="haxe.rtti.CType"/></c>
		</CClass>
		<CTypedef a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="Array"><e path="haxe.rtti.CType"/></c>
		</CTypedef>
		<CFunction a="args:ret">
			<c path="Array"><t path="haxe.rtti.FunctionArgument"/></c>
			<e path="haxe.rtti.CType"/>
		</CFunction>
		<CAnonymous a="fields"><c path="Array"><t path="haxe.rtti.ClassField"/></c></CAnonymous>
		<CDynamic a="?t"><e path="haxe.rtti.CType"/></CDynamic>
		<CAbstract a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="Array"><e path="haxe.rtti.CType"/></c>
		</CAbstract>
		<haxe_doc>The runtime member types.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="haxe.rtti.PathParams" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<path>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The path of the type.</haxe_doc>
			</path>
			<params>
				<c path="Array"><e path="haxe.rtti.CType"/></c>
				<haxe_doc>The array of parameters types.</haxe_doc>
			</params>
		</a>
		<haxe_doc>The type parameters in the runtime type information.</haxe_doc>
	</typedef>
	<typedef path="haxe.rtti.TypeParams" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<c path="Array"><c path="String"/></c>
		<haxe_doc>An array of strings representing the names of the type parameters the type
	has. As of Haxe 3.2.0, this does not include the constraints.</haxe_doc>
	</typedef>
	<enum path="haxe.rtti.Rights" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<RNormal/>
		<RNo/>
		<RCall a="m"><c path="String"/></RCall>
		<RMethod/>
		<RDynamic/>
		<RInline/>
		<haxe_doc>Represents the runtime rights of a type.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="haxe.rtti.MetaData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<c path="Array"><a>
	<params><c path="Array"><c path="String"/></c></params>
	<name><c path="String"/></name>
</a></c>
		<haxe_doc>The list of runtime metadata.</haxe_doc>
	</typedef>
	<typedef path="haxe.rtti.ClassField" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<type>
				<e path="haxe.rtti.CType"/>
				<haxe_doc>The type of the field.</haxe_doc>
			</type>
			<set>
				<e path="haxe.rtti.Rights"/>
				<haxe_doc>The [write access](https://haxe.org/manual/class-field-property.html#define-write-access)
		behavior of the field.</haxe_doc>
			</set>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the field is available.</haxe_doc>
			</platforms>
			<params>
				<t path="haxe.rtti.TypeParams"/>
				<haxe_doc>An array of strings representing the names of the type parameters
		the field has.</haxe_doc>
			</params>
			<overloads>
				<x path="Null"><c path="Array"><t path="haxe.rtti.ClassField"/></c></x>
				<haxe_doc>The list of available overloads for the fields or `null` if no overloads
		exists.</haxe_doc>
			</overloads>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The meta data the field was annotated with.</haxe_doc>
			</meta>
			<line>
				<x path="Null"><x path="Int"/></x>
				<haxe_doc>The line number where the field is defined. This information is only
		available if the field has an expression.
		Otherwise the value is `null`.</haxe_doc>
			</line>
			<isPublic>
				<x path="Bool"/>
				<haxe_doc>Whether or not the field is `public`.</haxe_doc>
			</isPublic>
			<isOverride>
				<x path="Bool"/>
				<haxe_doc>Whether or not the field overrides another field.</haxe_doc>
			</isOverride>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>Whether or not the field is `final`.</haxe_doc>
			</isFinal>
			<get>
				<e path="haxe.rtti.Rights"/>
				<haxe_doc>The [read access](https://haxe.org/manual/class-field-property.html#define-read-access)
		behavior of the field.</haxe_doc>
			</get>
			<expr>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The actual expression of the field or `null` if there is no expression.</haxe_doc>
			</expr>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The documentation of the field. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or
		if the field has no documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc><![CDATA[The runtime class field information.

	@see <https://haxe.org/manual/cr-rtti-structure.html#class-field-information>]]></haxe_doc>
	</typedef>
	<typedef path="haxe.rtti.TypeInfos" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the type is available.</haxe_doc>
			</platforms>
			<path>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the type.</haxe_doc>
			</path>
			<params>
				<t path="haxe.rtti.TypeParams"/>
				<haxe_doc>An array of strings representing the names of the type parameters the
		type has.</haxe_doc>
			</params>
			<module>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the module containing the type.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The [metadata](https://haxe.org/manual/lf-metadata.html) the type was
		annotated with.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).</haxe_doc>
			</isPrivate>
			<file>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The full slash path of the .hx file containing the type.
		This might be `null` in case there is no such file, e.g. if the
		type is defined through a macro.</haxe_doc>
			</file>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The documentation of the type. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if
		the constructor has no documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The general runtime type information.</haxe_doc>
	</typedef>
	<typedef path="haxe.rtti.Classdef" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<tdynamic>
				<x path="Null"><e path="haxe.rtti.CType"/></x>
				<haxe_doc>The type which is dynamically implemented by the class or `null` if no
		such type exists.</haxe_doc>
			</tdynamic>
			<superClass>
				<x path="Null"><t path="haxe.rtti.PathParams"/></x>
				<haxe_doc>The class' parent class defined by its type path and list of type
		parameters.</haxe_doc>
			</superClass>
			<statics>
				<c path="Array"><t path="haxe.rtti.ClassField"/></c>
				<haxe_doc>The list of static class fields.</haxe_doc>
			</statics>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the type is available.</haxe_doc>
			</platforms>
			<path>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the type.</haxe_doc>
			</path>
			<params>
				<t path="haxe.rtti.TypeParams"/>
				<haxe_doc>An array of strings representing the names of the type parameters the
		type has.</haxe_doc>
			</params>
			<module>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the module containing the type.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The [metadata](https://haxe.org/manual/lf-metadata.html) the type was
		annotated with.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).</haxe_doc>
			</isPrivate>
			<isInterface>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class is actually an [interface](https://haxe.org/manual/types-interfaces.html).</haxe_doc>
			</isInterface>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class is `final`.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class is [extern](https://haxe.org/manual/lf-externs.html).</haxe_doc>
			</isExtern>
			<interfaces>
				<c path="Array"><t path="haxe.rtti.PathParams"/></c>
				<haxe_doc>The list of interfaces defined by their type path and list of type
		parameters.</haxe_doc>
			</interfaces>
			<file>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The full slash path of the .hx file containing the type.
		This might be `null` in case there is no such file, e.g. if the
		type is defined through a macro.</haxe_doc>
			</file>
			<fields>
				<c path="Array"><t path="haxe.rtti.ClassField"/></c>
				<haxe_doc>The list of member [class fields](https://haxe.org/manual/class-field.html).</haxe_doc>
			</fields>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The documentation of the type. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if
		the constructor has no documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The runtime class definition information.</haxe_doc>
	</typedef>
	<typedef path="haxe.rtti.EnumField" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the constructor is
		available.</haxe_doc>
			</platforms>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the constructor.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The meta data the constructor was annotated with.</haxe_doc>
			</meta>
			<doc>
				<c path="String"/>
				<haxe_doc>The documentation of the constructor. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if
		the constructor has no documentation, the value is `null`.</haxe_doc>
			</doc>
			<args>
				<x path="Null"><c path="Array"><a>
	<t><e path="haxe.rtti.CType"/></t>
	<opt><x path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c></x>
				<haxe_doc>The list of arguments the constructor has or `null` if no arguments are
		available.</haxe_doc>
			</args>
		</a>
		<haxe_doc><![CDATA[The runtime enum constructor information.

	@see <https://haxe.org/manual/cr-rtti-structure.html#enum-constructor-information>]]></haxe_doc>
	</typedef>
	<typedef path="haxe.rtti.Enumdef" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the type is available.</haxe_doc>
			</platforms>
			<path>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the type.</haxe_doc>
			</path>
			<params>
				<t path="haxe.rtti.TypeParams"/>
				<haxe_doc>An array of strings representing the names of the type parameters the
		type has.</haxe_doc>
			</params>
			<module>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the module containing the type.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The [metadata](https://haxe.org/manual/lf-metadata.html) the type was
		annotated with.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the enum is [extern](https://haxe.org/manual/lf-externs.html).</haxe_doc>
			</isExtern>
			<file>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The full slash path of the .hx file containing the type.
		This might be `null` in case there is no such file, e.g. if the
		type is defined through a macro.</haxe_doc>
			</file>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The documentation of the type. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if
		the constructor has no documentation, the value is `null`.</haxe_doc>
			</doc>
			<constructors>
				<c path="Array"><t path="haxe.rtti.EnumField"/></c>
				<haxe_doc>The list of enum constructors.</haxe_doc>
			</constructors>
		</a>
		<haxe_doc><![CDATA[The enum runtime type information.

	@see <https://haxe.org/manual/cr-rtti-structure.html#enum-type-information>]]></haxe_doc>
	</typedef>
	<typedef path="haxe.rtti.Typedef" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<types>
				<t path="Map">
					<c path="String"/>
					<e path="haxe.rtti.CType"/>
				</t>
				<haxe_doc>The types of the typedef, by platform.</haxe_doc>
			</types>
			<type>
				<e path="haxe.rtti.CType"/>
				<haxe_doc>The type of the typedef.</haxe_doc>
			</type>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the type is available.</haxe_doc>
			</platforms>
			<path>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the type.</haxe_doc>
			</path>
			<params>
				<t path="haxe.rtti.TypeParams"/>
				<haxe_doc>An array of strings representing the names of the type parameters the
		type has.</haxe_doc>
			</params>
			<module>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the module containing the type.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The [metadata](https://haxe.org/manual/lf-metadata.html) the type was
		annotated with.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).</haxe_doc>
			</isPrivate>
			<file>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The full slash path of the .hx file containing the type.
		This might be `null` in case there is no such file, e.g. if the
		type is defined through a macro.</haxe_doc>
			</file>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The documentation of the type. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if
		the constructor has no documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The typedef runtime information.</haxe_doc>
	</typedef>
	<typedef path="haxe.rtti.Abstractdef" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<to><c path="Array"><a>
	<t><e path="haxe.rtti.CType"/></t>
	<field><x path="Null"><c path="String"/></x></field>
</a></c></to>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the type is available.</haxe_doc>
			</platforms>
			<path>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the type.</haxe_doc>
			</path>
			<params>
				<t path="haxe.rtti.TypeParams"/>
				<haxe_doc>An array of strings representing the names of the type parameters the
		type has.</haxe_doc>
			</params>
			<module>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the module containing the type.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The [metadata](https://haxe.org/manual/lf-metadata.html) the type was
		annotated with.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).</haxe_doc>
			</isPrivate>
			<impl><t path="haxe.rtti.Classdef"/></impl>
			<from><c path="Array"><a>
	<t><e path="haxe.rtti.CType"/></t>
	<field><x path="Null"><c path="String"/></x></field>
</a></c></from>
			<file>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The full slash path of the .hx file containing the type.
		This might be `null` in case there is no such file, e.g. if the
		type is defined through a macro.</haxe_doc>
			</file>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The documentation of the type. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if
		the constructor has no documentation, the value is `null`.</haxe_doc>
			</doc>
			<athis><e path="haxe.rtti.CType"/></athis>
		</a>
		<haxe_doc><![CDATA[The abstract type runtime information.

	@see <https://haxe.org/manual/cr-rtti-structure.html#abstract-type-information>]]></haxe_doc>
	</typedef>
	<enum path="haxe.rtti.TypeTree" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<TPackage a="name:full:subs">
			<c path="String"/>
			<c path="String"/>
			<c path="Array"><e path="haxe.rtti.TypeTree"/></c>
		</TPackage>
		<TClassdecl a="c"><t path="haxe.rtti.Classdef"/></TClassdecl>
		<TEnumdecl a="e"><t path="haxe.rtti.Enumdef"/></TEnumdecl>
		<TTypedecl a="t"><t path="haxe.rtti.Typedef"/></TTypedecl>
		<TAbstractdecl a="a"><t path="haxe.rtti.Abstractdef"/></TAbstractdecl>
		<haxe_doc>The tree types of the runtime type.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="haxe.rtti.TypeRoot" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<c path="Array"><e path="haxe.rtti.TypeTree"/></c>
		<haxe_doc>Array of `TypeTree`.</haxe_doc>
	</typedef>
	<typedef path="haxe.rtti._Meta.MetaObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/Meta.hx" private="1" module="haxe.rtti.Meta"><a>
	<statics>
		<x path="Null"><d><d><x path="Null"><c path="Array"><d/></c></x></d></d></x>
		<meta><m n=":optional"/></meta>
	</statics>
	<obj>
		<x path="Null"><d><x path="Null"><c path="Array"><d/></c></x></d></x>
		<meta><m n=":optional"/></meta>
	</obj>
	<fields>
		<x path="Null"><d><d><x path="Null"><c path="Array"><d/></c></x></d></d></x>
		<meta><m n=":optional"/></meta>
	</fields>
</a></typedef>
	<class path="haxe.rtti.Meta" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/Meta.hx">
		<getMeta set="method" line="56" static="1">
			<f a="t">
				<d/>
				<t path="haxe.rtti._Meta.MetaObject"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getMeta>
		<getFields public="1" set="method" line="89" static="1">
			<f a="t">
				<d/>
				<d><d><c path="Array"><d/></c></d></d>
			</f>
			<haxe_doc>Returns the metadata that were declared for the given class fields or enum constructors</haxe_doc>
		</getFields>
		<haxe_doc><![CDATA[An API to access classes and enums metadata at runtime.

	@see <https://haxe.org/manual/cr-rtti.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.rtti.Rtti" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/Rtti.hx">
		<getRtti public="1" params="T" set="method" line="41" static="1">
			<f a="c">
				<x path="Class"><c path="getRtti.T"/></x>
				<t path="haxe.rtti.Classdef"/>
			</f>
			<haxe_doc>Returns the `haxe.rtti.CType.Classdef` corresponding to class `c`.

		If `c` has no runtime type information, e.g. because no `@:rtti` was
		added, an exception of type `String` is thrown.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getRtti>
		<haxe_doc><![CDATA[Rtti is a helper class which supplements the `@:rtti` metadata.

	@see <https://haxe.org/manual/cr-rtti.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.rtti.XmlParser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/XmlParser.hx">
		<root public="1"><t path="haxe.rtti.TypeRoot"/></root>
		<curplatform><c path="String"/></curplatform>
		<mkPath set="method" line="295"><f a="p">
	<c path="String"/>
	<t path="haxe.rtti.Path"/>
</f></mkPath>
		<mkTypeParams set="method" line="299"><f a="p">
	<c path="String"/>
	<t path="haxe.rtti.TypeParams"/>
</f></mkTypeParams>
		<mkRights set="method" line="306"><f a="r">
	<c path="String"/>
	<e path="haxe.rtti.Rights"/>
</f></mkRights>
		<xerror set="method" line="316"><f a="c">
	<x path="haxe.xml.Access"/>
	<d/>
</f></xerror>
		<processElement public="1" set="method" line="325"><f a="x">
	<c path="Xml"/>
	<e path="haxe.rtti.TypeTree"/>
</f></processElement>
		<xmeta set="method" line="336"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.MetaData"/>
</f></xmeta>
		<xoverloads set="method" line="347"><f a="x">
	<x path="haxe.xml.Access"/>
	<c path="Array"><t path="haxe.rtti.ClassField"/></c>
</f></xoverloads>
		<xpath set="method" line="355"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.PathParams"/>
</f></xpath>
		<xclass set="method" line="366"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.Classdef"/>
</f></xclass>
		<xclassfield set="method" line="417">
			<f a="x:?defPublic" v=":false">
				<x path="haxe.xml.Access"/>
				<x path="Bool"/>
				<t path="haxe.rtti.ClassField"/>
			</f>
			<meta><m n=":value"><e>{ defPublic : false }</e></m></meta>
		</xclassfield>
		<xenum set="method" line="446"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.Enumdef"/>
</f></xenum>
		<xenumfield set="method" line="471"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.EnumField"/>
</f></xenumfield>
		<xabstract set="method" line="502"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.Abstractdef"/>
</f></xabstract>
		<xtypedef set="method" line="540"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.Typedef"/>
</f></xtypedef>
		<xtype set="method" line="568"><f a="x">
	<x path="haxe.xml.Access"/>
	<e path="haxe.rtti.CType"/>
</f></xtype>
		<xtypeparams set="method" line="624"><f a="x">
	<x path="haxe.xml.Access"/>
	<c path="Array"><e path="haxe.rtti.CType"/></c>
</f></xtypeparams>
		<defplat set="method" line="631"><f a=""><c path="Array"><c path="String"/></c></f></defplat>
		<new public="1" set="method" line="39"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[XmlParser processes the runtime type information (RTTI) which
	is stored as a XML string in a static field `__rtti`.

	@see <https://haxe.org/manual/cr-rtti.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.NodeAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.NodeAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="27" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="haxe.xml.Access"/>
		</f>
		<meta><m n=":op"><e>a.b</e></m></meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.NodeAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="27" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="haxe.xml.Access"/>
			</f>
			<meta><m n=":op"><e>a.b</e></m></meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.AttribAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.AttribAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="39" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":op"><e>a.b</e></m></meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.AttribAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="39" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":op"><e>a.b</e></m></meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.HasAttribAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.HasAttribAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="59" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>a.b</e></m></meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.HasAttribAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="59" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>a.b</e></m></meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.HasNodeAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.HasNodeAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="68" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>a.b</e></m></meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.HasNodeAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="68" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>a.b</e></m></meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.NodeListAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.NodeListAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="75" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<c path="Array"><x path="haxe.xml.Access"/></c>
		</f>
		<meta><m n=":op"><e>a.b</e></m></meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.NodeListAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="75" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<c path="Array"><x path="haxe.xml.Access"/></c>
			</f>
			<meta><m n=":op"><e>a.b</e></m></meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml.Access" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx">
		<this><c path="Xml"/></this>
		<haxe_doc>The `haxe.xml.Access` API helps providing a fast dot-syntax access to the
	most common `Xml` methods.</haxe_doc>
		<impl><class path="haxe.xml._Access.Access_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<x public="1" get="accessor" set="null" static="1"><c path="Xml"/></x>
	<get_x public="1" get="inline" set="null" line="91" static="1"><f a="this">
	<c path="Xml"/>
	<c path="Xml"/>
</f></get_x>
	<name public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<haxe_doc>The name of the current element. This is the same as `Xml.nodeName`.</haxe_doc>
	</name>
	<get_name get="inline" set="null" line="98" static="1"><f a="this">
	<c path="Xml"/>
	<c path="String"/>
</f></get_name>
	<innerData public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<haxe_doc>The inner PCDATA or CDATA of the node.

		An exception is thrown if there is no data or if there not only data
		but also other nodes.</haxe_doc>
	</innerData>
	<innerHTML public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<haxe_doc>The XML string built with all the sub nodes, excluding the current one.</haxe_doc>
	</innerHTML>
	<node public="1" get="accessor" set="null" static="1">
		<x path="haxe.xml._Access.NodeAccess"/>
		<haxe_doc><![CDATA[Access to the first sub element with the given name.

		An exception is thrown if the element doesn't exists.
		Use `hasNode` to check the existence of a node.

		```haxe
		var access = new haxe.xml.Access(Xml.parse("<user><name>John</name></user>"));
		var user = access.node.user;
		var name = user.node.name;
		trace(name.innerData); // John

		// Uncaught Error: Document is missing element password
		var password = user.node.password;
		```]]></haxe_doc>
	</node>
	<get_node get="inline" set="null" line="134" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.NodeAccess"/>
</f></get_node>
	<nodes public="1" get="accessor" set="null" static="1">
		<x path="haxe.xml._Access.NodeListAccess"/>
		<haxe_doc><![CDATA[Access to the List of elements with the given name.
		```haxe
		var fast = new haxe.xml.Access(Xml.parse("
			<users>
				<user name='John'/>
				<user name='Andy'/>
				<user name='Dan'/>
			</users>"
		));

		var users = fast.node.users;
		for (user in users.nodes.user) {
			trace(user.att.name);
		}
		```]]></haxe_doc>
	</nodes>
	<get_nodes get="inline" set="null" line="156" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.NodeListAccess"/>
</f></get_nodes>
	<att public="1" get="accessor" set="null" static="1">
		<x path="haxe.xml._Access.AttribAccess"/>
		<haxe_doc><![CDATA[Access to a given attribute.

		An exception is thrown if the attribute doesn't exists.
		Use `has` to check the existence of an attribute.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user name='Mark'></user>"));
		var user = f.node.user;
		if (user.has.name) {
			trace(user.att.name); // Mark
		}
		```]]></haxe_doc>
	</att>
	<get_att get="inline" set="null" line="175" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.AttribAccess"/>
</f></get_att>
	<has public="1" get="accessor" set="null" static="1">
		<x path="haxe.xml._Access.HasAttribAccess"/>
		<haxe_doc>Check the existence of an attribute with the given name.</haxe_doc>
	</has>
	<get_has get="inline" set="null" line="183" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.HasAttribAccess"/>
</f></get_has>
	<hasNode public="1" get="accessor" set="null" static="1">
		<x path="haxe.xml._Access.HasNodeAccess"/>
		<haxe_doc><![CDATA[Check the existence of a sub node with the given name.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user><age>31</age></user>"));
		var user = f.node.user;
		if (user.hasNode.age) {
			trace(user.node.age.innerData); // 31
		}
		```]]></haxe_doc>
	</hasNode>
	<get_hasNode get="inline" set="null" line="199" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.HasNodeAccess"/>
</f></get_hasNode>
	<elements public="1" get="accessor" set="null" static="1">
		<t path="Iterator"><x path="haxe.xml.Access"/></t>
		<haxe_doc>The list of all sub-elements which are the nodes with type `Xml.Element`.</haxe_doc>
	</elements>
	<get_elements get="inline" set="null" line="207" static="1"><f a="this">
	<c path="Xml"/>
	<t path="Iterator"><x path="haxe.xml.Access"/></t>
</f></get_elements>
	<_new public="1" get="inline" set="null" line="209" static="1">
		<f a="x">
			<c path="Xml"/>
			<x path="haxe.xml.Access"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<get_innerData set="method" line="215" static="1"><f a="this">
	<c path="Xml"/>
	<c path="String"/>
</f></get_innerData>
	<get_innerHTML set="method" line="237" static="1"><f a="this">
	<c path="Xml"/>
	<c path="String"/>
</f></get_innerHTML>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.Access_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<x public="1" get="accessor" set="null" static="1"><c path="Xml"/></x>
		<get_x public="1" get="inline" set="null" line="91" static="1"><f a="this">
	<c path="Xml"/>
	<c path="Xml"/>
</f></get_x>
		<name public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>The name of the current element. This is the same as `Xml.nodeName`.</haxe_doc>
		</name>
		<get_name get="inline" set="null" line="98" static="1"><f a="this">
	<c path="Xml"/>
	<c path="String"/>
</f></get_name>
		<innerData public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>The inner PCDATA or CDATA of the node.

		An exception is thrown if there is no data or if there not only data
		but also other nodes.</haxe_doc>
		</innerData>
		<innerHTML public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>The XML string built with all the sub nodes, excluding the current one.</haxe_doc>
		</innerHTML>
		<node public="1" get="accessor" set="null" static="1">
			<x path="haxe.xml._Access.NodeAccess"/>
			<haxe_doc><![CDATA[Access to the first sub element with the given name.

		An exception is thrown if the element doesn't exists.
		Use `hasNode` to check the existence of a node.

		```haxe
		var access = new haxe.xml.Access(Xml.parse("<user><name>John</name></user>"));
		var user = access.node.user;
		var name = user.node.name;
		trace(name.innerData); // John

		// Uncaught Error: Document is missing element password
		var password = user.node.password;
		```]]></haxe_doc>
		</node>
		<get_node get="inline" set="null" line="134" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.NodeAccess"/>
</f></get_node>
		<nodes public="1" get="accessor" set="null" static="1">
			<x path="haxe.xml._Access.NodeListAccess"/>
			<haxe_doc><![CDATA[Access to the List of elements with the given name.
		```haxe
		var fast = new haxe.xml.Access(Xml.parse("
			<users>
				<user name='John'/>
				<user name='Andy'/>
				<user name='Dan'/>
			</users>"
		));

		var users = fast.node.users;
		for (user in users.nodes.user) {
			trace(user.att.name);
		}
		```]]></haxe_doc>
		</nodes>
		<get_nodes get="inline" set="null" line="156" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.NodeListAccess"/>
</f></get_nodes>
		<att public="1" get="accessor" set="null" static="1">
			<x path="haxe.xml._Access.AttribAccess"/>
			<haxe_doc><![CDATA[Access to a given attribute.

		An exception is thrown if the attribute doesn't exists.
		Use `has` to check the existence of an attribute.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user name='Mark'></user>"));
		var user = f.node.user;
		if (user.has.name) {
			trace(user.att.name); // Mark
		}
		```]]></haxe_doc>
		</att>
		<get_att get="inline" set="null" line="175" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.AttribAccess"/>
</f></get_att>
		<has public="1" get="accessor" set="null" static="1">
			<x path="haxe.xml._Access.HasAttribAccess"/>
			<haxe_doc>Check the existence of an attribute with the given name.</haxe_doc>
		</has>
		<get_has get="inline" set="null" line="183" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.HasAttribAccess"/>
</f></get_has>
		<hasNode public="1" get="accessor" set="null" static="1">
			<x path="haxe.xml._Access.HasNodeAccess"/>
			<haxe_doc><![CDATA[Check the existence of a sub node with the given name.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user><age>31</age></user>"));
		var user = f.node.user;
		if (user.hasNode.age) {
			trace(user.node.age.innerData); // 31
		}
		```]]></haxe_doc>
		</hasNode>
		<get_hasNode get="inline" set="null" line="199" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.HasNodeAccess"/>
</f></get_hasNode>
		<elements public="1" get="accessor" set="null" static="1">
			<t path="Iterator"><x path="haxe.xml.Access"/></t>
			<haxe_doc>The list of all sub-elements which are the nodes with type `Xml.Element`.</haxe_doc>
		</elements>
		<get_elements get="inline" set="null" line="207" static="1"><f a="this">
	<c path="Xml"/>
	<t path="Iterator"><x path="haxe.xml.Access"/></t>
</f></get_elements>
		<_new public="1" get="inline" set="null" line="209" static="1">
			<f a="x">
				<c path="Xml"/>
				<x path="haxe.xml.Access"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<get_innerData set="method" line="215" static="1"><f a="this">
	<c path="Xml"/>
	<c path="String"/>
</f></get_innerData>
		<get_innerHTML set="method" line="237" static="1"><f a="this">
	<c path="Xml"/>
	<c path="String"/>
</f></get_innerHTML>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Parser.S" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.xml._Parser.S_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.xml.XmlParserException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Parser.hx" module="haxe.xml.Parser">
		<message public="1">
			<c path="String"/>
			<haxe_doc>the XML parsing error message</haxe_doc>
		</message>
		<lineNumber public="1">
			<x path="Int"/>
			<haxe_doc>the line number at which the XML parsing error occurred</haxe_doc>
		</lineNumber>
		<positionAtLine public="1">
			<x path="Int"/>
			<haxe_doc>the character position in the reported line at which the parsing error occurred</haxe_doc>
		</positionAtLine>
		<position public="1">
			<x path="Int"/>
			<haxe_doc>the character position in the XML string at which the parsing error occurred</haxe_doc>
		</position>
		<xml public="1">
			<c path="String"/>
			<haxe_doc>the invalid XML string</haxe_doc>
		</xml>
		<toString public="1" set="method" line="94"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="75"><f a="message:xml:position">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="js.lib.Object" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Object.hx" extern="1">
		<assign public="1" params="T" set="method" static="1">
			<f a="target:sources">
				<c path="assign.T"/>
				<t path="haxe.extern.Rest"><a/></t>
				<c path="assign.T"/>
			</f>
			<haxe_doc>Copies the values of all enumerable own properties from one or more
		source objects to a target object.</haxe_doc>
		</assign>
		<create public="1" params="T" set="method" static="1">
			<f a="proto:?propertiesObject">
				<a/>
				<x path="haxe.DynamicAccess"><t path="js.lib.ObjectPropertyDescriptor"/></x>
				<c path="create.T"/>
			</f>
			<haxe_doc>Creates a new object with the specified prototype object and properties.</haxe_doc>
		</create>
		<defineProperties public="1" params="T" set="method" static="1">
			<f a="obj:props">
				<c path="defineProperties.T"/>
				<x path="haxe.DynamicAccess"><t path="js.lib.ObjectPropertyDescriptor"/></x>
				<c path="defineProperties.T"/>
			</f>
			<haxe_doc>Adds the named properties described by the given descriptors to an object.</haxe_doc>
		</defineProperties>
		<defineProperty public="1" params="T" set="method" static="1">
			<f a="obj:prop:descriptor">
				<c path="defineProperty.T"/>
				<c path="String"/>
				<t path="js.lib.ObjectPropertyDescriptor"/>
				<c path="defineProperty.T"/>
			</f>
			<haxe_doc>Adds the named property described by a given descriptor to an object.</haxe_doc>
			<overloads><defineProperty public="1" params="T" set="method">
	<f a="obj:prop:descriptor">
		<c path="defineProperty.T"/>
		<c path="js.lib.Symbol"/>
		<t path="js.lib.ObjectPropertyDescriptor"/>
		<c path="defineProperty.T"/>
	</f>
	<haxe_doc>Adds the named property described by a given descriptor to an object.</haxe_doc>
</defineProperty></overloads>
		</defineProperty>
		<entries public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><x path="js.lib.ObjectEntry"/></c>
			</f>
			<haxe_doc>Returns an array containing all of the [key, value] pairs of a given
		object's own enumerable string properties.</haxe_doc>
		</entries>
		<freeze public="1" params="T" set="method" static="1">
			<f a="obj">
				<c path="freeze.T"/>
				<c path="freeze.T"/>
			</f>
			<haxe_doc>Freezes an object: other code can't delete or change any properties.</haxe_doc>
		</freeze>
		<fromEntries public="1" params="T" set="method" static="1">
			<f a="iterable">
				<x path="Any"/>
				<c path="fromEntries.T"/>
			</f>
			<haxe_doc>Returns a new object from an iterable of key-value pairs
		(reverses Object.entries).</haxe_doc>
		</fromEntries>
		<getOwnPropertyDescriptor public="1" set="method" static="1">
			<f a="obj:prop">
				<a/>
				<c path="String"/>
				<x path="Null"><t path="js.lib.ObjectPropertyDescriptor"/></x>
			</f>
			<haxe_doc>Returns a property descriptor for a named property on an object.</haxe_doc>
			<overloads>
				<getOwnPropertyDescriptor public="1" params="T" set="method">
					<f a="target:propertyKey">
						<c path="Array"><c path="getOwnPropertyDescriptor.T"/></c>
						<x path="Int"/>
						<x path="Null"><t path="js.lib.ObjectPropertyDescriptor"/></x>
					</f>
					<haxe_doc>Returns a property descriptor for a named property on an object.</haxe_doc>
				</getOwnPropertyDescriptor>
				<getOwnPropertyDescriptor public="1" set="method">
					<f a="obj:prop">
						<a/>
						<c path="js.lib.Symbol"/>
						<x path="Null"><t path="js.lib.ObjectPropertyDescriptor"/></x>
					</f>
					<haxe_doc>Returns a property descriptor for a named property on an object.</haxe_doc>
				</getOwnPropertyDescriptor>
			</overloads>
		</getOwnPropertyDescriptor>
		<getOwnPropertyNames public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns an array containing the names of all of the given object's own
		enumerable and non-enumerable properties.</haxe_doc>
		</getOwnPropertyNames>
		<getOwnPropertySymbols public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><c path="js.lib.Symbol"/></c>
			</f>
			<haxe_doc>Returns an array of all symbol properties found directly upon a given object.</haxe_doc>
		</getOwnPropertySymbols>
		<getPrototypeOf public="1" params="TProto" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Null"><c path="getPrototypeOf.TProto"/></x>
			</f>
			<haxe_doc>Returns the prototype of the specified object.</haxe_doc>
		</getPrototypeOf>
		<is public="1" params="T" set="method" static="1">
			<f a="value1:value2">
				<c path="is.T"/>
				<c path="is.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares if two values are the same value. Equates all NaN values
		(which differs from both Abstract Equality Comparison and
		Strict Equality Comparison).</haxe_doc>
		</is>
		<isExtensible public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines if extending of an object is allowed.</haxe_doc>
		</isExtensible>
		<isFrozen public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines if an object was frozen.</haxe_doc>
		</isFrozen>
		<isSealed public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines if an object is sealed.</haxe_doc>
		</isSealed>
		<keys public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns an array containing the names of all of the given object's own
		enumerable string properties.</haxe_doc>
		</keys>
		<preventExtensions public="1" params="T" set="method" static="1">
			<f a="obj">
				<c path="preventExtensions.T"/>
				<c path="preventExtensions.T"/>
			</f>
			<haxe_doc>Prevents any extensions of an object.</haxe_doc>
		</preventExtensions>
		<seal public="1" params="T" set="method" static="1">
			<f a="obj">
				<c path="seal.T"/>
				<c path="seal.T"/>
			</f>
			<haxe_doc>Prevents other code from deleting properties of an object.</haxe_doc>
		</seal>
		<setPrototypeOf public="1" params="T" set="method" static="1">
			<f a="obj:prototype">
				<c path="setPrototypeOf.T"/>
				<x path="Null"><a/></x>
				<c path="setPrototypeOf.T"/>
			</f>
			<haxe_doc>Sets the prototype (i.e., the internal Prototype property).</haxe_doc>
		</setPrototypeOf>
		<values public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><x path="Any"/></c>
			</f>
			<haxe_doc>Returns an array containing the values that correspond to all of
		a given object's own enumerable string properties.</haxe_doc>
		</values>
		<prototype public="1" set="null" static="1">
			<t path="js.lib.ObjectPrototype"/>
			<haxe_doc>Allows the addition of properties to all objects of type Object.</haxe_doc>
		</prototype>
		<new public="1" set="method">
			<f a="?value">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>The Object constructor creates an object wrapper.</haxe_doc>
		</new>
		<haxe_doc>The `js.lib.Object` constructor creates an object wrapper.

	Documentation [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Object"</e></m>
		</meta>
	</class>
	<class path="haxe.xml.Parser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Parser.hx">
		<escapes expr="{
	var h = new haxe.ds.StringMap();
	h.set(&quot;lt&quot;, &quot;&lt;&quot;);
	h.set(&quot;gt&quot;, &quot;&gt;&quot;);
	h.set(&quot;amp&quot;, &quot;&amp;&quot;);
	h.set(&quot;quot&quot;, &quot;\&quot;&quot;);
	h.set(&quot;apos&quot;, &quot;&apos;&quot;);
	h;
}" line="100" static="1">
			<c path="haxe.ds.StringMap"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[{
	var h = new haxe.ds.StringMap();
	h.set("lt", "<");
	h.set("gt", ">");
	h.set("amp", "&");
	h.set("quot", "\"");
	h.set("apos", "'");
	h;
}]]></e></m></meta>
		</escapes>
		<parse public="1" set="method" line="115" static="1">
			<f a="str:?strict" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Xml"/>
			</f>
			<meta><m n=":value"><e>{ strict : false }</e></m></meta>
			<haxe_doc>Parses the String into an XML Document. Set strict parsing to true in order to enable a strict check of XML attributes and entities.

		@throws haxe.xml.XmlParserException</haxe_doc>
		</parse>
		<doParse set="method" line="121" static="1">
			<f a="str:strict:?p:?parent" v="::0:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Xml"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ p : 0 }</e></m></meta>
		</doParse>
		<isValidChar get="inline" set="null" line="415" static="1"><f a="c">
	<x path="Int"/>
	<x path="Bool"/>
</f></isValidChar>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml.Printer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Printer.hx">
		<print public="1" set="method" line="35" static="1">
			<f a="xml:?pretty" v=":false">
				<c path="Xml"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ pretty : false }</e></m></meta>
			<haxe_doc>Convert `Xml` to string representation.

		Set `pretty` to `true` to prettify the result.</haxe_doc>
		</print>
		<output><c path="StringBuf"/></output>
		<pretty><x path="Bool"/></pretty>
		<writeNode set="method" line="49"><f a="value:tabs">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeNode>
		<write get="inline" set="null" line="104"><f a="input">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<newline get="inline" set="null" line="108"><f a=""><x path="Void"/></f></newline>
		<hasChildren set="method" line="114"><f a="value">
	<c path="Xml"/>
	<x path="Bool"/>
</f></hasChildren>
		<new set="method" line="44"><f a="pretty">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>This class provides utility methods to convert Xml instances to
	String representation.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="hscript.Const" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<CInt a="v"><x path="Int"/></CInt>
		<CFloat a="f"><x path="Float"/></CFloat>
		<CString a="s"><c path="String"/></CString>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hscript.ExprDef" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr"><e path="hscript.Expr"/></typedef>
	<enum path="hscript.Expr" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx">
		<EConst a="c"><e path="hscript.Const"/></EConst>
		<EIdent a="v"><c path="String"/></EIdent>
		<EVar a="n:?t:?e">
			<c path="String"/>
			<e path="hscript.CType"/>
			<e path="hscript.Expr"/>
		</EVar>
		<EParent a="e"><e path="hscript.Expr"/></EParent>
		<EBlock a="e"><c path="Array"><e path="hscript.Expr"/></c></EBlock>
		<EField a="e:f">
			<e path="hscript.Expr"/>
			<c path="String"/>
		</EField>
		<EBinop a="op:e1:e2">
			<c path="String"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EBinop>
		<EUnop a="op:prefix:e">
			<c path="String"/>
			<x path="Bool"/>
			<e path="hscript.Expr"/>
		</EUnop>
		<ECall a="e:params">
			<e path="hscript.Expr"/>
			<c path="Array"><e path="hscript.Expr"/></c>
		</ECall>
		<EIf a="cond:e1:?e2">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EIf>
		<EWhile a="cond:e">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EWhile>
		<EFor a="v:it:e">
			<c path="String"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EFor>
		<EBreak/>
		<EContinue/>
		<EFunction a="args:e:?name:?ret">
			<c path="Array"><t path="hscript.Argument"/></c>
			<e path="hscript.Expr"/>
			<c path="String"/>
			<e path="hscript.CType"/>
		</EFunction>
		<EReturn a="?e"><e path="hscript.Expr"/></EReturn>
		<EArray a="e:index">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EArray>
		<EArrayDecl a="e"><c path="Array"><e path="hscript.Expr"/></c></EArrayDecl>
		<ENew a="cl:params">
			<c path="String"/>
			<c path="Array"><e path="hscript.Expr"/></c>
		</ENew>
		<EThrow a="e"><e path="hscript.Expr"/></EThrow>
		<ETry a="e:v:t:ecatch">
			<e path="hscript.Expr"/>
			<c path="String"/>
			<x path="Null"><e path="hscript.CType"/></x>
			<e path="hscript.Expr"/>
		</ETry>
		<EObject a="fl"><c path="Array"><a>
	<name><c path="String"/></name>
	<e><e path="hscript.Expr"/></e>
</a></c></EObject>
		<ETernary a="cond:e1:e2">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</ETernary>
		<ESwitch a="e:cases:?defaultExpr">
			<e path="hscript.Expr"/>
			<c path="Array"><a>
	<values><c path="Array"><e path="hscript.Expr"/></c></values>
	<expr><e path="hscript.Expr"/></expr>
</a></c>
			<e path="hscript.Expr"/>
		</ESwitch>
		<EDoWhile a="cond:e">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EDoWhile>
		<EMeta a="name:args:e">
			<c path="String"/>
			<c path="Array"><e path="hscript.Expr"/></c>
			<e path="hscript.Expr"/>
		</EMeta>
		<ECheckType a="e:t">
			<e path="hscript.Expr"/>
			<e path="hscript.CType"/>
		</ECheckType>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hscript.Argument" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr"><a>
	<value>
		<x path="Null"><e path="hscript.Expr"/></x>
		<meta><m n=":optional"/></meta>
	</value>
	<t>
		<x path="Null"><e path="hscript.CType"/></x>
		<meta><m n=":optional"/></meta>
	</t>
	<opt>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="hscript.Metadata" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr"><c path="Array"><a>
	<params><c path="Array"><e path="hscript.Expr"/></c></params>
	<name><c path="String"/></name>
</a></c></typedef>
	<enum path="hscript.CType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<CTPath a="path:?params">
			<c path="Array"><c path="String"/></c>
			<c path="Array"><e path="hscript.CType"/></c>
		</CTPath>
		<CTFun a="args:ret">
			<c path="Array"><e path="hscript.CType"/></c>
			<e path="hscript.CType"/>
		</CTFun>
		<CTAnon a="fields"><c path="Array"><a>
	<t><e path="hscript.CType"/></t>
	<name><c path="String"/></name>
	<meta>
		<x path="Null"><t path="hscript.Metadata"/></x>
		<meta><m n=":optional"/></meta>
	</meta>
</a></c></CTAnon>
		<CTParent a="t"><e path="hscript.CType"/></CTParent>
		<CTOpt a="t"><e path="hscript.CType"/></CTOpt>
		<CTNamed a="n:t">
			<c path="String"/>
			<e path="hscript.CType"/>
		</CTNamed>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hscript.Error" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<EInvalidChar a="c"><x path="Int"/></EInvalidChar>
		<EUnexpected a="s"><c path="String"/></EUnexpected>
		<EUnterminatedString/>
		<EUnterminatedComment/>
		<EInvalidPreprocessor a="msg"><c path="String"/></EInvalidPreprocessor>
		<EUnknownVariable a="v"><c path="String"/></EUnknownVariable>
		<EInvalidIterator a="v"><c path="String"/></EInvalidIterator>
		<EInvalidOp a="op"><c path="String"/></EInvalidOp>
		<EInvalidAccess a="f"><c path="String"/></EInvalidAccess>
		<ECustom a="msg"><c path="String"/></ECustom>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hscript.ModuleDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<DPackage a="path"><c path="Array"><c path="String"/></c></DPackage>
		<DImport a="path:?everything">
			<c path="Array"><c path="String"/></c>
			<x path="Bool"/>
		</DImport>
		<DClass a="c"><t path="hscript.ClassDecl"/></DClass>
		<DTypedef a="c"><t path="hscript.TypeDecl"/></DTypedef>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hscript.ModuleType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr"><a>
	<params><a/></params>
	<name><c path="String"/></name>
	<meta><t path="hscript.Metadata"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
</a></typedef>
	<typedef path="hscript.ClassDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr"><a>
	<params><a/></params>
	<name><c path="String"/></name>
	<meta><t path="hscript.Metadata"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<implement><c path="Array"><e path="hscript.CType"/></c></implement>
	<fields><c path="Array"><t path="hscript.FieldDecl"/></c></fields>
	<extend><x path="Null"><e path="hscript.CType"/></x></extend>
</a></typedef>
	<typedef path="hscript.TypeDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr"><a>
	<t><e path="hscript.CType"/></t>
	<params><a/></params>
	<name><c path="String"/></name>
	<meta><t path="hscript.Metadata"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
</a></typedef>
	<typedef path="hscript.FieldDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr"><a>
	<name><c path="String"/></name>
	<meta><t path="hscript.Metadata"/></meta>
	<kind><e path="hscript.FieldKind"/></kind>
	<access><c path="Array"><e path="hscript.FieldAccess"/></c></access>
</a></typedef>
	<enum path="hscript.FieldAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<APublic/>
		<APrivate/>
		<AInline/>
		<AOverride/>
		<AStatic/>
		<AMacro/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hscript.FieldKind" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<KFunction a="f"><t path="hscript.FunctionDecl"/></KFunction>
		<KVar a="v"><t path="hscript.VarDecl"/></KVar>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hscript.FunctionDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr"><a>
	<ret><x path="Null"><e path="hscript.CType"/></x></ret>
	<expr><e path="hscript.Expr"/></expr>
	<args><c path="Array"><t path="hscript.Argument"/></c></args>
</a></typedef>
	<typedef path="hscript.VarDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr"><a>
	<type><x path="Null"><e path="hscript.CType"/></x></type>
	<set><x path="Null"><c path="String"/></x></set>
	<get><x path="Null"><c path="String"/></x></get>
	<expr><x path="Null"><e path="hscript.Expr"/></x></expr>
</a></typedef>
	<enum path="hscript._Interp.Stop" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Interp.hx" private="1" module="hscript.Interp">
		<SBreak/>
		<SContinue/>
		<SReturn/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hscript.Token" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Parser.hx" module="hscript.Parser">
		<TEof/>
		<TConst a="c"><e path="hscript.Const"/></TConst>
		<TId a="s"><c path="String"/></TId>
		<TOp a="s"><c path="String"/></TOp>
		<TPOpen/>
		<TPClose/>
		<TBrOpen/>
		<TBrClose/>
		<TDot/>
		<TComma/>
		<TSemicolon/>
		<TBkOpen/>
		<TBkClose/>
		<TQuestion/>
		<TDoubleDot/>
		<TMeta a="s"><c path="String"/></TMeta>
		<TPrepro a="s"><c path="String"/></TPrepro>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hscript.Parser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Parser.hx">
		<p1 get="inline" set="null" expr="0" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</p1>
		<tokenMin get="inline" set="null" expr="0" line="102" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tokenMin>
		<tokenMax get="inline" set="null" expr="0" line="103" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tokenMax>
		<line public="1"><x path="Int"/></line>
		<opChars public="1"><c path="String"/></opChars>
		<identChars public="1"><c path="String"/></identChars>
		<opPriority public="1"><t path="Map">
	<c path="String"/>
	<x path="Int"/>
</t></opPriority>
		<opRightAssoc public="1"><t path="Map">
	<c path="String"/>
	<x path="Bool"/>
</t></opRightAssoc>
		<preprocesorValues public="1" expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
			<haxe_doc>allows to check for #if / #else in code</haxe_doc>
		</preprocesorValues>
		<allowJSON public="1">
			<x path="Bool"/>
			<haxe_doc>activate JSON compatiblity</haxe_doc>
		</allowJSON>
		<allowTypes public="1">
			<x path="Bool"/>
			<haxe_doc>allow types declarations</haxe_doc>
		</allowTypes>
		<allowMetadata public="1">
			<x path="Bool"/>
			<haxe_doc>allow haxe metadata declarations</haxe_doc>
		</allowMetadata>
		<resumeErrors public="1">
			<x path="Bool"/>
			<haxe_doc>resume from parsing errors (when parsing incomplete code, during completion for example)</haxe_doc>
		</resumeErrors>
		<input><c path="String"/></input>
		<readPos><x path="Int"/></readPos>
		<char><x path="Int"/></char>
		<ops><c path="Array"><x path="Bool"/></c></ops>
		<idents><c path="Array"><x path="Bool"/></c></idents>
		<uid expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</uid>
		<tokens><c path="haxe.ds.GenericStack"><e path="hscript.Token"/></c></tokens>
		<error public="1" get="inline" set="null" line="146"><f a="err:pmin:pmax">
	<e path="hscript.Error"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></error>
		<invalidChar public="1" set="method" line="155"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidChar>
		<initParser set="method" line="159"><f a="origin">
	<x path="Null"><c path="String"/></x>
	<x path="Void"/>
</f></initParser>
		<parseString public="1" set="method" line="183">
			<f a="s:?origin" v=":&quot;hscript&quot;">
				<c path="String"/>
				<c path="String"/>
				<e path="hscript.Expr"/>
			</f>
			<meta><m n=":value"><e>{ origin : "hscript" }</e></m></meta>
		</parseString>
		<unexpected set="method" line="197"><f a="tk">
	<e path="hscript.Token"/>
	<d/>
</f></unexpected>
		<push get="inline" set="null" line="202"><f a="tk">
	<e path="hscript.Token"/>
	<x path="Void"/>
</f></push>
		<ensure get="inline" set="null" line="212"><f a="tk">
	<x path="Null"><e path="hscript.Token"/></x>
	<x path="Void"/>
</f></ensure>
		<ensureToken get="inline" set="null" line="217"><f a="tk">
	<x path="Null"><e path="hscript.Token"/></x>
	<x path="Void"/>
</f></ensureToken>
		<maybe set="method" line="222"><f a="tk">
	<x path="Null"><e path="hscript.Token"/></x>
	<x path="Bool"/>
</f></maybe>
		<getIdent set="method" line="230"><f a=""><c path="String"/></f></getIdent>
		<expr get="inline" set="null" line="240"><f a="e">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></expr>
		<pmin get="inline" set="null" line="248"><f a="e">
	<e path="hscript.Expr"/>
	<x path="Int"/>
</f></pmin>
		<pmax get="inline" set="null" line="256"><f a="e">
	<e path="hscript.Expr"/>
	<x path="Int"/>
</f></pmax>
		<mk get="inline" set="null" line="264"><f a="e:?pmin:?pmax">
	<e path="hscript.Expr"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="hscript.Expr"/>
</f></mk>
		<isBlock set="method" line="275"><f a="e">
	<x path="Null"><e path="hscript.Expr"/></x>
	<x path="Bool"/>
</f></isBlock>
		<parseFullExpr set="method" line="294"><f a="exprs">
	<c path="Array"><e path="hscript.Expr"/></c>
	<x path="Void"/>
</f></parseFullExpr>
		<parseObject set="method" line="314"><f a="p1">
	<x path="Null"><x path="Null"><x path="Int"/></x></x>
	<e path="hscript.Expr"/>
</f></parseObject>
		<parseExpr set="method" line="349"><f a=""><x path="Null"><e path="hscript.Expr"/></x></f></parseExpr>
		<parseLambda set="method" line="488"><f a="args:pmin">
	<c path="Array"><t path="hscript.Argument"/></c>
	<x path="Null"><x path="Null"><x path="Int"/></x></x>
	<e path="hscript.Expr"/>
</f></parseLambda>
		<parseMetaArgs set="method" line="508"><f a=""><x path="Null"><c path="Array"><x path="Null"><e path="hscript.Expr"/></x></c></x></f></parseMetaArgs>
		<mapCompr set="method" line="532"><f a="tmp:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<x path="Null"><e path="hscript.Expr"/></x>
</f></mapCompr>
		<makeUnop set="method" line="553"><f a="op:e">
	<c path="String"/>
	<x path="Null"><e path="hscript.Expr"/></x>
	<x path="Null"><e path="hscript.Expr"/></x>
</f></makeUnop>
		<makeBinop set="method" line="563"><f a="op:e1:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<x path="Null"><e path="hscript.Expr"/></x>
	<e path="hscript.Expr"/>
</f></makeBinop>
		<parseStructure set="method" line="582"><f a="id">
	<c path="String"/>
	<x path="Null"><e path="hscript.Expr"/></x>
</f></parseStructure>
		<parseExprNext set="method" line="774"><f a="e1">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></parseExprNext>
		<parseFunctionArgs set="method" line="821"><f a=""><c path="Array"><t path="hscript.Argument"/></c></f></parseFunctionArgs>
		<parseFunctionDecl set="method" line="863"><f a=""><a>
	<ret><x path="Null"><e path="hscript.CType"/></x></ret>
	<body><x path="Null"><e path="hscript.Expr"/></x></body>
	<args><c path="Array"><t path="hscript.Argument"/></c></args>
</a></f></parseFunctionDecl>
		<parsePath set="method" line="877"><f a=""><c path="Array"><c path="String"/></c></f></parsePath>
		<parseType set="method" line="890"><f a=""><e path="hscript.CType"/></f></parseType>
		<parseTypeNext set="method" line="1012"><f a="t">
	<e path="hscript.CType"/>
	<e path="hscript.CType"/>
</f></parseTypeNext>
		<parseExprList set="method" line="1034"><f a="etk">
	<x path="Null"><e path="hscript.Token"/></x>
	<c path="Array"><x path="Null"><e path="hscript.Expr"/></x></c>
</f></parseExprList>
		<parseModule public="1" set="method" line="1056">
			<f a="content:?origin" v=":&quot;hscript&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><e path="hscript.ModuleDecl"/></c>
			</f>
			<meta><m n=":value"><e>{ origin : "hscript" }</e></m></meta>
		</parseModule>
		<parseMetadata set="method" line="1072"><f a=""><t path="hscript.Metadata"/></f></parseMetadata>
		<parseParams set="method" line="1087"><f a=""><a/></f></parseParams>
		<parseModuleDecl set="method" line="1093"><f a=""><e path="hscript.ModuleDecl"/></f></parseModuleDecl>
		<parseField set="method" line="1186"><f a=""><t path="hscript.FieldDecl"/></f></parseField>
		<readChar get="inline" set="null" line="1260"><f a=""><x path="Int"/></f></readChar>
		<readString set="method" line="1264"><f a="until">
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<token set="method" line="1324"><f a=""><x path="Null"><e path="hscript.Token"/></x></f></token>
		<preprocValue set="method" line="1564"><f a="id">
	<c path="String"/>
	<d/>
</f></preprocValue>
		<preprocStack><c path="Array"><a><r><x path="Bool"/></r></a></c></preprocStack>
		<parsePreproCond set="method" line="1570"><f a=""><e path="hscript.Expr"/></f></parsePreproCond>
		<evalPreproCond set="method" line="1585"><f a="e">
	<e path="hscript.Expr"/>
	<x path="Bool"/>
</f></evalPreproCond>
		<preprocess set="method" line="1603"><f a="id">
	<c path="String"/>
	<e path="hscript.Token"/>
</f></preprocess>
		<skipTokens set="method" line="1636"><f a=""><x path="Void"/></f></skipTokens>
		<tokenComment set="method" line="1651"><f a="op:char">
	<c path="String"/>
	<x path="Int"/>
	<x path="Null"><e path="hscript.Token"/></x>
</f></tokenComment>
		<constString set="method" line="1693"><f a="c">
	<e path="hscript.Const"/>
	<c path="String"/>
</f></constString>
		<tokenString set="method" line="1704"><f a="t">
	<e path="hscript.Token"/>
	<c path="String"/>
</f></tokenString>
		<new public="1" set="method" line="113"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hscript.Tools" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Tools.hx">
		<iter public="1" set="method" line="27" static="1"><f a="e:f">
	<e path="hscript.Expr"/>
	<f a="">
		<e path="hscript.Expr"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></iter>
		<map public="1" set="method" line="63" static="1"><f a="e:f">
	<e path="hscript.Expr"/>
	<f a="">
		<e path="hscript.Expr"/>
		<e path="hscript.Expr"/>
	</f>
	<t path="hscript.ExprDef"/>
</f></map>
		<expr public="1" get="inline" set="null" line="93" static="1"><f a="e">
	<e path="hscript.Expr"/>
	<t path="hscript.ExprDef"/>
</f></expr>
		<mk public="1" get="inline" set="null" line="101" static="1"><f a="e:p">
	<t path="hscript.ExprDef"/>
	<e path="hscript.Expr"/>
	<t path="hscript.ExprDef"/>
</f></mk>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hsluv.Point" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hsluv/haxe/src/hsluv/Geometry.hx" module="hsluv.Geometry"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
</a></typedef>
	<typedef path="hsluv.Line" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hsluv/haxe/src/hsluv/Geometry.hx" module="hsluv.Geometry"><a>
	<slope><x path="Float"/></slope>
	<intercept><x path="Float"/></intercept>
</a></typedef>
	<typedef path="hsluv.Angle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hsluv/haxe/src/hsluv/Geometry.hx" module="hsluv.Geometry"><x path="Float"/></typedef>
	<class path="hsluv.Geometry" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hsluv/haxe/src/hsluv/Geometry.hx">
		<intersectLineLine public="1" set="method" line="19" static="1"><f a="a:b">
	<t path="hsluv.Line"/>
	<t path="hsluv.Line"/>
	<t path="hsluv.Point"/>
</f></intersectLineLine>
		<distanceFromOrigin public="1" set="method" line="25" static="1"><f a="point">
	<t path="hsluv.Point"/>
	<x path="Float"/>
</f></distanceFromOrigin>
		<distanceLineFromOrigin public="1" set="method" line="29" static="1"><f a="line">
	<t path="hsluv.Line"/>
	<x path="Float"/>
</f></distanceLineFromOrigin>
		<perpendicularThroughPoint public="1" set="method" line="34" static="1"><f a="line:point">
	<t path="hsluv.Line"/>
	<t path="hsluv.Point"/>
	<t path="hsluv.Line"/>
</f></perpendicularThroughPoint>
		<angleFromOrigin public="1" set="method" line="43" static="1"><f a="point">
	<t path="hsluv.Point"/>
	<t path="hsluv.Angle"/>
</f></angleFromOrigin>
		<normalizeAngle public="1" set="method" line="47" static="1"><f a="angle">
	<t path="hsluv.Angle"/>
	<t path="hsluv.Angle"/>
</f></normalizeAngle>
		<lengthOfRayUntilIntersect public="1" set="method" line="52" static="1"><f a="theta:line">
	<t path="hsluv.Angle"/>
	<t path="hsluv.Line"/>
	<x path="Float"/>
</f></lengthOfRayUntilIntersect>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hsluv.Hsluv" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hsluv/haxe/src/hsluv/Hsluv.hx">
		<m expr="[[3.240969941904521, -1.537383177570093, -0.498610760293], [-0.96924363628087, 1.87596750150772, 0.041555057407175], [0.055630079696993, -0.20397695888897, 1.056971514242878]]" line="28" static="1">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>[[3.240969941904521, -1.537383177570093, -0.498610760293], [-0.96924363628087, 1.87596750150772, 0.041555057407175], [0.055630079696993, -0.20397695888897, 1.056971514242878]]</e></m></meta>
		</m>
		<minv expr="[[0.41239079926595, 0.35758433938387, 0.18048078840183], [0.21263900587151, 0.71516867876775, 0.072192315360733], [0.019330818715591, 0.11919477979462, 0.95053215224966]]" line="35" static="1">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>[[0.41239079926595, 0.35758433938387, 0.18048078840183], [0.21263900587151, 0.71516867876775, 0.072192315360733], [0.019330818715591, 0.11919477979462, 0.95053215224966]]</e></m></meta>
		</minv>
		<refY expr="1.0" line="41" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</refY>
		<refU expr="0.19783000664283" line="43" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.19783000664283</e></m></meta>
		</refU>
		<refV expr="0.46831999493879" line="44" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.46831999493879</e></m></meta>
		</refV>
		<kappa expr="903.2962962" line="47" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>903.2962962</e></m></meta>
		</kappa>
		<epsilon expr="0.0088564516" line="48" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0088564516</e></m></meta>
		</epsilon>
		<hexChars expr="&quot;0123456789abcdef&quot;" line="50" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"0123456789abcdef"</e></m></meta>
		</hexChars>
		<getBounds public="1" set="method" line="57" static="1">
			<f a="L">
				<x path="Float"/>
				<c path="Array"><t path="hsluv.Line"/></c>
			</f>
			<haxe_doc>For a given lightness, return a list of 6 lines in slope-intercept
    form that represent the bounds in CIELUV, stepping over which will
    push a value out of the RGB gamut</haxe_doc>
		</getBounds>
		<maxSafeChromaForL public="1" set="method" line="88" static="1">
			<f a="L">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>For given lightness, returns the maximum chroma. Keeping the chroma value
    below this number will ensure that for any hue, the color is within the RGB
    gamut.</haxe_doc>
		</maxSafeChromaForL>
		<maxChromaForLH public="1" set="method" line="100" static="1"><f a="L:H">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></maxChromaForLH>
		<dotProduct set="method" line="115" static="1"><f a="a:b">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
</f></dotProduct>
		<fromLinear set="method" line="126" static="1"><f a="c">
	<x path="Float"/>
	<x path="Float"/>
</f></fromLinear>
		<toLinear set="method" line="134" static="1"><f a="c">
	<x path="Float"/>
	<x path="Float"/>
</f></toLinear>
		<xyzToRgb public="1" set="method" line="148" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* XYZ coordinates are ranging in [0;1] and RGB coordinates in [0;1] range.
    * @param tuple An array containing the color's X,Y and Z values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's red, green and blue.</haxe_doc>
		</xyzToRgb>
		<rgbToXyz public="1" set="method" line="167" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* RGB coordinates are ranging in [0;1] and XYZ coordinates in [0;1].
    * @param tuple An array containing the color's R,G,B values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's XYZ coordinates.</haxe_doc>
		</rgbToXyz>
		<yToL public="1" set="method" line="192" static="1"><f a="Y">
	<x path="Float"/>
	<x path="Float"/>
</f></yToL>
		<lToY public="1" set="method" line="200" static="1"><f a="L">
	<x path="Float"/>
	<x path="Float"/>
</f></lToY>
		<xyzToLuv public="1" set="method" line="214" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* XYZ coordinates are ranging in [0;1].
    * @param tuple An array containing the color's X,Y,Z values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's LUV coordinates.</haxe_doc>
		</xyzToLuv>
		<luvToXyz public="1" set="method" line="260" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* XYZ coordinates are ranging in [0;1].
    * @param tuple An array containing the color's L,U,V values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's XYZ coordinates.</haxe_doc>
		</luvToXyz>
		<luvToLch public="1" set="method" line="294" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* @param tuple An array containing the color's L,U,V values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's LCH coordinates.</haxe_doc>
		</luvToLch>
		<lchToLuv public="1" set="method" line="329" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* @param tuple An array containing the color's L,C,H values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's LUV coordinates.</haxe_doc>
		</lchToLuv>
		<hsluvToLch public="1" set="method" line="354" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100].
    * @param tuple An array containing the color's H,S,L values in HSLuv color space.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's LCH coordinates.</haxe_doc>
		</hsluvToLch>
		<lchToHsluv public="1" set="method" line="393" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100].
    * @param tuple An array containing the color's LCH values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's HSL coordinates in HSLuv color space.</haxe_doc>
		</lchToHsluv>
		<hpluvToLch public="1" set="method" line="431" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* HSLuv values are in [0;360], [0;100] and [0;100].
    * @param tuple An array containing the color's H,S,L values in HPLuv (pastel variant) color space.
    * @return An array containing the resulting color's LCH coordinates.</haxe_doc>
		</hpluvToLch>
		<lchToHpluv public="1" set="method" line="455" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100].
    * @param tuple An array containing the color's LCH values.
    * @return An array containing the resulting color's HSL coordinates in HPLuv (pastel variant) color space.</haxe_doc>
		</lchToHpluv>
		<rgbToHex public="1" set="method" line="480" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* RGB values are ranging in [0;1].
    * @param tuple An array containing the color's RGB values.
    * @return A string containing a `#RRGGBB` representation of given color.</haxe_doc>
		</rgbToHex>
		<hexToRgb public="1" set="method" line="499" static="1">
			<f a="hex">
				<c path="String"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* RGB values are ranging in [0;1].
    * @param hex A `#RRGGBB` representation of a color.
    * @return An array containing the color's RGB values.</haxe_doc>
		</hexToRgb>
		<lchToRgb public="1" set="method" line="517" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* RGB values are ranging in [0;1].
    * @param tuple An array containing the color's LCH values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's RGB coordinates.</haxe_doc>
		</lchToRgb>
		<rgbToLch public="1" set="method" line="533" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* RGB values are ranging in [0;1].
    * @param tuple An array containing the color's RGB values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's LCH coordinates.</haxe_doc>
		</rgbToLch>
		<hsluvToRgb public="1" set="method" line="552" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param tuple An array containing the color's HSL values in HSLuv color space.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's RGB coordinates.</haxe_doc>
		</hsluvToRgb>
		<rgbToHsluv public="1" set="method" line="568" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param tuple An array containing the color's RGB coordinates.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's HSL coordinates in HSLuv color space.</haxe_doc>
		</rgbToHsluv>
		<hpluvToRgb public="1" set="method" line="583" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param tuple An array containing the color's HSL values in HPLuv (pastel variant) color space.
    * @return An array containing the resulting color's RGB coordinates.</haxe_doc>
		</hpluvToRgb>
		<rgbToHpluv public="1" set="method" line="593" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param tuple An array containing the color's RGB coordinates.
    * @return An array containing the resulting color's HSL coordinates in HPLuv (pastel variant) color space.</haxe_doc>
		</rgbToHpluv>
		<hsluvToHex public="1" set="method" line="605" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param tuple An array containing the color's HSL values in HSLuv color space.
    * @return A string containing a `#RRGGBB` representation of given color.</haxe_doc>
		</hsluvToHex>
		<hpluvToHex public="1" set="method" line="610" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</hpluvToHex>
		<hexToHsluv public="1" set="method" line="620" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param tuple An array containing the color's HSL values in HPLuv (pastel variant) color space.
    * @return An array containing the color's HSL values in HSLuv color space.</haxe_doc>
		</hexToHsluv>
		<hexToHpluv public="1" set="method" line="630" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param hex A `#RRGGBB` representation of a color.
    * @return An array containing the color's HSL values in HPLuv (pastel variant) color space.</haxe_doc>
		</hexToHpluv>
		<haxe_doc>Human-friendly HSL conversion utility class.

The math for most of this module was taken from:

 * http://www.easyrgb.com
 * http://www.brucelindbloom.com
 * Wikipedia

All numbers below taken from math/bounds.wxm wxMaxima file. We use 17
digits of decimal precision to export the numbers, effectively exporting
them as double precision IEEE 754 floats.

"If an IEEE 754 double precision is converted to a decimal string with at
least 17 significant digits and then converted back to double, then the
final number must match the original"

Source: https://en.wikipedia.org/wiki/Double-precision_floating-point_format
=======</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="js.Boot" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/Boot.hx">
		<isClass get="inline" set="null" line="29" static="1">
			<f a="o">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isClass>
		<isInterface get="inline" set="null" line="33" static="1">
			<f a="o">
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isInterface>
		<isEnum get="inline" set="null" line="37" static="1">
			<f a="e">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isEnum>
		<getClass set="method" line="41" static="1">
			<f a="o">
				<x path="Null"><d/></x>
				<x path="Null"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getClass>
		<__string_rec set="method" line="58" static="1">
			<f a="o:s">
				<x path="Null"><a>
	<toString set="null"><f a=""><c path="String"/></f></toString>
	<length set="null"><x path="Int"/></length>
	<hasOwnProperty set="null"><x path="Null"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></x></hasOwnProperty>
	<_hx_index set="null"><x path="Int"/></_hx_index>
	<__enum__ set="null"><x path="Bool"/></__enum__>
</a></x>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"has_enum"</e></m>
			</meta>
		</__string_rec>
		<__interfLoop set="method" line="143" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="162" static="1">
			<f a="o:cl">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__instanceof>
		<__downcastCheck set="method" line="206" static="1"><f a="o:cl">
	<d/>
	<x path="Class"><d/></x>
	<x path="Bool"/>
</f></__downcastCheck>
		<__implements set="method" line="210" static="1"><f a="o:iface">
	<d/>
	<x path="Class"><d/></x>
	<x path="Bool"/>
</f></__implements>
		<__cast set="method" line="214" static="1">
			<f a="o:t">
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":ifFeature"><e>"typed_cast"</e></m></meta>
		</__cast>
		<__toStr static="1"><c path="js.lib.Function"/></__toStr>
		<__nativeClassName set="method" line="228" static="1"><f a="o">
	<d/>
	<c path="String"/>
</f></__nativeClassName>
		<__isNativeObj set="method" line="238" static="1"><f a="o">
	<d/>
	<x path="Bool"/>
</f></__isNativeObj>
		<__resolveNativeClass set="method" line="243" static="1"><f a="name">
	<c path="String"/>
	<x path="Null"><d/></x>
</f></__resolveNativeClass>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="js.Lib" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/Lib.hx">
		<require public="1" get="inline" set="null" line="65" static="1">
			<f a="module">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Inserts a `require` expression that loads JavaScript object from
		a module or file specified in the `module` argument.

		This is only supported in environments where `require` function
		is available, such as Node.js or RequireJS.</haxe_doc>
		</require>
		<parseInt public="1" get="accessor" set="null" static="1">
			<f a="string:?radix">
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Native JavaScript `parseInt` function.

		Its specification is different from `Std.parseInt`, so one
		might want to access the native one.</haxe_doc>
		</parseInt>
		<get_parseInt get="inline" set="null" line="77" static="1"><f a=""><f a="string:?radix">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
</f></f></get_parseInt>
		<undefined public="1" get="accessor" set="null" static="1">
			<d/>
			<haxe_doc>Returns JavaScript `undefined` value.

		Note that this is only needed in very rare cases when working with external JavaScript code.

		In Haxe, `null` is used to represent the absence of a value.</haxe_doc>
		</undefined>
		<get_undefined get="inline" set="null" line="90" static="1"><f a=""><d/></f></get_undefined>
		<nativeThis public="1" get="accessor" set="null" static="1">
			<d/>
			<haxe_doc>`nativeThis` is the JavaScript `this`, which is semantically different
		from the Haxe `this`. Use `nativeThis` only when working with external
		JavaScript code.

		In Haxe, `this` is always bound to a class instance.
		In JavaScript, `this` in a function can be bound to an arbitrary
		variable when the function is called using `func.call(thisObj, ...)` or
		`func.apply(thisObj, [...])`.

		Read more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this</haxe_doc>
		</nativeThis>
		<get_nativeThis get="inline" set="null" line="108" static="1"><f a=""><d/></f></get_nativeThis>
		<typeof public="1" get="inline" set="null" line="118" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Call JavaScript `typeof` operator on the `o` value
		and return a string representing the JavaScript type of a value.

		Read more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof</haxe_doc>
		</typeof>
		<global public="1" get="accessor" set="null" static="1">
			<d/>
			<haxe_doc>An alias of the JS "global" object.

		Concretely, it is set as the first defined value in the list of
		`window`, `global`, `self`, and `this` in the top-level of the compiled output.</haxe_doc>
		</global>
		<get_global get="inline" set="null" line="130" static="1">
			<f a=""><d/></f>
			<meta><m n=":has_untyped"/></meta>
		</get_global>
		<getNextHaxeUID get="inline" set="null" line="158" static="1">
			<f a=""><x path="Int"/></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":allow"><e>haxe.ds.ObjectMap.assignId</e></m>
			</meta>
			<haxe_doc>Generate next unique id</haxe_doc>
		</getNextHaxeUID>
		<haxe_doc>Platform-specific JavaScript Library. Provides some platform-specific functions
	for the JavaScript target.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="js.Node" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/Node.hx" extern="1">
		<__dirname public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>This variable may appear to be global but is not. See [__dirname](https://nodejs.org/api/modules.html#modules_dirname).</haxe_doc>
		</__dirname>
		<get___dirname get="inline" set="null" line="46" static="1"><f a=""><c path="String"/></f></get___dirname>
		<__filename public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>This variable may appear to be global but is not. See [__filename](https://nodejs.org/api/modules.html#modules_filename).</haxe_doc>
		</__filename>
		<get___filename get="inline" set="null" line="59" static="1"><f a=""><c path="String"/></f></get___filename>
		<clearImmediate public="1" set="method" static="1">
			<f a="immediate">
				<c path="js.node.Immediate"/>
				<x path="Void"/>
			</f>
			<haxe_doc>`clearImmediate` is described in the [timers](https://nodejs.org/api/timers.html) section.</haxe_doc>
		</clearImmediate>
		<clearInterval public="1" set="method" static="1">
			<f a="timeout">
				<c path="js.node.Timeout"/>
				<x path="Void"/>
			</f>
			<haxe_doc>`clearInterval` is described in the [timers](https://nodejs.org/api/timers.html) section.</haxe_doc>
		</clearInterval>
		<clearTimeout public="1" set="method" static="1">
			<f a="timeout">
				<c path="js.node.Timeout"/>
				<x path="Void"/>
			</f>
			<haxe_doc>`clearTimeout` is described in the [timers](https://nodejs.org/api/timers.html) section.</haxe_doc>
		</clearTimeout>
		<console public="1" get="accessor" set="null" static="1">
			<c path="js.node.console.Console"/>
			<haxe_doc>Used to print to stdout and stderr. See the [console](https://nodejs.org/api/console.html) section.</haxe_doc>
		</console>
		<get_console get="inline" set="null" line="87" static="1"><f a=""><c path="js.node.console.Console"/></f></get_console>
		<exports public="1" get="accessor" set="null" static="1">
			<d><d/></d>
			<haxe_doc>This variable may appear to be global but is not. See [exports](https://nodejs.org/api/modules.html#modules_exports).</haxe_doc>
		</exports>
		<get_exports get="inline" set="null" line="100" static="1"><f a=""><d><d/></d></f></get_exports>
		<global public="1" get="inline" set="null" expr="cast Node" line="114" static="1">
			<d><d/></d>
			<meta><m n=":value"><e>cast Node</e></m></meta>
			<haxe_doc>In browsers, the top-level scope is the global scope.
		This means that within the browser `var something` will define a new global variable.
		In Node.js this is different. The top-level scope is not the global scope; `var something` inside a Node.js module
		will be local to that module.</haxe_doc>
		</global>
		<module public="1" get="accessor" set="null" static="1">
			<c path="js.node.Module"/>
			<haxe_doc>This variable may appear to be global but is not. See [module](https://nodejs.org/api/modules.html#modules_module).</haxe_doc>
		</module>
		<get_module get="inline" set="null" line="121" static="1"><f a=""><c path="js.node.Module"/></f></get_module>
		<process public="1" get="accessor" set="null" static="1">
			<c path="js.node.Process"/>
			<haxe_doc>The process object. See the [process object](https://nodejs.org/api/process.html#process_process) section.</haxe_doc>
		</process>
		<get_process get="inline" set="null" line="134" static="1"><f a=""><c path="js.node.Process"/></f></get_process>
		<queueMicrotask public="1" set="method" static="1">
			<f a="callback">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>The `queueMicrotask()` method queues a microtask to invoke `callback`.
		If `callback` throws an exception, the [process object](https://nodejs.org/api/process.html#process_process) 'uncaughtException' event will be emitted.

		The microtask queue is managed by V8 and may be used in a similar manner to the `Process.nextTick()` queue,
		which is managed by Node.js.
		The `Process.nextTick()` queue is always processed before the microtask queue within each turn of the Node.js event loop.</haxe_doc>
		</queueMicrotask>
		<require public="1" get="inline" set="null" line="155" static="1">
			<f a="module">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>This variable may appear to be global but is not. See [require()](https://nodejs.org/api/modules.html#modules_require_id).</haxe_doc>
		</require>
		<setImmediate public="1" set="method" static="1">
			<f a="callback:args">
				<x path="haxe.Function"/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.node.Immediate"/>
			</f>
			<haxe_doc>`setImmediate` is described in the [timers](https://nodejs.org/api/timers.html) section.</haxe_doc>
		</setImmediate>
		<setInterval public="1" set="method" static="1">
			<f a="callback:delay:args">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.node.Timeout"/>
			</f>
			<haxe_doc>`setInterval` is described in the [timers](https://nodejs.org/api/timers.html) section.</haxe_doc>
		</setInterval>
		<setTimeout public="1" set="method" static="1">
			<f a="callback:delay:args">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.node.Timeout"/>
			</f>
			<haxe_doc>`setTimeout` is described in the [timers](https://nodejs.org/api/timers.html) section.</haxe_doc>
		</setTimeout>
		<haxe_doc>Node.js globals</haxe_doc>
		<meta><m n=":native"><e>"global"</e></m></meta>
	</class>
	<typedef path="js.TimeoutObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/Node.hx" module="js.Node">
		<c path="js.node.Timeout"/>
		<meta><m n=":deprecated"/></meta>
	</typedef>
	<typedef path="js.IntervalObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/Node.hx" module="js.Node">
		<c path="js.node.Timeout"/>
		<meta><m n=":deprecated"/></meta>
	</typedef>
	<typedef path="js.ImmediateObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/Node.hx" module="js.Node">
		<c path="js.node.Immediate"/>
		<meta><m n=":deprecated"/></meta>
	</typedef>
	<class path="js.lib.Uint8Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Uint8Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 1 in the case of an `Uint8Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Creates a new `Uint8Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Uint8Array"/>
	</f>
	<haxe_doc>Creates a new `Uint8Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Creates a new `Uint8Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Uint8Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Uint8Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Uint8Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Uint8Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint8Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint8Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Uint8Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<x path="Null"><t path="js.lib.intl.NumberFormatOptions"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Uint8Array` typed array represents an array of 8-bit unsigned integers. The contents
	are initialized to 0. Once established, you can reference elements in the array using the object's
	methods, or using standard array index syntax (that is, using bracket notation).

	Documentation [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Uint8Array"</e></m>
		</meta>
	</class>
	<class path="js.lib.Error" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Error.hx" extern="1">
		<message public="1"><c path="String"/></message>
		<name public="1"><c path="String"/></name>
		<stack public="1" set="null"><c path="String"/></stack>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Error"</e></m>
		</meta>
	</class>
	<class path="js.lib.EvalError" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"EvalError"</e></m></meta>
	</class>
	<class path="js.lib.RangeError" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"RangeError"</e></m></meta>
	</class>
	<class path="js.lib.ReferenceError" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"ReferenceError"</e></m></meta>
	</class>
	<class path="js.lib.SyntaxError" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"SyntaxError"</e></m></meta>
	</class>
	<class path="js.lib.TypeError" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"TypeError"</e></m></meta>
	</class>
	<class path="js.lib.URIError" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"URIError"</e></m></meta>
	</class>
	<class path="js.lib.Float32Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Float32Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 4 in the case of an `Float32Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Float"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Creates a new `Float32Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Float"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Float32Array"/>
	</f>
	<haxe_doc>Creates a new `Float32Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Creates a new `Float32Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Float32Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Float32Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Float32Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Float32Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Float"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float32Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float32Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Float"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Float"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float32Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Float"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float32Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Float"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="js.lib.Float32Array"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Float"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="js.lib.Float32Array"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Float32Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="Array"><x path="Int"/></c>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Float"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<x path="Null"><t path="js.lib.intl.NumberFormatOptions"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Float32Array` typed array represents an array of 32-bit floating point numbers
	(corresponding to the C float data type) in the platform byte order. If control over byte order is
	needed, use `DataView` instead. The contents are initialized to `0`. Once established, you can
	reference elements in the array using the object's methods, or using standard array index
	syntax (that is, using bracket notation)

	Documentation [Float32Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Float32Array"</e></m></meta>
	</class>
	<class path="js.lib.Float64Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Float64Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 8 in the case of an `Float64Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Float"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Creates a new `Float64Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Float"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Float64Array"/>
	</f>
	<haxe_doc>Creates a new `Float64Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Creates a new `Float64Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Float64Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Float64Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Float64Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Float64Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Float"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float64Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float64Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Float"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Float"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float64Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Float"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float64Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Float"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="js.lib.Float64Array"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Float"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="js.lib.Float64Array"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Float64Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="Array"><x path="Int"/></c>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Float"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<x path="Null"><t path="js.lib.intl.NumberFormatOptions"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Float64Array` typed array represents an array of 64-bit floating point numbers
	(corresponding to the C double data type) in the platform byte order. If control over byte order
	is needed, use `DataView` instead. The contents are initialized to `0`. Once established, you can
	reference elements in the array using the object's methods, or using standard array index
	syntax (that is, using bracket notation).

	Documentation [Float64Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Float64Array"</e></m></meta>
	</class>
	<class path="js.lib.Function" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Function.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Specifies the number of arguments expected by the function.</haxe_doc>
		</length>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the function.</haxe_doc>
		</name>
		<apply public="1" set="method">
			<f a="thisArg:argsArray">
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Calls a function and sets its this to the provided value, arguments can be passed as an Array object.</haxe_doc>
		</apply>
		<call public="1" set="method">
			<f a="thisArg:args">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<d/>
			</f>
			<haxe_doc>Calls (executes) a function and sets its this to the provided value, arguments can be passed as they are.</haxe_doc>
		</call>
		<bind public="1" set="method">
			<f a="thisArg:args">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.lib.Function"/>
			</f>
			<haxe_doc>Creates a new function which, when called, has its this set to the provided value,
		with a given sequence of arguments preceding any provided when the new function was called.</haxe_doc>
		</bind>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the source code of the function.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="arg:rest">
				<c path="String"/>
				<t path="haxe.extern.Rest"><c path="String"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Function object.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Function"</e></m>
		</meta>
	</class>
	<class path="js.lib.Int16Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Int16Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 2 in the case of an `Int16Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Creates a new `Int16Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Int16Array"/>
	</f>
	<haxe_doc>Creates a new `Int16Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Creates a new `Int16Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Int16Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Int16Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Int16Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Int16Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int16Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int16Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int16Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int16Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Int16Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Int16Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Int16Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<x path="Null"><t path="js.lib.intl.NumberFormatOptions"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Int16Array` typed array represents an array of twos-complement 16-bit signed integers in
	the platform byte order. If control over byte order is needed, use `DataView` instead. The
	contents are initialized to 0. Once established, you can reference elements in the array using
	the object's methods, or using standard array index syntax (that is, using bracket notation).

	Documentation [Int16Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Int16Array"</e></m></meta>
	</class>
	<class path="js.lib.Int32Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Int32Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 4 in the case of an `Int32Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Creates a new `Int32Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Int32Array"/>
	</f>
	<haxe_doc>Creates a new `Int32Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Creates a new `Int32Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Int32Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Int32Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Int32Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Int32Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int32Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int32Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int32Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int32Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Int32Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Int32Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Int32Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<x path="Null"><t path="js.lib.intl.NumberFormatOptions"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Int32Array` typed array represents an array of twos-complement 32-bit signed integers in
	the platform byte order. If control over byte order is needed, use `DataView` instead. The
	contents are initialized to `0`. Once established, you can reference elements in the array using
	the object's methods, or using standard array index syntax (that is, using bracket notation).

	Documentation [Int32Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Int32Array"</e></m></meta>
	</class>
	<class path="js.lib.Int8Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Int8Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 1 in the case of an `Int8Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Creates a new `Int8Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Int8Array"/>
	</f>
	<haxe_doc>Creates a new `Int8Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Creates a new `Int8Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Int8Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Int8Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Int8Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Int8Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int8Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int8Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int8Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int8Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Int8Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Int8Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Int8Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<x path="Null"><t path="js.lib.intl.NumberFormatOptions"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Int8Array` typed array represents an array of twos-complement 8-bit signed integers. The
	contents are initialized to 0. Once established, you can reference elements in the array using
	the object's methods, or using standard array index syntax (that is, using bracket notation).

	Documentation [Int8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Int8Array"</e></m></meta>
	</class>
	<typedef path="js.lib.Iterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Iterator.hx">
		<a><next set="method"><f a=""><t path="js.lib.IteratorStep"><c path="js.lib.Iterator.T"/></t></f></next></a>
		<haxe_doc>Native JavaScript iterator structure. To enable haxe for-in iteration, use `js.lib.HaxeIterator`, for example `for (v in new js.lib.HaxeIterator(jsIterator))` or add `using js.lib.HaxeIterator;` to your module

	See [Iteration Protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)</haxe_doc>
	</typedef>
	<typedef path="js.lib.AsyncIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Iterator.hx" module="js.lib.Iterator">
		<a><next set="method"><f a=""><c path="js.lib.Promise"><t path="js.lib.IteratorStep"><c path="js.lib.AsyncIterator.T"/></t></c></f></next></a>
		<haxe_doc>Native JavaScript async iterator structure. 

	See [for await...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of)</haxe_doc>
	</typedef>
	<typedef path="js.lib.IteratorStep" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Iterator.hx" module="js.lib.Iterator"><a>
	<value>
		<x path="Null"><c path="js.lib.IteratorStep.T"/></x>
		<meta><m n=":optional"/></meta>
	</value>
	<done><x path="Bool"/></done>
</a></typedef>
	<abstract path="js.lib.KeyValue" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/KeyValue.hx">
		<this><c path="Array"><x path="Any"/></c></this>
		<haxe_doc>Key/value access helper.</haxe_doc>
		<impl><class path="js.lib._KeyValue.KeyValue_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/KeyValue.hx" private="1" module="js.lib.KeyValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="js.lib.ObjectPrototype" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Object.hx" module="js.lib.Object">
		<a>
			<valueOf set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns the primitive value of the specified object.</haxe_doc>
			</valueOf>
			<toString set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a string representation of the object.</haxe_doc>
			</toString>
			<toLocaleString set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Calls `toString()`.</haxe_doc>
			</toLocaleString>
			<propertyIsEnumerable set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a boolean indicating if the internal enumerable attribute is set.</haxe_doc>
			</propertyIsEnumerable>
			<isPrototypeOf set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a boolean indicating whether the object this method is called
		upon is in the prototype chain of the specified object.</haxe_doc>
			</isPrototypeOf>
			<hasOwnProperty set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a boolean indicating whether an object contains the specified
		property as a direct property of that object and not inherited through
		the prototype chain.</haxe_doc>
			</hasOwnProperty>
		</a>
		<haxe_doc><![CDATA[Type for
	@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object>]]></haxe_doc>
	</typedef>
	<typedef path="js.lib.ObjectPropertyDescriptor" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Object.hx" module="js.lib.Object">
		<a>
			<writable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>`true` if and only if the value associated with the property may be
		changed with an assignment operator.

		Defaults to `false`.</haxe_doc>
			</writable>
			<value>
				<x path="Null"><x path="Any"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The value associated with the property.
		Can be any valid JavaScript value (number, object, function, etc).</haxe_doc>
			</value>
			<set>
				<x path="Null"><f a="">
	<x path="Any"/>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A function which serves as a setter for the property, or undefined if
		there is no setter. When the property is assigned to, this function
		is called with one argument (the value being assigned to the property)
		and with `this` set to the object through which the property is assigned.</haxe_doc>
			</set>
			<get>
				<x path="Null"><f a=""><x path="Any"/></f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A function which serves as a getter for the property, or `undefined` if
		there is no getter. When the property is accessed, this function is
		called without arguments and with `this` set to the object through which
		the property is accessed (this may not be the object on which the
		property is defined due to inheritance).
		The return value will be used as the value of the property.</haxe_doc>
			</get>
			<enumerable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>`true` if and only if this property shows up during enumeration of the
		properties on the corresponding object.

		Defaults to `false`.</haxe_doc>
			</enumerable>
			<configurable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>`true` if and only if the type of this property descriptor may be
		changed and if the property may be deleted from the corresponding object.

		Defaults to `false`.</haxe_doc>
			</configurable>
		</a>
		<haxe_doc><![CDATA[@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty>]]></haxe_doc>
	</typedef>
	<abstract path="js.lib.ObjectEntry" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Object.hx" module="js.lib.Object">
		<this><c path="Array"><x path="Any"/></c></this>
		<haxe_doc>Key/value access helper for `js.lib.Object.entries()`.</haxe_doc>
		<impl><class path="js.lib._Object.ObjectEntry_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Object.hx" private="1" module="js.lib.Object" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="js.lib.Promise" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Promise.hx" extern="1">
		<resolve public="1" params="T" set="method" static="1">
			<f a="thenable">
				<x path="js.lib.Thenable"><c path="resolve.T"/></x>
				<c path="js.lib.Promise"><c path="resolve.T"/></c>
			</f>
			<haxe_doc>Returns a Promise object that is resolved with the given value. If the
		value is Thenable, the returned promise will "follow" that
		thenable, adopting its eventual state;
		otherwise the returned promise will be fulfilled with the value.
		Generally, when it's unknown when value is a promise or not,
		use `Promise.resolve(value)` instead and work with the return value as
		a promise.</haxe_doc>
			<overloads><resolve public="1" params="T" set="method">
	<f a="?value">
		<c path="resolve.T"/>
		<c path="js.lib.Promise"><c path="resolve.T"/></c>
	</f>
	<haxe_doc>Returns a Promise object that is resolved with the given value. If the
		value is Thenable, the returned promise will "follow" that
		thenable, adopting its eventual state;
		otherwise the returned promise will be fulfilled with the value.
		Generally, when it's unknown when value is a promise or not,
		use `Promise.resolve(value)` instead and work with the return value as
		a promise.</haxe_doc>
</resolve></overloads>
		</resolve>
		<reject public="1" params="T" set="method" static="1">
			<f a="?reason">
				<d/>
				<c path="js.lib.Promise"><c path="reject.T"/></c>
			</f>
			<haxe_doc>Returns a Promise object that is rejected with the given reason.</haxe_doc>
		</reject>
		<all public="1" params="T" set="method" static="1">
			<f a="iterable">
				<c path="Array"><c path="js.lib.Promise"><c path="all.T"/></c></c>
				<c path="js.lib.Promise"><c path="Array"><c path="all.T"/></c></c>
			</f>
			<haxe_doc>Returns a promise that either fulfills when all of the promises in the
		iterable argument have fulfilled or rejects as soon as one of the
		promises in the iterable argument rejects. If the returned promise
		fulfills, it is fulfilled with an array of the values from the
		fulfilled promises in the same order as defined in the iterable.
		If the returned promise rejects, it is rejected with the reason from
		the first promise in the iterable that rejected. This method can be
		useful for aggregating results of multiple promises.</haxe_doc>
			<overloads><all public="1" set="method">
	<f a="iterable">
		<c path="Array"><d/></c>
		<c path="js.lib.Promise"><c path="Array"><d/></c></c>
	</f>
	<haxe_doc>Returns a promise that either fulfills when all of the promises in the
		iterable argument have fulfilled or rejects as soon as one of the
		promises in the iterable argument rejects. If the returned promise
		fulfills, it is fulfilled with an array of the values from the
		fulfilled promises in the same order as defined in the iterable.
		If the returned promise rejects, it is rejected with the reason from
		the first promise in the iterable that rejected. This method can be
		useful for aggregating results of multiple promises.</haxe_doc>
</all></overloads>
		</all>
		<allSettled public="1" params="T" set="method" static="1">
			<f a="iterable">
				<c path="Array"><c path="js.lib.Promise"><c path="allSettled.T"/></c></c>
				<c path="js.lib.Promise"><c path="Array"><t path="js.lib.PromiseSettleOutcome"><c path="allSettled.T"/></t></c></c>
			</f>
			<haxe_doc>Returns a promise that resolves after all of the given promises have either fulfilled or rejected,
		with an array of objects that each describes the outcome of each promise.

		It is typically used when you have multiple asynchronous tasks that are not dependent on one another
		to complete successfully, or you'd always like to know the result of each promise.

		In comparison, the Promise returned by `Promise.all` may be more appropriate if the tasks are dependent
		on each other / if you'd like to immediately reject upon any of them rejecting.</haxe_doc>
			<overloads><allSettled public="1" set="method">
	<f a="iterable">
		<c path="Array"><d/></c>
		<c path="js.lib.Promise"><c path="Array"><t path="js.lib.PromiseSettleOutcome"><d/></t></c></c>
	</f>
	<haxe_doc>Returns a promise that resolves after all of the given promises have either fulfilled or rejected,
		with an array of objects that each describes the outcome of each promise.

		It is typically used when you have multiple asynchronous tasks that are not dependent on one another
		to complete successfully, or you'd always like to know the result of each promise.

		In comparison, the Promise returned by `Promise.all` may be more appropriate if the tasks are dependent
		on each other / if you'd like to immediately reject upon any of them rejecting.</haxe_doc>
</allSettled></overloads>
		</allSettled>
		<race public="1" params="T" set="method" static="1">
			<f a="iterable">
				<c path="Array"><c path="js.lib.Promise"><c path="race.T"/></c></c>
				<c path="js.lib.Promise"><c path="race.T"/></c>
			</f>
			<haxe_doc>Returns a promise that fulfills or rejects as soon as one of the
		promises in the iterable fulfills or rejects, with the value or reason
		from that promise.</haxe_doc>
			<overloads><race public="1" set="method">
	<f a="iterable">
		<c path="Array"><d/></c>
		<c path="js.lib.Promise"><d/></c>
	</f>
	<haxe_doc>Returns a promise that fulfills or rejects as soon as one of the
		promises in the iterable fulfills or rejects, with the value or reason
		from that promise.</haxe_doc>
</race></overloads>
		</race>
		<then public="1" params="TOut" set="method">
			<f a="onFulfilled:?onRejected">
				<x path="Null"><x path="js.lib.PromiseHandler">
	<c path="js.lib.Promise.T"/>
	<c path="then.TOut"/>
</x></x>
				<x path="js.lib.PromiseHandler">
					<d/>
					<c path="then.TOut"/>
				</x>
				<c path="js.lib.Promise"><c path="then.TOut"/></c>
			</f>
			<haxe_doc>Appends fulfillment and rejection handlers to the promise and returns a
		new promise resolving to the return value of the called handler, or to
		its original settled value if the promise was not handled
		(i.e. if the relevant handler onFulfilled or onRejected is not a function).</haxe_doc>
		</then>
		<catchError public="1" set="method">
			<f a="onRejected">
				<x path="js.lib.PromiseHandler">
					<d/>
					<c path="js.lib.Promise.T"/>
				</x>
				<c path="js.lib.Promise"><c path="js.lib.Promise.T"/></c>
			</f>
			<meta><m n=":native"><e>"catch"</e></m></meta>
			<haxe_doc>Appends a rejection handler callback to the promise, and returns a new
		promise resolving to the return value of the callback if it is called,
		or to its original fulfillment value if the promise is instead fulfilled.</haxe_doc>
			<overloads><catch public="1" params="TOut" set="method">
	<f a="onRejected">
		<x path="js.lib.PromiseHandler">
			<d/>
			<c path="catchError.TOut"/>
		</x>
		<c path="js.lib.Promise"><x path="haxe.extern.EitherType">
	<c path="js.lib.Promise.T"/>
	<c path="catchError.TOut"/>
</x></c>
	</f>
	<meta><m n=":native"><e>"catch"</e></m></meta>
	<haxe_doc>Appends a rejection handler callback to the promise, and returns a new
		promise resolving to the return value of the callback if it is called,
		or to its original fulfillment value if the promise is instead fulfilled.</haxe_doc>
</catch></overloads>
		</catchError>
		<finally public="1" set="method">
			<f a="onFinally">
				<f a=""><x path="Void"/></f>
				<c path="js.lib.Promise"><c path="js.lib.Promise.T"/></c>
			</f>
			<haxe_doc>Returns a Promise. When the promise is settled, i.e either fulfilled or rejected,
		the specified callback function is executed. This provides a way for code to be run
		whether the promise was fulfilled successfully or rejected once the Promise has been dealt with.</haxe_doc>
		</finally>
		<new public="1" set="method">
			<f a="init">
				<f a="resolve:reject">
					<f a="value">
						<c path="js.lib.Promise.T"/>
						<x path="Void"/>
					</f>
					<f a="reason">
						<d/>
						<x path="Void"/>
					</f>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<haxe_doc>The Promise object represents the eventual completion (or failure) of an
	asynchronous operation and its resulting value.

	Documentation [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Promise"</e></m></meta>
	</class>
	<abstract path="js.lib.PromiseHandler" params="T:TOut" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Promise.hx" module="js.lib.Promise">
		<from>
			<icast><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<c path="js.lib.Promise"><c path="js.lib.PromiseHandler.TOut"/></c>
</f></icast>
			<icast><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<x path="js.lib.Thenable"><c path="js.lib.PromiseHandler.TOut"/></x>
</f></icast>
			<icast><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<c path="js.lib.PromiseHandler.TOut"/>
</f></icast>
		</from>
		<this><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<d/>
</f></this>
		<haxe_doc>Handler type for the Promise object.</haxe_doc>
		<impl><class path="js.lib._Promise.PromiseHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Promise.hx" private="1" module="js.lib.Promise" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="js.lib.Thenable" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Promise.hx" module="js.lib.Promise">
		<from><icast><t path="js.lib.ThenableStruct"><c path="js.lib.Thenable.T"/></t></icast></from>
		<this><t path="js.lib.ThenableStruct"><c path="js.lib.Thenable.T"/></t></this>
		<haxe_doc>A value with a `then` method.</haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":transitive"/>
		</meta>
		<impl><class path="js.lib._Promise.Thenable_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Promise.hx" private="1" module="js.lib.Promise" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="js.lib.ThenableStruct" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Promise.hx" module="js.lib.Promise"><a><then params="TOut" set="method"><f a="onFulfilled:?onRejected">
	<x path="Null"><x path="js.lib.PromiseHandler">
	<c path="js.lib.ThenableStruct.T"/>
	<c path="then.TOut"/>
</x></x>
	<x path="js.lib.PromiseHandler">
		<d/>
		<c path="then.TOut"/>
	</x>
	<x path="js.lib.Thenable"><c path="then.TOut"/></x>
</f></then></a></typedef>
	<typedef path="js.lib.PromiseSettleOutcome" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Promise.hx" module="js.lib.Promise"><a>
	<value>
		<x path="Null"><c path="js.lib.PromiseSettleOutcome.T"/></x>
		<meta><m n=":optional"/></meta>
	</value>
	<status><x path="js.lib.PromiseSettleStatus"/></status>
	<reason>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</reason>
</a></typedef>
	<abstract path="js.lib.PromiseSettleStatus" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Promise.hx" module="js.lib.Promise">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.lib._Promise.PromiseSettleStatus_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Promise.hx" private="1" module="js.lib.Promise" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.lib.RegExpMatch" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/RegExp.hx" module="js.lib.RegExp" extern="1">
		<extends path="Array"><c path="String"/></extends>
		<index public="1">
			<x path="Int"/>
			<haxe_doc>The index of the search at which the result was found.</haxe_doc>
		</index>
		<input public="1">
			<c path="String"/>
			<haxe_doc>A copy of the search string.</haxe_doc>
		</input>
		<groups public="1">
			<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
			<haxe_doc>Named capturing groups or undefined if no named capturing groups were defined.
		See [Groups and Ranges](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges) for more information.

		Note: Not all browsers support this feature; refer to the [compatibility table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Browser_compatibility).</haxe_doc>
		</groups>
		<haxe_doc>A return value of the `RegExp.exec` method.</haxe_doc>
	</class>
	<class path="js.lib.Symbol" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Symbol.hx" extern="1">
		<for_ public="1" set="method" static="1">
			<f a="key">
				<c path="String"/>
				<c path="js.lib.Symbol"/>
			</f>
			<meta><m n=":native"><e>"for"</e></m></meta>
			<haxe_doc>Searches for existing symbols with the given key and returns it if found.
		Otherwise a new symbol gets created in the global symbol registry with this key.</haxe_doc>
		</for_>
		<keyFor public="1" set="method" static="1">
			<f a="sym">
				<c path="js.lib.Symbol"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<haxe_doc>Retrieves a shared symbol key from the global symbol registry for the given symbol.</haxe_doc>
		</keyFor>
		<iterator public="1" set="null" static="1">
			<c path="js.lib.Symbol"/>
			<haxe_doc>A method returning the default iterator for an object.</haxe_doc>
		</iterator>
		<asyncIterator public="1" set="null" static="1">
			<c path="js.lib.Symbol"/>
			<haxe_doc>A method that returns the default AsyncIterator for an object.</haxe_doc>
		</asyncIterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string containing the description of the Symbol.</haxe_doc>
		</toString>
		<ofObject public="1" params="T" get="inline" set="null" line="67">
			<f a="object">
				<a/>
				<x path="Null"><c path="ofObject.T"/></x>
			</f>
			<haxe_doc>Retrieve symbol from a given `object`.

		NOTE: This is a Haxe-specific method that generates an `object[symbol]` expression.</haxe_doc>
		</ofObject>
		<new public="1" set="method">
			<f a="?description">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":selfCall"/></meta>
			<haxe_doc>To create a new primitive symbol, use `new Symbol()` with an optional string as its `description`.

		NOTE: Unlike in plain JavaScript, `new Symbol()` syntax is used in Haxe. This generates a `Symbol(...)`
		expression as required by the JavaScript specification.</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Symbol"</e></m></meta>
	</class>
	<class path="js.lib.Uint16Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Uint16Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 2 in the case of an `Uint16Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Creates a new `Uint16Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Uint16Array"/>
	</f>
	<haxe_doc>Creates a new `Uint16Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Creates a new `Uint16Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Uint16Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Uint16Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Uint16Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Uint16Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint16Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint16Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint16Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint16Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint16Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint16Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Uint16Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<x path="Null"><t path="js.lib.intl.NumberFormatOptions"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Uint16Array` typed array represents an array of 16-bit unsigned integers in the platform
	byte order. If control over byte order is needed, use `DataView` instead. The contents are
	initialized to `0`. Once established, you can reference elements in the array using the object's
	methods, or using standard array index syntax (that is, using bracket notation).

	Documentation [Uint16Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Uint16Array"</e></m></meta>
	</class>
	<class path="js.lib.Uint32Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Uint32Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 4 in the case of an `Uint32Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Creates a new `Uint32Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Uint32Array"/>
	</f>
	<haxe_doc>Creates a new `Uint32Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Creates a new `Uint32Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Uint32Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Uint32Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Uint32Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Uint32Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint32Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint32Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint32Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint32Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint32Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint32Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Uint32Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<x path="Null"><t path="js.lib.intl.NumberFormatOptions"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Uint32Array` typed array represents an array of 32-bit unsigned integers in the platform
	byte order. If control over byte order is needed, use `DataView` instead. The contents are
	initialized to `0`. Once established, you can reference elements in the array using the object's
	methods, or using standard array index syntax (that is, using bracket notation).

	Documentation [Uint32Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Uint32Array"</e></m></meta>
	</class>
	<class path="js.lib.Uint8ClampedArray" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/Uint8ClampedArray.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 1 in the case of an `Uint8ClampedArray`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Creates a new `Uint8ClampedArray` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Uint8ClampedArray"/>
	</f>
	<haxe_doc>Creates a new `Uint8ClampedArray` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Creates a new `Uint8ClampedArray` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Uint8ClampedArray` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Uint8ClampedArray` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Uint8ClampedArray` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Uint8ClampedArray`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8ClampedArray"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8ClampedArray"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8ClampedArray"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8ClampedArray"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint8ClampedArray"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint8ClampedArray"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Uint8ClampedArray"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<x path="Null"><t path="js.lib.intl.NumberFormatOptions"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Uint8ClampedArray` typed array represents an array of 8-bit unsigned integers clamped
	to 0-255; if you specified a value that is out of the range of [0,255], 0 or 255 will be set instead;
	if you specify a non-integer, the nearest integer will be set. The contents are initialized to `0`.
	Once established, you can reference elements in the array using the object's methods, or using
	standard array index syntax (that is, using bracket notation).

	Documentation [Uint8ClampedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Uint8ClampedArray"</e></m></meta>
	</class>
	<abstract path="js.lib.intl.LocaleMatcher" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/LocaleMatcher.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.lib.intl._LocaleMatcher.LocaleMatcher_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/LocaleMatcher.hx" private="1" module="js.lib.intl.LocaleMatcher" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.lib.intl.NumberFormat" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/NumberFormat.hx" extern="1">
		<supportedLocalesOf public="1" set="method" static="1">
			<f a="locales:?options">
				<c path="String"/>
				<x path="Null"><t path="js.lib.intl.NumberFormatSupportedLocalesOfOptions"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns an array containing those of the provided locales that are supported
		without having to fall back to the runtime's default locale.</haxe_doc>
			<overloads><supportedLocalesOf public="1" set="method">
	<f a="locales:?options">
		<c path="Array"><c path="String"/></c>
		<x path="Null"><t path="js.lib.intl.NumberFormatSupportedLocalesOfOptions"/></x>
		<c path="Array"><c path="String"/></c>
	</f>
	<haxe_doc>Returns an array containing those of the provided locales that are supported
		without having to fall back to the runtime's default locale.</haxe_doc>
</supportedLocalesOf></overloads>
		</supportedLocalesOf>
		<format public="1" set="method">
			<f a="number">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>Getter function that formats a number according to the locale
		and formatting options of this `NumberFormat` object.</haxe_doc>
		</format>
		<formatToParts public="1" set="method">
			<f a="?number">
				<x path="Float"/>
				<c path="Array"><t path="js.lib.intl.NumberFormatPart"/></c>
			</f>
			<haxe_doc>Returns an `Array` of objects representing the number string in parts
		that can be used for custom locale-aware formatting.</haxe_doc>
		</formatToParts>
		<resolvedOptions public="1" set="method">
			<f a=""><t path="js.lib.intl.NumberFormatResolvedOption"/></f>
			<haxe_doc>Returns a new object with properties reflecting the locale and collation options
		computed during initialization of the object.</haxe_doc>
		</resolvedOptions>
		<new public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<x path="Null"><t path="js.lib.intl.NumberFormatOptions"/></x>
				<x path="Void"/>
			</f>
			<overloads><new public="1" set="method"><f a="?locales:?options">
	<c path="Array"><c path="String"/></c>
	<x path="Null"><t path="js.lib.intl.NumberFormatOptions"/></x>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<haxe_doc>The `NumberFormat` object is a constructor for objects that enable language sensitive number formatting.

	Documentation [NumberFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Intl.NumberFormat"</e></m></meta>
	</class>
	<typedef path="js.lib.intl.NumberFormatOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat"><a>
	<useGrouping>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators.
		The default is `true`.</haxe_doc>
	</useGrouping>
	<style>
		<x path="Null"><x path="js.lib.intl.NumberFormatStyle"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The formatting style to use.
		The default is `Decimal`.</haxe_doc>
	</style>
	<minimumSignificantDigits>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The minimum number of significant digits to use.
		Possible values are from 1 to 21; the default is 1.</haxe_doc>
	</minimumSignificantDigits>
	<minimumIntegerDigits>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The minimum number of integer digits to use.
		Possible values are from 1 to 21; the default is 1.</haxe_doc>
	</minimumIntegerDigits>
	<minimumFractionDigits>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The minimum number of fraction digits to use.
		Possible values are from 0 to 20; the default for plain number and percent formatting is 0;
		the default for currency formatting is the number of minor unit digits provided by the
		[ISO 4217 currency code list](http://www.currency-iso.org/en/home/tables/table-a1.html)
		(2 if the list doesn't provide that information).</haxe_doc>
	</minimumFractionDigits>
	<maximumSignificantDigits>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The maximum number of significant digits to use.
		Possible values are from 1 to 21; the default is 21.</haxe_doc>
	</maximumSignificantDigits>
	<maximumFractionDigits>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The maximum number of fraction digits to use.
		Possible values are from 0 to 20; the default for plain number formatting is the larger of
		minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits
		and the number of minor unit digits provided by the [ISO 4217 currency code list](http://www.currency-iso.org/en/home/tables/table-a1.html)
		(2 if the list doesn't provide that information); the default for percent formatting is the larger of
		minimumFractionDigits and 0.</haxe_doc>
	</maximumFractionDigits>
	<localeMatcher>
		<x path="Null"><x path="js.lib.intl.LocaleMatcher"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The locale matching algorithm to use.
		The default is `BestFit`.
		For information about this option, see the [Intl page](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_negotiation).</haxe_doc>
	</localeMatcher>
	<currencyDisplay>
		<x path="Null"><x path="js.lib.intl.CurrencyDisplay"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>How to display the currency in currency formatting.
		The default is `Symbol`.</haxe_doc>
	</currencyDisplay>
	<currency>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc><![CDATA[The currency to use in currency formatting. Possible values are the ISO 4217 currency codes,
		such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB  see the
		[Current currency & funds code list](https://www.currency-iso.org/en/home/tables/table-a1.html).
		There is no default value; if the style is "currency", the currency property must be provided.]]></haxe_doc>
	</currency>
</a></typedef>
	<typedef path="js.lib.intl.NumberFormatResolvedOption" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat"><a>
	<useGrouping final="1" set="null">
		<c path="String"/>
		<haxe_doc>The values provided for these properties in the `options` argument or filled in as defaults.</haxe_doc>
	</useGrouping>
	<style final="1" set="null"><x path="js.lib.intl.NumberFormatStyle"/></style>
	<numberingSystem final="1" set="null">
		<c path="String"/>
		<haxe_doc>The value requested using the Unicode extension key `"nu"` or filled in as a default.</haxe_doc>
	</numberingSystem>
	<minimumSignificantDigits final="1" set="null"><x path="Int"/></minimumSignificantDigits>
	<minimumIntegerDigits final="1" set="null"><x path="Int"/></minimumIntegerDigits>
	<minimumFractionDigits final="1" set="null"><x path="Int"/></minimumFractionDigits>
	<maximumSignificantDigits final="1" set="null">
		<x path="Int"/>
		<haxe_doc>The values provided for these properties in the `options` argument or filled in as defaults.
		These properties are present only if at least one of them was provided in the `options` argument.</haxe_doc>
	</maximumSignificantDigits>
	<maximumFractionDigits final="1" set="null">
		<x path="Int"/>
		<haxe_doc>The values provided for these properties in the `options` argument or filled in as defaults.
		These properties are present only if neither m`inimumSignificantDigits` nor `maximumSignificantDigits`
		was provided in the `options` argument.</haxe_doc>
	</maximumFractionDigits>
	<locale final="1" set="null">
		<c path="String"/>
		<haxe_doc>The BCP 47 language tag for the locale actually used. If any Unicode extension values were
		requested in the input BCP 47 language tag that led to this locale, the key-value pairs that
		were requested and are supported for this locale are included in `locale`.</haxe_doc>
	</locale>
	<currencyDisplay final="1" set="null">
		<c path="String"/>
		<haxe_doc>The values provided for these properties in the `options` argument or filled in as defaults.
		These properties are only present if `style` is `"currency"`.</haxe_doc>
	</currencyDisplay>
	<currency final="1" set="null"><c path="String"/></currency>
</a></typedef>
	<abstract path="js.lib.intl.NumberFormatStyle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.lib.intl._NumberFormat.NumberFormatStyle_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/NumberFormat.hx" private="1" module="js.lib.intl.NumberFormat" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="js.lib.intl.CurrencyDisplay" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.lib.intl._NumberFormat.CurrencyDisplay_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/NumberFormat.hx" private="1" module="js.lib.intl.NumberFormat" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<typedef path="js.lib.intl.NumberFormatPart" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat"><a>
	<value final="1" set="null"><c path="String"/></value>
	<type final="1" set="null"><x path="js.lib.intl.NumberFormatPartType"/></type>
</a></typedef>
	<abstract path="js.lib.intl.NumberFormatPartType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.lib.intl._NumberFormat.NumberFormatPartType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/NumberFormat.hx" private="1" module="js.lib.intl.NumberFormat" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<typedef path="js.lib.intl.NumberFormatSupportedLocalesOfOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat"><a><localeMatcher>
	<x path="Null"><x path="js.lib.intl.LocaleMatcher"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The locale matching algorithm to use.
		The default is `BestFit`.</haxe_doc>
</localeMatcher></a></typedef>
	<typedef path="js.node.Buffer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Buffer.hx"><c path="js.node.buffer.Buffer"/></typedef>
	<typedef path="js.node._ChildProcess.ChildProcessCommonOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Common options for all `ChildProcess` methods.</haxe_doc>
	</typedef>
	<typedef path="js.node._ChildProcess.ChildProcessSpawnOptionsBase" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<stdio>
				<x path="Null"><t path="js.node.ChildProcessSpawnOptionsStdio"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Child's stdio configuration.</haxe_doc>
			</stdio>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Common options for `spawn` and `spawnSync` methods.</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessSpawnOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<stdio>
				<x path="Null"><t path="js.node.ChildProcessSpawnOptionsStdio"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Child's stdio configuration.</haxe_doc>
			</stdio>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<detached>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The child will be a process group leader.</haxe_doc>
			</detached>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Options for the `spawn` method.</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessSpawnSyncOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<timeout>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If greater than 0, then it will kill the child process if it runs longer than timeout milliseconds.</haxe_doc>
			</timeout>
			<stdio>
				<x path="Null"><t path="js.node.ChildProcessSpawnOptionsStdio"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Child's stdio configuration.</haxe_doc>
			</stdio>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<maxBuffer>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The largest amount of data allowed on stdout or stderr.
		If this value is exceeded then the child process is killed.
		Default: 200*1024</haxe_doc>
			</maxBuffer>
			<killSignal>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The child process is killed with `killSignal` (default: 'SIGTERM').</haxe_doc>
			</killSignal>
			<input>
				<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="js.node.Buffer"/>
</x></x>
				<meta><m n=":optional"/></meta>
			</input>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Default: 'utf8'</haxe_doc>
			</encoding>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Options for the `spawnSync` method.</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessSpawnOptionsStdio" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<x path="haxe.extern.EitherType">
			<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
			<t path="js.node.ChildProcessSpawnOptionsStdioFull"/>
		</x>
		<haxe_doc>The `stdio` option is an array where each index corresponds to a fd in the child.
	The value is one of the following:

		* 'pipe' - Create a pipe between the child process and the parent process.
				   The parent end of the pipe is exposed to the parent as a property on the child_process object as ChildProcess.stdio[fd].
				   Pipes created for fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout and ChildProcess.stderr, respectively.

		* 'ipc' - Create an IPC channel for passing messages/file descriptors between parent and child.
				  A ChildProcess may have at most one IPC stdio file descriptor. Setting this option enables the ChildProcess.send() method.
				  If the child writes JSON messages to this file descriptor, then this will trigger ChildProcess.on('message').
				  If the child is a Node.js program, then the presence of an IPC channel will enable process.send() and process.on('message').

		* 'ignore' - Do not set this file descriptor in the child. Note that Node will always open fd 0 - 2 for the processes it spawns.
					 When any of these is ignored node will open /dev/null and attach it to the child's fd.

		* Stream object - Share a readable or writable stream that refers to a tty, file, socket, or a pipe with the child process.
						  The stream's underlying file descriptor is duplicated in the child process to the fd that corresponds to the index
						  in the stdio array. Note that the stream must have an underlying descriptor (file streams do not until the 'open'
						  event has occurred).

		* Positive integer - The integer value is interpreted as a file descriptor that is is currently open in the parent process.
							 It is shared with the child process, similar to how Stream objects can be shared.

		* null - Use default value. For stdio fds 0, 1 and 2 (in other words, stdin, stdout, and stderr) a pipe is created.
				 For fd 3 and up, the default is 'ignore'.

	 As a shorthand, the stdio argument may also be one of the following strings, rather than an array:
		ignore - ['ignore', 'ignore', 'ignore']
		pipe - ['pipe', 'pipe', 'pipe']
		inherit - [process.stdin, process.stdout, process.stderr] or [0,1,2]</haxe_doc>
	</typedef>
	<abstract path="js.node.ChildProcessSpawnOptionsStdioSimple" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>A shorthand for the `stdio` argument in `ChildProcessSpawnOptions`</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node._ChildProcess.ChildProcessSpawnOptionsStdioSimple_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess" extern="1" final="1">
	<Ignore public="1" get="inline" set="null" expr="cast &quot;ignore&quot;" line="143" static="1">
		<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
		<meta>
			<m n=":value"><e>cast "ignore"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Equivalent to ['ignore', 'ignore', 'ignore']</haxe_doc>
	</Ignore>
	<Pipe public="1" get="inline" set="null" expr="cast &quot;pipe&quot;" line="148" static="1">
		<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
		<meta>
			<m n=":value"><e>cast "pipe"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Equivalent to ['pipe', 'pipe', 'pipe']</haxe_doc>
	</Pipe>
	<Inherit public="1" get="inline" set="null" expr="cast &quot;inherit&quot;" line="153" static="1">
		<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
		<meta>
			<m n=":value"><e>cast "inherit"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Equivalent to [process.stdin, process.stdout, process.stderr] or [0,1,2]</haxe_doc>
	</Inherit>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node._ChildProcess.ChildProcessSpawnOptionsStdioSimple_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess" extern="1" final="1">
		<Ignore public="1" get="inline" set="null" expr="cast &quot;ignore&quot;" line="143" static="1">
			<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
			<meta>
				<m n=":value"><e>cast "ignore"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Equivalent to ['ignore', 'ignore', 'ignore']</haxe_doc>
		</Ignore>
		<Pipe public="1" get="inline" set="null" expr="cast &quot;pipe&quot;" line="148" static="1">
			<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
			<meta>
				<m n=":value"><e>cast "pipe"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Equivalent to ['pipe', 'pipe', 'pipe']</haxe_doc>
		</Pipe>
		<Inherit public="1" get="inline" set="null" expr="cast &quot;inherit&quot;" line="153" static="1">
			<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
			<meta>
				<m n=":value"><e>cast "inherit"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Equivalent to [process.stdin, process.stdout, process.stderr] or [0,1,2]</haxe_doc>
		</Inherit>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="js.node.ChildProcessSpawnOptionsStdioBehaviour" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>Enumeration of possible `stdio` behaviours.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node._ChildProcess.ChildProcessSpawnOptionsStdioBehaviour_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess" extern="1" final="1">
	<Pipe public="1" get="inline" set="null" expr="cast &quot;pipe&quot;" line="165" static="1">
		<x path="js.node.ChildProcessSpawnOptionsStdioBehaviour"/>
		<meta>
			<m n=":value"><e>cast "pipe"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Create a pipe between the child process and the parent process.
		The parent end of the pipe is exposed to the parent as a property on the child_process object as ChildProcess.stdio[fd].
		Pipes created for fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout and ChildProcess.stderr, respectively.</haxe_doc>
	</Pipe>
	<Ipc public="1" get="inline" set="null" expr="cast &quot;ipc&quot;" line="179" static="1">
		<x path="js.node.ChildProcessSpawnOptionsStdioBehaviour"/>
		<meta>
			<m n=":value"><e>cast "ipc"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Create an IPC channel for passing messages/file descriptors between parent and child.
		A ChildProcess may have at most one IPC stdio file descriptor.

		Setting this option enables the ChildProcess.send() method.

		If the child writes JSON messages to this file descriptor, then this will trigger
		ChildProcess.on('message').

		If the child is a Node.js program, then the presence of an IPC channel will
		enable process.send() and process.on('message').</haxe_doc>
	</Ipc>
	<Ignore public="1" get="inline" set="null" expr="cast &quot;ignore&quot;" line="186" static="1">
		<x path="js.node.ChildProcessSpawnOptionsStdioBehaviour"/>
		<meta>
			<m n=":value"><e>cast "ignore"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Do not set this file descriptor in the child.
		Note that Node will always open fd 0 - 2 for the processes it spawns.
		When any of these is ignored node will open /dev/null and attach it to the child's fd.</haxe_doc>
	</Ignore>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node._ChildProcess.ChildProcessSpawnOptionsStdioBehaviour_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess" extern="1" final="1">
		<Pipe public="1" get="inline" set="null" expr="cast &quot;pipe&quot;" line="165" static="1">
			<x path="js.node.ChildProcessSpawnOptionsStdioBehaviour"/>
			<meta>
				<m n=":value"><e>cast "pipe"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Create a pipe between the child process and the parent process.
		The parent end of the pipe is exposed to the parent as a property on the child_process object as ChildProcess.stdio[fd].
		Pipes created for fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout and ChildProcess.stderr, respectively.</haxe_doc>
		</Pipe>
		<Ipc public="1" get="inline" set="null" expr="cast &quot;ipc&quot;" line="179" static="1">
			<x path="js.node.ChildProcessSpawnOptionsStdioBehaviour"/>
			<meta>
				<m n=":value"><e>cast "ipc"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Create an IPC channel for passing messages/file descriptors between parent and child.
		A ChildProcess may have at most one IPC stdio file descriptor.

		Setting this option enables the ChildProcess.send() method.

		If the child writes JSON messages to this file descriptor, then this will trigger
		ChildProcess.on('message').

		If the child is a Node.js program, then the presence of an IPC channel will
		enable process.send() and process.on('message').</haxe_doc>
		</Ipc>
		<Ignore public="1" get="inline" set="null" expr="cast &quot;ignore&quot;" line="186" static="1">
			<x path="js.node.ChildProcessSpawnOptionsStdioBehaviour"/>
			<meta>
				<m n=":value"><e>cast "ignore"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Do not set this file descriptor in the child.
		Note that Node will always open fd 0 - 2 for the processes it spawns.
		When any of these is ignored node will open /dev/null and attach it to the child's fd.</haxe_doc>
		</Ignore>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="js.node.ChildProcessSpawnOptionsStdioFull" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" module="js.node.ChildProcess"><c path="Array"><d/></c></typedef>
	<typedef path="js.node._ChildProcess.ChildProcessExecOptionsBase" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<timeout>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If greater than 0, then it will kill the child process if it runs longer than timeout milliseconds.</haxe_doc>
			</timeout>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<maxBuffer>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The largest amount of data allowed on stdout or stderr.
		If this value is exceeded then the child process is killed.
		Default: 200*1024</haxe_doc>
			</maxBuffer>
			<killSignal>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The child process is killed with `killSignal` (default: 'SIGTERM').</haxe_doc>
			</killSignal>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Default: 'utf8'</haxe_doc>
			</encoding>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Common options for `exec` and `execFile` methods.</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessExecOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<timeout>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If greater than 0, then it will kill the child process if it runs longer than timeout milliseconds.</haxe_doc>
			</timeout>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<maxBuffer>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The largest amount of data allowed on stdout or stderr.
		If this value is exceeded then the child process is killed.
		Default: 200*1024</haxe_doc>
			</maxBuffer>
			<killSignal>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The child process is killed with `killSignal` (default: 'SIGTERM').</haxe_doc>
			</killSignal>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Default: 'utf8'</haxe_doc>
			</encoding>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Options for the `exec` method.</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessExecFileOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<timeout>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If greater than 0, then it will kill the child process if it runs longer than timeout milliseconds.</haxe_doc>
			</timeout>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<maxBuffer>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The largest amount of data allowed on stdout or stderr.
		If this value is exceeded then the child process is killed.
		Default: 200*1024</haxe_doc>
			</maxBuffer>
			<killSignal>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The child process is killed with `killSignal` (default: 'SIGTERM').</haxe_doc>
			</killSignal>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Default: 'utf8'</haxe_doc>
			</encoding>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Options for the `execFile` method.</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessForkOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<silent>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If `true`, stdin, stdout, and stderr of the child will be piped to the parent,
		otherwise they will be inherited from the parent, see the "pipe" and "inherit"
		options for `ChildProcessSpawnOptions.stdio` for more details (default is `false`)</haxe_doc>
			</silent>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<execPath>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Executable used to create the child process</haxe_doc>
			</execPath>
			<execArgv>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>List of string arguments passed to the executable (Default: process.execArgv)</haxe_doc>
			</execArgv>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Options for the `fork` method.</haxe_doc>
	</typedef>
	<class path="js.node.ChildProcessExecError" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" module="js.node.ChildProcess" extern="1">
		<extends path="js.lib.Error"/>
		<code public="1" set="null">
			<x path="Int"/>
			<haxe_doc>the exit code of the child proces.</haxe_doc>
		</code>
		<signal public="1" set="null">
			<c path="String"/>
			<haxe_doc>the signal that terminated the process.</haxe_doc>
		</signal>
		<haxe_doc>An error passed to the `ChildProcess.exec` callback.</haxe_doc>
		<meta><m n=":native"><e>"Error"</e></m></meta>
	</class>
	<typedef path="js.node.ChildProcessExecCallback" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<f a="error:stdout:stderr">
			<x path="Null"><c path="js.node.ChildProcessExecError"/></x>
			<x path="haxe.extern.EitherType">
				<t path="js.node.Buffer"/>
				<c path="String"/>
			</x>
			<x path="haxe.extern.EitherType">
				<t path="js.node.Buffer"/>
				<c path="String"/>
			</x>
			<x path="Void"/>
		</f>
		<haxe_doc>A callback type for `ChildProcess.exec`.
	It receives three arguments: `error`, `stdout`, `stderr`.

	On success, error will be `null`. On error, `error` will be an instance of `Error`
	and `error.code` will be the exit code of the child process, and `error.signal` will be set
	to the signal that terminated the process (see `ChildProcessExecError`).</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessSpawnSyncResult" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<a>
			<stdout>
				<x path="haxe.extern.EitherType">
					<t path="js.node.Buffer"/>
					<c path="String"/>
				</x>
				<haxe_doc>The contents of output[1]</haxe_doc>
			</stdout>
			<stderr>
				<x path="haxe.extern.EitherType">
					<t path="js.node.Buffer"/>
					<c path="String"/>
				</x>
				<haxe_doc>The contents of output[2]</haxe_doc>
			</stderr>
			<status>
				<x path="Int"/>
				<haxe_doc>The exit code of the child process</haxe_doc>
			</status>
			<signal>
				<c path="String"/>
				<haxe_doc>The signal used to kill the child process</haxe_doc>
			</signal>
			<pid>
				<x path="Int"/>
				<haxe_doc>Pid of the child process</haxe_doc>
			</pid>
			<output>
				<c path="Array"><x path="haxe.extern.EitherType">
	<t path="js.node.Buffer"/>
	<c path="String"/>
</x></c>
				<haxe_doc>Array of results from stdio output</haxe_doc>
			</output>
			<error>
				<c path="js.lib.Error"/>
				<haxe_doc>The error object if the child process failed or timed out</haxe_doc>
			</error>
		</a>
		<haxe_doc>Object returned from the `spawnSync` method.</haxe_doc>
	</typedef>
	<class path="js.node.ChildProcess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/ChildProcess.hx" extern="1">
		<spawn public="1" set="method" static="1">
			<f a="command:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
			</f>
			<haxe_doc>Launches a new process with the given `command`, with command line arguments in `args`.
		If omitted, `args` defaults to an empty `Array`.

		The third argument is used to specify additional options, which defaults to:
			{ cwd: null,
			  env: process.env
			}

		Note that if spawn receives an empty options object, it will result in spawning the process with an empty
		environment rather than using `process.env`. This due to backwards compatibility issues with a deprecated API.</haxe_doc>
			<overloads>
				<spawn public="1" set="method">
					<f a="command:?options">
						<c path="String"/>
						<x path="Null"><t path="js.node.ChildProcessSpawnOptions"/></x>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>Launches a new process with the given `command`, with command line arguments in `args`.
		If omitted, `args` defaults to an empty `Array`.

		The third argument is used to specify additional options, which defaults to:
			{ cwd: null,
			  env: process.env
			}

		Note that if spawn receives an empty options object, it will result in spawning the process with an empty
		environment rather than using `process.env`. This due to backwards compatibility issues with a deprecated API.</haxe_doc>
				</spawn>
				<spawn public="1" set="method">
					<f a="command:args:?options">
						<c path="String"/>
						<c path="Array"><c path="String"/></c>
						<x path="Null"><t path="js.node.ChildProcessSpawnOptions"/></x>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>Launches a new process with the given `command`, with command line arguments in `args`.
		If omitted, `args` defaults to an empty `Array`.

		The third argument is used to specify additional options, which defaults to:
			{ cwd: null,
			  env: process.env
			}

		Note that if spawn receives an empty options object, it will result in spawning the process with an empty
		environment rather than using `process.env`. This due to backwards compatibility issues with a deprecated API.</haxe_doc>
				</spawn>
			</overloads>
		</spawn>
		<exec public="1" set="method" static="1">
			<f a="command:callback">
				<c path="String"/>
				<t path="js.node.ChildProcessExecCallback"/>
				<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
			</f>
			<haxe_doc>Runs a command in a shell and buffers the output.

		`command` is the command to run, with space-separated arguments.

		The default `options` are:
			{ encoding: 'utf8',
			  timeout: 0,
			  maxBuffer: 200*1024,
			  killSignal: 'SIGTERM',
			  cwd: null,
			  env: null }</haxe_doc>
			<overloads><exec public="1" set="method">
	<f a="command:options:callback">
		<c path="String"/>
		<t path="js.node.ChildProcessExecOptions"/>
		<t path="js.node.ChildProcessExecCallback"/>
		<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
	</f>
	<haxe_doc>Runs a command in a shell and buffers the output.

		`command` is the command to run, with space-separated arguments.

		The default `options` are:
			{ encoding: 'utf8',
			  timeout: 0,
			  maxBuffer: 200*1024,
			  killSignal: 'SIGTERM',
			  cwd: null,
			  env: null }</haxe_doc>
</exec></overloads>
		</exec>
		<execFile public="1" set="method" static="1">
			<f a="file:?callback">
				<c path="String"/>
				<x path="Null"><t path="js.node.ChildProcessExecCallback"/></x>
				<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
			</f>
			<haxe_doc>This is similar to `exec` except it does not execute a subshell but rather the specified file directly.
		This makes it slightly leaner than `exec`</haxe_doc>
			<overloads>
				<execFile public="1" set="method">
					<f a="file:args:options:?callback">
						<c path="String"/>
						<c path="Array"><c path="String"/></c>
						<t path="js.node.ChildProcessExecFileOptions"/>
						<x path="Null"><t path="js.node.ChildProcessExecCallback"/></x>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>This is similar to `exec` except it does not execute a subshell but rather the specified file directly.
		This makes it slightly leaner than `exec`</haxe_doc>
				</execFile>
				<execFile public="1" set="method">
					<f a="file:options:?callback">
						<c path="String"/>
						<t path="js.node.ChildProcessExecFileOptions"/>
						<x path="Null"><t path="js.node.ChildProcessExecCallback"/></x>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>This is similar to `exec` except it does not execute a subshell but rather the specified file directly.
		This makes it slightly leaner than `exec`</haxe_doc>
				</execFile>
				<execFile public="1" set="method">
					<f a="file:args:?callback">
						<c path="String"/>
						<c path="Array"><c path="String"/></c>
						<x path="Null"><t path="js.node.ChildProcessExecCallback"/></x>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>This is similar to `exec` except it does not execute a subshell but rather the specified file directly.
		This makes it slightly leaner than `exec`</haxe_doc>
				</execFile>
			</overloads>
		</execFile>
		<fork public="1" set="method" static="1">
			<f a="modulePath:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
			</f>
			<haxe_doc>This is a special case of the `spawn` functionality for spawning Node processes.
		In addition to having all the methods in a normal `ChildProcess` instance,
		the returned object has a communication channel built-in.
		See `send` for details.</haxe_doc>
			<overloads>
				<fork public="1" set="method">
					<f a="modulePath:args:options">
						<c path="String"/>
						<c path="Array"><c path="String"/></c>
						<t path="js.node.ChildProcessForkOptions"/>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>This is a special case of the `spawn` functionality for spawning Node processes.
		In addition to having all the methods in a normal `ChildProcess` instance,
		the returned object has a communication channel built-in.
		See `send` for details.</haxe_doc>
				</fork>
				<fork public="1" set="method">
					<f a="modulePath:options">
						<c path="String"/>
						<t path="js.node.ChildProcessForkOptions"/>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>This is a special case of the `spawn` functionality for spawning Node processes.
		In addition to having all the methods in a normal `ChildProcess` instance,
		the returned object has a communication channel built-in.
		See `send` for details.</haxe_doc>
				</fork>
			</overloads>
		</fork>
		<spawnSync public="1" set="method" static="1">
			<f a="command:?options">
				<c path="String"/>
				<x path="Null"><t path="js.node.ChildProcessSpawnSyncOptions"/></x>
				<t path="js.node.ChildProcessSpawnSyncResult"/>
			</f>
			<haxe_doc>Synchronous version of `spawn`.

		`spawnSync` will not return until the child process has fully closed.
		When a timeout has been encountered and `killSignal` is sent, the method won't return until the process
		has completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,
		your process will wait until the child process has exited.</haxe_doc>
			<overloads><spawnSync public="1" set="method">
	<f a="command:args:?options">
		<c path="String"/>
		<c path="Array"><c path="String"/></c>
		<x path="Null"><t path="js.node.ChildProcessSpawnSyncOptions"/></x>
		<t path="js.node.ChildProcessSpawnSyncResult"/>
	</f>
	<haxe_doc>Synchronous version of `spawn`.

		`spawnSync` will not return until the child process has fully closed.
		When a timeout has been encountered and `killSignal` is sent, the method won't return until the process
		has completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,
		your process will wait until the child process has exited.</haxe_doc>
</spawnSync></overloads>
		</spawnSync>
		<execFileSync public="1" set="method" static="1">
			<f a="command:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<t path="js.node.Buffer"/>
				</x>
			</f>
			<haxe_doc>Synchronous version of `execFile`.

		`execFileSync` will not return until the child process has fully closed.
		When a timeout has been encountered and `killSignal` is sent, the method won't return until the process
		has completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,
		your process will wait until the child process has exited.

		If the process times out, or has a non-zero exit code, this method will throw.
		The Error object will contain the entire result from `spawnSync`</haxe_doc>
			<overloads>
				<execFileSync public="1" set="method">
					<f a="command:?options">
						<c path="String"/>
						<x path="Null"><t path="js.node.ChildProcessSpawnSyncOptions"/></x>
						<x path="haxe.extern.EitherType">
							<c path="String"/>
							<t path="js.node.Buffer"/>
						</x>
					</f>
					<haxe_doc>Synchronous version of `execFile`.

		`execFileSync` will not return until the child process has fully closed.
		When a timeout has been encountered and `killSignal` is sent, the method won't return until the process
		has completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,
		your process will wait until the child process has exited.

		If the process times out, or has a non-zero exit code, this method will throw.
		The Error object will contain the entire result from `spawnSync`</haxe_doc>
				</execFileSync>
				<execFileSync public="1" set="method">
					<f a="command:args:?options">
						<c path="String"/>
						<c path="Array"><c path="String"/></c>
						<x path="Null"><t path="js.node.ChildProcessSpawnSyncOptions"/></x>
						<x path="haxe.extern.EitherType">
							<c path="String"/>
							<t path="js.node.Buffer"/>
						</x>
					</f>
					<haxe_doc>Synchronous version of `execFile`.

		`execFileSync` will not return until the child process has fully closed.
		When a timeout has been encountered and `killSignal` is sent, the method won't return until the process
		has completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,
		your process will wait until the child process has exited.

		If the process times out, or has a non-zero exit code, this method will throw.
		The Error object will contain the entire result from `spawnSync`</haxe_doc>
				</execFileSync>
			</overloads>
		</execFileSync>
		<execSync public="1" set="method" static="1">
			<f a="command:?options">
				<c path="String"/>
				<x path="Null"><t path="js.node.ChildProcessSpawnSyncOptions"/></x>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<t path="js.node.Buffer"/>
				</x>
			</f>
			<haxe_doc>Synchronous version of `exec`.

		`execSync` will not return until the child process has fully closed.
		When a timeout has been encountered and `killSignal` is sent, the method won't return until the process
		has completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,
		your process will wait until the child process has exited.

		If the process times out, or has a non-zero exit code, this method will throw.
		The Error object will contain the entire result from `spawnSync`</haxe_doc>
		</execSync>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":jsRequire"><e>"child_process"</e></m>
		</meta>
	</class>
	<typedef path="js.node.FsPath" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" module="js.node.Fs">
		<x path="haxe.extern.EitherType">
			<c path="String"/>
			<t path="js.node.Buffer"/>
		</x>
		<haxe_doc>Most FS functions now support passing `String` and `Buffer`.
	This type is used for path arguments and allows passing either of those.</haxe_doc>
	</typedef>
	<typedef path="js.node.FsWatchFileOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" module="js.node.Fs">
		<a>
			<persistent>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>indicates whether the process should continue to run as long as files are being watched
		default: true</haxe_doc>
			</persistent>
			<interval>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>indicates how often the target should be polled, in milliseconds
		default: 5007</haxe_doc>
			</interval>
		</a>
		<haxe_doc>Possible options for `Fs.watchFile`.</haxe_doc>
	</typedef>
	<typedef path="js.node.FsMode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" module="js.node.Fs">
		<x path="haxe.extern.EitherType">
			<x path="Int"/>
			<c path="String"/>
		</x>
		<haxe_doc>The `mode` argument used by `Fs.open` and related functions
	can be either an integer or a string with octal number.</haxe_doc>
	</typedef>
	<typedef path="js.node.FsWriteFileOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" module="js.node.Fs">
		<a>
			<mode>
				<x path="Null"><t path="js.node.FsMode"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>default = 438 (aka 0666 in Octal)</haxe_doc>
			</mode>
			<flag>
				<x path="Null"><x path="js.node.FsOpenFlag"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>default: 'w' for `Fs.writeFile`, 'a' for `Fs.appendFile`</haxe_doc>
			</flag>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Encoding for writing strings.
		Defaults to 'utf8'.
		Ignored if data is a buffer</haxe_doc>
			</encoding>
		</a>
		<haxe_doc>Possible options for `Fs.writeFile` and `Fs.appendFile`.</haxe_doc>
	</typedef>
	<typedef path="js.node.FsCreateReadStreamOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" module="js.node.Fs">
		<a>
			<start>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Start of the range of bytes to read</haxe_doc>
			</start>
			<mode>
				<x path="Null"><t path="js.node.FsMode"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>default: 0666</haxe_doc>
			</mode>
			<flags>
				<x path="Null"><x path="js.node.FsOpenFlag"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>default: 'r'</haxe_doc>
			</flags>
			<fd>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>default: null</haxe_doc>
			</fd>
			<end>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>End of the range of bytes to read</haxe_doc>
			</end>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>can be 'utf8', 'ascii', or 'base64'.
		default: null</haxe_doc>
			</encoding>
			<autoClose>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If autoClose is false, then the file descriptor won't be closed, even if there's an error.
		It is your responsiblity to close it and make sure there's no file descriptor leak.

		If autoClose is set to true (default behavior), on error or end the file
		descriptor will be closed automatically.</haxe_doc>
			</autoClose>
		</a>
		<haxe_doc>Options for `Fs.createReadStream`.</haxe_doc>
	</typedef>
	<typedef path="js.node.FsCreateWriteStreamOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" module="js.node.Fs">
		<a>
			<start>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>position to write data the beginning of the file.</haxe_doc>
			</start>
			<mode>
				<x path="Null"><t path="js.node.FsMode"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>default: 0666</haxe_doc>
			</mode>
			<flags>
				<x path="Null"><x path="js.node.FsOpenFlag"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>default: 'w'</haxe_doc>
			</flags>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>default: null</haxe_doc>
			</encoding>
		</a>
		<haxe_doc>Options for `Fs.createWriteStream`.</haxe_doc>
	</typedef>
	<abstract path="js.node.SymlinkType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" module="js.node.Fs">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>Enumeration of possible symlink types</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node._Fs.SymlinkType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" private="1" module="js.node.Fs" extern="1" final="1">
	<Dir public="1" get="inline" set="null" expr="cast &quot;dir&quot;" line="172" static="1">
		<x path="js.node.SymlinkType"/>
		<meta>
			<m n=":value"><e>cast "dir"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Dir>
	<File public="1" get="inline" set="null" expr="cast &quot;file&quot;" line="173" static="1">
		<x path="js.node.SymlinkType"/>
		<meta>
			<m n=":value"><e>cast "file"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</File>
	<Junction public="1" get="inline" set="null" expr="cast &quot;junction&quot;" line="174" static="1">
		<x path="js.node.SymlinkType"/>
		<meta>
			<m n=":value"><e>cast "junction"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Junction>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node._Fs.SymlinkType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" private="1" module="js.node.Fs" extern="1" final="1">
		<Dir public="1" get="inline" set="null" expr="cast &quot;dir&quot;" line="172" static="1">
			<x path="js.node.SymlinkType"/>
			<meta>
				<m n=":value"><e>cast "dir"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Dir>
		<File public="1" get="inline" set="null" expr="cast &quot;file&quot;" line="173" static="1">
			<x path="js.node.SymlinkType"/>
			<meta>
				<m n=":value"><e>cast "file"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</File>
		<Junction public="1" get="inline" set="null" expr="cast &quot;junction&quot;" line="174" static="1">
			<x path="js.node.SymlinkType"/>
			<meta>
				<m n=":value"><e>cast "junction"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Junction>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="js.node.FsOpenFlag" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" module="js.node.Fs">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>Enumeration of possible flags for opening file.

	The exclusive flag 'x' (O_EXCL flag in open(2)) ensures that path is newly created.
	On POSIX systems, path is considered to exist even if it is a symlink to a non-existent file.
	The exclusive flag may or may not work with network file systems.

	On Linux, positional writes don't work when the file is opened in append mode.
	The kernel ignores the position argument and always appends the data to the end of the file.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node._Fs.FsOpenFlag_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" private="1" module="js.node.Fs" extern="1" final="1">
	<Read public="1" get="inline" set="null" expr="cast &quot;r&quot;" line="192" static="1">
		<x path="js.node.FsOpenFlag"/>
		<meta>
			<m n=":value"><e>cast "r"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Open file for reading.
		An exception occurs if the file does not exist.</haxe_doc>
	</Read>
	<ReadWrite public="1" get="inline" set="null" expr="cast &quot;r+&quot;" line="198" static="1">
		<x path="js.node.FsOpenFlag"/>
		<meta>
			<m n=":value"><e>cast "r+"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Open file for reading and writing.
		An exception occurs if the file does not exist.</haxe_doc>
	</ReadWrite>
	<ReadSync public="1" get="inline" set="null" expr="cast &quot;rs&quot;" line="209" static="1">
		<x path="js.node.FsOpenFlag"/>
		<meta>
			<m n=":value"><e>cast "rs"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.

		This is primarily useful for opening files on NFS mounts as it allows you to skip the potentially stale local cache.
		It has a very real impact on I/O performance so don't use this flag unless you need it.

		Note that this doesn't turn `Fs.open` into a synchronous blocking call.
		If that's what you want then you should be using `Fs.openSync`</haxe_doc>
	</ReadSync>
	<ReadWriteSync public="1" get="inline" set="null" expr="cast &quot;rs+&quot;" line="215" static="1">
		<x path="js.node.FsOpenFlag"/>
		<meta>
			<m n=":value"><e>cast "rs+"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Open file for reading and writing, telling the OS to open it synchronously.
		See notes for `ReadSync` about using this with caution.</haxe_doc>
	</ReadWriteSync>
	<WriteCreate public="1" get="inline" set="null" expr="cast &quot;w&quot;" line="221" static="1">
		<x path="js.node.FsOpenFlag"/>
		<meta>
			<m n=":value"><e>cast "w"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Open file for writing.
		The file is created (if it does not exist) or truncated (if it exists).</haxe_doc>
	</WriteCreate>
	<WriteCheck public="1" get="inline" set="null" expr="cast &quot;wx&quot;" line="226" static="1">
		<x path="js.node.FsOpenFlag"/>
		<meta>
			<m n=":value"><e>cast "wx"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Like `WriteCreate` but fails if path exists.</haxe_doc>
	</WriteCheck>
	<WriteReadCreate public="1" get="inline" set="null" expr="cast &quot;w+&quot;" line="232" static="1">
		<x path="js.node.FsOpenFlag"/>
		<meta>
			<m n=":value"><e>cast "w+"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Open file for reading and writing.
		The file is created (if it does not exist) or truncated (if it exists).</haxe_doc>
	</WriteReadCreate>
	<WriteReadCheck public="1" get="inline" set="null" expr="cast &quot;wx+&quot;" line="237" static="1">
		<x path="js.node.FsOpenFlag"/>
		<meta>
			<m n=":value"><e>cast "wx+"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Like `WriteReadCreate` but fails if path exists.</haxe_doc>
	</WriteReadCheck>
	<AppendCreate public="1" get="inline" set="null" expr="cast &quot;a&quot;" line="243" static="1">
		<x path="js.node.FsOpenFlag"/>
		<meta>
			<m n=":value"><e>cast "a"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Open file for appending.
		The file is created if it does not exist.</haxe_doc>
	</AppendCreate>
	<AppendCheck public="1" get="inline" set="null" expr="cast &quot;ax&quot;" line="248" static="1">
		<x path="js.node.FsOpenFlag"/>
		<meta>
			<m n=":value"><e>cast "ax"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Like `AppendCreate` but fails if path exists.</haxe_doc>
	</AppendCheck>
	<AppendReadCreate public="1" get="inline" set="null" expr="cast &quot;a+&quot;" line="254" static="1">
		<x path="js.node.FsOpenFlag"/>
		<meta>
			<m n=":value"><e>cast "a+"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Open file for reading and appending.
		The file is created if it does not exist.</haxe_doc>
	</AppendReadCreate>
	<AppendReadCheck public="1" get="inline" set="null" expr="cast &quot;ax+&quot;" line="259" static="1">
		<x path="js.node.FsOpenFlag"/>
		<meta>
			<m n=":value"><e>cast "ax+"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Like `AppendReadCreate` but fails if path exists.</haxe_doc>
	</AppendReadCheck>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node._Fs.FsOpenFlag_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" private="1" module="js.node.Fs" extern="1" final="1">
		<Read public="1" get="inline" set="null" expr="cast &quot;r&quot;" line="192" static="1">
			<x path="js.node.FsOpenFlag"/>
			<meta>
				<m n=":value"><e>cast "r"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Open file for reading.
		An exception occurs if the file does not exist.</haxe_doc>
		</Read>
		<ReadWrite public="1" get="inline" set="null" expr="cast &quot;r+&quot;" line="198" static="1">
			<x path="js.node.FsOpenFlag"/>
			<meta>
				<m n=":value"><e>cast "r+"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Open file for reading and writing.
		An exception occurs if the file does not exist.</haxe_doc>
		</ReadWrite>
		<ReadSync public="1" get="inline" set="null" expr="cast &quot;rs&quot;" line="209" static="1">
			<x path="js.node.FsOpenFlag"/>
			<meta>
				<m n=":value"><e>cast "rs"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.

		This is primarily useful for opening files on NFS mounts as it allows you to skip the potentially stale local cache.
		It has a very real impact on I/O performance so don't use this flag unless you need it.

		Note that this doesn't turn `Fs.open` into a synchronous blocking call.
		If that's what you want then you should be using `Fs.openSync`</haxe_doc>
		</ReadSync>
		<ReadWriteSync public="1" get="inline" set="null" expr="cast &quot;rs+&quot;" line="215" static="1">
			<x path="js.node.FsOpenFlag"/>
			<meta>
				<m n=":value"><e>cast "rs+"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Open file for reading and writing, telling the OS to open it synchronously.
		See notes for `ReadSync` about using this with caution.</haxe_doc>
		</ReadWriteSync>
		<WriteCreate public="1" get="inline" set="null" expr="cast &quot;w&quot;" line="221" static="1">
			<x path="js.node.FsOpenFlag"/>
			<meta>
				<m n=":value"><e>cast "w"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Open file for writing.
		The file is created (if it does not exist) or truncated (if it exists).</haxe_doc>
		</WriteCreate>
		<WriteCheck public="1" get="inline" set="null" expr="cast &quot;wx&quot;" line="226" static="1">
			<x path="js.node.FsOpenFlag"/>
			<meta>
				<m n=":value"><e>cast "wx"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Like `WriteCreate` but fails if path exists.</haxe_doc>
		</WriteCheck>
		<WriteReadCreate public="1" get="inline" set="null" expr="cast &quot;w+&quot;" line="232" static="1">
			<x path="js.node.FsOpenFlag"/>
			<meta>
				<m n=":value"><e>cast "w+"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Open file for reading and writing.
		The file is created (if it does not exist) or truncated (if it exists).</haxe_doc>
		</WriteReadCreate>
		<WriteReadCheck public="1" get="inline" set="null" expr="cast &quot;wx+&quot;" line="237" static="1">
			<x path="js.node.FsOpenFlag"/>
			<meta>
				<m n=":value"><e>cast "wx+"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Like `WriteReadCreate` but fails if path exists.</haxe_doc>
		</WriteReadCheck>
		<AppendCreate public="1" get="inline" set="null" expr="cast &quot;a&quot;" line="243" static="1">
			<x path="js.node.FsOpenFlag"/>
			<meta>
				<m n=":value"><e>cast "a"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Open file for appending.
		The file is created if it does not exist.</haxe_doc>
		</AppendCreate>
		<AppendCheck public="1" get="inline" set="null" expr="cast &quot;ax&quot;" line="248" static="1">
			<x path="js.node.FsOpenFlag"/>
			<meta>
				<m n=":value"><e>cast "ax"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Like `AppendCreate` but fails if path exists.</haxe_doc>
		</AppendCheck>
		<AppendReadCreate public="1" get="inline" set="null" expr="cast &quot;a+&quot;" line="254" static="1">
			<x path="js.node.FsOpenFlag"/>
			<meta>
				<m n=":value"><e>cast "a+"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Open file for reading and appending.
		The file is created if it does not exist.</haxe_doc>
		</AppendReadCreate>
		<AppendReadCheck public="1" get="inline" set="null" expr="cast &quot;ax+&quot;" line="259" static="1">
			<x path="js.node.FsOpenFlag"/>
			<meta>
				<m n=":value"><e>cast "ax+"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Like `AppendReadCreate` but fails if path exists.</haxe_doc>
		</AppendReadCheck>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="js.node.FsConstants" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" module="js.node.Fs">
		<a>
			<X_OK>
				<x path="Int"/>
				<haxe_doc>Flag indicating that the file can be executed by the calling process.
		Meant for use with `Fs.access`.</haxe_doc>
			</X_OK>
			<W_OK>
				<x path="Int"/>
				<haxe_doc>Flag indicating that the file can be written by the calling process.
		Meant for use with `Fs.access`.</haxe_doc>
			</W_OK>
			<S_IXUSR>
				<x path="Int"/>
				<haxe_doc>File mode indicating executable by owner.</haxe_doc>
			</S_IXUSR>
			<S_IXOTH>
				<x path="Int"/>
				<haxe_doc>File mode indicating executable by others.</haxe_doc>
			</S_IXOTH>
			<S_IXGRP>
				<x path="Int"/>
				<haxe_doc>File mode indicating executable by group.</haxe_doc>
			</S_IXGRP>
			<S_IWUSR>
				<x path="Int"/>
				<haxe_doc>File mode indicating writable by owner.</haxe_doc>
			</S_IWUSR>
			<S_IWOTH>
				<x path="Int"/>
				<haxe_doc>File mode indicating writable by others.</haxe_doc>
			</S_IWOTH>
			<S_IWGRP>
				<x path="Int"/>
				<haxe_doc>File mode indicating writable by group.</haxe_doc>
			</S_IWGRP>
			<S_IRWXU>
				<x path="Int"/>
				<haxe_doc>File mode indicating readable, writable and executable by owner.</haxe_doc>
			</S_IRWXU>
			<S_IRWXO>
				<x path="Int"/>
				<haxe_doc>File mode indicating readable, writable and executable by others.</haxe_doc>
			</S_IRWXO>
			<S_IRWXG>
				<x path="Int"/>
				<haxe_doc>File mode indicating readable, writable and executable by group.</haxe_doc>
			</S_IRWXG>
			<S_IRUSR>
				<x path="Int"/>
				<haxe_doc>File mode indicating readable by owner.</haxe_doc>
			</S_IRUSR>
			<S_IROTH>
				<x path="Int"/>
				<haxe_doc>File mode indicating readable by others.</haxe_doc>
			</S_IROTH>
			<S_IRGRP>
				<x path="Int"/>
				<haxe_doc>File mode indicating readable by group.</haxe_doc>
			</S_IRGRP>
			<S_IFSOCK>
				<x path="Int"/>
				<haxe_doc>File type constant for a socket.</haxe_doc>
			</S_IFSOCK>
			<S_IFREG>
				<x path="Int"/>
				<haxe_doc>File type constant for a regular file.</haxe_doc>
			</S_IFREG>
			<S_IFMT>
				<x path="Int"/>
				<haxe_doc>Bit mask used to extract the file type code.</haxe_doc>
			</S_IFMT>
			<S_IFLNK>
				<x path="Int"/>
				<haxe_doc>File type constant for a symbolic link.</haxe_doc>
			</S_IFLNK>
			<S_IFIFO>
				<x path="Int"/>
				<haxe_doc>File type constant for a FIFO/pipe.</haxe_doc>
			</S_IFIFO>
			<S_IFDIR>
				<x path="Int"/>
				<haxe_doc>File type constant for a directory.</haxe_doc>
			</S_IFDIR>
			<S_IFCHR>
				<x path="Int"/>
				<haxe_doc>File type constant for a character-oriented device file.</haxe_doc>
			</S_IFCHR>
			<S_IFBLK>
				<x path="Int"/>
				<haxe_doc>File type constant for a block-oriented device file.</haxe_doc>
			</S_IFBLK>
			<R_OK>
				<x path="Int"/>
				<haxe_doc>Flag indicating that the file can be read by the calling process.
		Meant for use with `Fs.access`.</haxe_doc>
			</R_OK>
			<O_WRONLY>
				<x path="Int"/>
				<haxe_doc>Flag indicating to open a file for write-only access.</haxe_doc>
			</O_WRONLY>
			<O_TRUNC>
				<x path="Int"/>
				<haxe_doc>Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero.</haxe_doc>
			</O_TRUNC>
			<O_SYNC>
				<x path="Int"/>
				<haxe_doc>Flag indicating that the file is opened for synchronous I/O.</haxe_doc>
			</O_SYNC>
			<O_SYMLINK>
				<x path="Int"/>
				<haxe_doc>Flag indicating to open the symbolic link itself rather than the resource it is pointing to.</haxe_doc>
			</O_SYMLINK>
			<O_RDWR>
				<x path="Int"/>
				<haxe_doc>Flag indicating to open a file for read-write access.</haxe_doc>
			</O_RDWR>
			<O_RDONLY>
				<x path="Int"/>
				<haxe_doc>Flag indicating to open a file for read-only access.</haxe_doc>
			</O_RDONLY>
			<O_NONBLOCK>
				<x path="Int"/>
				<haxe_doc>Flag indicating to open the file in nonblocking mode when possible.</haxe_doc>
			</O_NONBLOCK>
			<O_NOFOLLOW>
				<x path="Int"/>
				<haxe_doc>Flag indicating that the open should fail if the path is a symbolic link.</haxe_doc>
			</O_NOFOLLOW>
			<O_NOCTTY>
				<x path="Int"/>
				<haxe_doc>Flag indicating that if path identifies a terminal device, opening the path shall not cause that terminal to become the controlling terminal for the process (if the process does not already have one).</haxe_doc>
			</O_NOCTTY>
			<O_NOATIME>
				<x path="Int"/>
				<haxe_doc>Flag indicating reading accesses to the file system will no longer result in an update to the atime information associated with the file. This flag is available on Linux operating systems only.</haxe_doc>
			</O_NOATIME>
			<O_EXCL>
				<x path="Int"/>
				<haxe_doc>Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists.</haxe_doc>
			</O_EXCL>
			<O_DIRECTORY>
				<x path="Int"/>
				<haxe_doc>Flag indicating that the open should fail if the path is not a directory.</haxe_doc>
			</O_DIRECTORY>
			<O_DIRECT>
				<x path="Int"/>
				<haxe_doc>When set, an attempt will be made to minimize caching effects of file I/O.</haxe_doc>
			</O_DIRECT>
			<O_CREAT>
				<x path="Int"/>
				<haxe_doc>Flag indicating to create the file if it does not already exist.</haxe_doc>
			</O_CREAT>
			<O_APPEND>
				<x path="Int"/>
				<haxe_doc>Flag indicating that data will be appended to the end of the file.</haxe_doc>
			</O_APPEND>
			<F_OK>
				<x path="Int"/>
				<haxe_doc>Flag indicating that the file is visible to the calling process.
		Meant for use with `Fs.access`.</haxe_doc>
			</F_OK>
		</a>
		<haxe_doc>Constants for use in `Fs` module.

	Note: Not every constant will be available on every operating system.</haxe_doc>
	</typedef>
	<typedef path="js.node.FsRmdirOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" module="js.node.Fs">
		<a>
			<retryDelay>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The amount of time in milliseconds to wait between retries.
		This option is ignored if the `recursive` option is not `true`.</haxe_doc>
			</retryDelay>
			<recursive>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If `true`, perform a recursive directory removal.
		In recursive mode, errors are not reported if `path` does not exist,
		and operations are retried on failure.</haxe_doc>
			</recursive>
			<maxRetries>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or `EPERM` error is encountered,
		Node.js will retry the operation with a linear backoff wait of `retryDelay` ms longer on each try.
		This option represents the number of retries.
		This option is ignored if the `recursive` option is not `true`.</haxe_doc>
			</maxRetries>
		</a>
		<haxe_doc>Options for `Fs.rmdir` and `Fs.rmdirSync`.</haxe_doc>
	</typedef>
	<class path="js.node.Fs" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Fs.hx" extern="1">
		<constants public="1" set="null" static="1">
			<t path="js.node.FsConstants"/>
			<haxe_doc>An object containing commonly used constants for file system operations.</haxe_doc>
		</constants>
		<rename public="1" set="method" static="1">
			<f a="oldPath:newPath:callback">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsPath"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous rename(2).</haxe_doc>
		</rename>
		<renameSync public="1" set="method" static="1">
			<f a="oldPath:newPath">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsPath"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous rename(2).</haxe_doc>
		</renameSync>
		<ftruncate public="1" set="method" static="1">
			<f a="fd:len:callback">
				<x path="Int"/>
				<x path="Int"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous ftruncate(2).</haxe_doc>
		</ftruncate>
		<ftruncateSync public="1" set="method" static="1">
			<f a="fd:len">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous ftruncate(2).</haxe_doc>
		</ftruncateSync>
		<truncate public="1" set="method" static="1">
			<f a="path:len:callback">
				<t path="js.node.FsPath"/>
				<x path="Int"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous truncate(2).</haxe_doc>
		</truncate>
		<truncateSync public="1" set="method" static="1">
			<f a="path:len">
				<t path="js.node.FsPath"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous truncate(2).</haxe_doc>
		</truncateSync>
		<chown public="1" set="method" static="1">
			<f a="path:uid:gid:callback">
				<t path="js.node.FsPath"/>
				<x path="Int"/>
				<x path="Int"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous chown(2).</haxe_doc>
		</chown>
		<chownSync public="1" set="method" static="1">
			<f a="path:uid:gid">
				<t path="js.node.FsPath"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous chown(2).</haxe_doc>
		</chownSync>
		<fchown public="1" set="method" static="1">
			<f a="fd:uid:gid:callback">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous fchown(2).</haxe_doc>
		</fchown>
		<fchownSync public="1" set="method" static="1">
			<f a="fd:uid:gid">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous fchown(2).</haxe_doc>
		</fchownSync>
		<lchown public="1" set="method" static="1">
			<f a="path:uid:gid:callback">
				<t path="js.node.FsPath"/>
				<x path="Int"/>
				<x path="Int"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous lchown(2).</haxe_doc>
		</lchown>
		<lchownSync public="1" set="method" static="1">
			<f a="path:uid:gid">
				<t path="js.node.FsPath"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous lchown(2).</haxe_doc>
		</lchownSync>
		<chmod public="1" set="method" static="1">
			<f a="path:mode:callback">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsMode"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous chmod(2).</haxe_doc>
		</chmod>
		<chmodSync public="1" set="method" static="1">
			<f a="path:mode">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsMode"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous chmod(2).</haxe_doc>
		</chmodSync>
		<fchmod public="1" set="method" static="1">
			<f a="fd:mode:callback">
				<x path="Int"/>
				<t path="js.node.FsMode"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous fchmod(2).</haxe_doc>
		</fchmod>
		<fchmodSync public="1" set="method" static="1">
			<f a="fd:mode">
				<x path="Int"/>
				<t path="js.node.FsMode"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous fchmod(2).</haxe_doc>
		</fchmodSync>
		<lchmod public="1" set="method" static="1">
			<f a="path:mode:callback">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsMode"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous lchmod(2).
		Only available on Mac OS X.</haxe_doc>
		</lchmod>
		<lchmodSync public="1" set="method" static="1">
			<f a="path:mode">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsMode"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous lchmod(2).</haxe_doc>
		</lchmodSync>
		<stat public="1" set="method" static="1">
			<f a="path:callback">
				<t path="js.node.FsPath"/>
				<f a=":">
					<c path="js.lib.Error"/>
					<c path="js.node.fs.Stats"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous stat(2).</haxe_doc>
		</stat>
		<lstat public="1" set="method" static="1">
			<f a="path:callback">
				<t path="js.node.FsPath"/>
				<f a=":">
					<c path="js.lib.Error"/>
					<c path="js.node.fs.Stats"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous lstat(2).

		lstat() is identical to stat(), except that if path is a symbolic link,
		then the link itself is stat-ed, not the file that it refers to.</haxe_doc>
		</lstat>
		<fstat public="1" set="method" static="1">
			<f a="fd:callback">
				<x path="Int"/>
				<f a=":">
					<c path="js.lib.Error"/>
					<c path="js.node.fs.Stats"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous fstat(2).

		fstat() is identical to stat(), except that the file to be stat-ed
		is specified by the file descriptor fd.</haxe_doc>
		</fstat>
		<statSync public="1" set="method" static="1">
			<f a="path">
				<t path="js.node.FsPath"/>
				<c path="js.node.fs.Stats"/>
			</f>
			<haxe_doc>Synchronous stat(2).</haxe_doc>
		</statSync>
		<lstatSync public="1" set="method" static="1">
			<f a="path">
				<t path="js.node.FsPath"/>
				<c path="js.node.fs.Stats"/>
			</f>
			<haxe_doc>Synchronous lstat(2).</haxe_doc>
		</lstatSync>
		<fstatSync public="1" set="method" static="1">
			<f a="fd">
				<x path="Int"/>
				<c path="js.node.fs.Stats"/>
			</f>
			<haxe_doc>Synchronous fstat(2).</haxe_doc>
		</fstatSync>
		<link public="1" set="method" static="1">
			<f a="srcpath:dstpath:callback">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsPath"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous link(2).</haxe_doc>
		</link>
		<linkSync public="1" set="method" static="1">
			<f a="srcpath:dstpath">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsPath"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous link(2).</haxe_doc>
		</linkSync>
		<symlink public="1" set="method" static="1">
			<f a="srcpath:dstpath:type:callback">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsPath"/>
				<x path="js.node.SymlinkType"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous symlink(2).

		The `type` argument can be set to 'dir', 'file', or 'junction' (default is 'file')
		and is only available on Windows (ignored on other platforms). Note that Windows junction
		points require the destination path to be absolute. When using 'junction', the destination
		argument will automatically be normalized to absolute path.</haxe_doc>
			<overloads><symlink public="1" set="method">
	<f a="srcpath:dstpath:callback">
		<t path="js.node.FsPath"/>
		<t path="js.node.FsPath"/>
		<f a="">
			<c path="js.lib.Error"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<haxe_doc>Asynchronous symlink(2).

		The `type` argument can be set to 'dir', 'file', or 'junction' (default is 'file')
		and is only available on Windows (ignored on other platforms). Note that Windows junction
		points require the destination path to be absolute. When using 'junction', the destination
		argument will automatically be normalized to absolute path.</haxe_doc>
</symlink></overloads>
		</symlink>
		<symlinkSync public="1" set="method" static="1">
			<f a="srcpath:dstpath:type">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsPath"/>
				<x path="js.node.SymlinkType"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous symlink(2).</haxe_doc>
			<overloads><symlinkSync public="1" set="method">
	<f a="srcpath:dstpath">
		<t path="js.node.FsPath"/>
		<t path="js.node.FsPath"/>
		<x path="Void"/>
	</f>
	<haxe_doc>Synchronous symlink(2).</haxe_doc>
</symlinkSync></overloads>
		</symlinkSync>
		<readlink public="1" set="method" static="1">
			<f a="path:callback">
				<t path="js.node.FsPath"/>
				<f a=":">
					<c path="js.lib.Error"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous readlink(2).</haxe_doc>
		</readlink>
		<readlinkSync public="1" set="method" static="1">
			<f a="path">
				<t path="js.node.FsPath"/>
				<c path="String"/>
			</f>
			<haxe_doc>Synchronous readlink(2).
		Returns the symbolic link's string value.</haxe_doc>
		</readlinkSync>
		<realpath public="1" set="method" static="1">
			<f a="path:cache:callback">
				<t path="js.node.FsPath"/>
				<x path="haxe.DynamicAccess"><c path="String"/></x>
				<f a=":">
					<c path="js.lib.Error"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous realpath(2).

		The callback gets two arguments (err, resolvedPath).

		May use process.cwd to resolve relative paths.

		`cache` is an object literal of mapped paths that can be used to force a specific path resolution
		or avoid additional `stat` calls for known real paths.</haxe_doc>
			<overloads><realpath public="1" set="method">
	<f a="path:callback">
		<t path="js.node.FsPath"/>
		<f a=":">
			<c path="js.lib.Error"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<haxe_doc>Asynchronous realpath(2).

		The callback gets two arguments (err, resolvedPath).

		May use process.cwd to resolve relative paths.

		`cache` is an object literal of mapped paths that can be used to force a specific path resolution
		or avoid additional `stat` calls for known real paths.</haxe_doc>
</realpath></overloads>
		</realpath>
		<realpathSync public="1" set="method" static="1">
			<f a="path:cache">
				<t path="js.node.FsPath"/>
				<x path="haxe.DynamicAccess"><c path="String"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Synchronous realpath(2).
		Returns the resolved path.</haxe_doc>
			<overloads><realpathSync public="1" set="method">
	<f a="path">
		<t path="js.node.FsPath"/>
		<c path="String"/>
	</f>
	<haxe_doc>Synchronous realpath(2).
		Returns the resolved path.</haxe_doc>
</realpathSync></overloads>
		</realpathSync>
		<unlink public="1" set="method" static="1">
			<f a="path:callback">
				<t path="js.node.FsPath"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous unlink(2).</haxe_doc>
		</unlink>
		<unlinkSync public="1" set="method" static="1">
			<f a="path">
				<t path="js.node.FsPath"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous unlink(2).</haxe_doc>
		</unlinkSync>
		<rmdir public="1" set="method" static="1">
			<f a="path:options:callback">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsRmdirOptions"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous rmdir(2).</haxe_doc>
			<overloads><rmdir public="1" set="method">
	<f a="path:callback">
		<t path="js.node.FsPath"/>
		<f a="">
			<c path="js.lib.Error"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<haxe_doc>Asynchronous rmdir(2).</haxe_doc>
</rmdir></overloads>
		</rmdir>
		<rmdirSync public="1" set="method" static="1">
			<f a="path:?options">
				<t path="js.node.FsPath"/>
				<x path="Null"><t path="js.node.FsRmdirOptions"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous rmdir(2).</haxe_doc>
		</rmdirSync>
		<mkdir public="1" set="method" static="1">
			<f a="path:mode:callback">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsMode"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous mkdir(2).
		`mode` defaults to 0777.</haxe_doc>
			<overloads><mkdir public="1" set="method">
	<f a="path:callback">
		<t path="js.node.FsPath"/>
		<f a="">
			<c path="js.lib.Error"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<haxe_doc>Asynchronous mkdir(2).
		`mode` defaults to 0777.</haxe_doc>
</mkdir></overloads>
		</mkdir>
		<mkdirSync public="1" set="method" static="1">
			<f a="path:?mode">
				<t path="js.node.FsPath"/>
				<x path="Null"><t path="js.node.FsMode"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous mkdir(2).</haxe_doc>
		</mkdirSync>
		<mkdtemp public="1" set="method" static="1">
			<f a="prefix:callback">
				<c path="String"/>
				<f a=":">
					<c path="js.lib.Error"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a unique temporary directory.

		Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.

		The created folder path is passed as a string to the `callback`'s second parameter.</haxe_doc>
		</mkdtemp>
		<mkdtempSync public="1" set="method" static="1">
			<f a="template">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>The synchronous version of `mkdtemp`.

		Returns the created folder path.</haxe_doc>
		</mkdtempSync>
		<readdir public="1" set="method" static="1">
			<f a="path:callback">
				<t path="js.node.FsPath"/>
				<f a=":">
					<c path="js.lib.Error"/>
					<c path="Array"><c path="String"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous readdir(3).
		Reads the contents of a directory.

		The callback gets two arguments (err, files) where files is an array of the
		names of the files in the directory excluding '.' and '..'.</haxe_doc>
		</readdir>
		<readdirSync public="1" set="method" static="1">
			<f a="path">
				<t path="js.node.FsPath"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Synchronous readdir(3).
		Returns an array of filenames excluding '.' and '..'.</haxe_doc>
		</readdirSync>
		<close public="1" set="method" static="1">
			<f a="fd:callback">
				<x path="Int"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous close(2).</haxe_doc>
		</close>
		<closeSync public="1" set="method" static="1">
			<f a="fd">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous close(2).</haxe_doc>
		</closeSync>
		<open public="1" set="method" static="1">
			<f a="path:flags:mode:callback">
				<t path="js.node.FsPath"/>
				<x path="js.node.FsOpenFlag"/>
				<t path="js.node.FsMode"/>
				<f a=":">
					<c path="js.lib.Error"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous file open. See open(2).

		See `FsOpenFlag` for description of possible `flags`.

		`mode` sets the file mode (permission and sticky bits), but only if the file was created.
		It defaults to 0666, readable and writeable.

		The `callback` gets two arguments (err, fd).</haxe_doc>
			<overloads><open public="1" set="method">
	<f a="path:flags:callback">
		<t path="js.node.FsPath"/>
		<x path="js.node.FsOpenFlag"/>
		<f a=":">
			<c path="js.lib.Error"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<haxe_doc>Asynchronous file open. See open(2).

		See `FsOpenFlag` for description of possible `flags`.

		`mode` sets the file mode (permission and sticky bits), but only if the file was created.
		It defaults to 0666, readable and writeable.

		The `callback` gets two arguments (err, fd).</haxe_doc>
</open></overloads>
		</open>
		<openSync public="1" set="method" static="1">
			<f a="path:flags:mode">
				<t path="js.node.FsPath"/>
				<x path="js.node.FsOpenFlag"/>
				<t path="js.node.FsMode"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Synchronous version of open().</haxe_doc>
			<overloads><openSync public="1" set="method">
	<f a="path:flags">
		<t path="js.node.FsPath"/>
		<x path="js.node.FsOpenFlag"/>
		<x path="Int"/>
	</f>
	<haxe_doc>Synchronous version of open().</haxe_doc>
</openSync></overloads>
		</openSync>
		<utimes public="1" set="method" static="1">
			<f a="path:atime:mtime:callback">
				<t path="js.node.FsPath"/>
				<c path="Date"/>
				<c path="Date"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Change file timestamps of the file referenced by the supplied path.</haxe_doc>
		</utimes>
		<utimesSync public="1" set="method" static="1">
			<f a="path:atime:mtime">
				<t path="js.node.FsPath"/>
				<c path="Date"/>
				<c path="Date"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change file timestamps of the file referenced by the supplied path.</haxe_doc>
		</utimesSync>
		<futimes public="1" set="method" static="1">
			<f a="fd:atime:mtime:callback">
				<x path="Int"/>
				<c path="Date"/>
				<c path="Date"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the file timestamps of a file referenced by the supplied file descriptor.</haxe_doc>
		</futimes>
		<futimesSync public="1" set="method" static="1">
			<f a="fd:atime:mtime">
				<x path="Int"/>
				<c path="Date"/>
				<c path="Date"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the file timestamps of a file referenced by the supplied file descriptor.</haxe_doc>
		</futimesSync>
		<fsync public="1" set="method" static="1">
			<f a="fd:callback">
				<x path="Int"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronous fsync(2).</haxe_doc>
		</fsync>
		<fsyncSync public="1" set="method" static="1">
			<f a="fd">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous fsync(2).</haxe_doc>
		</fsyncSync>
		<write public="1" set="method" static="1">
			<f a="fd:buffer:offset:length:position:callback">
				<x path="Int"/>
				<t path="js.node.Buffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<f a="::">
					<c path="js.lib.Error"/>
					<x path="Int"/>
					<t path="js.node.Buffer"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Documentation for the overloads with the `buffer` argument:

		Write `buffer` to the file specified by `fd`.

		`offset` and `length` determine the part of the `buffer` to be written.

		`position` refers to the offset from the beginning of the file where this data should be written.
		If position is null, the data will be written at the current position. See pwrite(2).

		The `callback` will be given three arguments (err, written, buffer)
		where `written` specifies how many bytes were written from `buffer`.

		---

		Documentation for the overloads with the `data` argument:

		Write `data` to the file specified by `fd`. If `data` is not a `Buffer` instance then
		the value will be coerced to a string.

		`position` refers to the offset from the beginning of the file where this data should be written.
		If omitted, the data will be written at the current position. See pwrite(2).

		`encoding` is the expected string encoding.

		The `callback` will receive the arguments (err, written, string) where written specifies how many bytes
		the passed string required to be written. Note that bytes written is not the same as string characters.
		See `Buffer.byteLength`.

		Unlike when writing `buffer`, the entire string must be written. No substring may be specified.
		This is because the byte offset of the resulting data may not be the same as the string offset.

		---

		Common notes:

		Note that it is unsafe to use `write` multiple times on the same file without waiting for the callback.
		For this scenario, `createWriteStream` is strongly recommended.

		On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position
		argument and always appends the data to the end of the file.</haxe_doc>
			<overloads>
				<write public="1" set="method">
					<f a="fd:data:position:encoding:callback">
						<x path="Int"/>
						<d/>
						<x path="Int"/>
						<c path="String"/>
						<f a="::">
							<c path="js.lib.Error"/>
							<x path="Int"/>
							<c path="String"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Documentation for the overloads with the `buffer` argument:

		Write `buffer` to the file specified by `fd`.

		`offset` and `length` determine the part of the `buffer` to be written.

		`position` refers to the offset from the beginning of the file where this data should be written.
		If position is null, the data will be written at the current position. See pwrite(2).

		The `callback` will be given three arguments (err, written, buffer)
		where `written` specifies how many bytes were written from `buffer`.

		---

		Documentation for the overloads with the `data` argument:

		Write `data` to the file specified by `fd`. If `data` is not a `Buffer` instance then
		the value will be coerced to a string.

		`position` refers to the offset from the beginning of the file where this data should be written.
		If omitted, the data will be written at the current position. See pwrite(2).

		`encoding` is the expected string encoding.

		The `callback` will receive the arguments (err, written, string) where written specifies how many bytes
		the passed string required to be written. Note that bytes written is not the same as string characters.
		See `Buffer.byteLength`.

		Unlike when writing `buffer`, the entire string must be written. No substring may be specified.
		This is because the byte offset of the resulting data may not be the same as the string offset.

		---

		Common notes:

		Note that it is unsafe to use `write` multiple times on the same file without waiting for the callback.
		For this scenario, `createWriteStream` is strongly recommended.

		On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position
		argument and always appends the data to the end of the file.</haxe_doc>
				</write>
				<write public="1" set="method">
					<f a="fd:data:position:callback">
						<x path="Int"/>
						<d/>
						<x path="Int"/>
						<f a="::">
							<c path="js.lib.Error"/>
							<x path="Int"/>
							<c path="String"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Documentation for the overloads with the `buffer` argument:

		Write `buffer` to the file specified by `fd`.

		`offset` and `length` determine the part of the `buffer` to be written.

		`position` refers to the offset from the beginning of the file where this data should be written.
		If position is null, the data will be written at the current position. See pwrite(2).

		The `callback` will be given three arguments (err, written, buffer)
		where `written` specifies how many bytes were written from `buffer`.

		---

		Documentation for the overloads with the `data` argument:

		Write `data` to the file specified by `fd`. If `data` is not a `Buffer` instance then
		the value will be coerced to a string.

		`position` refers to the offset from the beginning of the file where this data should be written.
		If omitted, the data will be written at the current position. See pwrite(2).

		`encoding` is the expected string encoding.

		The `callback` will receive the arguments (err, written, string) where written specifies how many bytes
		the passed string required to be written. Note that bytes written is not the same as string characters.
		See `Buffer.byteLength`.

		Unlike when writing `buffer`, the entire string must be written. No substring may be specified.
		This is because the byte offset of the resulting data may not be the same as the string offset.

		---

		Common notes:

		Note that it is unsafe to use `write` multiple times on the same file without waiting for the callback.
		For this scenario, `createWriteStream` is strongly recommended.

		On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position
		argument and always appends the data to the end of the file.</haxe_doc>
				</write>
				<write public="1" set="method">
					<f a="fd:data:callback">
						<x path="Int"/>
						<d/>
						<f a="::">
							<c path="js.lib.Error"/>
							<x path="Int"/>
							<c path="String"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Documentation for the overloads with the `buffer` argument:

		Write `buffer` to the file specified by `fd`.

		`offset` and `length` determine the part of the `buffer` to be written.

		`position` refers to the offset from the beginning of the file where this data should be written.
		If position is null, the data will be written at the current position. See pwrite(2).

		The `callback` will be given three arguments (err, written, buffer)
		where `written` specifies how many bytes were written from `buffer`.

		---

		Documentation for the overloads with the `data` argument:

		Write `data` to the file specified by `fd`. If `data` is not a `Buffer` instance then
		the value will be coerced to a string.

		`position` refers to the offset from the beginning of the file where this data should be written.
		If omitted, the data will be written at the current position. See pwrite(2).

		`encoding` is the expected string encoding.

		The `callback` will receive the arguments (err, written, string) where written specifies how many bytes
		the passed string required to be written. Note that bytes written is not the same as string characters.
		See `Buffer.byteLength`.

		Unlike when writing `buffer`, the entire string must be written. No substring may be specified.
		This is because the byte offset of the resulting data may not be the same as the string offset.

		---

		Common notes:

		Note that it is unsafe to use `write` multiple times on the same file without waiting for the callback.
		For this scenario, `createWriteStream` is strongly recommended.

		On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position
		argument and always appends the data to the end of the file.</haxe_doc>
				</write>
				<write public="1" set="method">
					<f a="fd:buffer:offset:length:callback">
						<x path="Int"/>
						<t path="js.node.Buffer"/>
						<x path="Int"/>
						<x path="Int"/>
						<f a="::">
							<c path="js.lib.Error"/>
							<x path="Int"/>
							<t path="js.node.Buffer"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Documentation for the overloads with the `buffer` argument:

		Write `buffer` to the file specified by `fd`.

		`offset` and `length` determine the part of the `buffer` to be written.

		`position` refers to the offset from the beginning of the file where this data should be written.
		If position is null, the data will be written at the current position. See pwrite(2).

		The `callback` will be given three arguments (err, written, buffer)
		where `written` specifies how many bytes were written from `buffer`.

		---

		Documentation for the overloads with the `data` argument:

		Write `data` to the file specified by `fd`. If `data` is not a `Buffer` instance then
		the value will be coerced to a string.

		`position` refers to the offset from the beginning of the file where this data should be written.
		If omitted, the data will be written at the current position. See pwrite(2).

		`encoding` is the expected string encoding.

		The `callback` will receive the arguments (err, written, string) where written specifies how many bytes
		the passed string required to be written. Note that bytes written is not the same as string characters.
		See `Buffer.byteLength`.

		Unlike when writing `buffer`, the entire string must be written. No substring may be specified.
		This is because the byte offset of the resulting data may not be the same as the string offset.

		---

		Common notes:

		Note that it is unsafe to use `write` multiple times on the same file without waiting for the callback.
		For this scenario, `createWriteStream` is strongly recommended.

		On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position
		argument and always appends the data to the end of the file.</haxe_doc>
				</write>
			</overloads>
		</write>
		<writeSync public="1" set="method" static="1">
			<f a="fd:buffer:offset:length:?position">
				<x path="Int"/>
				<t path="js.node.Buffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Synchronous version of `write`. Returns the number of bytes written.</haxe_doc>
			<overloads>
				<writeSync public="1" set="method">
					<f a="fd:data:position:encoding">
						<x path="Int"/>
						<d/>
						<x path="Int"/>
						<c path="String"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Synchronous version of `write`. Returns the number of bytes written.</haxe_doc>
				</writeSync>
				<writeSync public="1" set="method">
					<f a="fd:data:?position">
						<x path="Int"/>
						<d/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Synchronous version of `write`. Returns the number of bytes written.</haxe_doc>
				</writeSync>
			</overloads>
		</writeSync>
		<read public="1" set="method" static="1">
			<f a="fd:buffer:offset:length:position:callback">
				<x path="Int"/>
				<t path="js.node.Buffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
				<f a="::">
					<c path="js.lib.Error"/>
					<x path="Int"/>
					<t path="js.node.Buffer"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Read data from the file specified by `fd`.

		`buffer` is the buffer that the data will be written to.

		`offset` is the offset in the `buffer` to start writing at.

		`length` is an integer specifying the number of bytes to read.

		`position` is an integer specifying where to begin reading from in the file.
		If position is null, data will be read from the current file position.

		The `callback` is given the three arguments, (err, bytesRead, buffer).</haxe_doc>
		</read>
		<readSync public="1" set="method" static="1">
			<f a="fd:buffer:offset:length:position">
				<x path="Int"/>
				<t path="js.node.Buffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
				<x path="Int"/>
			</f>
			<haxe_doc>Synchronous version of `read`. Returns the number of bytes read.</haxe_doc>
		</readSync>
		<readFile public="1" set="method" static="1">
			<f a="filename:options:callback">
				<t path="js.node.FsPath"/>
				<a>
					<flag>
						<x path="Null"><x path="js.node.FsOpenFlag"/></x>
						<meta><m n=":optional"/></meta>
					</flag>
					<encoding><c path="String"/></encoding>
				</a>
				<f a=":">
					<c path="js.lib.Error"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronously reads the entire contents of a file.

		The `callback` is passed two arguments (err, data), where data is the contents of the file.
		If no `encoding` is specified, then the raw buffer is returned.

		If `options` is a string, then it specifies the encoding.</haxe_doc>
			<overloads>
				<readFile public="1" set="method">
					<f a="filename:callback">
						<t path="js.node.FsPath"/>
						<f a=":">
							<c path="js.lib.Error"/>
							<t path="js.node.Buffer"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Asynchronously reads the entire contents of a file.

		The `callback` is passed two arguments (err, data), where data is the contents of the file.
		If no `encoding` is specified, then the raw buffer is returned.

		If `options` is a string, then it specifies the encoding.</haxe_doc>
				</readFile>
				<readFile public="1" set="method">
					<f a="filename:options:callback">
						<t path="js.node.FsPath"/>
						<a><flag><x path="js.node.FsOpenFlag"/></flag></a>
						<f a=":">
							<c path="js.lib.Error"/>
							<t path="js.node.Buffer"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Asynchronously reads the entire contents of a file.

		The `callback` is passed two arguments (err, data), where data is the contents of the file.
		If no `encoding` is specified, then the raw buffer is returned.

		If `options` is a string, then it specifies the encoding.</haxe_doc>
				</readFile>
				<readFile public="1" set="method">
					<f a="filename:options:callback">
						<t path="js.node.FsPath"/>
						<c path="String"/>
						<f a=":">
							<c path="js.lib.Error"/>
							<c path="String"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Asynchronously reads the entire contents of a file.

		The `callback` is passed two arguments (err, data), where data is the contents of the file.
		If no `encoding` is specified, then the raw buffer is returned.

		If `options` is a string, then it specifies the encoding.</haxe_doc>
				</readFile>
			</overloads>
		</readFile>
		<readFileSync public="1" set="method" static="1">
			<f a="filename:options">
				<t path="js.node.FsPath"/>
				<a>
					<flag>
						<x path="Null"><x path="js.node.FsOpenFlag"/></x>
						<meta><m n=":optional"/></meta>
					</flag>
					<encoding><c path="String"/></encoding>
				</a>
				<c path="String"/>
			</f>
			<haxe_doc>Synchronous version of `readFile`. Returns the contents of the filename.
		If the `encoding` option is specified then this function returns a string. Otherwise it returns a buffer.</haxe_doc>
			<overloads>
				<readFileSync public="1" set="method">
					<f a="filename">
						<t path="js.node.FsPath"/>
						<t path="js.node.Buffer"/>
					</f>
					<haxe_doc>Synchronous version of `readFile`. Returns the contents of the filename.
		If the `encoding` option is specified then this function returns a string. Otherwise it returns a buffer.</haxe_doc>
				</readFileSync>
				<readFileSync public="1" set="method">
					<f a="filename:options">
						<t path="js.node.FsPath"/>
						<a><flag><x path="js.node.FsOpenFlag"/></flag></a>
						<t path="js.node.Buffer"/>
					</f>
					<haxe_doc>Synchronous version of `readFile`. Returns the contents of the filename.
		If the `encoding` option is specified then this function returns a string. Otherwise it returns a buffer.</haxe_doc>
				</readFileSync>
				<readFileSync public="1" set="method">
					<f a="filename:options">
						<t path="js.node.FsPath"/>
						<c path="String"/>
						<c path="String"/>
					</f>
					<haxe_doc>Synchronous version of `readFile`. Returns the contents of the filename.
		If the `encoding` option is specified then this function returns a string. Otherwise it returns a buffer.</haxe_doc>
				</readFileSync>
			</overloads>
		</readFileSync>
		<writeFile public="1" set="method" static="1">
			<f a="filename:data:options:callback">
				<t path="js.node.FsPath"/>
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<t path="js.node.FsWriteFileOptions"/>
				</x>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronously writes data to a file, replacing the file if it already exists.

		`data` can be a string or a buffer.

		The encoding option is ignored if data is a buffer. It defaults to 'utf8'.</haxe_doc>
			<overloads>
				<writeFile public="1" set="method">
					<f a="filename:data:callback">
						<t path="js.node.FsPath"/>
						<t path="js.node.Buffer"/>
						<f a="">
							<c path="js.lib.Error"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Asynchronously writes data to a file, replacing the file if it already exists.

		`data` can be a string or a buffer.

		The encoding option is ignored if data is a buffer. It defaults to 'utf8'.</haxe_doc>
				</writeFile>
				<writeFile public="1" set="method">
					<f a="filename:data:callback">
						<t path="js.node.FsPath"/>
						<c path="String"/>
						<f a="">
							<c path="js.lib.Error"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Asynchronously writes data to a file, replacing the file if it already exists.

		`data` can be a string or a buffer.

		The encoding option is ignored if data is a buffer. It defaults to 'utf8'.</haxe_doc>
				</writeFile>
				<writeFile public="1" set="method">
					<f a="filename:data:options:callback">
						<t path="js.node.FsPath"/>
						<t path="js.node.Buffer"/>
						<x path="haxe.extern.EitherType">
							<c path="String"/>
							<t path="js.node.FsWriteFileOptions"/>
						</x>
						<f a="">
							<c path="js.lib.Error"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Asynchronously writes data to a file, replacing the file if it already exists.

		`data` can be a string or a buffer.

		The encoding option is ignored if data is a buffer. It defaults to 'utf8'.</haxe_doc>
				</writeFile>
			</overloads>
		</writeFile>
		<writeFileSync public="1" set="method" static="1">
			<f a="filename:data:options">
				<t path="js.node.FsPath"/>
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<t path="js.node.FsWriteFileOptions"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>The synchronous version of `writeFile`.</haxe_doc>
			<overloads>
				<writeFileSync public="1" set="method">
					<f a="filename:data">
						<t path="js.node.FsPath"/>
						<t path="js.node.Buffer"/>
						<x path="Void"/>
					</f>
					<haxe_doc>The synchronous version of `writeFile`.</haxe_doc>
				</writeFileSync>
				<writeFileSync public="1" set="method">
					<f a="filename:data">
						<t path="js.node.FsPath"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<haxe_doc>The synchronous version of `writeFile`.</haxe_doc>
				</writeFileSync>
				<writeFileSync public="1" set="method">
					<f a="filename:data:options">
						<t path="js.node.FsPath"/>
						<t path="js.node.Buffer"/>
						<x path="haxe.extern.EitherType">
							<c path="String"/>
							<t path="js.node.FsWriteFileOptions"/>
						</x>
						<x path="Void"/>
					</f>
					<haxe_doc>The synchronous version of `writeFile`.</haxe_doc>
				</writeFileSync>
			</overloads>
		</writeFileSync>
		<appendFile public="1" set="method" static="1">
			<f a="filename:data:options:callback">
				<t path="js.node.FsPath"/>
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<t path="js.node.FsWriteFileOptions"/>
				</x>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Asynchronously append data to a file, creating the file if it not yet exists.
		`data` can be a string or a buffer.</haxe_doc>
			<overloads>
				<appendFile public="1" set="method">
					<f a="filename:data:callback">
						<t path="js.node.FsPath"/>
						<t path="js.node.Buffer"/>
						<f a="">
							<c path="js.lib.Error"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Asynchronously append data to a file, creating the file if it not yet exists.
		`data` can be a string or a buffer.</haxe_doc>
				</appendFile>
				<appendFile public="1" set="method">
					<f a="filename:data:callback">
						<t path="js.node.FsPath"/>
						<c path="String"/>
						<f a="">
							<c path="js.lib.Error"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Asynchronously append data to a file, creating the file if it not yet exists.
		`data` can be a string or a buffer.</haxe_doc>
				</appendFile>
				<appendFile public="1" set="method">
					<f a="filename:data:options:callback">
						<t path="js.node.FsPath"/>
						<t path="js.node.Buffer"/>
						<x path="haxe.extern.EitherType">
							<c path="String"/>
							<t path="js.node.FsWriteFileOptions"/>
						</x>
						<f a="">
							<c path="js.lib.Error"/>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>Asynchronously append data to a file, creating the file if it not yet exists.
		`data` can be a string or a buffer.</haxe_doc>
				</appendFile>
			</overloads>
		</appendFile>
		<appendFileSync public="1" set="method" static="1">
			<f a="filename:data:options">
				<t path="js.node.FsPath"/>
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<t path="js.node.FsWriteFileOptions"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>The synchronous version of `appendFile`.</haxe_doc>
			<overloads>
				<appendFileSync public="1" set="method">
					<f a="filename:data">
						<t path="js.node.FsPath"/>
						<t path="js.node.Buffer"/>
						<x path="Void"/>
					</f>
					<haxe_doc>The synchronous version of `appendFile`.</haxe_doc>
				</appendFileSync>
				<appendFileSync public="1" set="method">
					<f a="filename:data">
						<t path="js.node.FsPath"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<haxe_doc>The synchronous version of `appendFile`.</haxe_doc>
				</appendFileSync>
				<appendFileSync public="1" set="method">
					<f a="filename:data:options">
						<t path="js.node.FsPath"/>
						<t path="js.node.Buffer"/>
						<x path="haxe.extern.EitherType">
							<c path="String"/>
							<t path="js.node.FsWriteFileOptions"/>
						</x>
						<x path="Void"/>
					</f>
					<haxe_doc>The synchronous version of `appendFile`.</haxe_doc>
				</appendFileSync>
			</overloads>
		</appendFileSync>
		<watchFile public="1" set="method" static="1">
			<f a="filename:options:listener">
				<t path="js.node.FsPath"/>
				<t path="js.node.FsWatchFileOptions"/>
				<f a=":">
					<c path="js.node.fs.Stats"/>
					<c path="js.node.fs.Stats"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Unstable. Use `watch` instead, if possible.

		Watch for changes on `filename`.
		The callback `listener` will be called each time the file is accessed.

		The `options` if provided should be an object containing two members:
			- `persistent` indicates whether the process should continue to run as long as files are being watched.
			- `interval` indicates how often the target should be polled, in milliseconds.
		The default is { persistent: true, interval: 5007 }.

		The `listener` gets two arguments: the current stat object and the previous stat object.</haxe_doc>
			<overloads><watchFile public="1" set="method">
	<f a="filename:listener">
		<t path="js.node.FsPath"/>
		<f a=":">
			<c path="js.node.fs.Stats"/>
			<c path="js.node.fs.Stats"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<haxe_doc>Unstable. Use `watch` instead, if possible.

		Watch for changes on `filename`.
		The callback `listener` will be called each time the file is accessed.

		The `options` if provided should be an object containing two members:
			- `persistent` indicates whether the process should continue to run as long as files are being watched.
			- `interval` indicates how often the target should be polled, in milliseconds.
		The default is { persistent: true, interval: 5007 }.

		The `listener` gets two arguments: the current stat object and the previous stat object.</haxe_doc>
</watchFile></overloads>
		</watchFile>
		<unwatchFile public="1" set="method" static="1">
			<f a="filename:?listener">
				<t path="js.node.FsPath"/>
				<f a=":">
					<c path="js.node.fs.Stats"/>
					<c path="js.node.fs.Stats"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Unstable. Use `watch` instead, if possible.

		Stop watching for changes on filename.
		If `listener` is specified, only that particular listener is removed.
		Otherwise, all listeners are removed and you have effectively stopped watching filename.
		Calling `unwatchFile` with a `filename` that is not being watched is a no-op, not an error.</haxe_doc>
		</unwatchFile>
		<watch public="1" set="method" static="1">
			<f a="filename:listener">
				<t path="js.node.FsPath"/>
				<f a=":">
					<x path="js.node.fs.FSWatcherChangeType"/>
					<t path="js.node.FsPath"/>
					<x path="Void"/>
				</f>
				<c path="js.node.fs.FSWatcher"/>
			</f>
			<haxe_doc>Watch for changes on `filename`, where filename is either a file or a directory.

		`persistent` indicates whether the process should continue to run as long as files are being watched. Default is `true`.

		The `listener` callback gets two arguments (event, filename). event is either 'rename' or 'change', and filename
		is the name of the file which triggered the event.</haxe_doc>
			<overloads>
				<watch public="1" set="method">
					<f a="filename">
						<t path="js.node.FsPath"/>
						<c path="js.node.fs.FSWatcher"/>
					</f>
					<haxe_doc>Watch for changes on `filename`, where filename is either a file or a directory.

		`persistent` indicates whether the process should continue to run as long as files are being watched. Default is `true`.

		The `listener` callback gets two arguments (event, filename). event is either 'rename' or 'change', and filename
		is the name of the file which triggered the event.</haxe_doc>
				</watch>
				<watch public="1" set="method">
					<f a="filename:options:listener">
						<t path="js.node.FsPath"/>
						<a>
							<recursive>
								<x path="Null"><x path="Bool"/></x>
								<meta><m n=":optional"/></meta>
							</recursive>
							<persistent><x path="Bool"/></persistent>
						</a>
						<f a=":">
							<x path="js.node.fs.FSWatcherChangeType"/>
							<c path="String"/>
							<x path="Void"/>
						</f>
						<c path="js.node.fs.FSWatcher"/>
					</f>
					<haxe_doc>Watch for changes on `filename`, where filename is either a file or a directory.

		`persistent` indicates whether the process should continue to run as long as files are being watched. Default is `true`.

		The `listener` callback gets two arguments (event, filename). event is either 'rename' or 'change', and filename
		is the name of the file which triggered the event.</haxe_doc>
				</watch>
			</overloads>
		</watch>
		<exists public="1" set="method" static="1">
			<f a="path:callback">
				<t path="js.node.FsPath"/>
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"><e>"Use Fs.stat or Fs.access instead"</e></m></meta>
			<haxe_doc>Test whether or not the given `path` exists by checking with the file system.
		Then call the `callback` argument with either `true` or `false`.

		`exists` is an anachronism and exists only for historical reasons.
		There should almost never be a reason to use it in your own code.

		In particular, checking if a file exists before opening it is an anti-pattern that leaves you vulnerable to race conditions:
		another process may remove the file between the calls to `exists` and `open`.

		Just open the file and handle the error when it's not there.</haxe_doc>
		</exists>
		<existsSync public="1" set="method" static="1">
			<f a="path">
				<t path="js.node.FsPath"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Synchronous version of `exists`.</haxe_doc>
		</existsSync>
		<access public="1" set="method" static="1">
			<f a="path:mode:callback">
				<t path="js.node.FsPath"/>
				<x path="Int"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Tests a user's permissions for the file or directory specified by `path`.

		The `mode` argument is an optional integer that specifies the accessibility checks to be performed.
		The following constants define the possible values of `mode`. It is possible to create a mask consisting
		of the bitwise OR of two or more values.

		* `Fs.constants.F_OK` - path is visible to the calling process. This is useful for determining if a file exists,
		  but says nothing about `rwx` permissions. Default if no `mode` is specified.
		* `Fs.constants.R_OK` - path can be read by the calling process.
		* `Fs.constants.W_OK` - path can be written by the calling process.
		* `Fs.constants.X_OK` - path can be executed by the calling process.
		  This has no effect on Windows (will behave like `Fs.constants.F_OK`).

		The final argument, `callback`, is a callback function that is invoked with a possible error argument.
		If any of the accessibility checks fail, the error argument will be populated.</haxe_doc>
			<overloads><access public="1" set="method">
	<f a="path:callback">
		<t path="js.node.FsPath"/>
		<f a="">
			<c path="js.lib.Error"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<haxe_doc>Tests a user's permissions for the file or directory specified by `path`.

		The `mode` argument is an optional integer that specifies the accessibility checks to be performed.
		The following constants define the possible values of `mode`. It is possible to create a mask consisting
		of the bitwise OR of two or more values.

		* `Fs.constants.F_OK` - path is visible to the calling process. This is useful for determining if a file exists,
		  but says nothing about `rwx` permissions. Default if no `mode` is specified.
		* `Fs.constants.R_OK` - path can be read by the calling process.
		* `Fs.constants.W_OK` - path can be written by the calling process.
		* `Fs.constants.X_OK` - path can be executed by the calling process.
		  This has no effect on Windows (will behave like `Fs.constants.F_OK`).

		The final argument, `callback`, is a callback function that is invoked with a possible error argument.
		If any of the accessibility checks fail, the error argument will be populated.</haxe_doc>
</access></overloads>
		</access>
		<F_OK public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>A mode flag for `access` and `accessSync` methods:

		File is visible to the calling process.
		This is useful for determining if a file exists, but says nothing about rwx permissions.</haxe_doc>
		</F_OK>
		<R_OK public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>A mode flag for `access` and `accessSync` methods:

		File can be read by the calling process.</haxe_doc>
		</R_OK>
		<W_OK public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>A mode flag for `access` and `accessSync` methods:

		File can be written by the calling process.</haxe_doc>
		</W_OK>
		<X_OK public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>A mode flag for `access` and `accessSync` methods:

		File can be executed by the calling process.
		This has no effect on Windows.</haxe_doc>
		</X_OK>
		<accessSync public="1" set="method" static="1">
			<f a="path:?mode">
				<t path="js.node.FsPath"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronous version of `access`.
		This throws if any accessibility checks fail, and does nothing otherwise.</haxe_doc>
		</accessSync>
		<createReadStream public="1" set="method" static="1">
			<f a="path:?options">
				<t path="js.node.FsPath"/>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<t path="js.node.FsCreateReadStreamOptions"/>
				</x>
				<c path="js.node.fs.ReadStream"/>
			</f>
			<haxe_doc>Returns a new ReadStream object (See Readable Stream).

		`options` can include `start` and `end` values to read a range of bytes from the file instead of the entire file.
		Both `start` and `end` are inclusive and start at 0.

		The encoding can be 'utf8', 'ascii', or 'base64'.

		If `autoClose` is `false`, then the file descriptor won't be closed, even if there's an error.
		It is your responsiblity to close it and make sure there's no file descriptor leak.
		If `autoClose` is set to true (default behavior), on error or end the file descriptor will be closed automatically.</haxe_doc>
		</createReadStream>
		<createWriteStream public="1" set="method" static="1">
			<f a="path:?options">
				<t path="js.node.FsPath"/>
				<x path="Null"><t path="js.node.FsCreateWriteStreamOptions"/></x>
				<c path="js.node.fs.WriteStream"/>
			</f>
			<haxe_doc>Returns a new WriteStream object (See Writable Stream).

		`options` may also include a `start` option to allow writing data at some position past the beginning of the file.

		Modifying a file rather than replacing it may require a flags mode of r+ rather than the default mode w.</haxe_doc>
		</createWriteStream>
		<haxe_doc>File I/O is provided by simple wrappers around standard POSIX functions.
	All the methods have asynchronous and synchronous forms.

	The asynchronous form always take a completion callback as its last argument.
	The arguments passed to the completion callback depend on the method,
	but the first argument is always reserved for an exception.

	If the operation was completed successfully, then the first argument will be null.

	When using the synchronous form any exceptions are immediately thrown.
	You can use try/catch to handle exceptions or allow them to bubble up.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":jsRequire"><e>"fs"</e></m>
		</meta>
	</class>
	<typedef path="js.node.Iterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Iterator.hx"><t path="js.lib.Iterator"><c path="js.node.Iterator.T"/></t></typedef>
	<typedef path="js.node.IteratorStep" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Iterator.hx" module="js.node.Iterator"><t path="js.lib.IteratorStep"><c path="js.node.IteratorStep.T"/></t></typedef>
	<abstract path="js.node.KeyValue" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/KeyValue.hx">
		<this><c path="Array"><x path="Any"/></c></this>
		<haxe_doc>Key/value access helper.</haxe_doc>
		<impl><class path="js.node._KeyValue.KeyValue_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/KeyValue.hx" private="1" module="js.node.KeyValue" final="1">
	<key public="1" get="accessor" set="null" static="1"><c path="js.node.KeyValue.K"/></key>
	<value public="1" get="accessor" set="null" static="1"><c path="js.node.KeyValue.V"/></value>
	<get_key get="inline" set="null" line="32" static="1"><f a="this">
	<c path="Array"><x path="Any"/></c>
	<c path="js.node.KeyValue.K"/>
</f></get_key>
	<get_value get="inline" set="null" line="36" static="1"><f a="this">
	<c path="Array"><x path="Any"/></c>
	<c path="js.node.KeyValue.V"/>
</f></get_value>
</class></impl>
	</abstract>
	<class path="js.node._KeyValue.KeyValue_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/KeyValue.hx" private="1" module="js.node.KeyValue" final="1">
		<key public="1" get="accessor" set="null" static="1"><c path="js.node.KeyValue.K"/></key>
		<value public="1" get="accessor" set="null" static="1"><c path="js.node.KeyValue.V"/></value>
		<get_key get="inline" set="null" line="32" static="1"><f a="this">
	<c path="Array"><x path="Any"/></c>
	<c path="js.node.KeyValue.K"/>
</f></get_key>
		<get_value get="inline" set="null" line="36" static="1"><f a="this">
	<c path="Array"><x path="Any"/></c>
	<c path="js.node.KeyValue.V"/>
</f></get_value>
	</class>
	<class path="js.node.Module" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Module.hx" extern="1">
		<builtinModules public="1" set="null" static="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>A list of the names of all modules provided by Node.js.
		Can be used to verify if a module is maintained by a third party or not.

		@see https://nodejs.org/api/modules.html#modules_module_builtinmodules</haxe_doc>
		</builtinModules>
		<createRequire public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<f a="">
					<c path="String"/>
					<d/>
				</f>
			</f>
			<haxe_doc>@see https://nodejs.org/api/modules.html#modules_module_createrequire_filename</haxe_doc>
			<overloads><createRequire public="1" set="method">
	<f a="filename">
		<c path="js.node.url.URL"/>
		<f a="">
			<c path="String"/>
			<d/>
		</f>
	</f>
	<haxe_doc>@see https://nodejs.org/api/modules.html#modules_module_createrequire_filename</haxe_doc>
</createRequire></overloads>
		</createRequire>
		<syncBuiltinESMExports public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>The `module.syncBuiltinESMExports()` method updates all the live bindings for builtin ES Modules to match the
		properties of the CommonJS exports.
		It does not add or remove exported names from the ES Modules.

		@see https://nodejs.org/api/modules.html#modules_module_syncbuiltinesmexports</haxe_doc>
		</syncBuiltinESMExports>
		<children public="1" set="null">
			<c path="Array"><c path="js.node.Module"/></c>
			<haxe_doc>The module objects required for the first time by this one.

		@see https://nodejs.org/api/modules.html#modules_module_children</haxe_doc>
		</children>
		<exports public="1">
			<d/>
			<haxe_doc>The `module.exports` object is created by the Module system.
		Sometimes this is not acceptable; many want their module to be an instance of some class.
		To do this, assign the desired export object to `module.exports`.
		Assigning the desired object to `exports` will simply rebind the local `exports` variable, which is probably not
		what is desired.

		@see https://nodejs.org/api/modules.html#modules_module_exports</haxe_doc>
		</exports>
		<filename public="1" set="null">
			<c path="String"/>
			<haxe_doc>The fully resolved filename of the module.

		@see https://nodejs.org/api/modules.html#modules_module_filename</haxe_doc>
		</filename>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>The identifier for the module.
		Typically this is the fully resolved filename.

		@see https://nodejs.org/api/modules.html#modules_module_id</haxe_doc>
		</id>
		<loaded public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether or not the module is done loading, or is in the process of loading.

		@see https://nodejs.org/api/modules.html#modules_module_loaded</haxe_doc>
		</loaded>
		<parent public="1" set="null">
			<c path="js.node.Module"/>
			<haxe_doc>The module that first required this one.

		@see https://nodejs.org/api/modules.html#modules_module_parent</haxe_doc>
		</parent>
		<paths public="1" set="null">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>The search paths for the module.

		@see https://nodejs.org/api/modules.html#modules_module_paths</haxe_doc>
		</paths>
		<require public="1" set="method">
			<f a="id">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>The `module.require()` method provides a way to load a module as if `require()` was called from the original
		module.

		@see https://nodejs.org/api/modules.html#modules_module_require_id</haxe_doc>
		</require>
		<haxe_doc>In each module, the `module` free variable is a reference to the object representing the current module.
	For convenience, `module.exports` is also accessible via the `exports` module-global.
	`module` is not actually a global but rather local to each module.

	@see https://nodejs.org/api/modules.html#modules_the_module_object</haxe_doc>
		<meta><m n=":jsRequire"><e>"module"</e></m></meta>
	</class>
	<class path="js.node.Path" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Path.hx" extern="1">
		<basename public="1" set="method" static="1">
			<f a="path:?ext">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>The `path.basename()` methods returns the last portion of a `path`, similar to the Unix `basename` command. Trailing directory separators are ignored, see path.sep.

		@see https://nodejs.org/api/path.html#path_path_basename_path_ext</haxe_doc>
		</basename>
		<delimiter public="1" set="null" static="1">
			<c path="String"/>
			<haxe_doc>Platform-specific path delimiter:

		`;` for Windows
		`:` for POSIX
		@see https://nodejs.org/api/path.html#path_path_delimiter</haxe_doc>
		</delimiter>
		<dirname public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>The `path.dirname()` method returns the directory name of a `path`, similar to the Unix `dirname` command. Trailing directory separators are ignored, see path.sep.

		@see https://nodejs.org/api/path.html#path_path_dirname_path</haxe_doc>
		</dirname>
		<extname public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>The `path.extname()` method returns the extension of the `path`, from the last occurrence of the `.` (period) character to end of string in the last portion of the `path`.
		If there is no `.` in the last portion of the `path`, or if there are no `.` characters other than the first character of the basename of `path` (see `path.basename()`) ,
		an empty string is returned.

		@see https://nodejs.org/api/path.html#path_path_extname_path</haxe_doc>
		</extname>
		<format public="1" set="method" static="1">
			<f a="pathObject">
				<t path="js.node.PathObject"/>
				<c path="String"/>
			</f>
			<haxe_doc>The path.format() method returns a path string from an object. This is the opposite of path.parse().

		@see https://nodejs.org/api/path.html#path_path_format_pathobject</haxe_doc>
		</format>
		<isAbsolute public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>The `path.isAbsolute()` method determines if `path` is an absolute path.

		@see https://nodejs.org/api/path.html#path_path_isabsolute_path</haxe_doc>
		</isAbsolute>
		<join public="1" set="method" static="1">
			<f a="paths">
				<t path="haxe.extern.Rest"><c path="String"/></t>
				<c path="String"/>
			</f>
			<haxe_doc>The `path.join()` method joins all given `path` segments together using the platform-specific separator as a delimiter, then normalizes the resulting path.

		@see https://nodejs.org/api/path.html#path_path_join_paths</haxe_doc>
		</join>
		<normalize public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>The `path.normalize()` method normalizes the given `path`, resolving `'..'` and `'.'` segments.

		@see https://nodejs.org/api/path.html#path_path_normalize_path</haxe_doc>
		</normalize>
		<parse public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<t path="js.node.PathObject"/>
			</f>
			<haxe_doc>The `path.parse()` method returns an object whose properties represent significant elements of the `path`. Trailing directory separators are ignored, see path.sep.

		@see https://nodejs.org/api/path.html#path_path_parse_path</haxe_doc>
		</parse>
		<posix public="1" set="null" static="1">
			<t path="js.node._Path.PathModule"/>
			<haxe_doc>The `path.posix` property provides access to POSIX specific implementations of the `path` methods.

		@see https://nodejs.org/api/path.html#path_path_posix</haxe_doc>
		</posix>
		<relative public="1" set="method" static="1">
			<f a="from:to">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>The `path.relative()` method returns the relative path from `from` to `to` based on the current working directory.
		If `from` and `to` each resolve to the same path (after calling path.resolve() on each), a zero-length string is returned.

		@see https://nodejs.org/api/path.html#path_path_relative_from_to</haxe_doc>
		</relative>
		<resolve public="1" set="method" static="1">
			<f a="paths">
				<t path="haxe.extern.Rest"><c path="String"/></t>
				<c path="String"/>
			</f>
			<haxe_doc>The `path.resolve()` method resolves a sequence of paths or path segments into an absolute path.

		@see https://nodejs.org/api/path.html#path_path_resolve_paths</haxe_doc>
		</resolve>
		<sep public="1" set="null" static="1">
			<c path="String"/>
			<haxe_doc>Provides the platform-specific path segment separator:

		`\` on Windows
		`/` on POSIX

		@see https://nodejs.org/api/path.html#path_path_sep</haxe_doc>
		</sep>
		<toNamespacedPath public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>On Windows systems only, returns an equivalent namespace-prefixed path for the given `path`. If `path` is not a string, `path` will be returned without modifications.

		@see https://nodejs.org/api/path.html#path_path_tonamespacedpath_path</haxe_doc>
		</toNamespacedPath>
		<win32 public="1" set="null" static="1">
			<t path="js.node._Path.PathModule"/>
			<haxe_doc>The path.win32 property provides access to Windows-specific implementations of the path methods.

		@see https://nodejs.org/api/path.html#path_path_win32</haxe_doc>
		</win32>
		<haxe_doc>The `path` module provides utilities for working with file and directory paths.

	@see https://nodejs.org/api/path.html#path_path</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":jsRequire"><e>"path"</e></m>
		</meta>
	</class>
	<typedef path="js.node.PathObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Path.hx" module="js.node.Path">
		<a>
			<root>
				<c path="String"/>
				<haxe_doc>E.g. "C:\" for "C:\path\dir\index.html"</haxe_doc>
			</root>
			<name>
				<c path="String"/>
				<haxe_doc>E.g. "index" for "C:\path\dir\index.html"</haxe_doc>
			</name>
			<ext>
				<c path="String"/>
				<haxe_doc>E.g. ".html" for "C:\path\dir\index.html"</haxe_doc>
			</ext>
			<dir>
				<c path="String"/>
				<haxe_doc>E.g. "C:\path\dir" for "C:\path\dir\index.html"</haxe_doc>
			</dir>
			<base>
				<c path="String"/>
				<haxe_doc>E.g. "index.html" for "C:\path\dir\index.html"</haxe_doc>
			</base>
		</a>
		<haxe_doc>Path object returned from `Path.parse` and taken by `Path.format`.

	@see https://nodejs.org/api/path.html#path_path_format_pathobject</haxe_doc>
	</typedef>
	<typedef path="js.node._Path.PathModule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Path.hx" private="1" module="js.node.Path"><a>
	<sep set="null"><c path="String"/></sep>
	<resolve set="method"><f a="paths">
	<t path="haxe.extern.Rest"><c path="String"/></t>
	<c path="String"/>
</f></resolve>
	<relative set="method"><f a="from:to">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></relative>
	<parse set="method"><f a="pathString">
	<c path="String"/>
	<t path="js.node.PathObject"/>
</f></parse>
	<normalize set="method"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></normalize>
	<join set="method"><f a="paths">
	<t path="haxe.extern.Rest"><c path="String"/></t>
	<c path="String"/>
</f></join>
	<isAbsolute set="method"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isAbsolute>
	<format set="method"><f a="pathObject">
	<t path="js.node.PathObject"/>
	<c path="String"/>
</f></format>
	<extname set="method"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></extname>
	<dirname set="method"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></dirname>
	<delimiter set="null"><c path="String"/></delimiter>
	<basename set="method"><f a="path:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></basename>
</a></typedef>
	<abstract path="js.node.ProcessEvent" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Process.hx" module="js.node.Process">
		<this><x path="js.node.events.Event"><c path="js.node.ProcessEvent.T"/></x></this>
		<to><icast><x path="js.node.events.Event"><c path="js.node.ProcessEvent.T"/></x></icast></to>
		<haxe_doc>Enumeration of events emitted by the Process class.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node._Process.ProcessEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Process.hx" private="1" module="js.node.Process" extern="1" final="1">
	<Exit public="1" get="inline" set="null" expr="cast &quot;exit&quot;" line="50" static="1">
		<x path="js.node.ProcessEvent"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "exit"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Emitted when the process is about to exit.
		There is no way to prevent the exiting of the event loop at this point,
		and once all exit listeners have finished running the process will exit.
		Therefore you must only perform synchronous operations in this handler.
		This is a good hook to perform checks on the module's state (like for unit tests).
		The callback takes one argument, the code the process is exiting with.</haxe_doc>
	</Exit>
	<BeforeExit public="1" get="inline" set="null" expr="cast &quot;beforeExit&quot;" line="62" static="1">
		<x path="js.node.ProcessEvent"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "beforeExit"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Emitted when node empties it's event loop and has nothing else to schedule.

		Normally, node exits when there is no work scheduled, but a listener for `beforeExit`
		can make asynchronous calls, and cause node to continue.

		`beforeExit` is not emitted for conditions causing explicit termination, such as `process.exit()`
		or uncaught exceptions, and should not be used as an alternative to the `exit` event
		unless the intention is to schedule more work.</haxe_doc>
	</BeforeExit>
	<UncaughtException public="1" get="inline" set="null" expr="cast &quot;uncaughtException&quot;" line="69" static="1">
		<x path="js.node.ProcessEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "uncaughtException"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Emitted when an exception bubbles all the way back to the event loop.
		If a listener is added for this exception, the default action (which is to print a stack trace and exit)
		will not occur.</haxe_doc>
	</UncaughtException>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node._Process.ProcessEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Process.hx" private="1" module="js.node.Process" extern="1" final="1">
		<Exit public="1" get="inline" set="null" expr="cast &quot;exit&quot;" line="50" static="1">
			<x path="js.node.ProcessEvent"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "exit"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Emitted when the process is about to exit.
		There is no way to prevent the exiting of the event loop at this point,
		and once all exit listeners have finished running the process will exit.
		Therefore you must only perform synchronous operations in this handler.
		This is a good hook to perform checks on the module's state (like for unit tests).
		The callback takes one argument, the code the process is exiting with.</haxe_doc>
		</Exit>
		<BeforeExit public="1" get="inline" set="null" expr="cast &quot;beforeExit&quot;" line="62" static="1">
			<x path="js.node.ProcessEvent"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "beforeExit"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Emitted when node empties it's event loop and has nothing else to schedule.

		Normally, node exits when there is no work scheduled, but a listener for `beforeExit`
		can make asynchronous calls, and cause node to continue.

		`beforeExit` is not emitted for conditions causing explicit termination, such as `process.exit()`
		or uncaught exceptions, and should not be used as an alternative to the `exit` event
		unless the intention is to schedule more work.</haxe_doc>
		</BeforeExit>
		<UncaughtException public="1" get="inline" set="null" expr="cast &quot;uncaughtException&quot;" line="69" static="1">
			<x path="js.node.ProcessEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "uncaughtException"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Emitted when an exception bubbles all the way back to the event loop.
		If a listener is added for this exception, the default action (which is to print a stack trace and exit)
		will not occur.</haxe_doc>
		</UncaughtException>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="js.node.events.IEventEmitter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/events/EventEmitter.hx" module="js.node.events.EventEmitter" extern="1" interface="1">
		<addListener public="1" params="T" set="method"><f a="eventName:listener">
	<x path="js.node.events.Event"><c path="addListener.T"/></x>
	<c path="addListener.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></addListener>
		<emit public="1" params="T" set="method"><f a="eventName:args">
	<x path="js.node.events.Event"><c path="emit.T"/></x>
	<t path="haxe.extern.Rest"><d/></t>
	<x path="Bool"/>
</f></emit>
		<eventNames public="1" set="method"><f a=""><c path="Array"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<c path="js.lib.Symbol"/>
</x></c></f></eventNames>
		<getMaxListeners public="1" set="method"><f a=""><x path="Int"/></f></getMaxListeners>
		<listenerCount public="1" params="T" set="method"><f a="eventName">
	<x path="js.node.events.Event"><c path="listenerCount.T"/></x>
	<x path="Int"/>
</f></listenerCount>
		<listeners public="1" params="T" set="method"><f a="eventName">
	<x path="js.node.events.Event"><c path="listeners.T"/></x>
	<c path="Array"><c path="listeners.T"/></c>
</f></listeners>
		<off public="1" params="T" set="method"><f a="eventName:listener">
	<x path="js.node.events.Event"><c path="off.T"/></x>
	<c path="off.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></off>
		<on public="1" params="T" set="method"><f a="eventName:listener">
	<x path="js.node.events.Event"><c path="on.T"/></x>
	<c path="on.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></on>
		<once public="1" params="T" set="method"><f a="eventName:listener">
	<x path="js.node.events.Event"><c path="once.T"/></x>
	<c path="once.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></once>
		<prependListener public="1" params="T" set="method"><f a="eventName:listener">
	<x path="js.node.events.Event"><c path="prependListener.T"/></x>
	<c path="prependListener.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></prependListener>
		<prependOnceListener public="1" params="T" set="method"><f a="eventName:listener">
	<x path="js.node.events.Event"><c path="prependOnceListener.T"/></x>
	<c path="prependOnceListener.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></prependOnceListener>
		<removeAllListeners public="1" params="T" set="method"><f a="?eventName">
	<x path="js.node.events.Event"><c path="removeAllListeners.T"/></x>
	<c path="js.node.events.IEventEmitter"/>
</f></removeAllListeners>
		<removeListener public="1" params="T" set="method"><f a="eventName:listener">
	<x path="js.node.events.Event"><c path="removeListener.T"/></x>
	<c path="removeListener.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></removeListener>
		<setMaxListeners public="1" set="method"><f a="n">
	<x path="Int"/>
	<x path="Void"/>
</f></setMaxListeners>
		<rawListeners public="1" params="T" set="method"><f a="eventName">
	<x path="js.node.events.Event"><c path="rawListeners.T"/></x>
	<c path="Array"><c path="rawListeners.T"/></c>
</f></rawListeners>
		<haxe_doc>`IEventEmitter` interface is used as "any EventEmitter".

	See `EventEmitter` for actual class documentation.</haxe_doc>
		<meta><m n=":remove"/></meta>
	</class>
	<class path="js.node.events.EventEmitter" params="TSelf" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/events/EventEmitter.hx" extern="1">
		<defaultMaxListeners public="1" static="1">
			<x path="Int"/>
			<haxe_doc>By default, a maximum of `10` listeners can be registered for any single
		event. This limit can be changed for individual `EventEmitter` instances
		using the `emitter.setMaxListeners(n)` method. To change the default
		for all `EventEmitter` instances, the `EventEmitter.defaultMaxListeners`
		property can be used. If this value is not a positive number, a `TypeError`
		will be thrown.

		@see https://nodejs.org/api/events.html#events_eventemitter_defaultmaxlisteners</haxe_doc>
		</defaultMaxListeners>
		<addListener public="1" params="T" set="method">
			<f a="eventName:listener">
				<x path="js.node.events.Event"><c path="addListener.T"/></x>
				<c path="addListener.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Alias for `emitter.on(eventName, listener)`.

		@see https://nodejs.org/api/events.html#events_emitter_addlistener_eventname_listener</haxe_doc>
		</addListener>
		<emit public="1" params="T" set="method">
			<f a="eventName:args">
				<x path="js.node.events.Event"><c path="emit.T"/></x>
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Bool"/>
			</f>
			<haxe_doc>Synchronously calls each of the listeners registered for the event named
		`eventName`, in the order they were registered, passing the supplied arguments
		to each.

		@see https://nodejs.org/api/events.html#events_emitter_emit_eventname_args</haxe_doc>
		</emit>
		<eventNames public="1" set="method">
			<f a=""><c path="Array"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<c path="js.lib.Symbol"/>
</x></c></f>
			<haxe_doc>Returns an array listing the events for which the emitter has registered
		listeners. The values in the array will be strings or `Symbol`s.

		@see https://nodejs.org/api/events.html#events_emitter_eventnames</haxe_doc>
		</eventNames>
		<getMaxListeners public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the current max listener value for the `EventEmitter` which is either
		set by `emitter.setMaxListeners(n)` or defaults to
		`EventEmitter.defaultMaxListeners`.

		@see https://nodejs.org/api/events.html#events_emitter_getmaxlisteners</haxe_doc>
		</getMaxListeners>
		<listenerCount public="1" params="T" set="method">
			<f a="eventName">
				<x path="js.node.events.Event"><c path="listenerCount.T"/></x>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of listeners listening to the event named `eventName`.

		@see https://nodejs.org/api/events.html#events_emitter_listenercount_eventname</haxe_doc>
		</listenerCount>
		<listeners public="1" params="T" set="method">
			<f a="eventName">
				<x path="js.node.events.Event"><c path="listeners.T"/></x>
				<c path="Array"><c path="listeners.T"/></c>
			</f>
			<haxe_doc>Returns a copy of the array of listeners for the event named `eventName`.

		@see https://nodejs.org/api/events.html#events_emitter_listeners_eventname</haxe_doc>
		</listeners>
		<off public="1" params="T" set="method">
			<f a="eventName:listener">
				<x path="js.node.events.Event"><c path="off.T"/></x>
				<c path="off.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Alias for `emitter.removeListener()`.

		@see https://nodejs.org/api/events.html#events_emitter_off_eventname_listener</haxe_doc>
		</off>
		<on public="1" params="T" set="method">
			<f a="eventName:listener">
				<x path="js.node.events.Event"><c path="on.T"/></x>
				<c path="on.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Adds the `listener` function to the end of the listeners array for the
		event named `eventName`. No checks are made to see if the `listener` has
		already been added. Multiple calls passing the same combination of `eventName`
		and `listener` will result in the `listener` being added, and called, multiple
		times.

		@see https://nodejs.org/api/events.html#events_emitter_on_eventname_listener</haxe_doc>
		</on>
		<once public="1" params="T" set="method">
			<f a="eventName:listener">
				<x path="js.node.events.Event"><c path="once.T"/></x>
				<c path="once.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Adds a one-time `listener` function for the event named `eventName`. The
		next time `eventName` is triggered, this listener is removed and then invoked.

		@see https://nodejs.org/api/events.html#events_emitter_once_eventname_listener</haxe_doc>
		</once>
		<prependListener public="1" params="T" set="method">
			<f a="eventName:listener">
				<x path="js.node.events.Event"><c path="prependListener.T"/></x>
				<c path="prependListener.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Adds the `listener` function to the beginning of the listeners array for the
		event named `eventName`. No checks are made to see if the `listener` has
		already been added. Multiple calls passing the same combination of `eventName`
		and `listener` will result in the `listener` being added, and called, multiple
		times.

		@see https://nodejs.org/api/events.html#events_emitter_prependlistener_eventname_listener</haxe_doc>
		</prependListener>
		<prependOnceListener public="1" params="T" set="method">
			<f a="eventName:listener">
				<x path="js.node.events.Event"><c path="prependOnceListener.T"/></x>
				<c path="prependOnceListener.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Adds a one-time `listener` function for the event named `eventName` to the
		beginning of the listeners array. The next time `eventName` is triggered, this
		listener is removed, and then invoked.

		@see https://nodejs.org/api/events.html#events_emitter_prependoncelistener_eventname_listener</haxe_doc>
		</prependOnceListener>
		<removeAllListeners public="1" params="T" set="method">
			<f a="?eventName">
				<x path="js.node.events.Event"><c path="removeAllListeners.T"/></x>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Removes all listeners, or those of the specified `eventName`.

		@see https://nodejs.org/api/events.html#events_emitter_removealllisteners_eventname</haxe_doc>
		</removeAllListeners>
		<removeListener public="1" params="T" set="method">
			<f a="eventName:listener">
				<x path="js.node.events.Event"><c path="removeListener.T"/></x>
				<c path="removeListener.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Removes the specified `listener` from the listener array for the event named
		`eventName`.

		@see https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener</haxe_doc>
		</removeListener>
		<setMaxListeners public="1" set="method">
			<f a="n">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>By default `EventEmitter`s will print a warning if more than `10` listeners are
		added for a particular event. This is a useful default that helps finding
		memory leaks. Obviously, not all events should be limited to just 10 listeners.
		The `emitter.setMaxListeners()` method allows the limit to be modified for this
		specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`)
		to indicate an unlimited number of listeners.

		@see https://nodejs.org/api/events.html#events_emitter_setmaxlisteners_n</haxe_doc>
		</setMaxListeners>
		<rawListeners public="1" params="T" set="method">
			<f a="eventName">
				<x path="js.node.events.Event"><c path="rawListeners.T"/></x>
				<c path="Array"><c path="rawListeners.T"/></c>
			</f>
			<haxe_doc>Returns a copy of the array of listeners for the event named `eventName`,
		including any wrappers (such as those created by `.once()`).

		@see https://nodejs.org/api/events.html#events_emitter_rawlisteners_eventname</haxe_doc>
		</rawListeners>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The `EventEmitter` class is defined and exposed by the `events` module:

	@see https://nodejs.org/api/events.html#events_class_eventemitter</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"events"</e>
	<e>"EventEmitter"</e>
</m></meta>
	</class>
	<class path="js.node.Process" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Process.hx" extern="1">
		<extends path="js.node.events.EventEmitter"><c path="js.node.Process"/></extends>
		<stdout public="1">
			<c path="js.node.stream.IWritable"/>
			<haxe_doc>A Writable Stream to stdout.

		`stderr` and `stdout` are unlike other streams in Node in that writes to them are usually blocking.</haxe_doc>
		</stdout>
		<stderr public="1">
			<c path="js.node.stream.IWritable"/>
			<haxe_doc>A writable stream to stderr.

		`stderr` and `stdout` are unlike other streams in Node in that writes to them are usually blocking.</haxe_doc>
		</stderr>
		<stdin public="1">
			<c path="js.node.stream.IReadable"/>
			<haxe_doc>A Readable Stream for stdin.</haxe_doc>
		</stdin>
		<argv public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>An array containing the command line arguments.
		The first element will be `node`, the second element will be the name of the JavaScript file.
		The next elements will be any additional command line arguments.

		E.g:
			$ node process-2.js one two=three four
			0: node
			1: /Users/mjr/work/node/process-2.js
			2: one
			3: two=three
			4: four</haxe_doc>
		</argv>
		<execPath public="1">
			<c path="String"/>
			<haxe_doc>This is the absolute pathname of the executable that started the process.</haxe_doc>
		</execPath>
		<execArgv public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>This is the set of node-specific command line options from the executable that started the process.
		These options do not show up in `argv`, and do not include the node executable, the name of the script,
		or any options following the script name.

		These options are useful in order to spawn child processes with the same execution environment as the parent.</haxe_doc>
		</execArgv>
		<abort public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This causes node to emit an abort. This will cause node to exit and generate a core file.</haxe_doc>
		</abort>
		<chdir public="1" set="method">
			<f a="directory">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the current working directory of the process or throws an exception if that fails.</haxe_doc>
		</chdir>
		<cwd public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the current working directory of the process.</haxe_doc>
		</cwd>
		<env public="1">
			<x path="haxe.DynamicAccess"><c path="String"/></x>
			<haxe_doc>An object containing the user environment. See environ(7).</haxe_doc>
		</env>
		<exit public="1" set="method">
			<f a="?code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Ends the process with the specified `code`. If the `code` is omitted, exit uses either the
		'success' code `0` or the value of `process.exitCode` if specified.</haxe_doc>
		</exit>
		<exitCode public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>A number which will be the process exit code, when the process either exits gracefully,
		or is exited via `process.exit()` without specifying a code.

		Specifying a code to `process.exit(code)` will override any previous setting of `process.exitCode`.</haxe_doc>
		</exitCode>
		<getgid public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Gets the group identity of the process. See getgid(2).
		Note: this function is only available on POSIX platforms (i.e. not Windows)</haxe_doc>
		</getgid>
		<setgid public="1" set="method">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the group identity of the process. See setgid(2).
		This accepts either a numerical ID or a groupname string.
		If a groupname is specified, this method blocks while resolving it to a numerical ID.

		Note: this function is only available on POSIX platforms (i.e. not Windows)</haxe_doc>
			<overloads><setgid public="1" set="method">
	<f a="id">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>Sets the group identity of the process. See setgid(2).
		This accepts either a numerical ID or a groupname string.
		If a groupname is specified, this method blocks while resolving it to a numerical ID.

		Note: this function is only available on POSIX platforms (i.e. not Windows)</haxe_doc>
</setgid></overloads>
		</setgid>
		<getuid public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Gets the user identity of the process. See getuid(2).
		Note: this function is only available on POSIX platforms (i.e. not Windows)</haxe_doc>
		</getuid>
		<setuid public="1" set="method">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the user identity of the process. See setuid(2).
		This accepts either a numerical ID or a username string.
		If a username is specified, this method blocks while resolving it to a numerical ID.

		Note: this function is only available on POSIX platforms (i.e. not Windows)</haxe_doc>
			<overloads><setuid public="1" set="method">
	<f a="id">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>Sets the user identity of the process. See setuid(2).
		This accepts either a numerical ID or a username string.
		If a username is specified, this method blocks while resolving it to a numerical ID.

		Note: this function is only available on POSIX platforms (i.e. not Windows)</haxe_doc>
</setuid></overloads>
		</setuid>
		<getgroups public="1" set="method">
			<f a=""><c path="Array"><x path="Int"/></c></f>
			<haxe_doc>Returns an array with the supplementary group IDs.
		POSIX leaves it unspecified if the effective group ID is included but node.js ensures it always is.
		Note: this function is only available on POSIX platforms (i.e. not Windows)</haxe_doc>
		</getgroups>
		<setgroups public="1" set="method">
			<f a="groups">
				<c path="Array"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="Int"/>
</x></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the supplementary group IDs.
		This is a privileged operation, meaning you need to be root or have the CAP_SETGID capability.

		Note: this function is only available on POSIX platforms (i.e. not Windows)
		The list can contain group IDs, group names or both.</haxe_doc>
		</setgroups>
		<initgroups public="1" set="method">
			<f a="user:extra_group">
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<x path="Int"/>
				</x>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<x path="Int"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>Reads /etc/group and initializes the group access list, using all groups of which the user is a member.
		This is a privileged operation, meaning you need to be root or have the CAP_SETGID capability.

		Note: this function is only available on POSIX platforms (i.e. not Windows)</haxe_doc>
		</initgroups>
		<version public="1" set="null">
			<c path="String"/>
			<haxe_doc>A compiled-in property that exposes NODE_VERSION.</haxe_doc>
		</version>
		<versions public="1">
			<x path="haxe.DynamicAccess"><c path="String"/></x>
			<haxe_doc>A property exposing version strings of node and its dependencies.</haxe_doc>
		</versions>
		<config public="1">
			<d><d/></d>
			<haxe_doc>An Object containing the JavaScript representation of the configure options that were used to compile the current node executable.
		This is the same as the "config.gypi" file that was produced when running the ./configure script.</haxe_doc>
		</config>
		<kill public="1" set="method">
			<f a="pid:?signal">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Send a signal to a process.
		`pid` is the process id and `signal` is the string describing the signal to send. Signal names are strings like 'SIGINT' or 'SIGHUP'.

		If omitted, the `signal` will be 'SIGTERM'. See Signal Events and kill(2) for more information.

		Will throw an error if target does not exist, and as a special case,
		a signal of 0 can be used to test for the existence of a process.

		Note that just because the name of this function is `kill`, it is really just a signal sender, like the kill system call.
		The signal sent may do something other than kill the target process.</haxe_doc>
		</kill>
		<pid public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The PID of the process.</haxe_doc>
		</pid>
		<title public="1">
			<c path="String"/>
			<haxe_doc>Getter/setter to set what is displayed in 'ps'.

		When used as a setter, the maximum length is platform-specific and probably short.
		On Linux and OS X, it's limited to the size of the binary name plus the length of the
		command line arguments because it overwrites the argv memory.</haxe_doc>
		</title>
		<arch public="1">
			<c path="String"/>
			<haxe_doc>What processor architecture you're running on: 'arm', 'ia32', or 'x64'.</haxe_doc>
		</arch>
		<platform public="1">
			<c path="String"/>
			<haxe_doc>What platform you're running on: 'darwin', 'freebsd', 'linux', 'sunos' or 'win32'</haxe_doc>
		</platform>
		<memoryUsage public="1" set="method">
			<f a=""><t path="js.node.MemoryUsage"/></f>
			<haxe_doc>Returns an object describing the memory usage of the Node process measured in bytes.</haxe_doc>
		</memoryUsage>
		<nextTick public="1" set="method">
			<f a="callback:args">
				<f a=""><x path="Void"/></f>
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>On the next loop around the event loop call this callback.
		This is not a simple alias to setTimeout(fn, 0), it's much more efficient.
		It typically runs before any other I/O events fire, but there are some exceptions.

		This is important in developing APIs where you want to give the user the chance to
		assign event handlers after an object has been constructed, but before any I/O has occurred.</haxe_doc>
		</nextTick>
		<umask public="1" set="method">
			<f a="?mask">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Sets or reads the process's file mode creation mask.
		Child processes inherit the mask from the parent process.
		Returns the old mask if mask argument is given, otherwise returns the current mask.</haxe_doc>
		</umask>
		<uptime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Number of seconds Node has been running.</haxe_doc>
		</uptime>
		<hrtime public="1" set="method">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>Returns the current high-resolution real time in a [seconds, nanoseconds] tuple Array.
		It is relative to an arbitrary time in the past.
		It is not related to the time of day and therefore not subject to clock drift.
		The primary use is for measuring performance between intervals.
		You may pass in the result of a previous call to `hrtime` to get a diff reading,
		useful for benchmarks and measuring intervals</haxe_doc>
			<overloads><hrtime public="1" set="method">
	<f a="prev">
		<c path="Array"><x path="Float"/></c>
		<c path="Array"><x path="Float"/></c>
	</f>
	<haxe_doc>Returns the current high-resolution real time in a [seconds, nanoseconds] tuple Array.
		It is relative to an arbitrary time in the past.
		It is not related to the time of day and therefore not subject to clock drift.
		The primary use is for measuring performance between intervals.
		You may pass in the result of a previous call to `hrtime` to get a diff reading,
		useful for benchmarks and measuring intervals</haxe_doc>
</hrtime></overloads>
		</hrtime>
		<mainModule public="1" set="null">
			<c path="js.node.Module"/>
			<haxe_doc>Alternate way to retrieve require.main. The difference is that if the main module changes at runtime,
		require.main might still refer to the original main module in modules that were required
		before the change occurred. Generally it's safe to assume that the two refer to the same module.

		As with require.main, it will be undefined if there was no entry script.</haxe_doc>
		</mainModule>
		<send public="1" set="method">
			<f a="message:?callback">
				<d/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Send a message to the parent process.

		Only available for child processes. See `ChildProcess.send`.</haxe_doc>
			<overloads>
				<send public="1" set="method">
					<f a="message:sendHandle:options:?callback">
						<d/>
						<d/>
						<t path="js.node.child_process.ChildProcessSendOptions"/>
						<f a="">
							<c path="js.lib.Error"/>
							<x path="Void"/>
						</f>
						<x path="Bool"/>
					</f>
					<haxe_doc>Send a message to the parent process.

		Only available for child processes. See `ChildProcess.send`.</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="message:sendHandle:?callback">
						<d/>
						<d/>
						<f a="">
							<c path="js.lib.Error"/>
							<x path="Void"/>
						</f>
						<x path="Bool"/>
					</f>
					<haxe_doc>Send a message to the parent process.

		Only available for child processes. See `ChildProcess.send`.</haxe_doc>
				</send>
			</overloads>
		</send>
		<disconnect public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the IPC channel to parent process.

		Only available for child processes. See `ChildProcess.disconnect`.</haxe_doc>
		</disconnect>
		<noDeprecation public="1">
			<x path="Bool"/>
			<haxe_doc>Disable run-time deprecation warnings.
		See `Util.deprecate`.</haxe_doc>
		</noDeprecation>
		<traceDeprecation public="1">
			<x path="Bool"/>
			<haxe_doc>Enable logging of deprecation warnings.
		See `Util.deprecate`.</haxe_doc>
		</traceDeprecation>
		<throwDeprecation public="1">
			<x path="Bool"/>
			<haxe_doc>Throw on deprecated API usage.
		See `Util.deprecate`.</haxe_doc>
		</throwDeprecation>
	</class>
	<typedef path="js.node.MemoryUsage" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Process.hx" module="js.node.Process"><a>
	<rss><x path="Float"/></rss>
	<heapUsed><x path="Float"/></heapUsed>
	<heapTotal><x path="Float"/></heapTotal>
</a></typedef>
	<class path="js.node.IStream" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Stream.hx" module="js.node.Stream" extern="1" interface="1">
		<haxe_doc>`IStream` interface is used as "any Stream".

	See `Stream` for actual class.</haxe_doc>
		<meta><m n=":remove"/></meta>
	</class>
	<class path="js.node.Stream" params="TSelf" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Stream.hx" extern="1">
		<extends path="js.node.events.EventEmitter"><c path="js.node.Stream.TSelf"/></extends>
		<pipeline public="1" set="method" static="1">
			<f a="readable:streams">
				<c path="js.node.stream.IReadable"/>
				<t path="haxe.extern.Rest"><c path="js.node.stream.IWritable"/></t>
				<c path="js.lib.Promise"><x path="Void"/></c>
			</f>
			<haxe_doc>A module method to pipe between streams forwarding errors and properly cleaning up
		and provide a callback when the pipeline is complete.

		@see https://nodejs.org/api/stream.html#stream_stream_pipeline_streams_callback</haxe_doc>
			<overloads>
				<pipeline public="1" set="method">
					<f a="readable:callback">
						<c path="js.node.stream.IReadable"/>
						<f a="">
							<x path="Null"><c path="js.lib.Error"/></x>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>A module method to pipe between streams forwarding errors and properly cleaning up
		and provide a callback when the pipeline is complete.

		@see https://nodejs.org/api/stream.html#stream_stream_pipeline_streams_callback</haxe_doc>
				</pipeline>
				<pipeline public="1" set="method">
					<f a="readable:writable1:callback">
						<c path="js.node.stream.IReadable"/>
						<c path="js.node.stream.IWritable"/>
						<f a="">
							<x path="Null"><c path="js.lib.Error"/></x>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>A module method to pipe between streams forwarding errors and properly cleaning up
		and provide a callback when the pipeline is complete.

		@see https://nodejs.org/api/stream.html#stream_stream_pipeline_streams_callback</haxe_doc>
				</pipeline>
				<pipeline public="1" set="method">
					<f a="readable:writable1:writable2:callback">
						<c path="js.node.stream.IReadable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<f a="">
							<x path="Null"><c path="js.lib.Error"/></x>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>A module method to pipe between streams forwarding errors and properly cleaning up
		and provide a callback when the pipeline is complete.

		@see https://nodejs.org/api/stream.html#stream_stream_pipeline_streams_callback</haxe_doc>
				</pipeline>
				<pipeline public="1" set="method">
					<f a="readable:writable1:writable2:writable3:callback">
						<c path="js.node.stream.IReadable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<f a="">
							<x path="Null"><c path="js.lib.Error"/></x>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>A module method to pipe between streams forwarding errors and properly cleaning up
		and provide a callback when the pipeline is complete.

		@see https://nodejs.org/api/stream.html#stream_stream_pipeline_streams_callback</haxe_doc>
				</pipeline>
				<pipeline public="1" set="method">
					<f a="readable:writable1:writable2:writable3:writable4:callback">
						<c path="js.node.stream.IReadable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<f a="">
							<x path="Null"><c path="js.lib.Error"/></x>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>A module method to pipe between streams forwarding errors and properly cleaning up
		and provide a callback when the pipeline is complete.

		@see https://nodejs.org/api/stream.html#stream_stream_pipeline_streams_callback</haxe_doc>
				</pipeline>
				<pipeline public="1" set="method">
					<f a="readable:writable1:writable2:writable3:writable4:writable5:callback">
						<c path="js.node.stream.IReadable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<f a="">
							<x path="Null"><c path="js.lib.Error"/></x>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>A module method to pipe between streams forwarding errors and properly cleaning up
		and provide a callback when the pipeline is complete.

		@see https://nodejs.org/api/stream.html#stream_stream_pipeline_streams_callback</haxe_doc>
				</pipeline>
				<pipeline public="1" set="method">
					<f a="readable:writable1:writable2:writable3:writable4:writable5:writable6:callback">
						<c path="js.node.stream.IReadable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<f a="">
							<x path="Null"><c path="js.lib.Error"/></x>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>A module method to pipe between streams forwarding errors and properly cleaning up
		and provide a callback when the pipeline is complete.

		@see https://nodejs.org/api/stream.html#stream_stream_pipeline_streams_callback</haxe_doc>
				</pipeline>
				<pipeline public="1" set="method">
					<f a="readable:writable1:writable2:writable3:writable4:writable5:writable6:writable7:callback">
						<c path="js.node.stream.IReadable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<f a="">
							<x path="Null"><c path="js.lib.Error"/></x>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>A module method to pipe between streams forwarding errors and properly cleaning up
		and provide a callback when the pipeline is complete.

		@see https://nodejs.org/api/stream.html#stream_stream_pipeline_streams_callback</haxe_doc>
				</pipeline>
				<pipeline public="1" set="method">
					<f a="readable:writable1:writable2:writable3:writable4:writable5:writable6:writable7:writable8:callback">
						<c path="js.node.stream.IReadable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<c path="js.node.stream.IWritable"/>
						<f a="">
							<x path="Null"><c path="js.lib.Error"/></x>
							<x path="Void"/>
						</f>
						<x path="Void"/>
					</f>
					<haxe_doc>A module method to pipe between streams forwarding errors and properly cleaning up
		and provide a callback when the pipeline is complete.

		@see https://nodejs.org/api/stream.html#stream_stream_pipeline_streams_callback</haxe_doc>
				</pipeline>
			</overloads>
		</pipeline>
		<new set="method"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Base class for all streams.</haxe_doc>
		<meta><m n=":jsRequire"><e>"stream"</e></m></meta>
	</class>
	<class path="js.node.Timers" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Timers.hx" extern="1">
		<setImmediate public="1" set="method" static="1">
			<f a="callback:args">
				<x path="haxe.Function"/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.node.Immediate"/>
			</f>
			<haxe_doc>Schedules the "immediate" execution of the callback after I/O events' callbacks.

		When multiple calls to `setImmediate()` are made, the `callback` functions are queued for execution
		in the order in which they are created. The entire callback queue is processed every event loop iteration.
		If an immediate timer is queued from inside an executing callback, that timer will not be triggered until
		the next event loop iteration.

		If `callback` is not a function, a `TypeError` will be thrown.

		This method has a custom variant for promises that is available using `util.promisify()`.</haxe_doc>
		</setImmediate>
		<setInterval public="1" set="method" static="1">
			<f a="callback:delay:args">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.node.Timeout"/>
			</f>
			<haxe_doc>Schedules repeated execution of `callback` every `delay` milliseconds.

		When delay is larger than `2147483647` or less than `1`, the `delay` will be set to `1`.
		Non-integer delays are truncated to an integer.

		If `callback` is not a function, a `TypeError` will be thrown.

		This method has a custom variant for promises that is available using `util.promisify()`.</haxe_doc>
		</setInterval>
		<setTimeout public="1" set="method" static="1">
			<f a="callback:delay:args">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.node.Timeout"/>
			</f>
			<haxe_doc>Schedules execution of a one-time `callback` after `delay` milliseconds.

		The `callback` will likely not be invoked in precisely `delay` milliseconds.
		Node.js makes no guarantees about the exact timing of when callbacks will fire, nor of their ordering.
		The callback will be called as close as possible to the time specified.

		When delay is larger than `2147483647` or less than `1`, the delay will be set to `1`.
		Non-integer delays are truncated to an integer.

		If `callback` is not a function, a `TypeError` will be thrown.

		This method has a custom variant for promises that is available using `util.promisify()`.</haxe_doc>
		</setTimeout>
		<clearImmediate public="1" set="method" static="1">
			<f a="immediate">
				<c path="js.node.Immediate"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Cancels an Immediate object created by `setImmediate()`.</haxe_doc>
		</clearImmediate>
		<clearInterval public="1" set="method" static="1">
			<f a="timeout">
				<c path="js.node.Timeout"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Cancels a Timeout object created by `setInterval()`.</haxe_doc>
		</clearInterval>
		<clearTimeout public="1" set="method" static="1">
			<f a="timeout">
				<c path="js.node.Timeout"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Cancels a Timeout object created by `setTimeout()`.</haxe_doc>
		</clearTimeout>
		<haxe_doc>The `timer` module exposes a global API for scheduling functions to be called at some future period of time.
	Because the timer functions are globals, there is no need to call `require('timers')` to use the API.

	The timer functions within Node.js implement a similar API as the timers API provided by Web Browsers
	but use a different internal implementation that is built around the Node.js Event Loop.</haxe_doc>
		<meta><m n=":jsRequire"><e>"timers"</e></m></meta>
	</class>
	<class path="js.node.Immediate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Timers.hx" module="js.node.Timers" extern="1">
		<hasRef public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>If true, the `Immediate` object will keep the Node.js event loop active.</haxe_doc>
		</hasRef>
		<ref public="1" set="method">
			<f a=""><c path="js.node.Immediate"/></f>
			<haxe_doc>When called, requests that the Node.js event loop not exit so long as the `Immediate` is active.
		Calling `immediate.ref()` multiple times will have no effect.

		By default, all `Immediate` objects are "ref'ed", making it normally unnecessary to call `immediate.ref()`
		unless `immediate.unref()` had been called previously.</haxe_doc>
		</ref>
		<unref public="1" set="method">
			<f a=""><c path="js.node.Immediate"/></f>
			<haxe_doc>When called, the active `Immediate` object will not require the Node.js event loop to remain active.
		If there is no other activity keeping the event loop running, the process may exit before the `Immediate` object's
		callback is invoked. Calling immediate.unref() multiple times will have no effect.</haxe_doc>
		</unref>
		<haxe_doc>This object is created internally and is returned from `setImmediate()`.
	It can be passed to `clearImmediate()` in order to cancel the scheduled actions.</haxe_doc>
	</class>
	<class path="js.node.Timeout" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Timers.hx" module="js.node.Timers" extern="1">
		<hasRef public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>If true, the `Timeout` object will keep the Node.js event loop active.</haxe_doc>
		</hasRef>
		<ref public="1" set="method">
			<f a=""><c path="js.node.Timeout"/></f>
			<haxe_doc>When called, the active `Timeout` object will not require the Node.js event loop to remain active.
		If there is no other activity keeping the event loop running, the process may exit before the `Timeout` object's
		callback is invoked. Calling `timeout.unref()` multiple times will have no effect.

		Calling `timeout.unref()` creates an internal timer that will wake the Node.js event loop.
		Creating too many of these can adversely impact performance of the Node.js application.</haxe_doc>
		</ref>
		<refresh public="1" set="method">
			<f a=""><c path="js.node.Timeout"/></f>
			<haxe_doc>Sets the timer's start time to the current time, and reschedules the timer to call its callback at the previously
		specified duration adjusted to the current time. This is useful for refreshing a timer without allocating
		a new JavaScript object.

		Using this on a timer that has already called its callback will reactivate the timer.</haxe_doc>
		</refresh>
		<unref public="1" set="method">
			<f a=""><c path="js.node.Timeout"/></f>
			<haxe_doc>When called, the active `Timeout` object will not require the Node.js event loop to remain active.
		If there is no other activity keeping the event loop running, the process may exit before the `Timeout` object's
		callback is invoked. Calling `timeout.unref()` multiple times will have no effect.

		Calling `timeout.unref()` creates an internal timer that will wake the Node.js event loop.
		Creating too many of these can adversely impact performance of the Node.js application.</haxe_doc>
		</unref>
		<haxe_doc>This object is created internally and is returned from `setTimeout()` and `setInterval()`.
	It can be passed to either `clearTimeout()` or `clearInterval()` in order to cancel the scheduled actions.</haxe_doc>
	</class>
	<class path="js.node.Util" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Util.hx" extern="1">
		<callbackify public="1" set="method" static="1">
			<f a="original:args">
				<x path="haxe.Function"/>
				<t path="haxe.extern.Rest"><d/></t>
				<f a=":">
					<x path="Null"><c path="js.lib.Error"/></x>
					<x path="Null"><d/></x>
					<x path="Void"/>
				</f>
			</f>
			<haxe_doc><![CDATA[Takes an `async` function (or a function that returns a `Promise`) and returns a function following the
		error-first callback style, i.e. taking an `(err, value) => ...` callback as the last argument.

		@see https://nodejs.org/api/util.html#util_util_callbackify_original]]></haxe_doc>
		</callbackify>
		<debuglog public="1" set="method" static="1">
			<f a="section">
				<c path="String"/>
				<f a="">
					<t path="haxe.extern.Rest"><d/></t>
					<x path="Void"/>
				</f>
			</f>
			<haxe_doc>The `util.debuglog()` method is used to create a function that conditionally writes debug messages to `stderr`
		based on the existence of the `NODE_DEBUG` environment variable.

		@see https://nodejs.org/api/util.html#util_util_debuglog_section</haxe_doc>
		</debuglog>
		<deprecate public="1" params="T" set="method" static="1">
			<f a="fun:msg:?code">
				<c path="deprecate.T"/>
				<c path="String"/>
				<c path="String"/>
				<c path="deprecate.T"/>
			</f>
			<haxe_doc>The `util.deprecate()` method wraps `fn` (which may be a function or class) in such a way that it is marked
		asdeprecated.

		@see https://nodejs.org/api/util.html#util_util_deprecate_fn_msg_code</haxe_doc>
		</deprecate>
		<format public="1" set="method" static="1">
			<f a="format:args">
				<c path="String"/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="String"/>
			</f>
			<haxe_doc>The `util.format()` method returns a formatted string using the first argument as a `printf`-like format string
		which can contain zero or more format specifiers.

		@see https://nodejs.org/api/util.html#util_util_format_format_args</haxe_doc>
			<overloads><format public="1" set="method">
	<f a="args">
		<t path="haxe.extern.Rest"><d/></t>
		<c path="String"/>
	</f>
	<haxe_doc>The `util.format()` method returns a formatted string using the first argument as a `printf`-like format string
		which can contain zero or more format specifiers.

		@see https://nodejs.org/api/util.html#util_util_format_format_args</haxe_doc>
</format></overloads>
		</format>
		<formatWithOptions public="1" set="method" static="1">
			<f a="inspectOptions:format:args">
				<t path="js.node.InspectOptions"/>
				<c path="String"/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="String"/>
			</f>
			<haxe_doc>This function is identical to `util.format()`, except in that it takes an `inspectOptions` argument which
		specifies options that are passed along to `util.inspect()`.

		@see https://nodejs.org/api/util.html#util_util_formatwithoptions_inspectoptions_format_args</haxe_doc>
			<overloads><formatWithOptions public="1" set="method">
	<f a="inspectOptions:args">
		<t path="js.node.InspectOptions"/>
		<t path="haxe.extern.Rest"><d/></t>
		<c path="String"/>
	</f>
	<haxe_doc>This function is identical to `util.format()`, except in that it takes an `inspectOptions` argument which
		specifies options that are passed along to `util.inspect()`.

		@see https://nodejs.org/api/util.html#util_util_formatwithoptions_inspectoptions_format_args</haxe_doc>
</formatWithOptions></overloads>
		</formatWithOptions>
		<getSystemErrorName public="1" set="method" static="1">
			<f a="err">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the string name for a numeric error code that comes from a Node.js API.

		@see https://nodejs.org/api/util.html#util_util_getsystemerrorname_err</haxe_doc>
		</getSystemErrorName>
		<inherits public="1" set="method" static="1">
			<f a="constructor:superConstructor">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Inherit the prototype methods from one `constructor` into another.

		@see https://nodejs.org/api/util.html#util_util_inherits_constructor_superconstructor</haxe_doc>
		</inherits>
		<inspect public="1" set="method" static="1">
			<f a="object:?options">
				<d/>
				<x path="Null"><t path="js.node.InspectOptions"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>The `util.inspect()` method returns a string representation of `object` that is intended for debugging.

		@see https://nodejs.org/api/util.html#util_util_inspect_object_options</haxe_doc>
			<overloads><inspect public="1" set="method">
	<f a="object:?showHidden:?depth:?colors">
		<d/>
		<x path="Bool"/>
		<x path="Int"/>
		<x path="Bool"/>
		<c path="String"/>
	</f>
	<haxe_doc>The `util.inspect()` method returns a string representation of `object` that is intended for debugging.

		@see https://nodejs.org/api/util.html#util_util_inspect_object_options</haxe_doc>
</inspect></overloads>
		</inspect>
		<isDeepStrictEqual public="1" set="method" static="1">
			<f a="val1:val2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if there is deep strict equality between `val1` and `val2`.

		@see https://nodejs.org/api/util.html#util_util_isdeepstrictequal_val1_val2</haxe_doc>
		</isDeepStrictEqual>
		<promisify public="1" set="method" static="1">
			<f a="original">
				<x path="haxe.Function"/>
				<f a="">
					<t path="haxe.extern.Rest"><d/></t>
					<c path="js.lib.Promise"><d/></c>
				</f>
			</f>
			<haxe_doc><![CDATA[Takes a function following the common error-first callback style, i.e. taking an `(err, value) => ...` callback
		as the last argument, and returns a version that returns promises.

		@see https://nodejs.org/api/util.html#util_util_promisify_original]]></haxe_doc>
		</promisify>
		<debug public="1" set="method" static="1">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"><e>"Use js.Node.console.error instead"</e></m></meta>
			<haxe_doc>Deprecated predecessor of `Console.error`.</haxe_doc>
		</debug>
		<error public="1" set="method" static="1">
			<f a="args">
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"><e>"Use js.Node.console.error instead"</e></m></meta>
			<haxe_doc>Deprecated predecessor of console.error.</haxe_doc>
		</error>
		<isArray public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is an Array. false otherwise.</haxe_doc>
		</isArray>
		<isBoolean public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is a Bool. false otherwise.</haxe_doc>
		</isBoolean>
		<isBuffer public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is a Buffer. false otherwise.</haxe_doc>
		</isBuffer>
		<isDate public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is a Date. false otherwise.</haxe_doc>
		</isDate>
		<isError public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is an Error. false otherwise.</haxe_doc>
		</isError>
		<isFunction public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is a Function. false otherwise.</haxe_doc>
		</isFunction>
		<isNull public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is strictly null. false otherwise.</haxe_doc>
		</isNull>
		<isNullOrUndefined public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is null or undefined. false otherwise.</haxe_doc>
		</isNullOrUndefined>
		<isNumber public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is a Float. false otherwise.</haxe_doc>
		</isNumber>
		<isObject public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is strictly an Object and not a Function. false otherwise.</haxe_doc>
		</isObject>
		<isPrimitive public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is a primitive type. false otherwise.</haxe_doc>
		</isPrimitive>
		<isRegExp public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is a RegExp. false otherwise.</haxe_doc>
		</isRegExp>
		<isString public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is a String. false otherwise.</haxe_doc>
		</isString>
		<isSymbol public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is a Symbol. false otherwise.</haxe_doc>
		</isSymbol>
		<isUndefined public="1" set="method" static="1">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Returns true if the given "object" is undefined. false otherwise.</haxe_doc>
		</isUndefined>
		<log public="1" set="method" static="1">
			<f a="args">
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Output with timestamp on stdout.</haxe_doc>
		</log>
		<print public="1" set="method" static="1">
			<f a="args">
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"><e>"Use js.Node.console.log instead"</e></m></meta>
			<haxe_doc>Deprecated predecessor of console.log.</haxe_doc>
		</print>
		<puts public="1" set="method" static="1">
			<f a="args">
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"><e>"Use js.Node.console.log instead"</e></m></meta>
			<haxe_doc>Deprecated predecessor of console.log.</haxe_doc>
		</puts>
		<pump public="1" set="method" static="1">
			<f a="readableStream:writableStream:?callback">
				<c path="js.node.stream.IReadable"/>
				<c path="js.node.stream.IWritable"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"><e>"Use `readableStream.pipe(writableStream)` instead"</e></m></meta>
			<haxe_doc>Deprecated predecessor of stream.pipe().</haxe_doc>
		</pump>
		<haxe_doc>The `util` module is primarily designed to support the needs of Node.js' own internal APIs.

	@see https://nodejs.org/api/util.html#util_util</haxe_doc>
		<meta><m n=":jsRequire"><e>"util"</e></m></meta>
	</class>
	<typedef path="js.node.InspectOptionsBase" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Util.hx" module="js.node.Util">
		<a>
			<showHidden>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If `true`, `object`'s non-enumerable symbols and properties are included in the formatted result.
		`WeakMap` and `WeakSet` entries are also included.

		Default: `false`.</haxe_doc>
			</showHidden>
			<depth>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Specifies the number of times to recurse while formatting `object`.
		This is useful for inspecting large objects. To recurse up to the maximum call stack size pass `Infinity` or
		`null`.

		Default: `2`.</haxe_doc>
			</depth>
			<colors>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If `true`, the output is styled with ANSI color codes.
		Colors are customizable.
		See Customizing `util.inspect` colors.

		Default: `false`.</haxe_doc>
			</colors>
		</a>
		<haxe_doc>Options object used by `Console.dir`.</haxe_doc>
	</typedef>
	<typedef path="js.node.InspectOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/Util.hx" module="js.node.Util">
		<a>
			<sorted>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<f a=":">
		<d/>
		<d/>
		<x path="Int"/>
	</f>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If set to `true` or a function, all properties of an object, and `Set` and `Map` entries are sorted in the
		resulting string.
		If set to `true` the default sort is used.
		If set to a function, it is used as a compare function.</haxe_doc>
			</sorted>
			<showProxy>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If `true`, `Proxy` inspection includes the `target` and `handler` objects.

		Default: `false`.</haxe_doc>
			</showProxy>
			<showHidden>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If `true`, `object`'s non-enumerable symbols and properties are included in the formatted result.
		`WeakMap` and `WeakSet` entries are also included.

		Default: `false`.</haxe_doc>
			</showHidden>
			<maxArrayLength>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Specifies the maximum number of `Array`, `TypedArray`, `WeakMap` and `WeakSet` elements to include when
		formatting.
		Set to `null` or `Infinity` to show all elements.
		Set to `0` or negative to show no elements.

		Default: `100`.</haxe_doc>
			</maxArrayLength>
			<getters>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If set to `true`, getters are inspected.
		If set to `'get'`, only getters without a corresponding setter are inspected.
		If set to `'set'`, only getters with a corresponding setter are inspected.
		This might cause side effects depending on the getter function.

		Default: `false`.</haxe_doc>
			</getters>
			<depth>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Specifies the number of times to recurse while formatting `object`.
		This is useful for inspecting large objects. To recurse up to the maximum call stack size pass `Infinity` or
		`null`.

		Default: `2`.</haxe_doc>
			</depth>
			<customInspect>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If `false`, `[util.inspect.custom](depth, opts)` functions are not invoked.

		Default: `true`.</haxe_doc>
			</customInspect>
			<compact>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="Int"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Setting this to `false` causes each object key to be displayed on a new line.
		It will also add new lines to text that is longer than `breakLength`.
		If set to a number, the most `n` inner elements are united on a single line as long as all properties fit into
		`breakLength`.
		Short array elements are also grouped together.
		No text will be reduced below 16 characters, no matter the `breakLength` size.
		For more information, see the example below.

		Default: `3`.</haxe_doc>
			</compact>
			<colors>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If `true`, the output is styled with ANSI color codes.
		Colors are customizable.
		See Customizing `util.inspect` colors.

		Default: `false`.</haxe_doc>
			</colors>
			<breakLength>
				<x path="Null"><x path="Float"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[The length at which input values are split across multiple lines.
		Set to `Infinity` to format the input as a single line (in combination with `compact` set to `true` or any
		number >= `1`).

		Default: `80`.]]></haxe_doc>
			</breakLength>
		</a>
		<haxe_doc>Options object used by `Util.inspect`.</haxe_doc>
	</typedef>
	<class path="js.node.buffer.Buffer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/buffer/Buffer.hx" extern="1">
		<extends path="js.lib.Uint8Array"/>
		<alloc public="1" set="method" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the `Buffer` will be zero-filled.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_alloc_size_fill_encoding</haxe_doc>
			<overloads>
				<alloc public="1" set="method">
					<f a="size:fill:?encoding">
						<x path="Int"/>
						<c path="String"/>
						<c path="String"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the `Buffer` will be zero-filled.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_alloc_size_fill_encoding</haxe_doc>
				</alloc>
				<alloc public="1" set="method">
					<f a="size:fill">
						<x path="Int"/>
						<c path="js.lib.Uint8Array"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the `Buffer` will be zero-filled.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_alloc_size_fill_encoding</haxe_doc>
				</alloc>
				<alloc public="1" set="method">
					<f a="size:fill">
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the `Buffer` will be zero-filled.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_alloc_size_fill_encoding</haxe_doc>
				</alloc>
			</overloads>
		</alloc>
		<allocUnsafe public="1" set="method" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Allocates a new `Buffer` of `size` bytes. If `size` is larger than
		`buffer.constants.MAX_LENGTH` or smaller than 0, `ERR_INVALID_OPT_VALUE`
		is thrown. A zero-length `Buffer` is created if `size` is 0.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_allocunsafe_size</haxe_doc>
		</allocUnsafe>
		<allocUnsafeSlow public="1" set="method" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Allocates a new `Buffer` of `size` bytes. If `size` is larger than
		`buffer.constants.MAX_LENGTH` or smaller than 0, `ERR_INVALID_OPT_VALUE`
		is thrown. A zero-length `Buffer` is created if `size` is 0.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_allocunsafeslow_size</haxe_doc>
		</allocUnsafeSlow>
		<byteLength public="1" set="method" static="1">
			<f a="string">
				<c path="js.node.buffer.Buffer"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the actual byte length of a string. This is not the same as
		`String.prototype.length` since that returns the number of characters in
		a string.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_bytelength_string_encoding</haxe_doc>
			<overloads>
				<byteLength public="1" set="method">
					<f a="string:?encoding">
						<c path="String"/>
						<c path="String"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the actual byte length of a string. This is not the same as
		`String.prototype.length` since that returns the number of characters in
		a string.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_bytelength_string_encoding</haxe_doc>
				</byteLength>
				<byteLength public="1" set="method">
					<f a="string">
						<c path="js.lib.ArrayBufferView"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the actual byte length of a string. This is not the same as
		`String.prototype.length` since that returns the number of characters in
		a string.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_bytelength_string_encoding</haxe_doc>
				</byteLength>
				<byteLength public="1" set="method">
					<f a="string">
						<c path="js.lib.ArrayBuffer"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the actual byte length of a string. This is not the same as
		`String.prototype.length` since that returns the number of characters in
		a string.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_bytelength_string_encoding</haxe_doc>
				</byteLength>
			</overloads>
		</byteLength>
		<_byteLength public="1" get="inline" set="null" line="109" static="1">
			<f a="string:?encoding">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":deprecated"><e>"In haxe 3.3+, use Buffer.byteLength instead!"</e></m>
			</meta>
		</_byteLength>
		<compareBuffers public="1" set="method" static="1">
			<f a="buf1:buf2">
				<c path="js.lib.Uint8Array"/>
				<c path="js.lib.Uint8Array"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"compare"</e></m></meta>
			<haxe_doc>Compares `buf1` to `buf2` typically for the purpose of sorting arrays of
		`Buffer` instances. This is equivalent to calling `buf1.compare(buf2)`.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_compare_buf1_buf2</haxe_doc>
		</compareBuffers>
		<concat public="1" params="T" set="method" static="1">
			<f a="list:?totalLength">
				<c path="Array"><c path="concat.T"/></c>
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Returns a new `Buffer` which is the result of concatenating all the `Buffer` instances in the `list` together.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_concat_list_totallength</haxe_doc>
		</concat>
		<from public="1" set="method" static="1">
			<f a="string:?encoding">
				<c path="String"/>
				<c path="String"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Allocates a new `Buffer`.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_array
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_buffer
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_object_offsetorencoding_length
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_string_encoding</haxe_doc>
			<overloads>
				<from public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Int"/></c>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Allocates a new `Buffer`.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_array
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_buffer
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_object_offsetorencoding_length
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_string_encoding</haxe_doc>
				</from>
				<from public="1" set="method">
					<f a="arrayBuffer:?byteOffset:?length">
						<c path="js.lib.ArrayBuffer"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Allocates a new `Buffer`.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_array
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_buffer
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_object_offsetorencoding_length
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_string_encoding</haxe_doc>
				</from>
				<from public="1" set="method">
					<f a="buffer">
						<c path="js.lib.Uint8Array"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Allocates a new `Buffer`.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_array
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_buffer
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_object_offsetorencoding_length
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_string_encoding</haxe_doc>
				</from>
				<from public="1" set="method">
					<f a="object:?offset:?length">
						<a/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Allocates a new `Buffer`.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_array
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_buffer
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_object_offsetorencoding_length
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_string_encoding</haxe_doc>
				</from>
				<from public="1" set="method">
					<f a="object:?encoding:?length">
						<a/>
						<c path="String"/>
						<x path="Int"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Allocates a new `Buffer`.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_array
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_buffer
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_object_offsetorencoding_length
		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_string_encoding</haxe_doc>
				</from>
			</overloads>
		</from>
		<isBuffer public="1" set="method" static="1">
			<f a="obj">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if `obj` is a `Buffer`, `false` otherwise.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_isbuffer_obj</haxe_doc>
		</isBuffer>
		<isEncoding public="1" set="method" static="1">
			<f a="encoding">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if `encoding` contains a supported character encoding, or `false` otherwise.

		@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_isencoding_encoding</haxe_doc>
		</isEncoding>
		<poolSize public="1" static="1">
			<x path="Int"/>
			<haxe_doc>This is the size (in bytes) of pre-allocated internal `Buffer` instances used for pooling. This value may be modified.

		@see https://nodejs.org/api/buffer.html#buffer_class_property_buffer_poolsize</haxe_doc>
		</poolSize>
		<byteOffset public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>When setting `byteOffset` in `Buffer.from(ArrayBuffer, byteOffset, length)`
		or sometimes when allocating a buffer smaller than `Buffer.poolSize` the
		buffer doesn't start from a zero offset on the underlying `ArrayBuffer`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_byteoffset</haxe_doc>
		</byteOffset>
		<INSPECT_MAX_BYTES public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>Default: `50`

		Returns the maximum number of bytes that will be returned when `buf.inspect()` is called.
		This can be overridden by user modules.
		See `util.inspect()` for more details on `buf.inspect()` behavior.

		This is a property on the `buffer` module returned by `require('buffer')`, not on the `Buffer` global or a `Buffer` instance.

		@see https://nodejs.org/api/buffer.html#buffer_buffer_inspect_max_bytes</haxe_doc>
		</INSPECT_MAX_BYTES>
		<get_INSPECT_MAX_BYTES get="inline" set="null" line="664" static="1"><f a=""><x path="Int"/></f></get_INSPECT_MAX_BYTES>
		<set_INSPECT_MAX_BYTES get="inline" set="null" line="667" static="1"><f a="bytes">
	<x path="Int"/>
	<x path="Int"/>
</f></set_INSPECT_MAX_BYTES>
		<kMaxLength public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>An alias for `buffer.constants.MAX_LENGTH`.

		This is a property on the `buffer` module returned by `require('buffer')`, not on the `Buffer` global or a `Buffer` instance.

		@see https://nodejs.org/api/buffer.html#buffer_buffer_kmaxlength</haxe_doc>
		</kMaxLength>
		<get_kMaxLength get="inline" set="null" line="680" static="1"><f a=""><x path="Int"/></f></get_kMaxLength>
		<transcode public="1" get="inline" set="null" line="690" static="1">
			<f a="source:fromEnc:toEnc">
				<c path="js.lib.Uint8Array"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Re-encodes the given `Buffer` or `Uint8Array` instance from one character encoding to another.
		Returns a new `Buffer` instance.

		@see https://nodejs.org/api/buffer.html#buffer_buffer_transcode_source_fromenc_toenc</haxe_doc>
		</transcode>
		<constants public="1" set="null" static="1">
			<t path="js.node.buffer.BufferConstants"/>
			<haxe_doc>`buffer.constants` is a property on the `buffer` module returned by `require('buffer')`,
		not on the `Buffer` global or a `Buffer` instance.

		@see https://nodejs.org/api/buffer.html#buffer_buffer_constants</haxe_doc>
		</constants>
		<get_constants get="inline" set="null" line="702" static="1"><f a=""><t path="js.node.buffer.BufferConstants"/></f></get_constants>
		<hxFromBytes public="1" get="inline" set="null" line="718" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Create `Buffer` object from `haxe.io.Bytes` using the same underlying data storage.
		Any modifications done using the returned object will be reflected in given `haxe.io.Bytes` object.</haxe_doc>
		</hxFromBytes>
		<compare public="1" set="method">
			<f a="target:?targetStart:?targetEnd:?sourceStart:?sourceEnd">
				<c path="js.lib.Uint8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `buf` with `target` and returns a number indicating whether `buf` comes before, after,
		or is the same as `target` in sort order. Comparison is based on the actual sequence of bytes in each `Buffer`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend</haxe_doc>
			<overloads><compare public="1" set="method">
	<f a="target">
		<c path="js.lib.Uint8Array"/>
		<x path="Int"/>
	</f>
	<haxe_doc>Compares `buf` with `target` and returns a number indicating whether `buf` comes before, after,
		or is the same as `target` in sort order. Comparison is based on the actual sequence of bytes in each `Buffer`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend</haxe_doc>
</compare></overloads>
		</compare>
		<copy public="1" set="method">
			<f a="target:?targetStart:?sourceStart:?sourceEnd">
				<c path="js.lib.Uint8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies data from a region of `buf` to a region in `target` even if the `target` memory region overlaps with `buf`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_copy_target_targetstart_sourcestart_sourceend</haxe_doc>
			<overloads><copy public="1" set="method">
	<f a="target">
		<c path="js.lib.Uint8Array"/>
		<x path="Void"/>
	</f>
	<haxe_doc>Copies data from a region of `buf` to a region in `target` even if the `target` memory region overlaps with `buf`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_copy_target_targetstart_sourcestart_sourceend</haxe_doc>
</copy></overloads>
		</copy>
		<entries public="1" set="method" override="1">
			<f a=""><t path="js.node.Iterator"><x path="js.node.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Creates and returns an iterator of `[index, byte]` pairs from the contents of `buf`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_entries</haxe_doc>
		</entries>
		<equals public="1" set="method">
			<f a="otherBuffer">
				<c path="js.lib.Uint8Array"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes, `false` otherwise.

		@see https://nodejs.org/api/buffer.html#buffer_buf_equals_otherbuffer</haxe_doc>
		</equals>
		<fill public="1" set="method" override="1">
			<f a="value:?offset:?end:?encoding">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Fills `buf` with the specified `value`. If the `offset` and `end` are not given, the entire `buf` will be filled:

		@see https://nodejs.org/api/buffer.html#buffer_buf_fill_value_offset_end_encoding</haxe_doc>
			<overloads>
				<fill public="1" set="method">
					<f a="value:?offset:?end">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Fills `buf` with the specified `value`. If the `offset` and `end` are not given, the entire `buf` will be filled:

		@see https://nodejs.org/api/buffer.html#buffer_buf_fill_value_offset_end_encoding</haxe_doc>
				</fill>
				<fill public="1" set="method">
					<f a="value:?offset:?end">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Fills `buf` with the specified `value`. If the `offset` and `end` are not given, the entire `buf` will be filled:

		@see https://nodejs.org/api/buffer.html#buffer_buf_fill_value_offset_end_encoding</haxe_doc>
				</fill>
			</overloads>
		</fill>
		<includes public="1" set="method" override="1">
			<f a="value:?byteOffset:?encoding">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Equivalent to `buf.indexOf() !== -1`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_includes_value_byteoffset_encoding</haxe_doc>
			<overloads>
				<includes public="1" set="method">
					<f a="value:?byteOffset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Equivalent to `buf.indexOf() !== -1`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_includes_value_byteoffset_encoding</haxe_doc>
				</includes>
				<includes public="1" set="method">
					<f a="value:?byteOffset">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Equivalent to `buf.indexOf() !== -1`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_includes_value_byteoffset_encoding</haxe_doc>
				</includes>
			</overloads>
		</includes>
		<indexOf public="1" set="method" override="1">
			<f a="value:?byteOffset:?encoding">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>If `value` is:

		- a string, `value` is interpreted according to the character encoding in `encoding`.
		- a `Buffer` or Uint8Array, `value` will be used in its entirety. To compare a partial `Buffer`, use buf.slice().
		- a number, `value` will be interpreted as an unsigned 8-bit integer value between `0` and `255`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_indexof_value_byteoffset_encoding</haxe_doc>
			<overloads>
				<indexOf public="1" set="method">
					<f a="value:?byteOffset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<haxe_doc>If `value` is:

		- a string, `value` is interpreted according to the character encoding in `encoding`.
		- a `Buffer` or Uint8Array, `value` will be used in its entirety. To compare a partial `Buffer`, use buf.slice().
		- a number, `value` will be interpreted as an unsigned 8-bit integer value between `0` and `255`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_indexof_value_byteoffset_encoding</haxe_doc>
				</indexOf>
				<indexOf public="1" set="method">
					<f a="value:?byteOffset">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<haxe_doc>If `value` is:

		- a string, `value` is interpreted according to the character encoding in `encoding`.
		- a `Buffer` or Uint8Array, `value` will be used in its entirety. To compare a partial `Buffer`, use buf.slice().
		- a number, `value` will be interpreted as an unsigned 8-bit integer value between `0` and `255`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_indexof_value_byteoffset_encoding</haxe_doc>
				</indexOf>
			</overloads>
		</indexOf>
		<keys public="1" set="method" override="1">
			<f a=""><t path="js.node.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Creates and returns an iterator of `buf` keys (indices).

		@see https://nodejs.org/api/buffer.html#buffer_buf_keys</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method" override="1">
			<f a="value:?byteOffset:?encoding">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Identical to `buf.indexOf()`, except the last occurrence of `value` is found
		rather than the first occurrence.

		@see https://nodejs.org/api/buffer.html#buffer_buf_lastindexof_value_byteoffset_encoding</haxe_doc>
			<overloads>
				<lastIndexOf public="1" set="method">
					<f a="value:?byteOffset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Identical to `buf.indexOf()`, except the last occurrence of `value` is found
		rather than the first occurrence.

		@see https://nodejs.org/api/buffer.html#buffer_buf_lastindexof_value_byteoffset_encoding</haxe_doc>
				</lastIndexOf>
				<lastIndexOf public="1" set="method">
					<f a="value:?byteOffset">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Identical to `buf.indexOf()`, except the last occurrence of `value` is found
		rather than the first occurrence.

		@see https://nodejs.org/api/buffer.html#buffer_buf_lastindexof_value_byteoffset_encoding</haxe_doc>
				</lastIndexOf>
			</overloads>
		</lastIndexOf>
		<readDoubleBE public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Reads a 64-bit double from `buf` at the specified `offset` with specified endian format
		(`readDoubleBE()` returns big endian, `readDoubleLE()` returns little endian).

		@see https://nodejs.org/api/buffer.html#buffer_buf_readdoublebe_offset</haxe_doc>
		</readDoubleBE>
		<readDoubleLE public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Reads a 64-bit double from `buf` at the specified `offset` with specified endian format
		(`readDoubleBE()` returns big endian, `readDoubleLE()` returns little endian).

		@see https://nodejs.org/api/buffer.html#buffer_buf_readdoublele_offset</haxe_doc>
		</readDoubleLE>
		<readFloatBE public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Reads a 32-bit float from `buf` at the specified `offset` with specified endian format
		(`readFloatBE()` returns big endian, `readFloatLE()` returns little endian).

		@see https://nodejs.org/api/buffer.html#buffer_buf_readfloatbe_offset</haxe_doc>
		</readFloatBE>
		<readFloatLE public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Reads a 32-bit float from `buf` at the specified `offset` with specified endian format
		(`readFloatBE()` returns big endian, `readFloatLE()` returns little endian).

		@see https://nodejs.org/api/buffer.html#buffer_buf_readfloatle_offset</haxe_doc>
		</readFloatLE>
		<readInt8 public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a signed 8-bit integer from `buf` at the specified `offset`.

		https://nodejs.org/api/buffer.html#buffer_buf_readint8_offset</haxe_doc>
		</readInt8>
		<readInt16BE public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a signed 16-bit integer from `buf` at the specified `offset` with the specified endian format
		(`readInt16BE()` returns big endian, `readInt16LE()` returns little endian).

		@see https://nodejs.org/api/buffer.html#buffer_buf_readint16be_offset</haxe_doc>
		</readInt16BE>
		<readInt16LE public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a signed 16-bit integer from `buf` at the specified `offset` with the specified endian format
		(`readInt16BE()` returns big endian, `readInt16LE()` returns little endian).

		@see https://nodejs.org/api/buffer.html#buffer_buf_readint16le_offset</haxe_doc>
		</readInt16LE>
		<readInt32BE public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a signed 32-bit integer from buf at the specified offset with the specified endian format
		(`readInt32BE()` returns big endian, `readInt32LE()` returns little endian).

		@see https://nodejs.org/api/buffer.html#buffer_buf_readint32be_offset</haxe_doc>
		</readInt32BE>
		<readInt32LE public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a signed 32-bit integer from buf at the specified offset with the specified endian format
		(`readInt32BE()` returns big endian, `readInt32LE()` returns little endian).

		@see https://nodejs.org/api/buffer.html#buffer_buf_readint32be_offset</haxe_doc>
		</readInt32LE>
		<readIntBE public="1" set="method">
			<f a="offset:byteLength">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result
		as a two's complement signed value. Supports up to 48 bits of accuracy.

		@see https://nodejs.org/api/buffer.html#buffer_buf_readintbe_offset_bytelength</haxe_doc>
		</readIntBE>
		<readIntLE public="1" set="method">
			<f a="offset:byteLength">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result
		as a two's complement signed value. Supports up to 48 bits of accuracy.

		@see https://nodejs.org/api/buffer.html#buffer_buf_readintle_offset_bytelength</haxe_doc>
		</readIntLE>
		<readUInt8 public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads an unsigned 8-bit integer from `buf` at the specified `offset`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_readuint8_offset</haxe_doc>
		</readUInt8>
		<readUInt16BE public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads an unsigned 16-bit integer from `buf` at the specified `offset` with specified endian format
		`readUInt16BE()` returns big endian, `readUInt16LE()` returns little endian).

		@see https://nodejs.org/api/buffer.html#buffer_buf_readuint16be_offset</haxe_doc>
		</readUInt16BE>
		<readUInt16LE public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads an unsigned 16-bit integer from `buf` at the specified `offset` with specified endian format
		(`readUInt16BE()` returns big endian, `readUInt16LE()` returns little endian).

		@see https://nodejs.org/api/buffer.html#buffer_buf_readuint16le_offset</haxe_doc>
		</readUInt16LE>
		<readUInt32BE public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads an unsigned 32-bit integer from `buf` at the specified `offset` with specified endian format
		(`readUInt32BE()` returns big endian, `readUInt32LE()` returns little endian).

		@see https://nodejs.org/api/buffer.html#buffer_buf_readuint32be_offset</haxe_doc>
		</readUInt32BE>
		<readUInt32LE public="1" set="method">
			<f a="?offset">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads an unsigned 32-bit integer from `buf` at the specified `offset` with specified endian format
		(`readUInt32BE()` returns big endian, `readUInt32LE()` returns little endian).

		@see https://nodejs.org/api/buffer.html#buffer_buf_readuint32be_offset</haxe_doc>
		</readUInt32LE>
		<subarray public="1" set="method" override="1">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Returns a new `Buffer` that references the same memory as the original,
		but offset and cropped by the `start` and `end` indices.

		@see https://nodejs.org/api/buffer.html#buffer_buf_subarray_start_end</haxe_doc>
		</subarray>
		<slice public="1" set="method" override="1">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Returns a new `Buffer` that references the same memory as the original,
		but offset and cropped by the `start` and `end` indices.

		@see https://nodejs.org/api/buffer.html#buffer_buf_slice_start_end</haxe_doc>
		</slice>
		<swap16 public="1" set="method">
			<f a=""><c path="js.node.buffer.Buffer"/></f>
			<haxe_doc>Interprets `buf` as an array of unsigned 16-bit integers and swaps the
		byte order in-place. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length`
		is not a multiple of 2.

		@see https://nodejs.org/api/buffer.html#buffer_buf_swap16</haxe_doc>
		</swap16>
		<swap32 public="1" set="method">
			<f a=""><c path="js.node.buffer.Buffer"/></f>
			<haxe_doc>Interprets `buf` as an array of unsigned 32-bit integers and swaps the
		byte order in-place. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length`
		is not a multiple of 4.

		@see https://nodejs.org/api/buffer.html#buffer_buf_swap32</haxe_doc>
		</swap32>
		<swap64 public="1" set="method">
			<f a=""><c path="js.node.buffer.Buffer"/></f>
			<haxe_doc>Interprets `buf` as an array of 64-bit numbers and swaps byte order in-place.
		Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.

		@see https://nodejs.org/api/buffer.html#buffer_buf_swap64</haxe_doc>
		</swap64>
		<toJSON public="1" set="method">
			<f a=""><d/></f>
			<haxe_doc>Returns a JSON representation of `buf`. `JSON.stringify()` implicitly calls
		this function when stringifying a `Buffer` instance.

		@see https://nodejs.org/api/buffer.html#buffer_buf_tojson</haxe_doc>
		</toJSON>
		<toString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Decodes `buf` to a string according to the specified character encoding in `encoding`.
		`start` and `end` may be passed to decode only a subset of `buf`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end</haxe_doc>
			<overloads><toString public="1" set="method">
	<f a="?encoding:?start:?end">
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
		<c path="String"/>
	</f>
	<haxe_doc>Decodes `buf` to a string according to the specified character encoding in `encoding`.
		`start` and `end` may be passed to decode only a subset of `buf`.

		@see https://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end</haxe_doc>
</toString></overloads>
		</toString>
		<values public="1" set="method" override="1">
			<f a=""><t path="js.node.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Creates and returns an iterator for `buf` values (bytes). This function is called automatically
		when a `Buffer` is used in a `for..of` statement.

		@see https://nodejs.org/api/buffer.html#buffer_buf_values</haxe_doc>
		</values>
		<write public="1" set="method">
			<f a="string:?offset:?length:?encoding">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Writes `string` to `buf` at `offset` according to the character encoding in `encoding`.
		The `length` parameter is the number of bytes to write.
		If `buf` did not contain enough space to fit the entire `string`, only part of string will be written.
		However, partially encoded characters will not be written.

		@see https://nodejs.org/api/buffer.html#buffer_buf_write_string_offset_length_encoding</haxe_doc>
		</write>
		<writeDoubleBE public="1" set="method">
			<f a="value:?offset">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset` with specified endian format
		(`writeDoubleBE()` writes big endian, `writeDoubleLE()` writes little endian).
		`value` should be a valid 64-bit double. Behavior is undefined when `value` is anything other than a 64-bit double.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writedoublebe_value_offset</haxe_doc>
		</writeDoubleBE>
		<writeDoubleLE public="1" set="method">
			<f a="value:?offset">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset` with specified endian format
		(`writeDoubleBE()` writes big endian, `writeDoubleLE()` writes little endian).
		`value` should be a valid 64-bit double. Behavior is undefined when `value` is anything other than a 64-bit double.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writedoublele_value_offset</haxe_doc>
		</writeDoubleLE>
		<writeFloatBE public="1" set="method">
			<f a="value:?offset">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset` with specified endian format
		(`writeFloatBE()` writes big endian, `writeFloatLE()` writes little endian).
		`value` should be a valid 32-bit float. Behavior is undefined when `value` is anything other than a 32-bit float.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writefloatbe_value_offset</haxe_doc>
		</writeFloatBE>
		<writeFloatLE public="1" set="method">
			<f a="value:?offset">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset` with specified endian format
		(`writeFloatBE()` writes big endian, `writeFloatLE()` writes little endian).
		`value` should be a valid 32-bit float. Behavior is undefined when `value` is anything other than a 32-bit float.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writefloatle_value_offset</haxe_doc>
		</writeFloatLE>
		<writeInt8 public="1" set="method">
			<f a="value:?offset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset`. `value` should be a valid signed 8-bit integer.
		Behavior is undefined when `value` is anything other than a signed 8-bit integer.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writeint8_value_offset</haxe_doc>
		</writeInt8>
		<writeInt16BE public="1" set="method">
			<f a="value:?offset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset` with specified endian format
		(`writeInt16BE()` writes big endian, `writeInt16LE()` writes little endian).
		`value` should be a valid signed 16-bit integer.
		Behavior is undefined when value is anything other than a signed 16-bit integer.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writeint16be_value_offset</haxe_doc>
		</writeInt16BE>
		<writeInt16LE public="1" set="method">
			<f a="value:?offset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset` with specified endian format
		(`writeInt16BE()` writes big endian, `writeInt16LE()` writes little endian).
		`value` should be a valid signed 16-bit integer.
		Behavior is undefined when value is anything other than a signed 16-bit integer.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writeint16le_value_offset</haxe_doc>
		</writeInt16LE>
		<writeInt32BE public="1" set="method">
			<f a="value:?offset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset` with specified endian format
		(`writeInt32BE()` writes big endian, `writeInt32LE()` writes little endian).
		`value` should be a valid signed 32-bit integer.
		Behavior is undefined when `value` is anything other than a signed 32-bit integer.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writeint32be_value_offset</haxe_doc>
		</writeInt32BE>
		<writeInt32LE public="1" set="method">
			<f a="value:?offset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset` with specified endian format
		(`writeInt32BE()` writes big endian, `writeInt32LE()` writes little endian).
		`value` should be a valid signed 32-bit integer.
		Behavior is undefined when `value` is anything other than a signed 32-bit integer.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writeint32le_value_offset</haxe_doc>
		</writeInt32LE>
		<writeIntBE public="1" set="method">
			<f a="value:offset:byteLength">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Writes `byteLength` bytes of `value` to `buf` at the specified `offset`.
		Supports up to 48 bits of accuracy. Behavior is undefined when `value` is anything other than a signed integer.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writeintbe_value_offset_bytelength</haxe_doc>
		</writeIntBE>
		<writeIntLE public="1" set="method">
			<f a="value:offset:byteLength">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Writes `byteLength` bytes of `value` to `buf` at the specified `offset`.
		Supports up to 48 bits of accuracy. Behavior is undefined when `value` is anything other than a signed integer.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writeintle_value_offset_bytelength</haxe_doc>
		</writeIntLE>
		<writeUInt8 public="1" set="method">
			<f a="value:?offset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset`. `value` should be a valid unsigned 8-bit integer.
		Behavior is undefined when `value` is anything other than an unsigned 8-bit integer.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint8_value_offset</haxe_doc>
		</writeUInt8>
		<writeUInt16BE public="1" set="method">
			<f a="value:?offset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset` with specified endian format
		(`writeUInt16BE()` writes big endian, `writeUInt16LE()` writes little endian).
		`value` should be a valid unsigned 16-bit integer.
		Behavior is undefined when `value` is anything other than an unsigned 16-bit integer.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint16be_value_offset</haxe_doc>
		</writeUInt16BE>
		<writeUInt16LE public="1" set="method">
			<f a="value:?offset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset` with specified endian format
		(`writeUInt16BE()` writes big endian, `writeUInt16LE()` writes little endian).
		`value` should be a valid unsigned 16-bit integer.
		Behavior is undefined when `value` is anything other than an unsigned 16-bit integer.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint16le_value_offset</haxe_doc>
		</writeUInt16LE>
		<writeUInt32BE public="1" set="method">
			<f a="value:?offset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset` with specified endian format
		(`writeUInt32BE()` writes big endian, `writeUInt32LE()` writes little endian).
		`value` should be a valid unsigned 32-bit integer.
		Behavior is undefined when `value` is anything other than an unsigned 32-bit integer.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint32be_value_offset</haxe_doc>
		</writeUInt32BE>
		<writeUInt32LE public="1" set="method">
			<f a="value:?offset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to `buf` at the specified `offset` with specified endian format
		(`writeUInt32BE()` writes big endian, `writeUInt32LE()` writes little endian).
		`value` should be a valid unsigned 32-bit integer.
		Behavior is undefined when `value` is anything other than an unsigned 32-bit integer.

		@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint32le_value_offset</haxe_doc>
		</writeUInt32LE>
		<hxToBytes public="1" get="inline" set="null" line="710">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Create `haxe.io.Bytes` object that uses the same underlying data storage as `this` buffer.
		Any modifications done using the returned object will be reflected in the `this` buffer.</haxe_doc>
		</hxToBytes>
		<new public="1" set="method">
			<f a="string:?encoding">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>Allocates a new buffer.

		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_array
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_arraybuffer_byteoffset_length
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_buffer
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_size
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_string_encoding</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Int"/></c>
						<x path="Void"/>
					</f>
					<meta><m n=":deprecated"/></meta>
					<haxe_doc>Allocates a new buffer.

		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_array
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_arraybuffer_byteoffset_length
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_buffer
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_size
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_string_encoding</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="arrayBuffer:?byteOffset:?length">
						<c path="js.lib.ArrayBuffer"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":deprecated"/></meta>
					<haxe_doc>Allocates a new buffer.

		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_array
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_arraybuffer_byteoffset_length
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_buffer
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_size
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_string_encoding</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="buffer">
						<x path="haxe.io.UInt8Array"/>
						<x path="Void"/>
					</f>
					<meta><m n=":deprecated"/></meta>
					<haxe_doc>Allocates a new buffer.

		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_array
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_arraybuffer_byteoffset_length
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_buffer
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_size
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_string_encoding</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="size">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<meta><m n=":deprecated"/></meta>
					<haxe_doc>Allocates a new buffer.

		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_array
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_arraybuffer_byteoffset_length
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_buffer
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_size
		@see https://nodejs.org/api/buffer.html#buffer_new_buffer_string_encoding</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Buffer` class is a global type for dealing with binary data directly. It can be constructed in a variety of ways.

	@see https://nodejs.org/api/buffer.html#buffer_class_buffer</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":jsRequire">
				<e>"buffer"</e>
				<e>"Buffer"</e>
			</m>
		</meta>
	</class>
	<class path="js.node.buffer._Buffer.Helper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/buffer/Buffer.hx" private="1" module="js.node.buffer.Buffer">
		<bytesOfBuffer public="1" set="method" line="726" static="1">
			<f a="b">
				<c path="js.node.buffer.Buffer"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</bytesOfBuffer>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dce"/>
		</meta>
	</class>
	<class path="js.node.buffer._Buffer.BufferModule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/buffer/Buffer.hx" private="1" module="js.node.buffer.Buffer" extern="1">
		<INSPECT_MAX_BYTES public="1" static="1"><x path="Int"/></INSPECT_MAX_BYTES>
		<kMaxLength public="1" set="null" static="1"><x path="Int"/></kMaxLength>
		<transcode public="1" set="method" static="1"><f a="source:fromEnc:toEnc">
	<c path="js.lib.Uint8Array"/>
	<c path="String"/>
	<c path="String"/>
	<c path="js.node.buffer.Buffer"/>
</f></transcode>
		<constants public="1" set="null" static="1"><t path="js.node.buffer.BufferConstants"/></constants>
		<meta><m n=":jsRequire"><e>"buffer"</e></m></meta>
	</class>
	<typedef path="js.node.buffer.BufferConstants" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/buffer/Buffer.hx" module="js.node.buffer.Buffer"><a>
	<MAX_STRING_LENGTH set="null">
		<x path="Int"/>
		<haxe_doc>Represents the largest `length` that a `string` primitive can have, counted
		in UTF-16 code units.

		@see https://nodejs.org/api/buffer.html#buffer_buffer_constants_max_string_length</haxe_doc>
	</MAX_STRING_LENGTH>
	<MAX_LENGTH set="null">
		<x path="Int"/>
		<haxe_doc>On 32-bit architectures, this value is `(2^30)-1` (`~1GB`).
		On 64-bit architectures, this value is `(2^31)-1` (`~2GB`).

		@see https://nodejs.org/api/buffer.html#buffer_buffer_constants_max_length</haxe_doc>
	</MAX_LENGTH>
</a></typedef>
	<abstract path="js.node.child_process.ChildProcessEvent" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/child_process/ChildProcess.hx" module="js.node.child_process.ChildProcess">
		<this><x path="js.node.events.Event"><c path="js.node.child_process.ChildProcessEvent.T"/></x></this>
		<to><icast><x path="js.node.events.Event"><c path="js.node.child_process.ChildProcessEvent.T"/></x></icast></to>
		<haxe_doc>Enumeration of events emitted by `ChildProcess` objects.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node.child_process._ChildProcess.ChildProcessEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/child_process/ChildProcess.hx" private="1" module="js.node.child_process.ChildProcess" extern="1" final="1">
	<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="50" static="1">
		<x path="js.node.child_process.ChildProcessEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "error"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Emitted when:
			1. The process could not be spawned, or
			2. The process could not be killed, or
			3. Sending a message to the child process failed for whatever reason.

		Note that the exit-event may or may not fire after an error has occured.
		If you are listening on both events to fire a function, remember to guard against calling your function twice.

		See also `ChildProcess.kill` and `ChildProcess.send`.</haxe_doc>
	</Error>
	<Exit public="1" get="inline" set="null" expr="cast &quot;exit&quot;" line="68" static="1">
		<x path="js.node.child_process.ChildProcessEvent"><f a=":">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "exit"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>This event is emitted after the child process ends.

		Listener arguments:
			code - the exit code, if it exited normally.
			signal - the signal passed to kill the child process, if it was killed by the parent.

		If the process terminated normally, `code` is the final exit code of the process, otherwise null.
		If the process terminated due to receipt of a signal, `signal` is the string name of the signal, otherwise null.

		Note that the child process stdio streams might still be open.

		Also, note that node establishes signal handlers for 'SIGINT' and 'SIGTERM',
		so it will not terminate due to receipt of those signals, it will exit.
		See waitpid(2).</haxe_doc>
	</Exit>
	<Close public="1" get="inline" set="null" expr="cast &quot;close&quot;" line="78" static="1">
		<x path="js.node.child_process.ChildProcessEvent"><f a=":">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "close"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>This event is emitted when the stdio streams of a child process have all terminated.
		This is distinct from `Exit`, since multiple processes might share the same stdio streams.

		Listener arguments:
			code - the exit code, if it exited normally.
			signal - the signal passed to kill the child process, if it was killed by the parent.</haxe_doc>
	</Close>
	<Disconnect public="1" get="inline" set="null" expr="cast &quot;disconnect&quot;" line="84" static="1">
		<x path="js.node.child_process.ChildProcessEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "disconnect"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>This event is emitted after calling the `disconnect` method in the parent or in the child.
		After disconnecting it is no longer possible to send messages, and the `connected` property is false.</haxe_doc>
	</Disconnect>
	<Message public="1" get="inline" set="null" expr="cast &quot;message&quot;" line="95" static="1">
		<x path="js.node.child_process.ChildProcessEvent"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "message"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Messages send by `send` are obtained using the message event.

		This event can also be listened on the `process` object to receive messages from the parent.

		Listener arguments:
			message - a parsed JSON object or primitive value
			sendHandle - a Socket or Server object</haxe_doc>
	</Message>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node.child_process._ChildProcess.ChildProcessEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/child_process/ChildProcess.hx" private="1" module="js.node.child_process.ChildProcess" extern="1" final="1">
		<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="50" static="1">
			<x path="js.node.child_process.ChildProcessEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "error"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Emitted when:
			1. The process could not be spawned, or
			2. The process could not be killed, or
			3. Sending a message to the child process failed for whatever reason.

		Note that the exit-event may or may not fire after an error has occured.
		If you are listening on both events to fire a function, remember to guard against calling your function twice.

		See also `ChildProcess.kill` and `ChildProcess.send`.</haxe_doc>
		</Error>
		<Exit public="1" get="inline" set="null" expr="cast &quot;exit&quot;" line="68" static="1">
			<x path="js.node.child_process.ChildProcessEvent"><f a=":">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "exit"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>This event is emitted after the child process ends.

		Listener arguments:
			code - the exit code, if it exited normally.
			signal - the signal passed to kill the child process, if it was killed by the parent.

		If the process terminated normally, `code` is the final exit code of the process, otherwise null.
		If the process terminated due to receipt of a signal, `signal` is the string name of the signal, otherwise null.

		Note that the child process stdio streams might still be open.

		Also, note that node establishes signal handlers for 'SIGINT' and 'SIGTERM',
		so it will not terminate due to receipt of those signals, it will exit.
		See waitpid(2).</haxe_doc>
		</Exit>
		<Close public="1" get="inline" set="null" expr="cast &quot;close&quot;" line="78" static="1">
			<x path="js.node.child_process.ChildProcessEvent"><f a=":">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "close"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>This event is emitted when the stdio streams of a child process have all terminated.
		This is distinct from `Exit`, since multiple processes might share the same stdio streams.

		Listener arguments:
			code - the exit code, if it exited normally.
			signal - the signal passed to kill the child process, if it was killed by the parent.</haxe_doc>
		</Close>
		<Disconnect public="1" get="inline" set="null" expr="cast &quot;disconnect&quot;" line="84" static="1">
			<x path="js.node.child_process.ChildProcessEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "disconnect"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>This event is emitted after calling the `disconnect` method in the parent or in the child.
		After disconnecting it is no longer possible to send messages, and the `connected` property is false.</haxe_doc>
		</Disconnect>
		<Message public="1" get="inline" set="null" expr="cast &quot;message&quot;" line="95" static="1">
			<x path="js.node.child_process.ChildProcessEvent"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "message"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Messages send by `send` are obtained using the message event.

		This event can also be listened on the `process` object to receive messages from the parent.

		Listener arguments:
			message - a parsed JSON object or primitive value
			sendHandle - a Socket or Server object</haxe_doc>
		</Message>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="js.node.child_process.ChildProcessSendOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/child_process/ChildProcess.hx" module="js.node.child_process.ChildProcess"><a><keepOpen>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Can be used when passing instances of `js.node.net.Socket`.

		When true, the socket is kept open in the sending process.

		Defaults to false.</haxe_doc>
</keepOpen></a></typedef>
	<class path="js.node.child_process.ChildProcess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/child_process/ChildProcess.hx" extern="1">
		<extends path="js.node.events.EventEmitter"><c path="js.node.child_process.ChildProcess"/></extends>
		<stdin public="1" set="null">
			<c path="js.node.stream.IWritable"/>
			<haxe_doc>A Writable Stream that represents the child process's stdin.
		Closing this stream via `end` often causes the child process to terminate.

		If the child stdio streams are shared with the parent, then this will not be set.</haxe_doc>
		</stdin>
		<stdout public="1" set="null">
			<c path="js.node.stream.IReadable"/>
			<haxe_doc>A Readable Stream that represents the child process's stdout.

		If the child stdio streams are shared with the parent, then this will not be set.</haxe_doc>
		</stdout>
		<stderr public="1" set="null">
			<c path="js.node.stream.IReadable"/>
			<haxe_doc>A Readable Stream that represents the child process's stderr.

		If the child stdio streams are shared with the parent, then this will not be set.</haxe_doc>
		</stderr>
		<stdio public="1" set="null">
			<c path="Array"><c path="js.node.IStream"/></c>
			<haxe_doc>The parent end of the stdio pipes.</haxe_doc>
		</stdio>
		<pid public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The PID of the child process.</haxe_doc>
		</pid>
		<connected public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Set to false after `disconnect' is called
		If `connected` is false, it is no longer possible to send messages.</haxe_doc>
		</connected>
		<kill public="1" set="method">
			<f a="?signal">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Send a signal to the child process.

		If no argument is given, the process will be sent 'SIGTERM'.
		See signal(7) for a list of available signals.

		May emit an 'error' event when the signal cannot be delivered.

		Sending a signal to a child process that has already exited is not an error
		but may have unforeseen consequences: if the PID (the process ID) has been reassigned to another process,
		the signal will be delivered to that process instead. What happens next is anyone's guess.

		Note that while the function is called `kill`, the signal delivered to the child process may not actually kill it.
		`kill` really just sends a signal to a process. See kill(2)</haxe_doc>
		</kill>
		<send public="1" set="method">
			<f a="message:?callback">
				<d/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>When using `fork` you can write to the child using `send` and messages are received by a 'message' event on the child.

		In the child the `Process` object will have a `send` method, and process will emit objects each time it receives
		a message on its channel.

		Please note that the `send` method on both the parent and child are synchronous - sending large chunks of data is
		not advised (pipes can be used instead, see `spawn`).

		There is a special case when sending a {cmd: 'NODE_foo'} `message`. All messages containing a `NODE_` prefix in
		its cmd property will not be emitted in the 'message' event, since they are internal messages used by node core.
		Messages containing the prefix are emitted in the 'internalMessage' event, you should by all means avoid using
		this feature, it is subject to change without notice.

		The `sendHandle` option is for sending a TCP server or socket object to another process.
		The child will receive the object as its second argument to the message event.

		The `callback` option is a function that is invoked after the message is sent but before the target may have received it.
		It is called with a single argument: null on success, or an `Error` object on failure.

		Emits an 'error' event if the message cannot be sent, for example because the child process has already exited.

		Returns true under normal circumstances or false when the backlog of unsent messages exceeds a threshold that
		makes it unwise to send more. Use the callback mechanism to implement flow control.</haxe_doc>
			<overloads>
				<send public="1" set="method">
					<f a="message:sendHandle:options:?callback">
						<d/>
						<d/>
						<t path="js.node.child_process.ChildProcessSendOptions"/>
						<f a="">
							<c path="js.lib.Error"/>
							<x path="Void"/>
						</f>
						<x path="Bool"/>
					</f>
					<haxe_doc>When using `fork` you can write to the child using `send` and messages are received by a 'message' event on the child.

		In the child the `Process` object will have a `send` method, and process will emit objects each time it receives
		a message on its channel.

		Please note that the `send` method on both the parent and child are synchronous - sending large chunks of data is
		not advised (pipes can be used instead, see `spawn`).

		There is a special case when sending a {cmd: 'NODE_foo'} `message`. All messages containing a `NODE_` prefix in
		its cmd property will not be emitted in the 'message' event, since they are internal messages used by node core.
		Messages containing the prefix are emitted in the 'internalMessage' event, you should by all means avoid using
		this feature, it is subject to change without notice.

		The `sendHandle` option is for sending a TCP server or socket object to another process.
		The child will receive the object as its second argument to the message event.

		The `callback` option is a function that is invoked after the message is sent but before the target may have received it.
		It is called with a single argument: null on success, or an `Error` object on failure.

		Emits an 'error' event if the message cannot be sent, for example because the child process has already exited.

		Returns true under normal circumstances or false when the backlog of unsent messages exceeds a threshold that
		makes it unwise to send more. Use the callback mechanism to implement flow control.</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="message:sendHandle:?callback">
						<d/>
						<d/>
						<f a="">
							<c path="js.lib.Error"/>
							<x path="Void"/>
						</f>
						<x path="Bool"/>
					</f>
					<haxe_doc>When using `fork` you can write to the child using `send` and messages are received by a 'message' event on the child.

		In the child the `Process` object will have a `send` method, and process will emit objects each time it receives
		a message on its channel.

		Please note that the `send` method on both the parent and child are synchronous - sending large chunks of data is
		not advised (pipes can be used instead, see `spawn`).

		There is a special case when sending a {cmd: 'NODE_foo'} `message`. All messages containing a `NODE_` prefix in
		its cmd property will not be emitted in the 'message' event, since they are internal messages used by node core.
		Messages containing the prefix are emitted in the 'internalMessage' event, you should by all means avoid using
		this feature, it is subject to change without notice.

		The `sendHandle` option is for sending a TCP server or socket object to another process.
		The child will receive the object as its second argument to the message event.

		The `callback` option is a function that is invoked after the message is sent but before the target may have received it.
		It is called with a single argument: null on success, or an `Error` object on failure.

		Emits an 'error' event if the message cannot be sent, for example because the child process has already exited.

		Returns true under normal circumstances or false when the backlog of unsent messages exceeds a threshold that
		makes it unwise to send more. Use the callback mechanism to implement flow control.</haxe_doc>
				</send>
			</overloads>
		</send>
		<disconnect public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the IPC channel between parent and child, allowing the child to exit gracefully once there are no other
		connections keeping it alive.

		After calling this method the `connected` flag will be set to false in both the parent and child,
		and it is no longer possible to send messages.

		The 'disconnect' event will be emitted when there are no messages in the process of being received,
		most likely immediately.

		Note that you can also call `process.disconnect` in the child process.</haxe_doc>
		</disconnect>
		<unref public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>By default, the parent will wait for the detached child to exit.
		To prevent the parent from waiting for a given child, use the `unref` method,
		and the parent's event loop will not include the child in its reference count.</haxe_doc>
		</unref>
		<haxe_doc>An object representing a child process.

	The `ChildProcess` class is not intended to be used directly. Use the spawn() or fork() module methods
	to create a `ChildProcess` instance.</haxe_doc>
	</class>
	<class path="js.node.console.Console" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/console/Console.hx" extern="1">
		<assert public="1" set="method">
			<f a="value:message">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>A simple assertion test that verifies whether `value` is truthy. If it is not, `Assertion` failed is logged.
		If provided, the error `message` is formatted using `util.format()` by passing along all message arguments. The output is used as the error message.

		@see https://nodejs.org/api/console.html#console_console_assert_value_message</haxe_doc>
		</assert>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>When `stdout` is a TTY, calling `console.clear()` will attempt to clear the TTY. When `stdout` is not a TTY, this method does nothing.

		@see https://nodejs.org/api/console.html#console_console_clear</haxe_doc>
		</clear>
		<count public="1" set="method">
			<f a="?label">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Maintains an internal counter specific to `label` and outputs to `stdout` the number of times `console.count()` has been called with the given `label`.

		@see https://nodejs.org/api/console.html#console_console_count_label</haxe_doc>
		</count>
		<countReset public="1" set="method">
			<f a="?label">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Resets the internal counter specific to `label`.

		@see https://nodejs.org/api/console.html#console_console_countreset_label</haxe_doc>
		</countReset>
		<debug public="1" set="method">
			<f a="data:args">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>The `console.debug()` function is an alias for `console.log()`.

		@see https://nodejs.org/api/console.html#console_console_debug_data_args</haxe_doc>
		</debug>
		<dir public="1" set="method">
			<f a="obj:?options">
				<d/>
				<x path="Null"><t path="js.node.InspectOptionsBase"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Uses util.inspect() on `obj` and prints the resulting string to `stdout`. This function bypasses any custom `inspect()` function defined on `obj`.

		@see https://nodejs.org/api/console.html#console_console_dir_obj_options</haxe_doc>
		</dir>
		<dirxml public="1" set="method">
			<f a="data">
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>This method calls `console.log()` passing it the arguments received. This method does not produce any XML formatting.

		@see https://nodejs.org/api/console.html#console_console_dirxml_data</haxe_doc>
		</dirxml>
		<error public="1" set="method">
			<f a="data:args">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Prints to `stderr` with newline. Multiple arguments can be passed,
		with the first used as the primary message and all additional used as substitution values similar to printf(3)
		(the arguments are all passed to util.format()).

		@see https://nodejs.org/api/console.html#console_console_error_data_args</haxe_doc>
		</error>
		<group public="1" set="method">
			<f a="label">
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>If one or more `label`s are provided, those are printed first without the additional indentation.

		@see https://nodejs.org/api/console.html#console_console_group_label</haxe_doc>
		</group>
		<groupCollapsed public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>An alias for console.group().

		@see https://nodejs.org/api/console.html#console_console_groupcollapsed</haxe_doc>
		</groupCollapsed>
		<groupEnd public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Decreases indentation of subsequent lines by two spaces.

		@see https://nodejs.org/api/console.html#console_console_groupend</haxe_doc>
		</groupEnd>
		<info public="1" set="method">
			<f a="data:args">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>The `console.info()` function is an alias for console.log().

		@see https://nodejs.org/api/console.html#console_console_info_data_args</haxe_doc>
		</info>
		<log public="1" set="method">
			<f a="data:args">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Prints to `stdout` with newline. Multiple arguments can be passed,
		with the first used as the primary message and all additional used as substitution values similar to printf(3)
		(the arguments are all passed to util.format()).

		@see https://nodejs.org/api/console.html#console_console_log_data_args</haxe_doc>
		</log>
		<table public="1" set="method">
			<f a="tabularData:?properties">
				<d/>
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Try to construct a table with the columns of the properties of `tabularData` (or use `properties`)
		and rows of `tabularData` and log it. Falls back to just logging the argument if it cant be parsed as tabular.

		@see https://nodejs.org/api/console.html#console_console_table_tabulardata_properties</haxe_doc>
		</table>
		<time public="1" set="method">
			<f a="?label">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Starts a timer that can be used to compute the duration of an operation. Timers are identified by a unique `label`.
		Use the same `label` when calling console.timeEnd() to stop the timer and output the elapsed time in milliseconds to `stdout`.
		Timer durations are accurate to the sub-millisecond.

		@see https://nodejs.org/api/console.html#console_console_time_label</haxe_doc>
		</time>
		<timeEnd public="1" set="method">
			<f a="?label">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stops a timer that was previously started by calling console.time() and prints the result to `stdout`:

		@see https://nodejs.org/api/console.html#console_console_timeend_label</haxe_doc>
		</timeEnd>
		<timeLog public="1" set="method">
			<f a="?label:data">
				<c path="String"/>
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>For a timer that was previously started by calling console.time(), prints the elapsed time and other `data` arguments to `stdout`:

		@see https://nodejs.org/api/console.html#console_console_timelog_label_data</haxe_doc>
		</timeLog>
		<trace public="1" set="method">
			<f a="message:args">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Prints to `stderr` the string `'Trace: '`, followed by the util.format() formatted message and stack trace to the current position in the code.

		@see https://nodejs.org/api/console.html#console_console_trace_message_args</haxe_doc>
		</trace>
		<warn public="1" set="method">
			<f a="data:args">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>The `console.warn()` function is an alias for console.error().

		@see https://nodejs.org/api/console.html#console_console_warn_data_args</haxe_doc>
		</warn>
		<markTimeline public="1" set="method">
			<f a="?label">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method does not display anything unless used in the inspector. The `console.markTimeline()` method is the deprecated form of console.timeStamp().

		@see https://nodejs.org/api/console.html#console_console_marktimeline_label</haxe_doc>
		</markTimeline>
		<profile public="1" set="method">
			<f a="?label">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method does not display anything unless used in the inspector.
		The `console.profile()` method starts a JavaScript CPU profile with an optional label until console.profileEnd() is called.
		The profile is then added to the Profile panel of the inspector.

		@see https://nodejs.org/api/console.html#console_console_profile_label</haxe_doc>
		</profile>
		<profileEnd public="1" set="method">
			<f a="?label">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method does not display anything unless used in the inspector.
		Stops the current JavaScript CPU profiling session if one has been started and prints the report to the Profiles panel of the inspector.
		See console.profile() for an example.

		@see https://nodejs.org/api/console.html#console_console_profileend_label</haxe_doc>
		</profileEnd>
		<timeStamp public="1" set="method">
			<f a="?label">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method does not display anything unless used in the inspector.
		The `console.timeStamp()` method adds an event with the label `'label'` to the Timeline panel of the inspector.

		@see https://nodejs.org/api/console.html#console_console_timestamp_label</haxe_doc>
		</timeStamp>
		<timeline public="1" set="method">
			<f a="?label">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method does not display anything unless used in the inspector. The `console.timeline()` method is the deprecated form of console.time().

		@see https://nodejs.org/api/console.html#console_console_timeline_label</haxe_doc>
		</timeline>
		<timelineEnd public="1" set="method">
			<f a="?label">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method does not display anything unless used in the inspector. The `console.timelineEnd()` method is the deprecated form of console.timeEnd().

		@see https://nodejs.org/api/console.html#console_console_timelineend_label</haxe_doc>
		</timelineEnd>
		<new public="1" set="method">
			<f a="stdout:?stderr:?ignoreerrors">
				<c path="js.node.stream.IWritable"/>
				<c path="js.node.stream.IWritable"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `Console` with one or two writable stream instances. `stdout` is a writable stream to print log or info output.
		`stderr` is used for warning or error output. If `stderr` is not provided, `stdout` is used for stderr.

		@see https://nodejs.org/api/console.html#console_new_console_stdout_stderr_ignoreerrors</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="options">
		<t path="js.node.console.ConsoleOptions"/>
		<x path="Void"/>
	</f>
	<haxe_doc>Creates a new `Console` with one or two writable stream instances. `stdout` is a writable stream to print log or info output.
		`stderr` is used for warning or error output. If `stderr` is not provided, `stdout` is used for stderr.

		@see https://nodejs.org/api/console.html#console_new_console_stdout_stderr_ignoreerrors</haxe_doc>
</new></overloads>
		</new>
		<haxe_doc>The `Console` class can be used to create a simple logger with configurable output streams
	and can be accessed using either `require('console').Console` or `console.Console` (or their destructured counterparts):

	@see https://nodejs.org/api/console.html#console_class_console</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"console"</e>
	<e>"Console"</e>
</m></meta>
	</class>
	<typedef path="js.node.console.ConsoleOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/console/Console.hx" module="js.node.console.Console"><a>
	<stdout>
		<c path="js.node.stream.IWritable"/>
		<haxe_doc>`stdout` is a writable stream to print log or info output.</haxe_doc>
	</stdout>
	<stderr>
		<c path="js.node.stream.IWritable"/>
		<meta><m n="optional"/></meta>
		<haxe_doc>`stderr` is used for warning or error output. If stderr is not provided, stdout is used for stderr.</haxe_doc>
	</stderr>
	<inspectOptions>
		<t path="js.node.InspectOptions"/>
		<meta><m n="optional"/></meta>
		<haxe_doc>Specifies options that are passed along to util.inspect().</haxe_doc>
	</inspectOptions>
	<ignoreErrors>
		<x path="Bool"/>
		<meta><m n="optional"/></meta>
		<haxe_doc>Ignore errors when writing to the underlying streams. Default: `true`.</haxe_doc>
	</ignoreErrors>
	<colorMode>
		<x path="haxe.extern.EitherType">
			<x path="Bool"/>
			<c path="String"/>
		</x>
		<meta><m n="optional"/></meta>
		<haxe_doc>Set color support for this `Console` instance. Setting to `true` enables coloring while inspecting values,
		setting to `'auto'` will make color support depend on the value of the `isTTY` property and the value returned by `getColorDepth()` on the respective stream.
		 This option can not be used, if `inspectOptions.colors` is set as well. Default: `'auto'`.</haxe_doc>
	</colorMode>
</a></typedef>
	<abstract path="js.node.events.EventEmitterEvent" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/events/EventEmitter.hx" module="js.node.events.EventEmitter">
		<this><x path="js.node.events.Event"><c path="js.node.events.EventEmitterEvent.T"/></x></this>
		<to><icast><x path="js.node.events.Event"><c path="js.node.events.EventEmitterEvent.T"/></x></icast></to>
		<haxe_doc>Enumeration of events emitted by all `EventEmitter` instances.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node.events._EventEmitter.EventEmitterEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/events/EventEmitter.hx" private="1" module="js.node.events.EventEmitter" extern="1" final="1">
	<NewListener public="1" get="inline" set="null" expr="cast &quot;newListener&quot;" line="43" static="1">
		<x path="js.node.events.EventEmitterEvent"><f a="eventName:listener">
	<x path="haxe.extern.EitherType">
		<c path="String"/>
		<c path="js.lib.Symbol"/>
	</x>
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "newListener"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `EventEmitter` instance will emit its own `'newListener'` event before
		a listener is added to its internal array of listeners.

		@see https://nodejs.org/api/events.html#events_event_newlistener</haxe_doc>
	</NewListener>
	<RemoveListener public="1" get="inline" set="null" expr="cast &quot;removeListener&quot;" line="54" static="1">
		<x path="js.node.events.EventEmitterEvent"><f a="eventName:listener">
	<x path="haxe.extern.EitherType">
		<c path="String"/>
		<c path="js.lib.Symbol"/>
	</x>
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "removeListener"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'removeListener'` event is emitted after the `listener` is removed.

		@see https://nodejs.org/api/events.html#events_event_removelistener</haxe_doc>
	</RemoveListener>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node.events._EventEmitter.EventEmitterEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/events/EventEmitter.hx" private="1" module="js.node.events.EventEmitter" extern="1" final="1">
		<NewListener public="1" get="inline" set="null" expr="cast &quot;newListener&quot;" line="43" static="1">
			<x path="js.node.events.EventEmitterEvent"><f a="eventName:listener">
	<x path="haxe.extern.EitherType">
		<c path="String"/>
		<c path="js.lib.Symbol"/>
	</x>
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "newListener"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `EventEmitter` instance will emit its own `'newListener'` event before
		a listener is added to its internal array of listeners.

		@see https://nodejs.org/api/events.html#events_event_newlistener</haxe_doc>
		</NewListener>
		<RemoveListener public="1" get="inline" set="null" expr="cast &quot;removeListener&quot;" line="54" static="1">
			<x path="js.node.events.EventEmitterEvent"><f a="eventName:listener">
	<x path="haxe.extern.EitherType">
		<c path="String"/>
		<c path="js.lib.Symbol"/>
	</x>
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "removeListener"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'removeListener'` event is emitted after the `listener` is removed.

		@see https://nodejs.org/api/events.html#events_event_removelistener</haxe_doc>
		</RemoveListener>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="js.node.events.Event" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/events/EventEmitter.hx" module="js.node.events.EventEmitter">
		<from>
			<icast><c path="String"/></icast>
			<icast><c path="js.lib.Symbol"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="String"/></icast>
			<icast><c path="js.lib.Symbol"/></icast>
		</to>
		<haxe_doc>Abstract type for events. Its type parameter is a signature
	of a listener for a concrete event.</haxe_doc>
		<impl><class path="js.node.events._EventEmitter.Event_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/events/EventEmitter.hx" private="1" module="js.node.events.EventEmitter" extern="1" final="1"/></impl>
	</abstract>
	<class path="js.node.events._EventEmitter.Event_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/events/EventEmitter.hx" private="1" module="js.node.events.EventEmitter" extern="1" final="1"/>
	<abstract path="js.node.fs.FSWatcherChangeType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/FSWatcher.hx" module="js.node.fs.FSWatcher">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>Enumeration of possible types of changes for 'change' event.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node.fs._FSWatcher.FSWatcherChangeType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/FSWatcher.hx" private="1" module="js.node.fs.FSWatcher" extern="1" final="1">
	<Change public="1" get="inline" set="null" expr="cast &quot;change&quot;" line="37" static="1">
		<x path="js.node.fs.FSWatcherChangeType"/>
		<meta>
			<m n=":value"><e>cast "change"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Change>
	<Rename public="1" get="inline" set="null" expr="cast &quot;rename&quot;" line="38" static="1">
		<x path="js.node.fs.FSWatcherChangeType"/>
		<meta>
			<m n=":value"><e>cast "rename"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Rename>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node.fs._FSWatcher.FSWatcherChangeType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/FSWatcher.hx" private="1" module="js.node.fs.FSWatcher" extern="1" final="1">
		<Change public="1" get="inline" set="null" expr="cast &quot;change&quot;" line="37" static="1">
			<x path="js.node.fs.FSWatcherChangeType"/>
			<meta>
				<m n=":value"><e>cast "change"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Change>
		<Rename public="1" get="inline" set="null" expr="cast &quot;rename&quot;" line="38" static="1">
			<x path="js.node.fs.FSWatcherChangeType"/>
			<meta>
				<m n=":value"><e>cast "rename"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Rename>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="js.node.fs.FSWatcherEvent" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/FSWatcher.hx" module="js.node.fs.FSWatcher">
		<this><x path="js.node.events.Event"><c path="js.node.fs.FSWatcherEvent.T"/></x></this>
		<to><icast><x path="js.node.events.Event"><c path="js.node.fs.FSWatcherEvent.T"/></x></icast></to>
		<haxe_doc>Enumeration of the events emitted by `FSWatcher`.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node.fs._FSWatcher.FSWatcherEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/FSWatcher.hx" private="1" module="js.node.fs.FSWatcher" extern="1" final="1">
	<Change public="1" get="inline" set="null" expr="cast &quot;change&quot;" line="52" static="1">
		<x path="js.node.fs.FSWatcherEvent"><f a=":">
	<x path="js.node.fs.FSWatcherChangeType"/>
	<t path="js.node.FsPath"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "change"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Emitted when something changes in a watched directory or file. See more details in `Fs.watch`.

		Listener arguments:
			event - The type of fs change
			filename - The filename that changed (if relevant/available)</haxe_doc>
	</Change>
	<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="57" static="1">
		<x path="js.node.fs.FSWatcherEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "error"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Emitted when an error occurs.</haxe_doc>
	</Error>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node.fs._FSWatcher.FSWatcherEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/FSWatcher.hx" private="1" module="js.node.fs.FSWatcher" extern="1" final="1">
		<Change public="1" get="inline" set="null" expr="cast &quot;change&quot;" line="52" static="1">
			<x path="js.node.fs.FSWatcherEvent"><f a=":">
	<x path="js.node.fs.FSWatcherChangeType"/>
	<t path="js.node.FsPath"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "change"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Emitted when something changes in a watched directory or file. See more details in `Fs.watch`.

		Listener arguments:
			event - The type of fs change
			filename - The filename that changed (if relevant/available)</haxe_doc>
		</Change>
		<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="57" static="1">
			<x path="js.node.fs.FSWatcherEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "error"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Emitted when an error occurs.</haxe_doc>
		</Error>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="js.node.fs.FSWatcher" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/FSWatcher.hx" extern="1">
		<extends path="js.node.events.EventEmitter"><c path="js.node.fs.FSWatcher"/></extends>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stop watching for changes on the given `FSWatcher`.</haxe_doc>
		</close>
		<haxe_doc>Objects returned from `Fs.watch` are of this type.</haxe_doc>
	</class>
	<abstract path="js.node.fs.ReadStreamEvent" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/ReadStream.hx" module="js.node.fs.ReadStream">
		<this><x path="js.node.events.Event"><c path="js.node.fs.ReadStreamEvent.T"/></x></this>
		<to><icast><x path="js.node.events.Event"><c path="js.node.fs.ReadStreamEvent.T"/></x></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node.fs._ReadStream.ReadStreamEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/ReadStream.hx" private="1" module="js.node.fs.ReadStream" extern="1" final="1">
	<Open public="1" get="inline" set="null" expr="cast &quot;open&quot;" line="35" static="1">
		<x path="js.node.fs.ReadStreamEvent"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "open"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Emitted when the `ReadStream`'s file is opened.

		Listener arguments:
			fd - file descriptor used by the `ReadStream`.</haxe_doc>
	</Open>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node.fs._ReadStream.ReadStreamEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/ReadStream.hx" private="1" module="js.node.fs.ReadStream" extern="1" final="1">
		<Open public="1" get="inline" set="null" expr="cast &quot;open&quot;" line="35" static="1">
			<x path="js.node.fs.ReadStreamEvent"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "open"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Emitted when the `ReadStream`'s file is opened.

		Listener arguments:
			fd - file descriptor used by the `ReadStream`.</haxe_doc>
		</Open>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="js.node.stream.IReadable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Readable.hx" module="js.node.stream.Readable" extern="1" interface="1">
		<destroy public="1" set="method"><f a="?error">
	<c path="js.lib.Error"/>
	<c path="js.node.stream.IReadable"/>
</f></destroy>
		<destroyed public="1" set="null"><x path="Bool"/></destroyed>
		<isPaused public="1" set="method"><f a=""><x path="Bool"/></f></isPaused>
		<pause public="1" set="method"><f a=""><c path="js.node.stream.IReadable"/></f></pause>
		<pipe public="1" params="T" set="method"><f a="destination:?options">
	<c path="pipe.T"/>
	<a><end>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
</end></a>
	<c path="pipe.T"/>
</f></pipe>
		<read public="1" set="method"><f a="?size">
	<x path="Int"/>
	<x path="Null"><d/></x>
</f></read>
		<readable public="1" set="null"><x path="Bool"/></readable>
		<readableEncoding public="1" set="null"><x path="Null"><c path="String"/></x></readableEncoding>
		<readableEnded public="1" set="null"><x path="Bool"/></readableEnded>
		<readableHighWaterMark public="1" set="null"><x path="Int"/></readableHighWaterMark>
		<readableLength public="1" set="null"><x path="Int"/></readableLength>
		<readableObjectMode public="1" set="null"><x path="Bool"/></readableObjectMode>
		<resume public="1" set="method"><f a=""><c path="js.node.stream.IReadable"/></f></resume>
		<setEncoding public="1" set="method"><f a="encoding">
	<c path="String"/>
	<c path="js.node.stream.IReadable"/>
</f></setEncoding>
		<unpipe public="1" set="method"><f a="?destination">
	<c path="js.node.stream.IWritable"/>
	<c path="js.node.stream.IReadable"/>
</f></unpipe>
		<unshift public="1" set="method"><f a="chunk:?encoding">
	<x path="Null"><d/></x>
	<c path="String"/>
	<x path="Void"/>
</f></unshift>
		<wrap public="1" set="method"><f a="stream">
	<d/>
	<c path="js.node.stream.IReadable"/>
</f></wrap>
		<haxe_doc>`IReadable` interface is used as "any Readable".

	See `Readable` for actual class documentation.</haxe_doc>
		<meta><m n=":remove"/></meta>
	</class>
	<class path="js.node.stream.Readable" params="TSelf" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Readable.hx" extern="1">
		<extends path="js.node.Stream"><c path="js.node.stream.Readable.TSelf"/></extends>
		<from public="1" params="T" set="method" static="1"><f a="iterable:?options">
	<t path="js.node.Iterator"><c path="from.T"/></t>
	<x path="Null"><t path="js.node.stream.ReadableNewOptions"/></x>
	<c path="js.node.stream.IReadable"/>
</f></from>
		<destroy public="1" set="method">
			<f a="?error">
				<c path="js.lib.Error"/>
				<c path="js.node.stream.Readable.TSelf"/>
			</f>
			<haxe_doc>Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event unless `emitClose` is set in `false`.
		After this call, the readable stream will release any internal resources and subsequent calls to `push()` will be ignored.
		Implementors should not override this method, but instead implement `readable._destroy()`.

		@see https://nodejs.org/api/stream.html#stream_readable_destroy_error</haxe_doc>
		</destroy>
		<destroyed public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Is `true` after `readable.destroy()` has been called.

		@see https://nodejs.org/api/stream.html#stream_readable_destroyed</haxe_doc>
		</destroyed>
		<isPaused public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>The `readable.isPaused()` method returns the current operating state of the `Readable`.
		This is used primarily by the mechanism that underlies the `readable.pipe()` method.
		In most typical cases, there will be no reason to use this method directly.

		@see https://nodejs.org/api/stream.html#stream_readable_ispaused</haxe_doc>
		</isPaused>
		<pause public="1" set="method">
			<f a=""><c path="js.node.stream.Readable.TSelf"/></f>
			<haxe_doc>The `readable.pause()` method will cause a stream in flowing mode to stop emitting `'data'` events,
		switching out of flowing mode. Any data that becomes available will remain in the internal buffer.

		@see https://nodejs.org/api/stream.html#stream_readable_pause</haxe_doc>
		</pause>
		<pipe public="1" params="T" set="method">
			<f a="destination:?options">
				<c path="pipe.T"/>
				<a><end>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
</end></a>
				<c path="pipe.T"/>
			</f>
			<haxe_doc>The `readable.pipe()` method attaches a `Writable` stream to the `readable`,
		causing it to switch automatically into flowing mode and push all of its data to the attached `Writable`.
		The flow of data will be automatically managed so that the destination `Writable` stream
		is not overwhelmed by a faster `Readable` stream.

		@see https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options</haxe_doc>
		</pipe>
		<read public="1" set="method">
			<f a="?size">
				<x path="Int"/>
				<x path="Null"><d/></x>
			</f>
			<haxe_doc>The `readable.read()` method pulls some data out of the internal buffer and returns it.
		If no data available to be read, `null` is returned. By default,
		the data will be returned as a `Buffer` object unless an encoding has been specified using
		the `readable.setEncoding()` method or the stream is operating in object mode.

		@see https://nodejs.org/api/stream.html#stream_readable_read_size</haxe_doc>
		</read>
		<readable public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Is `true` if it is safe to call `readable.read()`.

		@see https://nodejs.org/api/stream.html#stream_readable_readable</haxe_doc>
		</readable>
		<readableEncoding public="1" set="null">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>Getter for the property `encoding` of a given `Readable` stream.
		The `encoding` property can be set using the `readable.setEncoding()` method.

		@see https://nodejs.org/api/stream.html#stream_readable_readableencoding</haxe_doc>
		</readableEncoding>
		<readableEnded public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Becomes `true` when `'end'` event is emitted.

		@see https://nodejs.org/api/stream.html#stream_readable_readableended</haxe_doc>
		</readableEnded>
		<readableHighWaterMark public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Returns the value of `highWaterMark` passed when constructing this `Readable`.

		@see https://nodejs.org/api/stream.html#stream_readable_readablehighwatermark</haxe_doc>
		</readableHighWaterMark>
		<readableLength public="1" set="null">
			<x path="Int"/>
			<haxe_doc>This property contains the number of bytes (or objects) in the queue ready to be read.
		The value provides introspection data regarding the status of the `highWaterMark`.

		@see https://nodejs.org/api/stream.html#stream_readable_readablelength</haxe_doc>
		</readableLength>
		<readableObjectMode public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Getter for the property `objectMode` of a given `Readable` stream.

		@see https://nodejs.org/api/stream.html#stream_readable_readableobjectmode</haxe_doc>
		</readableObjectMode>
		<resume public="1" set="method">
			<f a=""><c path="js.node.stream.Readable.TSelf"/></f>
			<haxe_doc>The `readable.resume()` method causes an explicitly paused `Readable` stream to resume emitting `'data'` events,
		switching the stream into flowing mode.

		@see https://nodejs.org/api/stream.html#stream_readable_resume</haxe_doc>
		</resume>
		<setEncoding public="1" set="method">
			<f a="encoding">
				<c path="String"/>
				<c path="js.node.stream.Readable.TSelf"/>
			</f>
			<haxe_doc>The `readable.setEncoding()` method sets the character encoding for data read from the `Readable` stream.

		@see https://nodejs.org/api/stream.html#stream_readable_setencoding_encoding</haxe_doc>
		</setEncoding>
		<unpipe public="1" set="method">
			<f a="?destination">
				<c path="js.node.stream.IWritable"/>
				<c path="js.node.stream.Readable.TSelf"/>
			</f>
			<haxe_doc>The `readable.unpipe()` method detaches a `Writable` stream previously attached using the `stream.pipe()` method.

		@see https://nodejs.org/api/stream.html#stream_readable_unpipe_destination</haxe_doc>
		</unpipe>
		<unshift public="1" set="method">
			<f a="chunk:?encoding">
				<x path="Null"><d/></x>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Passing `chunk` as `null` signals the end of the stream (EOF), after which no more data can be written.

		@see https://nodejs.org/api/stream.html#stream_readable_unshift_chunk_encoding</haxe_doc>
		</unshift>
		<wrap public="1" set="method">
			<f a="stream">
				<d/>
				<c path="js.node.stream.IReadable"/>
			</f>
			<haxe_doc>Prior to Node.js 0.10, streams did not implement the entire `stream` module API as it is currently defined.
		(See Compatibility for more information.)

		@see https://nodejs.org/api/stream.html#stream_readable_wrap_stream</haxe_doc>
		</wrap>
		<_read set="method">
			<f a="size">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This function **MUST NOT** be called by application code directly.
		It should be implemented by child classes, and called by the internal `Readable` class methods only.

		@see https://nodejs.org/api/stream.html#stream_readable_read_size_1</haxe_doc>
		</_read>
		<_destroy set="method">
			<f a="err:callback">
				<x path="Null"><c path="js.lib.Error"/></x>
				<f a="">
					<x path="Null"><c path="js.lib.Error"/></x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>The `_destroy()` method is called by `readable.destroy()`.
		It can be overridden by child classes but it **must not** be called directly.

		@see https://nodejs.org/api/stream.html#stream_readable_destroy_err_callback</haxe_doc>
		</_destroy>
		<push set="method">
			<f a="chunk:?encoding">
				<x path="Null"><d/></x>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>The `readable.push()` method is intended be called only by `Readable` implementers,
		and only from within the `readable._read()` method.

		@see https://nodejs.org/api/stream.html#stream_readable_push_chunk_encoding</haxe_doc>
		</push>
		<isTTY public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Terminal read streams (i.e. process.stdin) have this property set to true.
		It is false for any other read streams.

		@see https://nodejs.org/api/tty.html#tty_readstream_istty</haxe_doc>
		</isTTY>
		<new public="1" set="method">
			<f a="?options">
				<x path="Null"><t path="js.node.stream.ReadableNewOptions"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@see https://nodejs.org/api/stream.html#stream_new_stream_readable_options</haxe_doc>
		</new>
		<haxe_doc>@see https://nodejs.org/api/stream.html#stream_class_stream_readable</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"stream"</e>
	<e>"Readable"</e>
</m></meta>
	</class>
	<class path="js.node.fs.ReadStream" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/ReadStream.hx" extern="1">
		<extends path="js.node.stream.Readable"><c path="js.node.fs.ReadStream"/></extends>
		<path public="1">
			<t path="js.node.FsPath"/>
			<haxe_doc>The path to the file the stream is reading from as specified in the first argument to `Fs.createReadStream`.

		If path is passed as a string, then readStream.path will be a string.
		If path is passed as a Buffer, then readStream.path will be a Buffer.</haxe_doc>
		</path>
		<haxe_doc>Readable file stream.</haxe_doc>
	</class>
	<class path="js.node.fs.Stats" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/Stats.hx" extern="1">
		<dev public="1"><x path="Int"/></dev>
		<ino public="1"><x path="Float"/></ino>
		<mode public="1"><x path="Int"/></mode>
		<nlink public="1"><x path="Int"/></nlink>
		<uid public="1"><x path="Int"/></uid>
		<gid public="1"><x path="Int"/></gid>
		<rdev public="1"><x path="Int"/></rdev>
		<size public="1"><x path="Float"/></size>
		<blksize public="1"><x path="Null"><x path="Int"/></x></blksize>
		<blocks public="1"><x path="Null"><x path="Float"/></x></blocks>
		<atime public="1">
			<c path="Date"/>
			<haxe_doc>"Access Time" - Time when file data last accessed.

		Changed by the mknod(2), utimes(2), and read(2) system calls.</haxe_doc>
		</atime>
		<mtime public="1">
			<c path="Date"/>
			<haxe_doc>"Modified Time" - Time when file data last modified.

		Changed by the mknod(2), utimes(2), and write(2) system calls.</haxe_doc>
		</mtime>
		<ctime public="1">
			<c path="Date"/>
			<haxe_doc>"Change Time" - Time when file status was last changed (inode data modification).

		Changed by the chmod(2), chown(2), link(2), mknod(2), rename(2), unlink(2), utimes(2), read(2), and write(2) system calls.</haxe_doc>
		</ctime>
		<birthtime public="1">
			<c path="Date"/>
			<haxe_doc>"Birth Time" - Time of file creation. Set once when the file is created.

		On filesystems where birthtime is not available, this field may instead hold either the ctime or 1970-01-01T00:00Z (ie, unix epoch timestamp 0).
		Note that this value may be greater than `atime` or `mtime` in this case. On Darwin and other FreeBSD variants,
		also set if the `atime` is explicitly set to an earlier value than the current birthtime using the utimes(2) system call.</haxe_doc>
		</birthtime>
		<isFile public="1" set="method"><f a=""><x path="Bool"/></f></isFile>
		<isDirectory public="1" set="method"><f a=""><x path="Bool"/></f></isDirectory>
		<isBlockDevice public="1" set="method"><f a=""><x path="Bool"/></f></isBlockDevice>
		<isCharacterDevice public="1" set="method"><f a=""><x path="Bool"/></f></isCharacterDevice>
		<isSymbolicLink public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Only valid with `Fs.lstat`.</haxe_doc>
		</isSymbolicLink>
		<isFIFO public="1" set="method"><f a=""><x path="Bool"/></f></isFIFO>
		<isSocket public="1" set="method"><f a=""><x path="Bool"/></f></isSocket>
		<haxe_doc>Objects returned from `Fs.stat`, `Fs.lstat` and `Fs.fstat` and their synchronous counterparts are of this type.</haxe_doc>
	</class>
	<abstract path="js.node.fs.WriteStreamEvent" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/WriteStream.hx" module="js.node.fs.WriteStream">
		<this><x path="js.node.events.Event"><c path="js.node.fs.WriteStreamEvent.T"/></x></this>
		<to><icast><x path="js.node.events.Event"><c path="js.node.fs.WriteStreamEvent.T"/></x></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node.fs._WriteStream.WriteStreamEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/WriteStream.hx" private="1" module="js.node.fs.WriteStream" extern="1" final="1">
	<Open public="1" get="inline" set="null" expr="cast &quot;open&quot;" line="35" static="1">
		<x path="js.node.fs.WriteStreamEvent"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "open"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Emitted when the `WriteStream`'s file is opened.

		Listener arguments:
			fd - file descriptor used by the `WriteStream`.</haxe_doc>
	</Open>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node.fs._WriteStream.WriteStreamEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/WriteStream.hx" private="1" module="js.node.fs.WriteStream" extern="1" final="1">
		<Open public="1" get="inline" set="null" expr="cast &quot;open&quot;" line="35" static="1">
			<x path="js.node.fs.WriteStreamEvent"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "open"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Emitted when the `WriteStream`'s file is opened.

		Listener arguments:
			fd - file descriptor used by the `WriteStream`.</haxe_doc>
		</Open>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="js.node.stream.IWritable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Writable.hx" module="js.node.stream.Writable" extern="1" interface="1">
		<cork public="1" set="method"><f a=""><x path="Void"/></f></cork>
		<destroy public="1" set="method"><f a="?error">
	<c path="js.lib.Error"/>
	<c path="js.node.stream.IWritable"/>
</f></destroy>
		<destroyed public="1" set="null"><x path="Bool"/></destroyed>
		<end public="1" set="method">
			<f a="chunk:?encoding:?callback">
				<d/>
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<f a=""><x path="Void"/></f>
					<f a="">
						<x path="Null"><c path="js.lib.Error"/></x>
						<x path="Void"/>
					</f>
				</x>
				<x path="Void"/>
			</f>
			<overloads><end public="1" set="method"><f a="?callback">
	<x path="haxe.extern.EitherType">
		<f a=""><x path="Void"/></f>
		<f a="">
			<x path="Null"><c path="js.lib.Error"/></x>
			<x path="Void"/>
		</f>
	</x>
	<x path="Void"/>
</f></end></overloads>
		</end>
		<setDefaultEncoding public="1" set="method"><f a="encoding">
	<c path="String"/>
	<c path="js.node.stream.IWritable"/>
</f></setDefaultEncoding>
		<uncork public="1" set="method"><f a=""><x path="Void"/></f></uncork>
		<writable public="1" set="null"><x path="Bool"/></writable>
		<writableEnded public="1" set="null"><x path="Bool"/></writableEnded>
		<writableFinished public="1" set="null"><x path="Bool"/></writableFinished>
		<writablehighWaterMark public="1" set="null"><x path="Int"/></writablehighWaterMark>
		<writableLength public="1" set="null"><x path="Int"/></writableLength>
		<writableObjectMode public="1" set="null"><x path="Bool"/></writableObjectMode>
		<write public="1" set="method"><f a="chunk:?encoding:?callback">
	<d/>
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<f a=""><x path="Void"/></f>
		<f a="">
			<x path="Null"><c path="js.lib.Error"/></x>
			<x path="Void"/>
		</f>
	</x>
	<x path="Bool"/>
</f></write>
		<isTTY public="1" set="null"><x path="Bool"/></isTTY>
		<haxe_doc>Writable interface used for type parameter constraints.
	See `Writable` for actual class documentation.</haxe_doc>
		<meta><m n=":remove"/></meta>
	</class>
	<class path="js.node.stream.Writable" params="TSelf" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Writable.hx" extern="1">
		<extends path="js.node.Stream"><c path="js.node.stream.Writable.TSelf"/></extends>
		<cork public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>The `writable.cork()` method forces all written data to be buffered in memory.
		The buffered data will be flushed when either the `stream.uncork()` or `stream.end()` methods are called.

		@see https://nodejs.org/api/stream.html#stream_writable_cork</haxe_doc>
		</cork>
		<destroy public="1" set="method">
			<f a="?error">
				<c path="js.lib.Error"/>
				<c path="js.node.stream.Writable.TSelf"/>
			</f>
			<haxe_doc>Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event unless `emitClose` is set in `false`.
		After this call, the writable stream has ended and subsequent calls to `write()` or `end()` will result in an `ERR_STREAM_DESTROYED` error.
		This is a destructive and immediate way to destroy a stream. Previous calls to `write()` may not have drained, and may trigger an `ERR_STREAM_DESTROYED` error.
		Use `end()` instead of destroy if data should flush before close, or wait for the `'drain'` event before destroying the stream.
		Implementors should not override this method, but instead implement `writable._destroy()`.

		@see https://nodejs.org/api/stream.html#stream_writable_destroy_error</haxe_doc>
		</destroy>
		<destroyed public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Is `true` after `writable.destroy()` has been called.

		@see https://nodejs.org/api/stream.html#stream_writable_destroyed</haxe_doc>
		</destroyed>
		<end public="1" set="method">
			<f a="chunk:?encoding:?callback">
				<d/>
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<f a=""><x path="Void"/></f>
					<f a="">
						<x path="Null"><c path="js.lib.Error"/></x>
						<x path="Void"/>
					</f>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>Calling the `writable.end()` method signals that no more data will be written to the Writable.
		The optional `chunk` and `encoding` arguments allow one final additional chunk of data to be written immediately before closing the stream.
		If provided, the optional `callback` function is attached as a listener for the 'finish' event.

		@see https://nodejs.org/api/stream.html#stream_writable_end_chunk_encoding_callback</haxe_doc>
			<overloads><end public="1" set="method">
	<f a="?callback">
		<x path="haxe.extern.EitherType">
			<f a=""><x path="Void"/></f>
			<f a="">
				<x path="Null"><c path="js.lib.Error"/></x>
				<x path="Void"/>
			</f>
		</x>
		<x path="Void"/>
	</f>
	<haxe_doc>Calling the `writable.end()` method signals that no more data will be written to the Writable.
		The optional `chunk` and `encoding` arguments allow one final additional chunk of data to be written immediately before closing the stream.
		If provided, the optional `callback` function is attached as a listener for the 'finish' event.

		@see https://nodejs.org/api/stream.html#stream_writable_end_chunk_encoding_callback</haxe_doc>
</end></overloads>
		</end>
		<setDefaultEncoding public="1" set="method">
			<f a="encoding">
				<c path="String"/>
				<c path="js.node.stream.Writable.TSelf"/>
			</f>
			<haxe_doc>The `writable.setDefaultEncoding()` method sets the default `encoding` for a Writable stream.

		@see https://nodejs.org/api/stream.html#stream_writable_setdefaultencoding_encoding</haxe_doc>
		</setDefaultEncoding>
		<uncork public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>The `writable.uncork()` method flushes all data buffered since `stream.cork()` was called.

		@see https://nodejs.org/api/stream.html#stream_writable_uncork</haxe_doc>
		</uncork>
		<writable public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Is `true` if it is safe to call `writable.write()`.

		@see https://nodejs.org/api/stream.html#stream_writable_writable</haxe_doc>
		</writable>
		<writableEnded public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Is `true` after `writable.end()` has been called. This property
		does not indicate whether the data has been flushed, for this use
		`writable.writableFinished` instead.

		@see https://nodejs.org/api/stream.html#stream_writable_writableended</haxe_doc>
		</writableEnded>
		<writableFinished public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Is set to `true` immediately before the 'finish' event is emitted.

		@see https://nodejs.org/api/stream.html#stream_writable_writablefinished</haxe_doc>
		</writableFinished>
		<writablehighWaterMark public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Return the value of `highWaterMark` passed when constructing this `Writable`.

		@see https://nodejs.org/api/stream.html#stream_writable_writablehighwatermark</haxe_doc>
		</writablehighWaterMark>
		<writableLength public="1" set="null">
			<x path="Int"/>
			<haxe_doc>This property contains the number of bytes (or objects) in the queue ready to be written.
		The value provides introspection data regarding the status of the `highWaterMark`.

		@see https://nodejs.org/api/stream.html#stream_writable_writablelength</haxe_doc>
		</writableLength>
		<writableObjectMode public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Getter for the property `objectMode` of a given `Writable` stream.

		@see https://nodejs.org/api/stream.html#stream_writable_writableobjectmode</haxe_doc>
		</writableObjectMode>
		<write public="1" set="method">
			<f a="chunk:?encoding:?callback">
				<d/>
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<f a=""><x path="Void"/></f>
					<f a="">
						<x path="Null"><c path="js.lib.Error"/></x>
						<x path="Void"/>
					</f>
				</x>
				<x path="Bool"/>
			</f>
			<haxe_doc>The `writable.write()` method writes some data to the stream, and calls the supplied `callback` once the data has been fully handled.
		If an error occurs, the `callback` may or may not be called with the error as its first argument.
		To reliably detect write errors, add a listener for the `'error'` event.

		@see https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback</haxe_doc>
		</write>
		<_write set="method">
			<f a="chunk:encoding:callback">
				<d/>
				<c path="String"/>
				<f a="">
					<x path="Null"><c path="js.lib.Error"/></x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>All `Writable` stream implementations must provide a `writable._write()` method to send data to the underlying resource.

		@see https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback_1</haxe_doc>
		</_write>
		<_writev set="method">
			<f a="chunks:callback">
				<c path="Array"><t path="js.node.stream.Chunk"/></c>
				<f a="">
					<x path="Null"><c path="js.lib.Error"/></x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>This function **MUST NOT** be called by application code directly.
		It should be implemented by child classes, and called by the internal `Writable` class methods only.

		@see https://nodejs.org/api/stream.html#stream_writable_writev_chunks_callback</haxe_doc>
		</_writev>
		<_destroy set="method">
			<f a="err:callback">
				<x path="Null"><c path="js.lib.Error"/></x>
				<f a="">
					<x path="Null"><c path="js.lib.Error"/></x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>The `_destroy()` method is called by `writable.destroy()`.
		It can be overridden by child classes but it **must not** be called directly.

		@see https://nodejs.org/api/stream.html#stream_writable_destroy_err_callback</haxe_doc>
		</_destroy>
		<_final set="method">
			<f a="callback">
				<f a="">
					<x path="Null"><c path="js.lib.Error"/></x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>The `_final()` method **must not** be called directly.
		t may be implemented by child classes, and if so, will be called by the internal `Writable` class methods only.

		@see https://nodejs.org/api/stream.html#stream_writable_final_callback</haxe_doc>
		</_final>
		<isTTY public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Terminal write streams (i.e. process.stdout) have this property set to true.
		It is false for any other write streams.

		@see https://nodejs.org/api/tty.html#tty_writestream_istty</haxe_doc>
		</isTTY>
		<new public="1" set="method">
			<f a="?options">
				<x path="js.node.stream.WritableNewOptionsAdapter"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@see https://nodejs.org/api/stream.html#stream_constructor_new_stream_writable_options</haxe_doc>
		</new>
		<haxe_doc>The Writable stream interface is an abstraction for a destination that you are writing data to.

	Examples of writable streams include:

		- http requests, on the client
		- http responses, on the server
		- fs write streams
		- zlib streams
		- crypto streams
		- tcp sockets
		- child process stdin
		- process.stdout, process.stderr</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"stream"</e>
	<e>"Writable"</e>
</m></meta>
	</class>
	<class path="js.node.fs.WriteStream" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/fs/WriteStream.hx" extern="1">
		<extends path="js.node.stream.Writable"><c path="js.node.fs.WriteStream"/></extends>
		<path public="1">
			<t path="js.node.FsPath"/>
			<haxe_doc>The path to the file the stream is writing to as specified in the first argument to `Fs.createWriteStream`.
		If path is passed as a string, then writeStream.path will be a string.
		If path is passed as a Buffer, then writeStream.path will be a Buffer.</haxe_doc>
		</path>
		<bytesWritten public="1">
			<x path="Int"/>
			<haxe_doc>The number of bytes written so far.
		Does not include data that is still queued for writing.</haxe_doc>
		</bytesWritten>
		<haxe_doc>Writable file stream.</haxe_doc>
	</class>
	<abstract path="js.node.stream.ReadableEvent" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Readable.hx" module="js.node.stream.Readable">
		<this><x path="js.node.events.Event"><c path="js.node.stream.ReadableEvent.T"/></x></this>
		<to><icast><x path="js.node.events.Event"><c path="js.node.stream.ReadableEvent.T"/></x></icast></to>
		<haxe_doc>Readable streams are an abstraction for a source from which data is consumed.

	@see https://nodejs.org/api/stream.html#stream_readable_streams</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node.stream._Readable.ReadableEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Readable.hx" private="1" module="js.node.stream.Readable" extern="1" final="1">
	<Close public="1" get="inline" set="null" expr="cast &quot;close&quot;" line="48" static="1">
		<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "close"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'close'` event is emitted when the stream and any of its underlying
		resources (a file descriptor, for example) have been closed.
		The event indicates that no more events will be emitted, and no further computation will occur.

		@see https://nodejs.org/api/stream.html#stream_event_close_1</haxe_doc>
	</Close>
	<Data public="1" get="inline" set="null" expr="cast &quot;data&quot;" line="60" static="1">
		<x path="js.node.stream.ReadableEvent"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "data"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'data'` event is emitted whenever the stream is relinquishing ownership of
		a chunk of data to a consumer. This may occur whenever the stream is switched
		in flowing mode by calling `readable.pipe()`, `readable.resume()`, or by
		attaching a listener callback to the `'data'` event. The `'data'` event will
		also be emitted whenever the `readable.read()` method is called and a chunk of
		data is available to be returned.

		@see https://nodejs.org/api/stream.html#stream_event_data</haxe_doc>
	</Data>
	<End public="1" get="inline" set="null" expr="cast &quot;end&quot;" line="68" static="1">
		<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "end"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'end'` event is emitted when there is no more data to be consumed from
		the stream.

		@see https://nodejs.org/api/stream.html#stream_event_end</haxe_doc>
	</End>
	<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="78" static="1">
		<x path="js.node.stream.ReadableEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "error"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'error'` event may be emitted by a `Readable` implementation at any time.
		Typically, this may occur if the underlying stream is unable to generate data
		due to an underlying internal failure, or when a stream implementation attempts
		to push an invalid chunk of data.

		@see https://nodejs.org/api/stream.html#stream_event_error_1</haxe_doc>
	</Error>
	<Pause public="1" get="inline" set="null" expr="cast &quot;pause&quot;" line="86" static="1">
		<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "pause"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'pause'` event is emitted when `stream.pause()` is called
		and `readableFlowing` is not `false`.

		@see https://nodejs.org/api/stream.html#stream_event_pause</haxe_doc>
	</Pause>
	<Readable public="1" get="inline" set="null" expr="cast &quot;readable&quot;" line="95" static="1">
		<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "readable"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'readable'` event is emitted when there is data available to be read from
		the stream. In some cases, attaching a listener for the `'readable'` event will
		cause some amount of data to be read into an internal buffer.

		@see https://nodejs.org/api/stream.html#stream_event_readable</haxe_doc>
	</Readable>
	<Resume public="1" get="inline" set="null" expr="cast &quot;resume&quot;" line="103" static="1">
		<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "resume"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'resume'` event is emitted when `stream.resume()` is
		called and `readableFlowing` is not `true`.

		@see https://nodejs.org/api/stream.html#stream_event_resume</haxe_doc>
	</Resume>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node.stream._Readable.ReadableEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Readable.hx" private="1" module="js.node.stream.Readable" extern="1" final="1">
		<Close public="1" get="inline" set="null" expr="cast &quot;close&quot;" line="48" static="1">
			<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "close"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'close'` event is emitted when the stream and any of its underlying
		resources (a file descriptor, for example) have been closed.
		The event indicates that no more events will be emitted, and no further computation will occur.

		@see https://nodejs.org/api/stream.html#stream_event_close_1</haxe_doc>
		</Close>
		<Data public="1" get="inline" set="null" expr="cast &quot;data&quot;" line="60" static="1">
			<x path="js.node.stream.ReadableEvent"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "data"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'data'` event is emitted whenever the stream is relinquishing ownership of
		a chunk of data to a consumer. This may occur whenever the stream is switched
		in flowing mode by calling `readable.pipe()`, `readable.resume()`, or by
		attaching a listener callback to the `'data'` event. The `'data'` event will
		also be emitted whenever the `readable.read()` method is called and a chunk of
		data is available to be returned.

		@see https://nodejs.org/api/stream.html#stream_event_data</haxe_doc>
		</Data>
		<End public="1" get="inline" set="null" expr="cast &quot;end&quot;" line="68" static="1">
			<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "end"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'end'` event is emitted when there is no more data to be consumed from
		the stream.

		@see https://nodejs.org/api/stream.html#stream_event_end</haxe_doc>
		</End>
		<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="78" static="1">
			<x path="js.node.stream.ReadableEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "error"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'error'` event may be emitted by a `Readable` implementation at any time.
		Typically, this may occur if the underlying stream is unable to generate data
		due to an underlying internal failure, or when a stream implementation attempts
		to push an invalid chunk of data.

		@see https://nodejs.org/api/stream.html#stream_event_error_1</haxe_doc>
		</Error>
		<Pause public="1" get="inline" set="null" expr="cast &quot;pause&quot;" line="86" static="1">
			<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "pause"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'pause'` event is emitted when `stream.pause()` is called
		and `readableFlowing` is not `false`.

		@see https://nodejs.org/api/stream.html#stream_event_pause</haxe_doc>
		</Pause>
		<Readable public="1" get="inline" set="null" expr="cast &quot;readable&quot;" line="95" static="1">
			<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "readable"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'readable'` event is emitted when there is data available to be read from
		the stream. In some cases, attaching a listener for the `'readable'` event will
		cause some amount of data to be read into an internal buffer.

		@see https://nodejs.org/api/stream.html#stream_event_readable</haxe_doc>
		</Readable>
		<Resume public="1" get="inline" set="null" expr="cast &quot;resume&quot;" line="103" static="1">
			<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "resume"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'resume'` event is emitted when `stream.resume()` is
		called and `readableFlowing` is not `true`.

		@see https://nodejs.org/api/stream.html#stream_event_resume</haxe_doc>
		</Resume>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="js.node.stream.ReadableNewOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Readable.hx" module="js.node.stream.Readable">
		<a>
			<read>
				<x path="Null"><f a="size">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Implementation for the `stream._read()` method.</haxe_doc>
			</read>
			<objectMode>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether this stream should behave as a stream of objects.
		Meaning that `stream.read(n)` returns a single value instead of a `Buffer` of size `n`.
		Default: `false`.</haxe_doc>
			</objectMode>
			<highWaterMark>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The maximum number of bytes to store in the internal buffer before ceasing to read from the underlying resource.
		Default: `16384` (16kb), or `16` for `objectMode` streams.</haxe_doc>
			</highWaterMark>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If specified, then buffers will be decoded to strings using the specified encoding.
		Default: `null`.</haxe_doc>
			</encoding>
			<emitClose>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the stream should emit `'close'` after it has been destroyed.
		Default: `true`.</haxe_doc>
			</emitClose>
			<destroy>
				<x path="Null"><f a="err:callback">
	<x path="Null"><c path="js.lib.Error"/></x>
	<f a="">
		<x path="Null"><c path="js.lib.Error"/></x>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Implementation for the `stream._destroy()` method.</haxe_doc>
			</destroy>
			<autoDestroy>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether this stream should automatically call `.destroy()` on itself after ending.
		Default: `false`.</haxe_doc>
			</autoDestroy>
		</a>
		<haxe_doc>Options for `Readable` private constructor.
	For stream implementors only, see node.js API documentation</haxe_doc>
	</typedef>
	<abstract path="js.node.stream.WritableEvent" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Writable.hx" module="js.node.stream.Writable">
		<this><x path="js.node.events.Event"><c path="js.node.stream.WritableEvent.T"/></x></this>
		<to><icast><x path="js.node.events.Event"><c path="js.node.stream.WritableEvent.T"/></x></icast></to>
		<haxe_doc>Writable streams are an abstraction for a destination to which data is written.

	@see https://nodejs.org/api/stream.html#stream_writable_streams</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node.stream._Writable.WritableEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Writable.hx" private="1" module="js.node.stream.Writable" extern="1" final="1">
	<Close public="1" get="inline" set="null" expr="cast &quot;close&quot;" line="51" static="1">
		<x path="js.node.stream.WritableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "close"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'close'` event is emitted when the stream and any of its underlying resources
		(a file descriptor, for example) have been closed.
		The event indicates that no more events will be emitted, and no further computation will occur.

		@see https://nodejs.org/api/stream.html#stream_event_close</haxe_doc>
	</Close>
	<Drain public="1" get="inline" set="null" expr="cast &quot;drain&quot;" line="59" static="1">
		<x path="js.node.stream.WritableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "drain"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>If a call to stream.write(chunk) returns `false`, the `'drain'` event will be emitted
		when it is appropriate to resume writing data to the stream.

		@see https://nodejs.org/api/stream.html#stream_event_drain</haxe_doc>
	</Drain>
	<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="67" static="1">
		<x path="js.node.stream.WritableEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "error"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'error'` event is emitted if an `error` occurred while writing or piping data.
		The listener callback is passed a single Error argument when called.

		@see https://nodejs.org/api/stream.html#stream_event_error</haxe_doc>
	</Error>
	<Finish public="1" get="inline" set="null" expr="cast &quot;finish&quot;" line="75" static="1">
		<x path="js.node.stream.WritableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "finish"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'finish'` event is emitted after the stream.end() method has been called,
		and all data has been flushed to the underlying system.

		@see https://nodejs.org/api/stream.html#stream_event_finish</haxe_doc>
	</Finish>
	<Pipe public="1" get="inline" set="null" expr="cast &quot;pipe&quot;" line="83" static="1">
		<x path="js.node.stream.WritableEvent"><f a="">
	<c path="js.node.stream.IReadable"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "pipe"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'pipe'` event is emitted when the stream.pipe() method is called on a readable stream,
		adding this writable to its set of destinations.

		@see https://nodejs.org/api/stream.html#stream_event_pipe</haxe_doc>
	</Pipe>
	<Unpipe public="1" get="inline" set="null" expr="cast &quot;unpipe&quot;" line="91" static="1">
		<x path="js.node.stream.WritableEvent"><f a="">
	<c path="js.node.stream.IReadable"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "unpipe"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The `'unpipe'` event is emitted when the stream.unpipe() method is called on a Readable stream,
		removing this Writable from its set of destinations.

		@see https://nodejs.org/api/stream.html#stream_event_unpipe</haxe_doc>
	</Unpipe>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node.stream._Writable.WritableEvent_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Writable.hx" private="1" module="js.node.stream.Writable" extern="1" final="1">
		<Close public="1" get="inline" set="null" expr="cast &quot;close&quot;" line="51" static="1">
			<x path="js.node.stream.WritableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "close"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'close'` event is emitted when the stream and any of its underlying resources
		(a file descriptor, for example) have been closed.
		The event indicates that no more events will be emitted, and no further computation will occur.

		@see https://nodejs.org/api/stream.html#stream_event_close</haxe_doc>
		</Close>
		<Drain public="1" get="inline" set="null" expr="cast &quot;drain&quot;" line="59" static="1">
			<x path="js.node.stream.WritableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "drain"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>If a call to stream.write(chunk) returns `false`, the `'drain'` event will be emitted
		when it is appropriate to resume writing data to the stream.

		@see https://nodejs.org/api/stream.html#stream_event_drain</haxe_doc>
		</Drain>
		<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="67" static="1">
			<x path="js.node.stream.WritableEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "error"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'error'` event is emitted if an `error` occurred while writing or piping data.
		The listener callback is passed a single Error argument when called.

		@see https://nodejs.org/api/stream.html#stream_event_error</haxe_doc>
		</Error>
		<Finish public="1" get="inline" set="null" expr="cast &quot;finish&quot;" line="75" static="1">
			<x path="js.node.stream.WritableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "finish"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'finish'` event is emitted after the stream.end() method has been called,
		and all data has been flushed to the underlying system.

		@see https://nodejs.org/api/stream.html#stream_event_finish</haxe_doc>
		</Finish>
		<Pipe public="1" get="inline" set="null" expr="cast &quot;pipe&quot;" line="83" static="1">
			<x path="js.node.stream.WritableEvent"><f a="">
	<c path="js.node.stream.IReadable"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "pipe"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'pipe'` event is emitted when the stream.pipe() method is called on a readable stream,
		adding this writable to its set of destinations.

		@see https://nodejs.org/api/stream.html#stream_event_pipe</haxe_doc>
		</Pipe>
		<Unpipe public="1" get="inline" set="null" expr="cast &quot;unpipe&quot;" line="91" static="1">
			<x path="js.node.stream.WritableEvent"><f a="">
	<c path="js.node.stream.IReadable"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "unpipe"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The `'unpipe'` event is emitted when the stream.unpipe() method is called on a Readable stream,
		removing this Writable from its set of destinations.

		@see https://nodejs.org/api/stream.html#stream_event_unpipe</haxe_doc>
		</Unpipe>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="js.node.stream.WritableNewOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Writable.hx" module="js.node.stream.Writable">
		<a>
			<writev>
				<x path="Null"><f a="chunks:callback">
	<c path="Array"><t path="js.node.stream.Chunk"/></c>
	<f a="">
		<x path="Null"><c path="js.lib.Error"/></x>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[`writev` <Function> Implementation for the stream._writev() method.]]></haxe_doc>
			</writev>
			<write>
				<x path="Null"><f a="chunk:encoding:callback">
	<d/>
	<c path="String"/>
	<f a="">
		<x path="Null"><c path="js.lib.Error"/></x>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[`write` <Function> Implementation for the stream._write() method.]]></haxe_doc>
			</write>
			<objectMode>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[`objectMode` <boolean> Whether or not the stream.write(anyObj) is a valid operation. When set,
		it becomes possible to write JavaScript values other than string, `Buffer` or `Uint8Array` if supported by the stream implementation.
		Default: `false`.]]></haxe_doc>
			</objectMode>
			<highWaterMark>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[`highWaterMark` <number> Buffer level when stream.write() starts returning `false`. Default: `16384` (16kb), or 16 for `objectMode` streams.]]></haxe_doc>
			</highWaterMark>
			<final_>
				<x path="Null"><f a="error">
	<x path="Null"><c path="js.lib.Error"/></x>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[`final` <Function> Implementation for the stream._final() method.]]></haxe_doc>
			</final_>
			<emitClose>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[`emitClose` <boolean> Whether or not the stream should emit `'close'` after it has been destroyed.
		Default: `true`.]]></haxe_doc>
			</emitClose>
			<destroy>
				<x path="Null"><f a="error:callback">
	<x path="Null"><c path="js.lib.Error"/></x>
	<f a="">
		<x path="Null"><c path="js.lib.Error"/></x>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[`destroy` <Function> Implementation for the stream._destroy() method.]]></haxe_doc>
			</destroy>
			<defaultEncoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[`defaultEncoding` <string> The default encoding that is used when no encoding is specified as an argument to stream.write().
		Default: `'utf8'`.]]></haxe_doc>
			</defaultEncoding>
			<decodeStrings>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[`decodeStrings` <boolean> Whether to encode `string`s passed to stream.write() to `Buffer`s (with the encoding specified in the stream.write() call) before passing them to stream._write().
		Other types of data are not converted (i.e. `Buffer`s are not decoded into `string`s). Setting to false will prevent strings from being converted.
		Default: `true`.]]></haxe_doc>
			</decodeStrings>
			<autoDestroy>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[`autoDestroy` <boolean> Whether this stream should automatically call .destroy() on itself after ending. Default: false.]]></haxe_doc>
			</autoDestroy>
		</a>
		<haxe_doc>@see https://nodejs.org/api/stream.html#stream_constructor_new_stream_writable_options</haxe_doc>
	</typedef>
	<abstract path="js.node.stream.WritableNewOptionsAdapter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Writable.hx" module="js.node.stream.Writable">
		<from><icast field="from"><t path="js.node.stream.WritableNewOptions"/></icast></from>
		<this><t path="js.node.stream.WritableNewOptions"/></this>
		<meta><m n=":forward"/></meta>
		<impl><class path="js.node.stream._Writable.WritableNewOptionsAdapter_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Writable.hx" private="1" module="js.node.stream.Writable" final="1"><from public="1" set="method" line="345" static="1">
	<f a="options">
		<t path="js.node.stream.WritableNewOptions"/>
		<x path="js.node.stream.WritableNewOptionsAdapter"/>
	</f>
	<meta><m n=":from"/></meta>
</from></class></impl>
	</abstract>
	<class path="js.node.stream._Writable.WritableNewOptionsAdapter_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Writable.hx" private="1" module="js.node.stream.Writable" final="1"><from public="1" set="method" line="345" static="1">
	<f a="options">
		<t path="js.node.stream.WritableNewOptions"/>
		<x path="js.node.stream.WritableNewOptionsAdapter"/>
	</f>
	<meta><m n=":from"/></meta>
</from></class>
	<typedef path="js.node.stream.Chunk" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/stream/Writable.hx" module="js.node.stream.Writable"><a>
	<encoding><c path="String"/></encoding>
	<chunk><d/></chunk>
</a></typedef>
	<class path="js.node.url.URL" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/url/URL.hx" extern="1">
		<hash public="1">
			<c path="String"/>
			<haxe_doc>Gets and sets the fragment portion of the URL.</haxe_doc>
		</hash>
		<host public="1">
			<c path="String"/>
			<haxe_doc>Gets and sets the host portion of the URL.</haxe_doc>
		</host>
		<hostname public="1">
			<c path="String"/>
			<haxe_doc>Gets and sets the hostname portion of the URL
		The key difference between `url.host` and `url.hostname` is that `url.hostname` does not include the port.</haxe_doc>
		</hostname>
		<href public="1">
			<c path="String"/>
			<haxe_doc>Gets and sets the serialized URL.</haxe_doc>
		</href>
		<origin public="1" set="null">
			<c path="String"/>
			<haxe_doc>Gets the read-only serialization of the URL's origin.</haxe_doc>
		</origin>
		<password public="1">
			<c path="String"/>
			<haxe_doc>Gets and sets the password portion of the URL.</haxe_doc>
		</password>
		<pathname public="1">
			<c path="String"/>
			<haxe_doc>Gets and sets the path portion of the URL.</haxe_doc>
		</pathname>
		<port public="1">
			<c path="String"/>
			<haxe_doc>Gets and sets the port portion of the URL.

		The port value may be a number or a string containing a number in the range `0` to `65535` (inclusive).
		Setting the value to the default port of the `URL` objects given `protocol` will result in the port value becoming the empty string (`''`).</haxe_doc>
		</port>
		<protocol public="1">
			<c path="String"/>
			<haxe_doc>Gets and sets the protocol portion of the URL.</haxe_doc>
		</protocol>
		<search public="1">
			<c path="String"/>
			<haxe_doc>Gets and sets the serialized query portion of the URL.</haxe_doc>
		</search>
		<searchParams public="1" set="null">
			<c path="js.node.url.URLSearchParams"/>
			<haxe_doc>Gets the `URLSearchParams` object representing the query parameters of the URL.
		This property is read-only; to replace the entirety of query parameters of the URL, use the `url.search` setter.
		See [URLSearchParams](https://nodejs.org/api/url.html#url_class_urlsearchparams) documentation for details.</haxe_doc>
		</searchParams>
		<username public="1">
			<c path="String"/>
			<haxe_doc>Gets and sets the username portion of the URL.</haxe_doc>
		</username>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>The `toString()` method on the `URL` object returns the serialized URL.
		The value returned is equivalent to that of `url.href` and `url.toJSON()`.

		Because of the need for standard compliance, this method does not allow users to customize the serialization process of the URL.
		For more flexibility, `require('url').format()` method might be of interest.</haxe_doc>
		</toString>
		<toJSON public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>The `toJSON()` method on the `URL` object returns the serialized URL.
		The value returned is equivalent to that of `url.href` and `url.toString()`.

		This method is automatically called when an `URL` object is serialized with `JSON.stringify()`.</haxe_doc>
		</toJSON>
		<new public="1" set="method">
			<f a="input:?base">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `URL` object by parsing the `input` relative to the `base`.
		If `base` is passed as a string, it will be parsed equivalent to `new URL(base)`.</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="input:?base">
		<c path="String"/>
		<c path="js.node.url.URL"/>
		<x path="Void"/>
	</f>
	<haxe_doc>Creates a new `URL` object by parsing the `input` relative to the `base`.
		If `base` is passed as a string, it will be parsed equivalent to `new URL(base)`.</haxe_doc>
</new></overloads>
		</new>
		<haxe_doc>Browser-compatible URL class, implemented by following the WHATWG URL Standard.
	[Examples of parsed URLs](https://url.spec.whatwg.org/#example-url-parsing) may be found in the Standard itself.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"url"</e>
	<e>"URL"</e>
</m></meta>
	</class>
	<class path="js.node.url.URLSearchParams" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/url/URLSearchParams.hx" extern="1">
		<append public="1" set="method">
			<f a="name:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Append a new name-value pair to the query string.</haxe_doc>
		</append>
		<delete public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Remove all name-value pairs whose name is `name`.</haxe_doc>
		</delete>
		<entries public="1" set="method">
			<f a=""><t path="js.node.Iterator"><x path="js.node.url.URLSearchParamsEntry"/></t></f>
			<haxe_doc>Returns an ES6 `Iterator` over each of the name-value pairs in the query.
		Each item of the iterator is a JavaScript `Array`.
		The first item of the `Array` is the `name`, the second item of the `Array` is the `value`.</haxe_doc>
		</entries>
		<forEach public="1" set="method">
			<f a="fn:?thisArg">
				<f a="value:name:searchParams">
					<c path="String"/>
					<c path="String"/>
					<c path="js.node.url.URLSearchParams"/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Iterates over each name-value pair in the query and invokes the given function.</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="fn:?thisArg">
						<f a="value">
							<c path="String"/>
							<x path="Void"/>
						</f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>Iterates over each name-value pair in the query and invokes the given function.</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="fn:?thisArg">
						<f a="value:name">
							<c path="String"/>
							<c path="String"/>
							<x path="Void"/>
						</f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>Iterates over each name-value pair in the query and invokes the given function.</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<get public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the first name-value pair whose name is `name`.
		If there are no such pairs, `null` is returned.</haxe_doc>
		</get>
		<getAll public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the values of all name-value pairs whose name is `name`.
		If there are no such pairs, an empty array is returned.</haxe_doc>
		</getAll>
		<has public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if there is at least one name-value pair whose name is `name`.</haxe_doc>
		</has>
		<keys public="1" set="method">
			<f a=""><t path="js.node.Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an ES6 `Iterator` over the names of each name-value pair.</haxe_doc>
		</keys>
		<set public="1" set="method">
			<f a="name:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the value in the `URLSearchParams` object associated with `name` to `value`.
		If there are any pre-existing name-value pairs whose names are `name`, set the first such pair's value to `value` and remove all others.
		If not, append the name-value pair to the query string.</haxe_doc>
		</set>
		<sort public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Sort all existing name-value pairs in-place by their names. Sorting is done with a [stable sorting algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm#Stability),
		so relative order between name-value pairs with the same name is preserved.

		This method can be used, in particular, to increase cache hits.</haxe_doc>
		</sort>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the search parameters serialized as a string, with characters percent-encoded where necessary.</haxe_doc>
		</toString>
		<values public="1" set="method">
			<f a=""><t path="js.node.Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an ES6 `Iterator` over the values of each name-value pair.</haxe_doc>
		</values>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new public="1" set="method"><f a="init">
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new public="1" set="method"><f a="obj">
	<d><c path="String"/></d>
	<x path="Void"/>
</f></new>
				<new public="1" set="method"><f a="array">
	<c path="Array"><x path="js.node.url.URLSearchParamsEntry"/></c>
	<x path="Void"/>
</f></new>
				<new public="1" set="method"><f a="iter">
	<t path="js.node.Iterator"><x path="js.node.url.URLSearchParamsEntry"/></t>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<haxe_doc><![CDATA[The `URLSearchParams` API provides read and write access to the query of a `URL`.
	The `URLSearchParams` class can also be used standalone with one of the four following constructors.
	The `URLSearchParams` class is also available on the global object.

	The WHATWG `URLSearchParams` interface and the `querystring` module have similar purpose,
	but the purpose of the querystring module is more general, as it allows the customization of delimiter characters (`&` and` `=`). On the other hand, this API is designed purely for URL query strings.]]></haxe_doc>
		<meta><m n=":jsRequire">
	<e>"url"</e>
	<e>"URLSearchParams"</e>
</m></meta>
	</class>
	<abstract path="js.node.url.URLSearchParamsEntry" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/url/URLSearchParams.hx" module="js.node.url.URLSearchParams">
		<this><c path="Array"><c path="String"/></c></this>
		<haxe_doc>The name-value pair access helper for `js.node.url.URLSearchParams.entries()`.</haxe_doc>
		<impl><class path="js.node.url._URLSearchParams.URLSearchParamsEntry_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/url/URLSearchParams.hx" private="1" module="js.node.url.URLSearchParams" final="1">
	<name public="1" get="accessor" set="null" static="1"><c path="String"/></name>
	<value public="1" get="accessor" set="null" static="1"><c path="String"/></value>
	<_new public="1" set="method" line="128" static="1">
		<f a="name:value">
			<c path="String"/>
			<c path="String"/>
			<x path="js.node.url.URLSearchParamsEntry"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<get_name get="inline" set="null" line="132" static="1"><f a="this">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
</f></get_name>
	<get_value get="inline" set="null" line="136" static="1"><f a="this">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
</f></get_value>
</class></impl>
	</abstract>
	<class path="js.node.url._URLSearchParams.URLSearchParamsEntry_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/js/node/url/URLSearchParams.hx" private="1" module="js.node.url.URLSearchParams" final="1">
		<name public="1" get="accessor" set="null" static="1"><c path="String"/></name>
		<value public="1" get="accessor" set="null" static="1"><c path="String"/></value>
		<_new public="1" set="method" line="128" static="1">
			<f a="name:value">
				<c path="String"/>
				<c path="String"/>
				<x path="js.node.url.URLSearchParamsEntry"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<get_name get="inline" set="null" line="132" static="1"><f a="this">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
</f></get_name>
		<get_value get="inline" set="null" line="136" static="1"><f a="this">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
</f></get_value>
	</class>
	<class path="poly2tri.AdvancingFront" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/AdvancingFront.hx">
		<head public="1"><c path="poly2tri.Node"/></head>
		<tail public="1"><c path="poly2tri.Node"/></tail>
		<search_node public="1"><c path="poly2tri.Node"/></search_node>
		<reset public="1" get="inline" set="null" line="14"><f a="head:tail">
	<c path="poly2tri.Node"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></reset>
		<locateNode public="1" get="inline" set="null" line="20"><f a="x">
	<x path="Float"/>
	<c path="poly2tri.Node"/>
</f></locateNode>
		<locatePoint public="1" get="inline" set="null" line="53"><f a="point">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Node"/>
</f></locatePoint>
		<new public="1" set="method" line="10"><f a="head:tail">
	<c path="poly2tri.Node"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.Basin" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Basin.hx">
		<left_node public="1"><c path="poly2tri.Node"/></left_node>
		<bottom_node public="1"><c path="poly2tri.Node"/></bottom_node>
		<right_node public="1"><c path="poly2tri.Node"/></right_node>
		<width public="1"><x path="Float"/></width>
		<left_highest public="1"><x path="Bool"/></left_highest>
		<clear public="1" get="inline" set="null" line="18"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.Constants" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Constants.hx">
		<kAlpha public="1" expr="0.3" line="8" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.3</e></m></meta>
		</kAlpha>
		<EPSILON public="1" expr="1e-12" line="9" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1e-12</e></m></meta>
		</EPSILON>
		<PI_2 public="1" expr="Math.PI / 2" line="10" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.PI / 2</e></m></meta>
		</PI_2>
		<PI_3div4 public="1" expr="3 * Math.PI / 4" line="11" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>3 * Math.PI / 4</e></m></meta>
		</PI_3div4>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.Edge" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Edge.hx">
		<p public="1"><c path="poly2tri.Point"/></p>
		<q public="1"><c path="poly2tri.Point"/></q>
		<reset public="1" get="inline" set="null" line="13"><f a="p1:p2">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Void"/>
</f></reset>
		<toString public="1" set="method" line="46"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="9"><f a="p1:p2">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.EdgeEvent" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/EdgeEvent.hx">
		<constrained_edge public="1" expr="null">
			<c path="poly2tri.Edge"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</constrained_edge>
		<right public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</right>
		<clear public="1" get="inline" set="null" line="13"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.Node" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Node.hx">
		<point public="1"><c path="poly2tri.Point"/></point>
		<triangle public="1"><c path="poly2tri.Triangle"/></triangle>
		<prev public="1"><c path="poly2tri.Node"/></prev>
		<next public="1"><c path="poly2tri.Node"/></next>
		<value public="1"><x path="Float"/></value>
		<reset public="1" get="inline" set="null" line="21">
			<f a="point:?triangle" v=":null">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Triangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ triangle : null }</e></m></meta>
		</reset>
		<getHoleAngle public="1" get="inline" set="null" line="37">
			<f a=""><x path="Float"/></f>
			<haxe_doc>*
     * @param node - middle node
     * @return the angle between 3 front nodes</haxe_doc>
		</getHoleAngle>
		<getBasinAngle public="1" get="inline" set="null" line="57"><f a=""><x path="Float"/></f></getBasinAngle>
		<new public="1" set="method" line="14">
			<f a="point:?triangle" v=":null">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Triangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ triangle : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.Orientation" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Orientation.hx">
		<CW public="1" get="inline" set="null" expr="1" line="5" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CW>
		<CCW public="1" get="inline" set="null" expr="-1" line="6" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</CCW>
		<COLLINEAR public="1" get="inline" set="null" expr="0" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</COLLINEAR>
		<orient2d public="1" get="inline" set="null" line="10" static="1"><f a="pa:pb:pc">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Int"/>
</f></orient2d>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.Point" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Point.hx">
		<sortPoints public="1" get="inline" set="null" line="51" static="1"><f a="points">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Void"/>
</f></sortPoints>
		<cmpPoints public="1" get="inline" set="null" line="56" static="1"><f a="l:r">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Int"/>
</f></cmpPoints>
		<C_ID public="1" expr="0" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</C_ID>
		<id public="1"><x path="Int"/></id>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<edge_list public="1" get="accessor" set="null"><c path="Array"><c path="poly2tri.Edge"/></c></edge_list>
		<reset public="1" get="inline" set="null" line="27"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></reset>
		<get_edge_list get="inline" set="null" line="38"><f a=""><c path="Array"><c path="poly2tri.Edge"/></c></f></get_edge_list>
		<equals public="1" get="inline" set="null" line="46"><f a="that">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="61"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="18"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.Pool" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Pool.hx">
		<enabled public="1" expr="true" line="5" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</enabled>
		<recycleAll public="1" set="method" line="7" static="1"><f a=""><x path="Void"/></f></recycleAll>
		<clearAll public="1" set="method" line="11" static="1"><f a=""><x path="Void"/></f></clearAll>
		<pointArrayIndex expr="0" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pointArrayIndex>
		<pointArrayPool expr="[]" line="17" static="1">
			<c path="Array"><c path="Array"><c path="poly2tri.Point"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pointArrayPool>
		<getPointArray public="1" set="method" line="19" static="1"><f a=""><c path="Array"><c path="poly2tri.Point"/></c></f></getPointArray>
		<triangleArrayIndex expr="0" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</triangleArrayIndex>
		<triangleArrayPool expr="[]" line="44" static="1">
			<c path="Array"><c path="Array"><c path="poly2tri.Triangle"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</triangleArrayPool>
		<getTriangleArray public="1" set="method" line="46" static="1"><f a=""><c path="Array"><c path="poly2tri.Triangle"/></c></f></getTriangleArray>
		<edgeArrayIndex expr="0" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</edgeArrayIndex>
		<edgeArrayPool expr="[]" line="71" static="1">
			<c path="Array"><c path="Array"><c path="poly2tri.Edge"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</edgeArrayPool>
		<getEdgeArray public="1" set="method" line="73" static="1"><f a=""><c path="Array"><c path="poly2tri.Edge"/></c></f></getEdgeArray>
		<edgeIndex expr="0" line="97" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</edgeIndex>
		<edgePool expr="[]" line="98" static="1">
			<c path="Array"><c path="poly2tri.Edge"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</edgePool>
		<getEdge public="1" set="method" line="100" static="1"><f a="p1:p2">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Edge"/>
</f></getEdge>
		<pointIndex expr="0" line="122" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pointIndex>
		<pointPool expr="[]" line="123" static="1">
			<c path="Array"><c path="poly2tri.Point"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pointPool>
		<getPoint public="1" set="method" line="125" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="poly2tri.Point"/>
</f></getPoint>
		<triangleIndex expr="0" line="147" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</triangleIndex>
		<trianglePool expr="[]" line="148" static="1">
			<c path="Array"><c path="poly2tri.Triangle"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</trianglePool>
		<getTriangle public="1" set="method" line="150" static="1">
			<f a="p1:p2:p3:?fixOrientation:?checkOrientation" v=":::false:true">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="poly2tri.Triangle"/>
			</f>
			<meta><m n=":value"><e>{ checkOrientation : true, fixOrientation : false }</e></m></meta>
		</getTriangle>
		<nodeIndex expr="0" line="172" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nodeIndex>
		<nodePool expr="[]" line="173" static="1">
			<c path="Array"><c path="poly2tri.Node"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</nodePool>
		<getNode public="1" set="method" line="175" static="1">
			<f a="point:?triangle" v=":null">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Triangle"/>
				<c path="poly2tri.Node"/>
			</f>
			<meta><m n=":value"><e>{ triangle : null }</e></m></meta>
		</getNode>
		<setArrayLength public="1" params="T" get="inline" set="null" line="197" static="1"><f a="array:length">
	<c path="Array"><c path="setArrayLength.T"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setArrayLength>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.SortPoints" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/SortPoints.hx">
		<cmp get="inline" set="null" line="35" static="1"><f a="l:r">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Int"/>
</f></cmp>
		<sort public="1" get="inline" set="null" line="59" static="1">
			<f a="a">
				<c path="Array"><c path="poly2tri.Point"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
         `cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
         negative Int if `x < y`.
 
         This operation modifies Array `a` in place.
 
         This operation is stable: The order of equal elements is preserved.
 
         If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec set="method" line="63" static="1"><f a="a:from:to">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge set="method" line="84" static="1"><f a="a:from:pivot:to:len1:len2">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate get="inline" set="null" line="110" static="1"><f a="a:from:mid:to">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd get="inline" set="null" line="128" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper get="inline" set="null" line="137" static="1"><f a="a:from:to:val">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower get="inline" set="null" line="152" static="1"><f a="a:from:to:val">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap get="inline" set="null" line="166" static="1"><f a="a:i:j">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<compare get="inline" set="null" line="172" static="1"><f a="a:i:j">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></compare>
		<haxe_doc>SortPoints provides a stable implementation of merge sort through its `sort`
     method. It should be used instead of `Array.sort` in cases where the order
     of equal elements has to be retained on all targets.
     
     This specific implementation has been modified to be exclusively used with array of `poly2tri.Point` instances.
     The compare function (and the rest of the implementation) are inlined to get the best performance out of it.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.Sweep" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Sweep.hx">
		<nextFlipPoint public="1" set="method" line="602" static="1"><f a="ep:eq:ot:op">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
</f></nextFlipPoint>
		<context><c path="poly2tri.SweepContext"/></context>
		<triangulate public="1" set="method" line="13"><f a=""><x path="Void"/></f></triangulate>
		<sweepPoints public="1" get="inline" set="null" line="21"><f a=""><x path="Void"/></f></sweepPoints>
		<finalizationPolygon public="1" get="inline" set="null" line="36"><f a=""><x path="Void"/></f></finalizationPolygon>
		<pointEvent public="1" get="inline" set="null" line="52">
			<f a="point">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Node"/>
			</f>
			<haxe_doc>* Find closes node to the left of the new point and
     * create a new triangle. If needed new holes and basins
     * will be filled to.</haxe_doc>
		</pointEvent>
		<edgeEventByEdge public="1" get="inline" set="null" line="67"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></edgeEventByEdge>
		<edgeEventByPoints public="1" get="inline" set="null" line="82"><f a="ep:eq:triangle:point">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Point"/>
	<x path="Void"/>
</f></edgeEventByPoints>
		<newFrontTriangle public="1" get="inline" set="null" line="114"><f a="point:node">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Node"/>
	<c path="poly2tri.Node"/>
</f></newFrontTriangle>
		<fill public="1" get="inline" set="null" line="140">
			<f a="node">
				<c path="poly2tri.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a triangle to the advancing front to fill a hole.
     * @param tcx
     * @param node - middle node, that is the bottom of the hole</haxe_doc>
		</fill>
		<fillAdvancingFront public="1" get="inline" set="null" line="165">
			<f a="n">
				<c path="poly2tri.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fills holes in the Advancing Front</haxe_doc>
		</fillAdvancingFront>
		<legalize public="1" set="method" line="202">
			<f a="t">
				<c path="poly2tri.Triangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if triangle was legalized</haxe_doc>
		</legalize>
		<fillBasin public="1" get="inline" set="null" line="272">
			<f a="node">
				<c path="poly2tri.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Fills a basin that has formed on the Advancing Front to the right
     * of given node.<br>
     * First we decide a left,bottom and right node that forms the
     * boundaries of the basin. Then we do a reqursive fill.
     *
     * @param tcx
     * @param node - starting node, this or next node will be left node]]></haxe_doc>
		</fillBasin>
		<fillBasinReq public="1" set="method" line="312">
			<f a="node">
				<c path="poly2tri.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Recursive algorithm to fill a Basin with triangles
     *
     * @param tcx
     * @param node - bottom_node</haxe_doc>
		</fillBasinReq>
		<isShallow public="1" get="inline" set="null" line="349"><f a="node">
	<c path="poly2tri.Node"/>
	<x path="Bool"/>
</f></isShallow>
		<fillEdgeEvent public="1" get="inline" set="null" line="360"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillEdgeEvent>
		<fillRightAboveEdgeEvent public="1" set="method" line="372"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillRightAboveEdgeEvent>
		<fillRightBelowEdgeEvent public="1" set="method" line="388"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillRightBelowEdgeEvent>
		<fillRightConcaveEdgeEvent public="1" set="method" line="403"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillRightConcaveEdgeEvent>
		<fillRightConvexEdgeEvent public="1" set="method" line="425"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillRightConvexEdgeEvent>
		<fillLeftAboveEdgeEvent public="1" set="method" line="449"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillLeftAboveEdgeEvent>
		<fillLeftBelowEdgeEvent public="1" set="method" line="465"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillLeftBelowEdgeEvent>
		<fillLeftConvexEdgeEvent public="1" set="method" line="484"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillLeftConvexEdgeEvent>
		<fillLeftConcaveEdgeEvent public="1" set="method" line="508"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillLeftConcaveEdgeEvent>
		<flipEdgeEvent public="1" set="method" line="532"><f a="ep:eq:t:p">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Point"/>
	<x path="Void"/>
</f></flipEdgeEvent>
		<nextFlipTriangle public="1" set="method" line="580"><f a="o:t:ot:p:op">
	<x path="Int"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
</f></nextFlipTriangle>
		<flipScanEdgeEvent public="1" set="method" line="621"><f a="ep:eq:flip_triangle:t:p">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Point"/>
	<x path="Void"/>
</f></flipScanEdgeEvent>
		<new public="1" set="method" line="8"><f a="context">
	<c path="poly2tri.SweepContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.SweepContext" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/SweepContext.hx">
		<_tmpArray expr="[]" line="150" static="1">
			<c path="Array"><c path="poly2tri.Triangle"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_tmpArray>
		<triangles public="1"><c path="Array"><c path="poly2tri.Triangle"/></c></triangles>
		<points public="1"><c path="Array"><c path="poly2tri.Point"/></c></points>
		<edge_list public="1"><c path="Array"><c path="poly2tri.Edge"/></c></edge_list>
		<front public="1"><c path="poly2tri.AdvancingFront"/></front>
		<head public="1"><c path="poly2tri.Point"/></head>
		<tail public="1"><c path="poly2tri.Point"/></tail>
		<basin public="1"><c path="poly2tri.Basin"/></basin>
		<edge_event public="1"><c path="poly2tri.EdgeEvent"/></edge_event>
		<reset public="1" set="method" line="29"><f a=""><x path="Void"/></f></reset>
		<addPoints get="inline" set="null" line="44"><f a="points">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Void"/>
</f></addPoints>
		<addPolyline public="1" get="inline" set="null" line="54"><f a="polyline">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Void"/>
</f></addPolyline>
		<initEdges get="inline" set="null" line="63"><f a="polyline">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Void"/>
</f></initEdges>
		<initTriangulation public="1" get="inline" set="null" line="76"><f a=""><x path="Void"/></f></initTriangulation>
		<locateNode public="1" get="inline" set="null" line="106"><f a="point">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Node"/>
</f></locateNode>
		<createAdvancingFront public="1" get="inline" set="null" line="111"><f a=""><x path="Void"/></f></createAdvancingFront>
		<removeNode public="1" get="inline" set="null" line="134"><f a="node">
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></removeNode>
		<mapTriangleToNodes public="1" get="inline" set="null" line="139"><f a="triangle">
	<c path="poly2tri.Triangle"/>
	<x path="Void"/>
</f></mapTriangleToNodes>
		<meshClean public="1" set="method" line="153"><f a="t">
	<c path="poly2tri.Triangle"/>
	<x path="Void"/>
</f></meshClean>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.Triangle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Triangle.hx">
		<CW_OFFSET get="inline" set="null" expr="1" line="186" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Return the point clockwise to the given point.
     * Return the point counter-clockwise to the given point.
     *
     * Return the neighbor clockwise to given point.
     * Return the neighbor counter-clockwise to given point.</haxe_doc>
		</CW_OFFSET>
		<CCW_OFFSET get="inline" set="null" expr="-1" line="187" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</CCW_OFFSET>
		<rotateTrianglePair public="1" get="inline" set="null" line="372" static="1">
			<f a="t:p:ot:op">
				<c path="poly2tri.Triangle"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Triangle"/>
				<c path="poly2tri.Point"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Rotates a triangle pair one vertex CW
     *<pre>
     *       n2                    n2
     *  P +-----+             P +-----+
     *    | t  /|               |\  t |
     *    |   / |               | \   |
     *  n1|  /  |n3           n1|  \  |n3
     *    | /   |    after CW   |   \ |
     *    |/ oT |               | oT \|
     *    +-----+ oP            +-----+
     *       n4                    n4
     * </pre>]]></haxe_doc>
		</rotateTrianglePair>
		<points public="1"><c path="Array"><c path="poly2tri.Point"/></c></points>
		<neighbors public="1"><c path="Array"><c path="poly2tri.Triangle"/></c></neighbors>
		<interior public="1"><x path="Bool"/></interior>
		<constrained_edge public="1"><c path="Array"><x path="Bool"/></c></constrained_edge>
		<delaunay_edge public="1"><c path="Array"><x path="Bool"/></c></delaunay_edge>
		<reset public="1" get="inline" set="null" line="26">
			<f a="p1:p2:p3:?fixOrientation:?checkOrientation" v=":::false:true">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkOrientation : true, fixOrientation : false }</e></m></meta>
		</reset>
		<containsPoint public="1" get="inline" set="null" line="84">
			<f a="point">
				<c path="poly2tri.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Test if this Triangle contains the Point object given as parameter as its vertices.
     *
     * @return <code>True</code> if the Point objects are of the Triangle's vertices,
     *         <code>false</code> otherwise.]]></haxe_doc>
		</containsPoint>
		<containsEdgePoints public="1" get="inline" set="null" line="89"><f a="p1:p2">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></containsEdgePoints>
		<markNeighbor public="1" get="inline" set="null" line="104">
			<f a="t:p1:p2">
				<c path="poly2tri.Triangle"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Update neighbor pointers.<br>
     * This method takes either 3 parameters (<code>p1</code>, <code>p2</code> and
     * <code>t</code>) or 1 parameter (<code>t</code>).
     * @param   t   Triangle object.
     * @param   p1  Point object.
     * @param   p2  Point object.]]></haxe_doc>
		</markNeighbor>
		<markNeighborTriangle public="1" get="inline" set="null" line="124"><f a="that">
	<c path="poly2tri.Triangle"/>
	<x path="Void"/>
</f></markNeighborTriangle>
		<getPointIndexOffset public="1" get="inline" set="null" line="147">
			<f a="p:?offset" v=":0">
				<c path="poly2tri.Point"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</getPointIndexOffset>
		<pointCW public="1" get="inline" set="null" line="190"><f a="p">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
</f></pointCW>
		<pointCCW public="1" get="inline" set="null" line="195"><f a="p">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
</f></pointCCW>
		<neighborCW public="1" get="inline" set="null" line="200"><f a="p">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
</f></neighborCW>
		<neighborCCW public="1" get="inline" set="null" line="205"><f a="p">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
</f></neighborCCW>
		<getConstrainedEdgeCW public="1" get="inline" set="null" line="209"><f a="p">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></getConstrainedEdgeCW>
		<setConstrainedEdgeCW public="1" get="inline" set="null" line="210"><f a="p:ce">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setConstrainedEdgeCW>
		<getConstrainedEdgeCCW public="1" get="inline" set="null" line="212"><f a="p">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></getConstrainedEdgeCCW>
		<setConstrainedEdgeCCW public="1" get="inline" set="null" line="213"><f a="p:ce">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setConstrainedEdgeCCW>
		<getDelaunayEdgeCW public="1" get="inline" set="null" line="215"><f a="p">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></getDelaunayEdgeCW>
		<setDelaunayEdgeCW public="1" get="inline" set="null" line="216"><f a="p:e">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setDelaunayEdgeCW>
		<getDelaunayEdgeCCW public="1" get="inline" set="null" line="218"><f a="p">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></getDelaunayEdgeCCW>
		<setDelaunayEdgeCCW public="1" get="inline" set="null" line="219"><f a="p:e">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setDelaunayEdgeCCW>
		<neighborAcross public="1" get="inline" set="null" line="225">
			<f a="p">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Triangle"/>
			</f>
			<haxe_doc>* The neighbor across to given point.</haxe_doc>
		</neighborAcross>
		<oppositePoint public="1" get="inline" set="null" line="228"><f a="t:p">
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
</f></oppositePoint>
		<legalize public="1" set="method" line="239">
			<f a="opoint:?npoint" v=":null">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ npoint : null }</e></m></meta>
			<haxe_doc><![CDATA[* Legalize triangle by rotating clockwise.<br>
     * This method takes either 1 parameter (then the triangle is rotated around
     * points(0)) or 2 parameters (then the triangle is rotated around the first
     * parameter).]]></haxe_doc>
		</legalize>
		<index public="1" get="inline" set="null" line="270">
			<f a="p">
				<c path="poly2tri.Point"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Alias for getPointIndexOffset
     *
     * @param	p</haxe_doc>
		</index>
		<edgeIndex public="1" get="inline" set="null" line="282"><f a="p1:p2">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Int"/>
</f></edgeIndex>
		<markConstrainedEdgeByIndex public="1" get="inline" set="null" line="309">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Mark an edge of this triangle as constrained.<br>
     * This method takes either 1 parameter (an edge index or an Edge instance) or
     * 2 parameters (two Point instances defining the edge of the triangle).]]></haxe_doc>
		</markConstrainedEdgeByIndex>
		<markConstrainedEdgeByEdge public="1" get="inline" set="null" line="314"><f a="edge">
	<c path="poly2tri.Edge"/>
	<x path="Void"/>
</f></markConstrainedEdgeByEdge>
		<markConstrainedEdgeByPoints public="1" get="inline" set="null" line="319"><f a="p:q">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Void"/>
</f></markConstrainedEdgeByPoints>
		<isEdgeSide public="1" get="inline" set="null" line="342">
			<f a="ep:eq">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if a side from this triangle is an edge side.
     * If sides are not marked they will be marked.
     *
     * @param	ep
     * @param	eq
     * @return</haxe_doc>
		</isEdgeSide>
		<clearNeigbors public="1" get="inline" set="null" line="418"><f a=""><x path="Void"/></f></clearNeigbors>
		<clearDelunayEdges public="1" get="inline" set="null" line="425"><f a=""><x path="Void"/></f></clearDelunayEdges>
		<toString public="1" set="method" line="433"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="22">
			<f a="p1:p2:p3:?fixOrientation:?checkOrientation" v=":::false:true">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkOrientation : true, fixOrientation : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="poly2tri.Utils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Utils.hx">
		<insideIncircle public="1" get="inline" set="null" line="30" static="1">
			<f a="pa:pb:pc:pd">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* <b>Requirement</b>:<br>
     * 1. a, b and c form a triangle.<br>
     * 2. a and d is know to be on opposite side of bc<br>
     * <pre>
     *                a
     *                +
     *               / \
     *              /   \
     *            b/     \c
     *            +-------+
     *           /    d    \
     *          /           \
     * </pre>
     * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
     *  a,b and c<br>
     *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
     *  This preknowledge gives us a way to optimize the incircle test
     * @param pa - triangle point, opposite d
     * @param pb - triangle point
     * @param pc - triangle point
     * @param pd - point opposite a
     * @return true if d is inside circle, false if on circle edge]]></haxe_doc>
		</insideIncircle>
		<inScanArea public="1" get="inline" set="null" line="69" static="1"><f a="pa:pb:pc:pd">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></inScanArea>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="polyline.Extensions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/polyline/polyline/Extensions.hx">
		<unsafeGet public="1" params="T" get="inline" set="null" line="7" static="1"><f a="array:index">
	<c path="Array"><c path="unsafeGet.T"/></c>
	<x path="Int"/>
	<c path="unsafeGet.T"/>
</f></unsafeGet>
		<unsafeSet public="1" params="T" get="inline" set="null" line="24" static="1"><f a="array:index:value">
	<c path="Array"><c path="unsafeSet.T"/></c>
	<x path="Int"/>
	<c path="unsafeSet.T"/>
	<x path="Void"/>
</f></unsafeSet>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="polyline.StrokeCap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/polyline/polyline/StrokeCap.hx">
		<BUTT/>
		<SQUARE/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="polyline.StrokeJoin" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/polyline/polyline/StrokeJoin.hx">
		<MITER/>
		<BEVEL/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="sys.FileStat" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
	<class path="sys.FileSystem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/sys/FileSystem.hx">
		<exists public="1" set="method" line="14" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` exists.</haxe_doc>
		</exists>
		<stat public="1" get="inline" set="null" line="25" static="1">
			<f a="path">
				<c path="String"/>
				<t path="sys.FileStat"/>
			</f>
			<haxe_doc>Returns `FileStat` information for the file or directory specified by
		`path`.</haxe_doc>
		</stat>
		<isDirectory public="1" set="method" line="39" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` is a directory.

		If `path` is not a valid file system entry or if its destination is not
		accessible, an exception is thrown.</haxe_doc>
		</isDirectory>
		<createDirectory public="1" set="method" line="43" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a directory specified by `path`.

		This method is recursive: The parent directories don't have to exist.

		If the directory cannot be created, an exception is thrown.</haxe_doc>
		</createDirectory>
		<deleteFile public="1" get="inline" set="null" line="61" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the file specified by `path`.

		If `path` does not denote a valid file, or if that file cannot be
		deleted, an exception is thrown.</haxe_doc>
		</deleteFile>
		<deleteDirectory public="1" get="inline" set="null" line="65" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the directory specified by `path`. Only empty directories can
		be deleted.

		If `path` does not denote a valid directory, or if that directory cannot
		be deleted, an exception is thrown.</haxe_doc>
		</deleteDirectory>
		<readDirectory public="1" get="inline" set="null" line="79" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the names of all files and directories in the directory specified
		by `path`. `"."` and `".."` are not included in the output.

		If `path` does not denote a valid directory, an exception is thrown.</haxe_doc>
		</readDirectory>
		<haxe_doc>This class provides information about files and directories.

	If `null` is passed as a file path to any function in this class, the
	result is unspecified, and may differ from target to target.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dce"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.File" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/sys/io/File.hx">
		<getContent public="1" get="inline" set="null" line="20" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getContent>
		<saveContent public="1" get="inline" set="null" line="24" static="1"><f a="path:content">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></saveContent>
		<getBytes public="1" get="inline" set="null" line="28" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<saveBytes public="1" get="inline" set="null" line="32" static="1"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></saveBytes>
		<copyBuf expr="js.node.Buffer.alloc(copyBufLen)" line="41" static="1">
			<c path="js.node.buffer.Buffer"/>
			<meta><m n=":value"><e>js.node.Buffer.alloc(copyBufLen)</e></m></meta>
		</copyBuf>
		<copy public="1" set="method" line="43" static="1"><f a="srcPath:dstPath">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></copy>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dce"/>
		</meta>
	</class>
	<class path="sys.io.FileInput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/sys/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<fd><x path="Int"/></fd>
		<pos><x path="Int"/></pos>
		<hasReachedEof expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasReachedEof>
		<throwEof get="inline" set="null" line="16"><f a=""><x path="Void"/></f></throwEof>
		<readByte public="1" set="method" line="27" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="42" override="1"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="57"><f a=""><x path="Void"/></f></close>
		<seek public="1" set="method" line="61"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method" line="73"><f a=""><x path="Int"/></f></tell>
		<eof public="1" set="method" line="77"><f a=""><x path="Bool"/></f></eof>
		<new set="method" line="22">
			<f a="fd">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>sys.io.File</e></m></meta>
		</new>
		<haxe_doc>Use `sys.io.File.read` to create a `FileInput`.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hxnodejs/src/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<fd><x path="Int"/></fd>
		<pos><x path="Int"/></pos>
		<writeByte public="1" set="method" line="20"><f a="b">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="27"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<close public="1" set="method" line="34"><f a=""><x path="Void"/></f></close>
		<seek public="1" set="method" line="38"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method" line="49"><f a=""><x path="Int"/></f></tell>
		<new set="method" line="15">
			<f a="fd">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>sys.io.File</e></m></meta>
		</new>
		<haxe_doc>Use `sys.io.File.write` to create a `FileOutput`.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<enum path="sys.io.FileSeek" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/sys/io/FileSeek.hx">
		<SeekBegin/>
		<SeekCur/>
		<SeekEnd/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="sys.io.Process" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/sys/io/Process.hx" extern="1">
		<stdout public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>Standard output. The output stream where a process writes its output data.</haxe_doc>
		</stdout>
		<stderr public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>Standard error. The output stream to output error messages or diagnostics.</haxe_doc>
		</stderr>
		<stdin public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>Standard input. The stream data going into a process.</haxe_doc>
		</stdin>
		<getPid public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Return the process ID.</haxe_doc>
		</getPid>
		<exitCode public="1" set="method">
			<f a="?block" v="true">
				<x path="Bool"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":value"><e>{ block : true }</e></m></meta>
			<haxe_doc>Query the exit code of the process.
		If `block` is true or not specified, it will block until the process terminates.
		If `block` is false, it will return either the process exit code if it's already terminated or null if it's still running.
		If the process has already exited, return the exit code immediately.</haxe_doc>
		</exitCode>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the process handle and release the associated resources.
		All `Process` fields should not be used after `close()` is called.</haxe_doc>
		</close>
		<kill public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Kill the process.</haxe_doc>
		</kill>
		<new public="1" set="method">
			<f a="cmd:?args:?detached">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Construct a `Process` object, which run the given command immediately.

		Command arguments can be passed in two ways: 1. using `args`, 2. appending to `cmd` and leaving `args` as `null`.

		 1. When using `args` to pass command arguments, each argument will be automatically quoted, and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		`detached` allows the created process to be standalone. You cannot communicate with it but you can look at its exit code. Not supported on php.

		`close()` should be called when the `Process` is no longer used.</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="tracker.Assert" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Assert.hx"><assert public="1" set="method" static="1">
	<f a="expr:?reason">
		<d/>
		<c path="String"/>
		<d/>
	</f>
	<haxe_doc>Assert the expression evaluates to `true`.
        This check is only done in `debug` builds and doesn't affect `release` builds.</haxe_doc>
</assert></class>
	<class path="tracker.Autorun" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Autorun.hx">
		<extends path="ceramic.Entity"/>
		<prevCurrent expr="[]" line="11" static="1">
			<c path="Array"><c path="tracker.Autorun"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</prevCurrent>
		<current public="1" expr="null" line="13" static="1">
			<c path="tracker.Autorun"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</current>
		<unobserve public="1" get="inline" set="null" line="117" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Ensures current `autorun` won't be affected by the code after this call.
        `reobserve()` should be called to restore previous state.</haxe_doc>
		</unobserve>
		<reobserve public="1" get="inline" set="null" line="127" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Resume observing values and resume affecting current `autorun` scope.
        This should be called after an `unobserve()` call.</haxe_doc>
		</reobserve>
		<unobserved public="1" set="method" line="138" static="1">
			<f a="func">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>Executes the given function synchronously and ensures the
        current `autorun` scope won't be affected</haxe_doc>
		</unobserved>
		<_autorunArrays expr="[]" line="233" static="1">
			<c path="Array"><c path="Array"><c path="tracker.Autorun"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_autorunArrays>
		<_autorunArraysLen expr="0" line="234" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_autorunArraysLen>
		<getAutorunArray public="1" set="method" line="236" static="1"><f a=""><c path="Array"><c path="tracker.Autorun"/></c></f></getAutorunArray>
		<recycleAutorunArray public="1" set="method" line="250" static="1"><f a="array">
	<c path="Array"><c path="tracker.Autorun"/></c>
	<x path="Void"/>
</f></recycleAutorunArray>
		<_arrayOfAutorunArrays expr="[]" line="265" static="1">
			<c path="Array"><c path="Array"><c path="Array"><c path="tracker.Autorun"/></c></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_arrayOfAutorunArrays>
		<_arrayOfAutorunArraysLen expr="0" line="266" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_arrayOfAutorunArraysLen>
		<getArrayOfAutorunArrays public="1" get="inline" set="null" line="268" static="1"><f a=""><c path="Array"><c path="Array"><c path="tracker.Autorun"/></c></c></f></getArrayOfAutorunArrays>
		<recycleArrayOfAutorunArrays public="1" get="inline" set="null" line="282" static="1"><f a="array">
	<c path="Array"><c path="Array"><c path="tracker.Autorun"/></c></c>
	<x path="Void"/>
</f></recycleArrayOfAutorunArrays>
		<_dox_event_reset public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_reset>
		<emitReset set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>reset event</haxe_doc>
		</emitReset>
		<onReset public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>reset event</haxe_doc>
		</onReset>
		<onceReset public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>reset event</haxe_doc>
		</onceReset>
		<offReset public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>reset event</haxe_doc>
		</offReset>
		<listensReset public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to reset event</haxe_doc>
		</listensReset>
		<onRun public="1" expr="null">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
		</onRun>
		<afterRun public="1" expr="null">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
		</afterRun>
		<boundAutorunArrays expr="null">
			<c path="Array"><c path="Array"><c path="tracker.Autorun"/></c></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</boundAutorunArrays>
		<invalidated public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</invalidated>
		<destroy public="1" set="method" line="52" override="1"><f a=""><x path="Void"/></f></destroy>
		<willEmitReset get="inline" set="null" line="66"><f a=""><x path="Void"/></f></willEmitReset>
		<run public="1" set="method" line="72"><f a=""><x path="Void"/></f></run>
		<invalidate public="1" get="inline" set="null" line="102"><f a=""><x path="Void"/></f></invalidate>
		<bindToAutorunArray public="1" set="method" line="148"><f a="autorunArray">
	<c path="Array"><c path="tracker.Autorun"/></c>
	<x path="Void"/>
</f></bindToAutorunArray>
		<unbindFromAllAutorunArrays public="1" set="method" line="205"><f a=""><x path="Void"/></f></unbindFromAllAutorunArrays>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="38">
			<f a="onRun:?afterRun">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialize a new autorun.
     * @param onRun The callback that will be executed and used to compute implicit bindings
     * @param afterRun
     *     (optional) A callback run right after `onRun`, not affecting implicit bindings.
     *     Useful when generating side effects without messing up binding dependencies.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="tracker.DynamicEvents" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/DynamicEvents.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<dispatcher><c path="tracker.EventDispatcher"/></dispatcher>
		<mapping><t path="Map">
	<c path="String"/>
	<x path="Int"/>
</t></mapping>
		<nextIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextIndex>
		<bindAsComponent set="method" line="26"><f a=""><x path="Void"/></f></bindAsComponent>
		<eventToString set="method" line="32"><f a="event">
	<c path="tracker.DynamicEvents.T"/>
	<c path="String"/>
</f></eventToString>
		<indexForEvent set="method" line="39"><f a="event">
	<c path="tracker.DynamicEvents.T"/>
	<x path="Int"/>
</f></indexForEvent>
		<emit public="1" set="method" line="55"><f a="event:?args">
	<c path="tracker.DynamicEvents.T"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></emit>
		<on public="1" set="method" line="77"><f a="event:owner:cb">
	<c path="tracker.DynamicEvents.T"/>
	<x path="Null"><c path="ceramic.Entity"/></x>
	<d/>
	<x path="Void"/>
</f></on>
		<once public="1" set="method" line="84"><f a="event:owner:cb">
	<c path="tracker.DynamicEvents.T"/>
	<x path="Null"><c path="ceramic.Entity"/></x>
	<d/>
	<x path="Void"/>
</f></once>
		<off public="1" set="method" line="91"><f a="event:?cb">
	<c path="tracker.DynamicEvents.T"/>
	<d/>
	<x path="Void"/>
</f></off>
		<listens public="1" set="method" line="98"><f a="event">
	<c path="tracker.DynamicEvents.T"/>
	<x path="Bool"/>
</f></listens>
		<entity public="1">
			<c path="ceramic.Entity"/>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</entity>
		<setEntity set="method" line="9">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="9">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Fire and listen to dynamic events. Works similarly to static events, but dynamic.
    If you can know the event names at compile time, using static events (`@event function myEvent();`) is preferred.</haxe_doc>
		<meta>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="tracker.EventDispatcher" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/EventDispatcher.hx">
		<items expr="[]">
			<c path="Array"><c path="tracker._EventDispatcher.EventDispatcherItem"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</items>
		<setWillEmit public="1" set="method" line="20"><f a="index:cb">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></setWillEmit>
		<setDidEmit public="1" set="method" line="32"><f a="index:cb">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></setDidEmit>
		<setWillListen public="1" set="method" line="44"><f a="index:cb">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></setWillListen>
		<wrapEmit public="1" set="method" line="58"><f a="index:numArgs">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></wrapEmit>
		<emit public="1" set="method" line="101"><f a="index:numArgs:?arg1:?arg2:?arg3">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></emit>
		<wrapOn public="1" set="method" line="211"><f a="index">
	<x path="Int"/>
	<d/>
</f></wrapOn>
		<on public="1" set="method" line="239"><f a="index:owner:cb">
	<x path="Int"/>
	<x path="Null"><c path="ceramic.Entity"/></x>
	<d/>
	<x path="Void"/>
</f></on>
		<wrapOnce public="1" set="method" line="296"><f a="index">
	<x path="Int"/>
	<d/>
</f></wrapOnce>
		<once public="1" set="method" line="324"><f a="index:owner:cb">
	<x path="Int"/>
	<x path="Null"><c path="ceramic.Entity"/></x>
	<d/>
	<x path="Void"/>
</f></once>
		<wrapOff public="1" set="method" line="381"><f a="index">
	<x path="Int"/>
	<d/>
</f></wrapOff>
		<off public="1" set="method" line="401"><f a="index:cb">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></off>
		<wrapListens public="1" set="method" line="450"><f a="index">
	<x path="Int"/>
	<d/>
</f></wrapListens>
		<listens public="1" set="method" line="470"><f a="index">
	<x path="Int"/>
	<x path="Bool"/>
</f></listens>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Event dispatcher used by DynamicEvents and Events macro as an alternative implementation
    that doesn't require to add a lot of methods on classes with events.
    This is basically the same code as what is statically generated by Events macro,
    but made dynamic and usable for any type.
    This is not really supposed to be used as is as it is pretty low-level.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="tracker._EventDispatcher.EventDispatcherItem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/EventDispatcher.hx" private="1" module="tracker.EventDispatcher">
		<willEmit expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</willEmit>
		<didEmit expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</didEmit>
		<willListen expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</willListen>
		<wrappedEmit expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</wrappedEmit>
		<wrappedEmitNumArgs expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</wrappedEmitNumArgs>
		<wrappedOn expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</wrappedOn>
		<wrappedOnce expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</wrappedOnce>
		<wrappedOff expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</wrappedOff>
		<wrappedListens expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</wrappedListens>
		<cbOnArray expr="[]">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</cbOnArray>
		<cbOnceArray expr="[]">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</cbOnceArray>
		<cbOnOwnerUnbindArray expr="[]">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</cbOnOwnerUnbindArray>
		<cbOnceOwnerUnbindArray expr="[]">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</cbOnceOwnerUnbindArray>
		<new public="1" set="method" line="511"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>tracker.EventDispatcher</e></m>
		</meta>
	</class>
	<class path="tracker.Extensions" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Extensions.hx">
		<unsafeGet public="1" params="T" get="inline" set="null" line="8" static="1"><f a="array:index">
	<c path="Array"><c path="unsafeGet.T"/></c>
	<x path="Int"/>
	<c path="unsafeGet.T"/>
</f></unsafeGet>
		<unsafeSet public="1" params="T" get="inline" set="null" line="25" static="1"><f a="array:index:value">
	<c path="Array"><c path="unsafeSet.T"/></c>
	<x path="Int"/>
	<c path="unsafeSet.T"/>
	<x path="Void"/>
</f></unsafeSet>
		<setArrayLength public="1" params="T" get="inline" set="null" line="42" static="1"><f a="array:length">
	<c path="Array"><c path="setArrayLength.T"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setArrayLength>
		<setProperty public="1" params="T" get="inline" set="null" line="62" static="1">
			<f a="instance:field:value">
				<c path="setProperty.T"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setProperty>
		<getProperty public="1" params="T" get="inline" set="null" line="69" static="1">
			<f a="instance:field">
				<c path="getProperty.T"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</getProperty>
		<haxe_doc>A bunch of static extensions to make life easier.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="tracker.History" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/History.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<_dox_event__undo public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__undo>
		<emitUndo set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>undo event</haxe_doc>
		</emitUndo>
		<onUndo public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>undo event</haxe_doc>
		</onUndo>
		<onceUndo public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>undo event</haxe_doc>
		</onceUndo>
		<offUndo public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>undo event</haxe_doc>
		</offUndo>
		<listensUndo public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to undo event</haxe_doc>
		</listensUndo>
		<_dox_event__redo public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__redo>
		<emitRedo set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>redo event</haxe_doc>
		</emitRedo>
		<onRedo public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>redo event</haxe_doc>
		</onRedo>
		<onceRedo public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>redo event</haxe_doc>
		</onceRedo>
		<offRedo public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>redo event</haxe_doc>
		</offRedo>
		<listensRedo public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to redo event</haxe_doc>
		</listensRedo>
		<entity public="1">
			<c path="tracker.Model"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<stepPending><x path="Bool"/></stepPending>
		<currentData expr="null">
			<c path="StringBuf"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</currentData>
		<steps expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</steps>
		<currentStep expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</currentStep>
		<scheduledStep expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</scheduledStep>
		<ignoreSteps expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ignoreSteps>
		<canScheduleImmediateStep expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</canScheduleImmediateStep>
		<clearDelayAllowImmediateStep expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</clearDelayAllowImmediateStep>
		<maxSteps public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* If provided, number of available steps will be limited to this value,
     * meaning older steps will be removed and not recoverable if reaching the limit.
     * Default is: store as many steps as possible, no limit (except available memory?)</haxe_doc>
		</maxSteps>
		<clearPreviousStepsOutsideLimit public="1" set="method" line="46">
			<f a="maxSteps">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Manually clear previous steps outside the given limit
     * @param maxSteps</haxe_doc>
		</clearPreviousStepsOutsideLimit>
		<bindAsComponent public="1" set="method" line="57"><f a=""><x path="Void"/></f></bindAsComponent>
		<bindSerializer set="method" line="80"><f a="serializer">
	<c path="tracker.SerializeModel"/>
	<x path="Void"/>
</f></bindSerializer>
		<recordStepIfNeeded set="method" line="105"><f a=""><x path="Void"/></f></recordStepIfNeeded>
		<step public="1" set="method" line="144">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Record a step in the undo stack</haxe_doc>
		</step>
		<disable public="1" set="method" line="158"><f a=""><x path="Void"/></f></disable>
		<enable public="1" set="method" line="164"><f a=""><x path="Void"/></f></enable>
		<undo public="1" set="method" line="173">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Undo last step, if any</haxe_doc>
		</undo>
		<redo public="1" set="method" line="192">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Redo last undone step, if any</haxe_doc>
		</redo>
		<applyCurrentStep set="method" line="208"><f a=""><x path="Void"/></f></applyCurrentStep>
		<setEntity set="method" line="5">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="5">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="tracker.Serializable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Serializable.hx" interface="1">
		<_serializeId public="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</_serializeId>
		<willSerialize set="method"><f a=""><x path="Void"/></f></willSerialize>
		<didDeserialize set="method"><f a=""><x path="Void"/></f></didDeserialize>
		<serializeShouldDestroy set="method"><f a=""><x path="Bool"/></f></serializeShouldDestroy>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":autoBuild"><e>tracker.macros.SerializableMacro.build()</e></m>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<class path="tracker.Model" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Model.hx">
		<extends path="ceramic.Entity"/>
		<implements path="tracker.Serializable"/>
		<implements path="tracker.Observable"/>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="tracker.Model"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="tracker.Model"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="tracker.Model"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="tracker.Model"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="tracker.Model"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<_dox_event__modelDirty public="1" set="method" line="637">
			<f a="model">
				<c path="tracker.Model"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__modelDirty>
		<emitModelDirty set="method" line="1095">
			<f a="model">
				<c path="tracker.Model"/>
				<x path="Void"/>
			</f>
			<haxe_doc>modelDirty event</haxe_doc>
		</emitModelDirty>
		<onModelDirty public="1" set="method" line="1199">
			<f a="owner:handleModel">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="model">
					<c path="tracker.Model"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>modelDirty event</haxe_doc>
		</onModelDirty>
		<onceModelDirty public="1" set="method" line="1298">
			<f a="owner:handleModel">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="model">
					<c path="tracker.Model"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>modelDirty event</haxe_doc>
		</onceModelDirty>
		<offModelDirty public="1" set="method" line="1368">
			<f a="?handleModel">
				<f a="model">
					<c path="tracker.Model"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>modelDirty event</haxe_doc>
		</offModelDirty>
		<listensModelDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to modelDirty event</haxe_doc>
		</listensModelDirty>
		<serializer public="1">
			<c path="tracker.SerializeModel"/>
			<meta><m n="component"/></meta>
		</serializer>
		<dirty public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</dirty>
		<set_dirty get="inline" set="null" line="21"><f a="dirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_dirty>
		<willSerialize set="method" line="39">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called right before the object will be serialized.</haxe_doc>
		</willSerialize>
		<didDeserialize set="method" line="45">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called right after the object has been deserialized. Could be useful to override it to check data integrity
        when running a newer model version etc...</haxe_doc>
		</didDeserialize>
		<serializeShouldDestroy set="method" line="53">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Called right before the object is destroyed because it is not used anymore.
     * @return `true` (default) if the destroy should happen or not</haxe_doc>
		</serializeShouldDestroy>
		<hxSerialize set="method" line="62">
			<f a="s">
				<c path="haxe.Serializer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</hxSerialize>
		<hxUnserialize set="method" line="67">
			<f a="u">
				<c path="haxe.Unserializer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</hxUnserialize>
		<_default_dirty set="method" line="19">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc></haxe_doc>
		</_default_dirty>
		<_serializeId public="1" expr="tracker.Utils.uniqueId()">
			<c path="String"/>
			<meta>
				<m n=":value"><e>tracker.Utils.uniqueId()</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc></haxe_doc>
		</_serializeId>
		<_dox_event_serialize public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when this object gets serialized.</haxe_doc>
		</_dox_event_serialize>
		<emitSerialize set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Event when this object gets serialized.</haxe_doc>
		</emitSerialize>
		<onSerialize public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets serialized.</haxe_doc>
		</onSerialize>
		<onceSerialize public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets serialized.</haxe_doc>
		</onceSerialize>
		<offSerialize public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets serialized.</haxe_doc>
		</offSerialize>
		<listensSerialize public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets serialized.</haxe_doc>
		</listensSerialize>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<_dox_event_deserialize public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when this object gets deserialized.</haxe_doc>
		</_dox_event_deserialize>
		<emitDeserialize set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Event when this object gets deserialized.</haxe_doc>
		</emitDeserialize>
		<onDeserialize public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets deserialized.</haxe_doc>
		</onDeserialize>
		<onceDeserialize public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets deserialized.</haxe_doc>
		</onceDeserialize>
		<offDeserialize public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets deserialized.</haxe_doc>
		</offDeserialize>
		<listensDeserialize public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets deserialized.</haxe_doc>
		</listensDeserialize>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>tracker.macros.SerializableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.SerializableMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<class path="tracker.SaveModel" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/SaveModel.hx">
		<BACKUP_NUM_STEPS expr="20000" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20000</e></m></meta>
		</BACKUP_NUM_STEPS>
		<NUM_BACKUPS expr="4" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</NUM_BACKUPS>
		<BACKUP_STEPS expr="null" line="12" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</BACKUP_STEPS>
		<busyKeys expr="[]" line="14" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</busyKeys>
		<getSavedOrCreate public="1" params="T" set="method" line="18" static="1"><f a="modelClass:key:?args">
	<x path="Class"><c path="getSavedOrCreate.T"/></x>
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="getSavedOrCreate.T"/>
</f></getSavedOrCreate>
		<isBusyKey public="1" set="method" line="30" static="1"><f a="key">
	<c path="String"/>
	<x path="Bool"/>
</f></isBusyKey>
		<loadFromKey public="1" set="method" line="37" static="1">
			<f a="model:key:?muteWarnings" v="::false">
				<c path="tracker.Model"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ muteWarnings : false }</e></m></meta>
			<haxe_doc>Load data from the given key.</haxe_doc>
		</loadFromKey>
		<autoSaveAsKey public="1" set="method" line="105" static="1">
			<f a="model:key:?appendInterval:?compactInterval" v="::1.0:60.0">
				<c path="tracker.Model"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ compactInterval : 60.0, appendInterval : 1.0 }</e></m></meta>
		</autoSaveAsKey>
		<_autoSaveAsKeyHandleChangeset set="method" line="159" static="1"><f a="changeset:key:saveDataKey1:saveDataKey2:saveIdKey1:saveIdKey2">
	<c path="tracker.SerializeChangeset"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyHandleChangeset>
		<_autoSaveAsKeyAppend set="method" line="189" static="1"><f a="data:key:saveDataKey1:saveDataKey2:saveIdKey1:saveIdKey2">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyAppend>
		<_autoSaveAsKeyAppendInBackground set="method" line="211" static="1"><f a="data:key:saveDataKey1:saveDataKey2:saveIdKey1:saveIdKey2">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyAppendInBackground>
		<_autoSaveAsKeyAppendBackInMain set="method" line="240" static="1"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyAppendBackInMain>
		<_autoSaveAsKeyCompact set="method" line="258" static="1"><f a="data:key:saveDataKey1:saveDataKey2:saveIdKey1:saveIdKey2">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyCompact>
		<_autoSaveAsKeyCompactRunInBackground set="method" line="282" static="1"><f a="data:key:saveDataKey1:saveDataKey2:saveIdKey1:saveIdKey2">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyCompactRunInBackground>
		<_autoSaveAsKeyCompactBackInMain set="method" line="338" static="1"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyCompactBackInMain>
		<encodeHashedString public="1" set="method" line="352" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode the given string `str` and return the result.</haxe_doc>
		</encodeHashedString>
		<decodeHashedString public="1" set="method" line="361" static="1">
			<f a="encoded">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode the given `encoded` string and return the result or null if it failed.</haxe_doc>
		</decodeHashedString>
	</class>
	<class path="tracker.Serialize" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Serialize.hx">
		<customHxSerialize public="1" expr="null" line="20" static="1">
			<f a="">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</customHxSerialize>
		<customHxDeserialize public="1" expr="null" line="22" static="1">
			<f a="">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</customHxDeserialize>
		<serialize public="1" set="method" line="24" static="1"><f a="serializable">
	<c path="tracker.Serializable"/>
	<c path="String"/>
</f></serialize>
		<deserialize public="1" set="method" line="41" static="1"><f a="?serializable:data">
	<c path="tracker.Serializable"/>
	<c path="String"/>
	<d/>
</f></deserialize>
		<_serializedMap expr="null" line="62" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<a>
					<type><c path="String"/></type>
					<props><d/></props>
					<id><c path="String"/></id>
				</a>
			</x>
			<meta><m n=":value"><e>null</e></m></meta>
		</_serializedMap>
		<_deserializedMap expr="null" line="64" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="tracker.Serializable"/>
			</x>
			<meta><m n=":value"><e>null</e></m></meta>
		</_deserializedMap>
		<_deserializedCacheMap expr="null" line="66" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="tracker.Serializable"/>
			</x>
			<meta><m n=":value"><e>null</e></m></meta>
		</_deserializedCacheMap>
		<_onAddSerializable expr="null" line="68" static="1">
			<f a="">
				<c path="tracker.Serializable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</_onAddSerializable>
		<_onCheckSerializable expr="null" line="70" static="1">
			<f a="">
				<c path="tracker.Serializable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</_onCheckSerializable>
		<_appendSerialize expr="false" line="72" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_appendSerialize>
		<_cachedEnumInfoBySerializableType expr="new Map()" line="74" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Bool"/>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</_cachedEnumInfoBySerializableType>
		<_enumInfo expr="new Map()" line="76" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="haxe.ds.Map">
					<c path="String"/>
					<c path="Array"><c path="String"/></c>
				</x>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</_enumInfo>
		<serializeValue set="method" line="78" static="1"><f a="value">
	<d/>
	<d/>
</f></serializeValue>
		<deserializeValue set="method" line="277" static="1"><f a="value:?serializable">
	<d/>
	<c path="tracker.Serializable"/>
	<d/>
</f></deserializeValue>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>tracker.SerializeModel</e></m>
			<m n=":allow"><e>tracker.SaveModel</e></m>
		</meta>
	</class>
	<class path="tracker.SerializeChangeset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/SerializeChangeset.hx">
		<data public="1"><c path="String"/></data>
		<append public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</append>
		<toString set="method" line="17"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="10">
			<f a="data:?append" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ append : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="tracker.SerializeModel" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/SerializeModel.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<loadFromData public="1" set="method" line="270" static="1">
			<f a="model:data:?hotReload" v="::false">
				<c path="tracker.Model"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ hotReload : false }</e></m></meta>
		</loadFromData>
		<_dox_event_changeset public="1" set="method" line="637">
			<f a="changeset">
				<c path="tracker.SerializeChangeset"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Triggered when serialized data is updated.
        If `append` is true, the given string should be appended to the existing one.</haxe_doc>
		</_dox_event_changeset>
		<emitChangeset set="method" line="1095">
			<f a="changeset">
				<c path="tracker.SerializeChangeset"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Triggered when serialized data is updated.
        If `append` is true, the given string should be appended to the existing one.</haxe_doc>
		</emitChangeset>
		<onChangeset public="1" set="method" line="1199">
			<f a="owner:handleChangeset">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="changeset">
					<c path="tracker.SerializeChangeset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Triggered when serialized data is updated.
        If `append` is true, the given string should be appended to the existing one.</haxe_doc>
		</onChangeset>
		<onceChangeset public="1" set="method" line="1298">
			<f a="owner:handleChangeset">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="changeset">
					<c path="tracker.SerializeChangeset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Triggered when serialized data is updated.
        If `append` is true, the given string should be appended to the existing one.</haxe_doc>
		</onceChangeset>
		<offChangeset public="1" set="method" line="1368">
			<f a="?handleChangeset">
				<f a="changeset">
					<c path="tracker.SerializeChangeset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Triggered when serialized data is updated.
        If `append` is true, the given string should be appended to the existing one.</haxe_doc>
		</offChangeset>
		<listensChangeset public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Triggered when serialized data is updated.
        If `append` is true, the given string should be appended to the existing one.</haxe_doc>
		</listensChangeset>
		<checkInterval public="1" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</checkInterval>
		<compactInterval public="1" expr="60.0">
			<x path="Float"/>
			<meta><m n=":value"><e>60.0</e></m></meta>
		</compactInterval>
		<destroyModelOnUntrack public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</destroyModelOnUntrack>
		<serializedMap public="1" set="null" expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<a>
					<type><c path="String"/></type>
					<props><d/></props>
					<id><c path="String"/></id>
				</a>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</serializedMap>
		<model public="1" get="accessor" set="null"><c path="tracker.Model"/></model>
		<get_model get="inline" set="null" line="27"><f a=""><c path="tracker.Model"/></f></get_model>
		<entity public="1">
			<c path="tracker.Model"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<bindAsComponent set="method" line="33"><f a=""><x path="Void"/></f></bindAsComponent>
		<compact public="1" set="method" line="53">
			<f a="?done">
				<f a="">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Recompute the whole object tree instead of appending. This will untrack every object not on the model anymore
        and generate a new changeset with the whole serialized object tree.</haxe_doc>
		</compact>
		<trackedModels expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<c path="tracker.Model"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</trackedModels>
		<willCleanDestroyedTrackedModels expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</willCleanDestroyedTrackedModels>
		<dirtyModels expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<c path="tracker.Model"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</dirtyModels>
		<canCompact expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</canCompact>
		<dirty expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</dirty>
		<track get="inline" set="null" line="102"><f a="model">
	<c path="tracker.Model"/>
	<x path="Void"/>
</f></track>
		<untrack get="inline" set="null" line="113"><f a="model">
	<c path="tracker.Model"/>
	<x path="Void"/>
</f></untrack>
		<trackedModelDestroyed set="method" line="127"><f a="_">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></trackedModelDestroyed>
		<cleanTrackingFromPrevSerializedMap set="method" line="150"><f a="prevSerializedMap">
	<t path="Map">
		<c path="String"/>
		<a>
			<type><c path="String"/></type>
			<props><d/></props>
			<id><c path="String"/></id>
		</a>
	</t>
	<x path="Void"/>
</f></cleanTrackingFromPrevSerializedMap>
		<modelDirty set="method" line="169"><f a="model:fromSerializedField">
	<c path="tracker.Model"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></modelDirty>
		<explicitModelDirty set="method" line="184"><f a="model">
	<c path="tracker.Model"/>
	<x path="Void"/>
</f></explicitModelDirty>
		<synchronize public="1" set="method" line="192">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Synchronize (expected to be called at regular intervals or when something important needs to be serialized)</haxe_doc>
		</synchronize>
		<compactIfNeeded set="method" line="221"><f a=""><x path="Void"/></f></compactIfNeeded>
		<serializeModel get="inline" set="null" line="230"><f a="model:toAppend">
	<c path="tracker.Model"/>
	<c path="Array"><a>
	<type><c path="String"/></type>
	<props><d/></props>
	<id><c path="String"/></id>
</a></c>
	<x path="Void"/>
</f></serializeModel>
		<setEntity set="method" line="6">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="6">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Utility to serialize a model object (and its children) continuously and efficiently</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="tracker.Tracker" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Tracker.hx">
		<backend public="1" static="1"><c path="ceramic.TrackerBackend"/></backend>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="tracker.Utils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Utils.hx">
		<uniformFrequencyList public="1" set="method" line="10" static="1">
			<f a="values:frequencies:size">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>Generate an uniform list of the requested size,
        containing values uniformly repartited from frequencies.
        @param values the values to put in list
        @param probabilities the corresponding probability for each value
        @param size the size of the final list</haxe_doc>
		</uniformFrequencyList>
		<_nextUniqueIntCursor expr="0" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_nextUniqueIntCursor>
		<_nextUniqueInt0 expr="Std.int(Math.random() * 0x7ffffffe)" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 0x7ffffffe)</e></m></meta>
		</_nextUniqueInt0>
		<_nextUniqueInt1 expr="Std.int(Date.now().getTime() * 0.0001)" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Date.now().getTime() * 0.0001)</e></m></meta>
		</_nextUniqueInt1>
		<_nextUniqueInt2 expr="Std.int(Math.random() * 0x7ffffffe)" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 0x7ffffffe)</e></m></meta>
		</_nextUniqueInt2>
		<_nextUniqueInt3 expr="Std.int(Math.random() * 0x7ffffffe)" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 0x7ffffffe)</e></m></meta>
		</_nextUniqueInt3>
		<uniqueId public="1" set="method" line="62" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Provides an identifier which is garanteed to be unique on the current session.
        It however doesn't garantee that this identifier is not predictable.</haxe_doc>
		</uniqueId>
		<base62Id public="1" get="inline" set="null" line="90" static="1"><f a="?val">
	<x path="Int"/>
	<c path="String"/>
</f></base62Id>
		<encodeChangesetData public="1" set="method" line="114" static="1"><f a="data">
	<c path="String"/>
	<c path="String"/>
</f></encodeChangesetData>
		<decodeChangesetData public="1" set="method" line="120" static="1"><f a="rawData">
	<c path="String"/>
	<a>
		<serializedMap><t path="Map">
	<c path="String"/>
	<a>
		<type><c path="String"/></type>
		<props><d/></props>
		<id><c path="String"/></id>
	</a>
</t></serializedMap>
		<serialized><x path="Null"><d/></x></serialized>
	</a>
</f></decodeChangesetData>
		<meta><m n=":directlyUsed"/></meta>
	</class>
</haxe>