<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Any.hx">
		<from><icast><d/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":forward.variance"/>
		</meta>
		<impl><class path="_Any.Any_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Any.hx" private="1" module="Any" final="1">
	<__promote params="T" get="inline" set="null" line="37" static="1">
		<f a="this">
			<d/>
			<c path="__promote.T"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":to"/>
		</meta>
	</__promote>
	<toString get="inline" set="null" line="40" static="1">
		<f a="this">
			<d/>
			<c path="String"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</toString>
	<meta>
		<m n=":keep"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="_Any.Any_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Any.hx" private="1" module="Any" final="1">
		<__promote params="T" get="inline" set="null" line="37" static="1">
			<f a="this">
				<d/>
				<c path="__promote.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":to"/>
			</meta>
		</__promote>
		<toString get="inline" set="null" line="40" static="1">
			<f a="this">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</toString>
		<meta>
			<m n=":keep"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="Array" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/Array.hx" final="1">
		<__hx_toString_depth expr="0" line="34" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":skipReflection"/>
			</meta>
		</__hx_toString_depth>
		<__hx_defaultCapacity final="1" get="inline" set="null" expr="4" line="35" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>4</e></m>
				<m n=":skipReflection"/>
			</meta>
		</__hx_defaultCapacity>
		<ofNative params="X" get="inline" set="null" line="42" static="1"><f a="native">
	<c path="cs.NativeArray"><c path="ofNative.X"/></c>
	<c path="Array"><c path="ofNative.X"/></c>
</f></ofNative>
		<alloc params="Y" get="inline" set="null" line="47" static="1"><f a="size">
	<x path="Int"/>
	<c path="Array"><c path="alloc.Y"/></c>
</f></alloc>
		<length public="1" set="null"><x path="Int"/></length>
		<__a><c path="cs.NativeArray"><c path="Array.T"/></c></__a>
		<concat public="1" set="method" line="68"><f a="a">
	<c path="Array"><c path="Array.T"/></c>
	<c path="Array"><c path="Array.T"/></c>
</f></concat>
		<concatNative set="method" line="77"><f a="a">
	<c path="cs.NativeArray"><c path="Array.T"/></c>
	<x path="Void"/>
</f></concatNative>
		<indexOf public="1" set="method" line="93"><f a="x:?fromIndex">
	<c path="Array.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOf>
		<lastIndexOf public="1" set="method" line="105"><f a="x:?fromIndex">
	<c path="Array.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lastIndexOf>
		<join public="1" set="method" line="117"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<pop public="1" set="method" line="134"><f a=""><x path="Null"><c path="Array.T"/></x></f></pop>
		<push public="1" set="method" line="148"><f a="x">
	<c path="Array.T"/>
	<x path="Int"/>
</f></push>
		<reverse public="1" set="method" line="161"><f a=""><x path="Void"/></f></reverse>
		<shift public="1" set="method" line="175"><f a=""><x path="Null"><c path="Array.T"/></x></f></shift>
		<slice public="1" set="method" line="190"><f a="pos:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="Array.T"/></c>
</f></slice>
		<sort public="1" set="method" line="212"><f a="f">
	<f a=":">
		<c path="Array.T"/>
		<c path="Array.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<quicksort set="method" line="218"><f a="lo:hi:f">
	<x path="Int"/>
	<x path="Int"/>
	<f a=":">
		<c path="Array.T"/>
		<c path="Array.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></quicksort>
		<splice public="1" set="method" line="240"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="Array.T"/></c>
</f></splice>
		<spliceVoid set="method" line="270"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></spliceVoid>
		<toString public="1" set="method" line="295"><f a=""><c path="String"/></f></toString>
		<__hx_toString set="method" line="311">
			<f a=""><c path="String"/></f>
			<meta><m n=":skipReflection"/></meta>
		</__hx_toString>
		<unshift public="1" set="method" line="328"><f a="x">
	<c path="Array.T"/>
	<x path="Void"/>
</f></unshift>
		<insert public="1" set="method" line="345"><f a="pos:x">
	<x path="Int"/>
	<c path="Array.T"/>
	<x path="Void"/>
</f></insert>
		<remove public="1" set="method" line="378"><f a="x">
	<c path="Array.T"/>
	<x path="Bool"/>
</f></remove>
		<map public="1" params="S" get="inline" set="null" line="394"><f a="f">
	<f a="">
		<c path="Array.T"/>
		<c path="map.S"/>
	</f>
	<c path="Array"><c path="map.S"/></c>
</f></map>
		<contains public="1" set="method" line="401"><f a="x">
	<c path="Array.T"/>
	<x path="Bool"/>
</f></contains>
		<filter public="1" get="inline" set="null" line="412"><f a="f">
	<f a="">
		<c path="Array.T"/>
		<x path="Bool"/>
	</f>
	<c path="Array"><c path="Array.T"/></c>
</f></filter>
		<copy public="1" set="method" line="422"><f a=""><c path="Array"><c path="Array.T"/></c></f></copy>
		<iterator public="1" get="inline" set="null" line="430"><f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f></iterator>
		<keyValueIterator public="1" get="inline" set="null" line="435"><f a=""><c path="haxe.iterators.ArrayKeyValueIterator"><c path="Array.T"/></c></f></keyValueIterator>
		<resize public="1" set="method" line="439"><f a="len">
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<__get set="method" line="450"><f a="idx">
	<x path="Int"/>
	<c path="Array.T"/>
</f></__get>
		<__set set="method" line="454"><f a="idx:v">
	<x path="Int"/>
	<c path="Array.T"/>
	<c path="Array.T"/>
</f></__set>
		<__unsafe_get get="inline" set="null" line="472"><f a="idx">
	<x path="Int"/>
	<c path="Array.T"/>
</f></__unsafe_get>
		<__unsafe_set get="inline" set="null" line="476"><f a="idx:val">
	<x path="Int"/>
	<c path="Array.T"/>
	<c path="Array.T"/>
</f></__unsafe_set>
		<new public="1" set="method" line="51">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><new set="method" line="62">
	<f a="native">
		<c path="cs.NativeArray"><c path="Array.T"/></c>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":hxGen"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="cs.system.ValueType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ValueType" extern="1" abstract="1">
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ValueType"</e></m>
		</meta>
	</class>
	<class path="cs.system.IComparable_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.IComparable_1" extern="1" interface="1">
		<CompareTo public="1" set="method"><f a="other">
	<c path="cs.system.IComparable_1.T0"/>
	<x path="Int"/>
</f></CompareTo>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IComparable`1"</e></m>
		</meta>
	</class>
	<class path="cs.system.IEquatable_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.IEquatable_1" extern="1" interface="1"><meta>
	<m n=":nativeGen"/>
	<m n=":abstract"/>
	<m n=":libType"/>
	<m n=":csNative"/>
	<m n=":native"><e>"System.IEquatable`1"</e></m>
</meta></class>
	<class path="cs.system.IComparable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.IComparable" extern="1" interface="1">
		<CompareTo public="1" set="method"><f a="obj">
	<d/>
	<x path="Int"/>
</f></CompareTo>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IComparable"</e></m>
		</meta>
	</class>
	<class path="cs.system.IConvertible" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.IConvertible" extern="1" interface="1">
		<GetTypeCode public="1" set="method"><f a=""><e path="cs.system.TypeCode"/></f></GetTypeCode>
		<ToBoolean public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<x path="Bool"/>
</f></ToBoolean>
		<ToByte public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
		<ToChar public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
		<ToDateTime public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
		<ToDecimal public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
		<ToDouble public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<x path="Float"/>
</f></ToDouble>
		<ToInt16 public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
		<ToInt32 public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<x path="Int"/>
</f></ToInt32>
		<ToInt64 public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
		<ToSByte public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
		<ToSingle public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<x path="Single"/>
</f></ToSingle>
		<ToString public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
		<ToType public="1" set="method"><f a="conversionType:provider">
	<c path="cs.system.Type"/>
	<c path="cs.system.IFormatProvider"/>
	<d/>
</f></ToType>
		<ToUInt16 public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
		<ToUInt32 public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<x path="UInt"/>
</f></ToUInt32>
		<ToUInt64 public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IConvertible"</e></m>
		</meta>
	</class>
	<class path="cs.system.IFormattable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.IFormattable" extern="1" interface="1">
		<ToString public="1" set="method"><f a="format:formatProvider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IFormattable"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.serialization.ISerializable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.serialization.ISerializable" extern="1" interface="1">
		<GetObjectData public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Serialization.ISerializable"</e></m>
		</meta>
	</class>
	<class path="cs.system.DateTime" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.DateTime" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.IComparable_1"><c path="cs.system.DateTime"/></implements>
		<implements path="cs.system.IEquatable_1"><c path="cs.system.DateTime"/></implements>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IConvertible"/>
		<implements path="cs.system.IFormattable"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<UtcNow public="1" get="accessor" set="null" static="1"><c path="cs.system.DateTime"/></UtcNow>
		<Today public="1" get="accessor" set="null" static="1"><c path="cs.system.DateTime"/></Today>
		<Now public="1" get="accessor" set="null" static="1"><c path="cs.system.DateTime"/></Now>
		<MinValue public="1" set="null" static="1">
			<c path="cs.system.DateTime"/>
			<meta><m n=":readOnly"/></meta>
		</MinValue>
		<MaxValue public="1" set="null" static="1">
			<c path="cs.system.DateTime"/>
			<meta><m n=":readOnly"/></meta>
		</MaxValue>
		<get_Now public="1" set="method" static="1"><f a=""><c path="cs.system.DateTime"/></f></get_Now>
		<get_Today public="1" set="method" static="1"><f a=""><c path="cs.system.DateTime"/></f></get_Today>
		<get_UtcNow public="1" set="method" static="1"><f a=""><c path="cs.system.DateTime"/></f></get_UtcNow>
		<Compare public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
</f></Compare>
		<FromBinary public="1" set="method" static="1"><f a="dateData">
	<x path="haxe.Int64"/>
	<c path="cs.system.DateTime"/>
</f></FromBinary>
		<SpecifyKind public="1" set="method" static="1"><f a="value:kind">
	<c path="cs.system.DateTime"/>
	<e path="cs.system.DateTimeKind"/>
	<c path="cs.system.DateTime"/>
</f></SpecifyKind>
		<DaysInMonth public="1" set="method" static="1"><f a="year:month">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></DaysInMonth>
		<_Equals public="1" set="method" static="1">
			<f a="t1:t2">
				<c path="cs.system.DateTime"/>
				<c path="cs.system.DateTime"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"Equals"</e></m></meta>
		</_Equals>
		<FromFileTime public="1" set="method" static="1"><f a="fileTime">
	<x path="haxe.Int64"/>
	<c path="cs.system.DateTime"/>
</f></FromFileTime>
		<FromFileTimeUtc public="1" set="method" static="1"><f a="fileTime">
	<x path="haxe.Int64"/>
	<c path="cs.system.DateTime"/>
</f></FromFileTimeUtc>
		<FromOADate public="1" set="method" static="1"><f a="d">
	<x path="Float"/>
	<c path="cs.system.DateTime"/>
</f></FromOADate>
		<IsLeapYear public="1" set="method" static="1"><f a="year">
	<x path="Int"/>
	<x path="Bool"/>
</f></IsLeapYear>
		<Parse public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="cs.system.DateTime"/>
			</f>
			<overloads>
				<Parse public="1" set="method"><f a="s:provider:styles">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<e path="cs.system.globalization.DateTimeStyles"/>
	<c path="cs.system.DateTime"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.system.DateTime"/>
</f></Parse>
			</overloads>
		</Parse>
		<ParseExact public="1" set="method" static="1">
			<f a="s:format:provider">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.IFormatProvider"/>
				<c path="cs.system.DateTime"/>
			</f>
			<overloads>
				<ParseExact public="1" set="method"><f a="s:formats:provider:style">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.system.IFormatProvider"/>
	<e path="cs.system.globalization.DateTimeStyles"/>
	<c path="cs.system.DateTime"/>
</f></ParseExact>
				<ParseExact public="1" set="method"><f a="s:format:provider:style">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<e path="cs.system.globalization.DateTimeStyles"/>
	<c path="cs.system.DateTime"/>
</f></ParseExact>
			</overloads>
		</ParseExact>
		<TryParse public="1" set="method" static="1">
			<f a="s:result">
				<c path="String"/>
				<t path="cs.Out"><c path="cs.system.DateTime"/></t>
				<x path="Bool"/>
			</f>
			<overloads><TryParse public="1" set="method"><f a="s:provider:styles:result">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<e path="cs.system.globalization.DateTimeStyles"/>
	<t path="cs.Out"><c path="cs.system.DateTime"/></t>
	<x path="Bool"/>
</f></TryParse></overloads>
		</TryParse>
		<TryParseExact public="1" set="method" static="1">
			<f a="s:format:provider:style:result">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.IFormatProvider"/>
				<e path="cs.system.globalization.DateTimeStyles"/>
				<t path="cs.Out"><c path="cs.system.DateTime"/></t>
				<x path="Bool"/>
			</f>
			<overloads><TryParseExact public="1" set="method"><f a="s:formats:provider:style:result">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.system.IFormatProvider"/>
	<e path="cs.system.globalization.DateTimeStyles"/>
	<t path="cs.Out"><c path="cs.system.DateTime"/></t>
	<x path="Bool"/>
</f></TryParseExact></overloads>
		</TryParseExact>
		<op_Addition public="1" set="method" static="1"><f a="d:t">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.DateTime"/>
</f></op_Addition>
		<op_Equality public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_GreaterThan public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
	<x path="Bool"/>
</f></op_GreaterThan>
		<op_GreaterThanOrEqual public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
	<x path="Bool"/>
</f></op_GreaterThanOrEqual>
		<op_Inequality public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
	<x path="Bool"/>
</f></op_Inequality>
		<op_LessThan public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
	<x path="Bool"/>
</f></op_LessThan>
		<op_LessThanOrEqual public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
	<x path="Bool"/>
</f></op_LessThanOrEqual>
		<op_Subtraction public="1" set="method" static="1">
			<f a="d1:d2">
				<c path="cs.system.DateTime"/>
				<c path="cs.system.DateTime"/>
				<c path="cs.system.TimeSpan"/>
			</f>
			<overloads><op_Subtraction public="1" set="method"><f a="d:t">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.DateTime"/>
</f></op_Subtraction></overloads>
		</op_Subtraction>
		<Kind public="1" get="accessor" set="null"><e path="cs.system.DateTimeKind"/></Kind>
		<Year public="1" get="accessor" set="null"><x path="Int"/></Year>
		<Ticks public="1" get="accessor" set="null"><x path="haxe.Int64"/></Ticks>
		<Millisecond public="1" get="accessor" set="null"><x path="Int"/></Millisecond>
		<Second public="1" get="accessor" set="null"><x path="Int"/></Second>
		<Minute public="1" get="accessor" set="null"><x path="Int"/></Minute>
		<Hour public="1" get="accessor" set="null"><x path="Int"/></Hour>
		<TimeOfDay public="1" get="accessor" set="null"><c path="cs.system.TimeSpan"/></TimeOfDay>
		<DayOfYear public="1" get="accessor" set="null"><x path="Int"/></DayOfYear>
		<DayOfWeek public="1" get="accessor" set="null"><e path="cs.system.DayOfWeek"/></DayOfWeek>
		<Day public="1" get="accessor" set="null"><x path="Int"/></Day>
		<Month public="1" get="accessor" set="null"><x path="Int"/></Month>
		<Date public="1" get="accessor" set="null"><c path="cs.system.DateTime"/></Date>
		<get_Date final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_Date>
		<get_Month final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Month>
		<get_Day final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Day>
		<get_DayOfWeek final="1" public="1" set="method"><f a=""><e path="cs.system.DayOfWeek"/></f></get_DayOfWeek>
		<get_DayOfYear final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_DayOfYear>
		<get_TimeOfDay final="1" public="1" set="method"><f a=""><c path="cs.system.TimeSpan"/></f></get_TimeOfDay>
		<get_Hour final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Hour>
		<get_Minute final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Minute>
		<get_Second final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Second>
		<get_Millisecond final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Millisecond>
		<get_Ticks final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_Ticks>
		<get_Year final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Year>
		<get_Kind final="1" public="1" set="method"><f a=""><e path="cs.system.DateTimeKind"/></f></get_Kind>
		<Add final="1" public="1" set="method"><f a="value">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.DateTime"/>
</f></Add>
		<AddDays final="1" public="1" set="method"><f a="value">
	<x path="Float"/>
	<c path="cs.system.DateTime"/>
</f></AddDays>
		<AddTicks final="1" public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<c path="cs.system.DateTime"/>
</f></AddTicks>
		<AddHours final="1" public="1" set="method"><f a="value">
	<x path="Float"/>
	<c path="cs.system.DateTime"/>
</f></AddHours>
		<AddMilliseconds final="1" public="1" set="method"><f a="value">
	<x path="Float"/>
	<c path="cs.system.DateTime"/>
</f></AddMilliseconds>
		<AddMinutes final="1" public="1" set="method"><f a="value">
	<x path="Float"/>
	<c path="cs.system.DateTime"/>
</f></AddMinutes>
		<AddMonths final="1" public="1" set="method"><f a="months">
	<x path="Int"/>
	<c path="cs.system.DateTime"/>
</f></AddMonths>
		<AddSeconds final="1" public="1" set="method"><f a="value">
	<x path="Float"/>
	<c path="cs.system.DateTime"/>
</f></AddSeconds>
		<AddYears final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<c path="cs.system.DateTime"/>
</f></AddYears>
		<CompareTo final="1" public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads><CompareTo final="1" public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
</f></CompareTo></overloads>
		</CompareTo>
		<IsDaylightSavingTime final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsDaylightSavingTime>
		<ToBinary final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></ToBinary>
		<GetDateTimeFormats final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="String"/></c></f>
			<overloads>
				<GetDateTimeFormats final="1" public="1" set="method"><f a="format:provider">
	<t path="cs.types.Char16"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetDateTimeFormats>
				<GetDateTimeFormats final="1" public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetDateTimeFormats>
				<GetDateTimeFormats final="1" public="1" set="method"><f a="format">
	<t path="cs.types.Char16"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetDateTimeFormats>
			</overloads>
		</GetDateTimeFormats>
		<GetTypeCode final="1" public="1" set="method"><f a=""><e path="cs.system.TypeCode"/></f></GetTypeCode>
		<Subtract final="1" public="1" set="method">
			<f a="value">
				<c path="cs.system.DateTime"/>
				<c path="cs.system.TimeSpan"/>
			</f>
			<overloads><Subtract final="1" public="1" set="method"><f a="value">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.DateTime"/>
</f></Subtract></overloads>
		</Subtract>
		<ToFileTime final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></ToFileTime>
		<ToFileTimeUtc final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></ToFileTimeUtc>
		<ToLongDateString final="1" public="1" set="method"><f a=""><c path="String"/></f></ToLongDateString>
		<ToLongTimeString final="1" public="1" set="method"><f a=""><c path="String"/></f></ToLongTimeString>
		<ToOADate final="1" public="1" set="method"><f a=""><x path="Float"/></f></ToOADate>
		<ToShortDateString final="1" public="1" set="method"><f a=""><c path="String"/></f></ToShortDateString>
		<ToShortTimeString final="1" public="1" set="method"><f a=""><c path="String"/></f></ToShortTimeString>
		<ToString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<overloads>
				<ToString final="1" public="1" set="method"><f a="format:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="format">
	<c path="String"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
			</overloads>
		</ToString>
		<ToLocalTime final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></ToLocalTime>
		<ToUniversalTime final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></ToUniversalTime>
		<new final="1" public="1" set="method">
			<f a="ticks">
				<x path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="year:month:day:hour:minute:second:millisecond:calendar:kind">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.globalization.Calendar"/>
	<e path="cs.system.DateTimeKind"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="year:month:day:hour:minute:second:millisecond:kind">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="cs.system.DateTimeKind"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="year:month:day:hour:minute:second:kind">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="cs.system.DateTimeKind"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="ticks:kind">
	<x path="haxe.Int64"/>
	<e path="cs.system.DateTimeKind"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="year:month:day:hour:minute:second:millisecond:calendar">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.globalization.Calendar"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="year:month:day:hour:minute:second:calendar">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.globalization.Calendar"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="year:month:day:calendar">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.globalization.Calendar"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="year:month:day:hour:minute:second:millisecond">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="year:month:day:hour:minute:second">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="year:month:day">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.DateTime"</e></m>
		</meta>
	</class>
	<class path="Date" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/Date.hx">
		<epochTicks expr="new DateTime(1970, 1, 1).Ticks" line="32" static="1">
			<x path="haxe.Int64"/>
			<meta>
				<m n=":value"><e>new DateTime(1970, 1, 1).Ticks</e></m>
				<m n=":readOnly"/>
			</meta>
		</epochTicks>
		<now public="1" get="inline" set="null" line="128" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" get="inline" set="null" line="132" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="141" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the formatted string `s`. The following formats are
		accepted by the function:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats expressed a date in local time. The third is a time
		relative to the UTC epoch.</haxe_doc>
		</fromString>
		<fromNative get="inline" set="null" line="159" static="1"><f a="d">
	<c path="cs.system.DateTime"/>
	<c path="Date"/>
</f></fromNative>
		<date><c path="cs.system.DateTime"/></date>
		<dateUTC><c path="cs.system.DateTime"/></dateUTC>
		<getTime public="1" get="inline" set="null" line="56">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of `this` date.
		On cpp and neko, this function only has a second resolution, so the
		result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
		To obtain the current timestamp with better precision on cpp and neko,
		see the `Sys.time` API.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<toString public="1" set="method" line="124">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method" line="37">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":overload"/></meta>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
			<overloads><new set="method" line="46">
	<f a="native">
		<c path="cs.system.DateTime"/>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="EReg" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/EReg.hx" final="1">
		<escape public="1" get="inline" set="null" line="132" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape the string `s` for use as a part of regular expression.

		If `s` is null, the result is unspecified.</haxe_doc>
		</escape>
		<regex><c path="cs.system.text.regularexpressions.Regex"/></regex>
		<m><c path="cs.system.text.regularexpressions.Match"/></m>
		<isGlobal><x path="Bool"/></isGlobal>
		<cur><c path="String"/></cur>
		<match public="1" set="method" line="55">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="61">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedPos public="1" set="method" line="77">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchSub public="1" set="method" line="81">
			<f a="s:pos:?len" v="::-1">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ len : -1 }</e></m></meta>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.match(s.substr(pos,len))` can be used instead.

		This method modifies the internal state.

		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<replace public="1" set="method" line="104">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<map public="1" set="method" line="108">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>Calls the function `f` for the substring of `s` which `this` EReg matches
		and replaces that substring with the result of `f` call.

		The `f` function takes `this` EReg object as its first argument and should
		return a replacement string for the substring matched.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `s` or `f` are null, the result is unspecified.</haxe_doc>
		</map>
		<new public="1" set="method" line="34">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":hxGen"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":coreType"/>
		</meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta>
	<m n=":keep"/>
	<m n=":hxGen"/>
</meta></class></impl>
	</abstract>
	<class path="IntIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/IntIterator.hx">
		<min>
			<x path="Int"/>
			<meta><m n=":keep"/></meta>
		</min>
		<max>
			<x path="Int"/>
			<meta><m n=":keep"/></meta>
		</max>
		<hasNext public="1" get="inline" set="null" line="53">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="62">
			<f a=""><x path="Int"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Moves to the next item of the iterator.

		If this is called while hasNext() is false, the result is unspecified.</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="45">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc><![CDATA[Iterates from `min` (inclusive) to `max` (exclusive).

		If `max <= min`, the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>IntIterator is used for implementing interval iterations.

	It is usually not used explicitly, but through its special syntax:
	`min...max`

	While it is possible to assign an instance of IntIterator to a variable or
	field, it is worth noting that IntIterator does not reset after being used
	in a for-loop. Subsequent uses of the same instance will then have no
	effect.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="Main" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/Main.hx">
		<project public="1" expr="null" line="8" static="1">
			<c path="Project"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</project>
		<_lastUpdateTime expr="0" line="10" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_lastUpdateTime>
		<_lastRegularUpdateTime expr="0" line="13" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_lastRegularUpdateTime>
		<_hasCriticalError expr="false" line="16" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_hasCriticalError>
		<monoBehaviour public="1" expr="null" line="18" static="1">
			<c path="unityengine.MonoBehaviour"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</monoBehaviour>
		<sync public="1" set="method" line="20" static="1">
			<f a="monoBehaviour">
				<c path="unityengine.MonoBehaviour"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</sync>
		<main public="1" set="method" line="30" static="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":keep"/>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</main>
		<regularUpdate public="1" set="method" line="53" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</regularUpdate>
		<renderPassUpdate public="1" set="method" line="67" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</renderPassUpdate>
		<update public="1" set="method" line="78" static="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</update>
		<hasCriticalError public="1" set="method" line="112" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</hasCriticalError>
		<markCriticalError public="1" set="method" line="118" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</markCriticalError>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="Map" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Map.hx">
		<x path="haxe.ds.Map">
			<c path="Map.K"/>
			<c path="Map.V"/>
		</x>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="IMap" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":nativeGen"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="cs.system.Double" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Double" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.IComparable_1"><x path="Float"/></implements>
		<implements path="cs.system.IEquatable_1"><x path="Float"/></implements>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IConvertible"/>
		<implements path="cs.system.IFormattable"/>
		<PositiveInfinity public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":readOnly"/></meta>
		</PositiveInfinity>
		<NegativeInfinity public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":readOnly"/></meta>
		</NegativeInfinity>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":readOnly"/></meta>
		</NaN>
		<MinValue public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":readOnly"/></meta>
		</MinValue>
		<MaxValue public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":readOnly"/></meta>
		</MaxValue>
		<Epsilon public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":readOnly"/></meta>
		</Epsilon>
		<IsInfinity public="1" set="method" static="1"><f a="d">
	<x path="Float"/>
	<x path="Bool"/>
</f></IsInfinity>
		<IsNaN public="1" set="method" static="1"><f a="d">
	<x path="Float"/>
	<x path="Bool"/>
</f></IsNaN>
		<IsNegativeInfinity public="1" set="method" static="1"><f a="d">
	<x path="Float"/>
	<x path="Bool"/>
</f></IsNegativeInfinity>
		<IsPositiveInfinity public="1" set="method" static="1"><f a="d">
	<x path="Float"/>
	<x path="Bool"/>
</f></IsPositiveInfinity>
		<Parse public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<overloads>
				<Parse public="1" set="method"><f a="s:style:provider">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<c path="cs.system.IFormatProvider"/>
	<x path="Float"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s:style">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<x path="Float"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<x path="Float"/>
</f></Parse>
			</overloads>
		</Parse>
		<TryParse public="1" set="method" static="1">
			<f a="s:style:provider:result">
				<c path="String"/>
				<e path="cs.system.globalization.NumberStyles"/>
				<c path="cs.system.IFormatProvider"/>
				<t path="cs.Out"><x path="Float"/></t>
				<x path="Bool"/>
			</f>
			<overloads><TryParse public="1" set="method"><f a="s:result">
	<c path="String"/>
	<t path="cs.Out"><x path="Float"/></t>
	<x path="Bool"/>
</f></TryParse></overloads>
		</TryParse>
		<CompareTo final="1" public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads><CompareTo final="1" public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Int"/>
</f></CompareTo></overloads>
		</CompareTo>
		<ToString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<overloads>
				<ToString final="1" public="1" set="method"><f a="format:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="format">
	<c path="String"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
			</overloads>
		</ToString>
		<GetTypeCode final="1" public="1" set="method"><f a=""><e path="cs.system.TypeCode"/></f></GetTypeCode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Double"</e></m>
		</meta>
	</class>
	<class path="cs.system.Math" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Math" extern="1" final="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":readOnly"/></meta>
		</PI>
		<E public="1" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":readOnly"/></meta>
		</E>
		<Abs public="1" set="method" static="1">
			<f a="value">
				<c path="cs.system.Decimal"/>
				<c path="cs.system.Decimal"/>
			</f>
			<overloads>
				<Abs public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<t path="cs.types.Int16"/>
</f></Abs>
				<Abs public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<t path="cs.types.Int8"/>
</f></Abs>
				<Abs public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
</f></Abs>
				<Abs public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></Abs>
				<Abs public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="Single"/>
</f></Abs>
				<Abs public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></Abs>
			</overloads>
		</Abs>
		<Ceiling public="1" set="method" static="1">
			<f a="d">
				<c path="cs.system.Decimal"/>
				<c path="cs.system.Decimal"/>
			</f>
			<overloads><Ceiling public="1" set="method"><f a="a">
	<x path="Float"/>
	<x path="Float"/>
</f></Ceiling></overloads>
		</Ceiling>
		<BigMul public="1" set="method" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.Int64"/>
</f></BigMul>
		<DivRem public="1" set="method" static="1">
			<f a="a:b:result">
				<x path="Int"/>
				<x path="Int"/>
				<t path="cs.Out"><x path="Int"/></t>
				<x path="Int"/>
			</f>
			<overloads><DivRem public="1" set="method"><f a="a:b:result">
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
	<t path="cs.Out"><x path="haxe.Int64"/></t>
	<x path="haxe.Int64"/>
</f></DivRem></overloads>
		</DivRem>
		<Floor public="1" set="method" static="1">
			<f a="d">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<overloads><Floor public="1" set="method"><f a="d">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Floor></overloads>
		</Floor>
		<IEEERemainder public="1" set="method" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></IEEERemainder>
		<Log public="1" set="method" static="1">
			<f a="a:newBase">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<overloads><Log public="1" set="method"><f a="d">
	<x path="Float"/>
	<x path="Float"/>
</f></Log></overloads>
		</Log>
		<Max public="1" set="method" static="1">
			<f a="val1:val2">
				<t path="cs.types.UInt8"/>
				<t path="cs.types.UInt8"/>
				<t path="cs.types.UInt8"/>
			</f>
			<overloads>
				<Max public="1" set="method"><f a="val1:val2">
	<t path="cs.types.UInt16"/>
	<t path="cs.types.UInt16"/>
	<t path="cs.types.UInt16"/>
</f></Max>
				<Max public="1" set="method"><f a="val1:val2">
	<t path="cs.types.UInt64"/>
	<t path="cs.types.UInt64"/>
	<t path="cs.types.UInt64"/>
</f></Max>
				<Max public="1" set="method"><f a="val1:val2">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
</f></Max>
				<Max public="1" set="method"><f a="val1:val2">
	<t path="cs.types.Int16"/>
	<t path="cs.types.Int16"/>
	<t path="cs.types.Int16"/>
</f></Max>
				<Max public="1" set="method"><f a="val1:val2">
	<t path="cs.types.Int8"/>
	<t path="cs.types.Int8"/>
	<t path="cs.types.Int8"/>
</f></Max>
				<Max public="1" set="method"><f a="val1:val2">
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
</f></Max>
				<Max public="1" set="method"><f a="val1:val2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Max>
				<Max public="1" set="method"><f a="val1:val2">
	<x path="Single"/>
	<x path="Single"/>
	<x path="Single"/>
</f></Max>
				<Max public="1" set="method"><f a="val1:val2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></Max>
				<Max public="1" set="method"><f a="val1:val2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Max>
			</overloads>
		</Max>
		<Min public="1" set="method" static="1">
			<f a="val1:val2">
				<t path="cs.types.UInt8"/>
				<t path="cs.types.UInt8"/>
				<t path="cs.types.UInt8"/>
			</f>
			<overloads>
				<Min public="1" set="method"><f a="val1:val2">
	<t path="cs.types.UInt16"/>
	<t path="cs.types.UInt16"/>
	<t path="cs.types.UInt16"/>
</f></Min>
				<Min public="1" set="method"><f a="val1:val2">
	<t path="cs.types.UInt64"/>
	<t path="cs.types.UInt64"/>
	<t path="cs.types.UInt64"/>
</f></Min>
				<Min public="1" set="method"><f a="val1:val2">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
</f></Min>
				<Min public="1" set="method"><f a="val1:val2">
	<t path="cs.types.Int16"/>
	<t path="cs.types.Int16"/>
	<t path="cs.types.Int16"/>
</f></Min>
				<Min public="1" set="method"><f a="val1:val2">
	<t path="cs.types.Int8"/>
	<t path="cs.types.Int8"/>
	<t path="cs.types.Int8"/>
</f></Min>
				<Min public="1" set="method"><f a="val1:val2">
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
</f></Min>
				<Min public="1" set="method"><f a="val1:val2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Min>
				<Min public="1" set="method"><f a="val1:val2">
	<x path="Single"/>
	<x path="Single"/>
	<x path="Single"/>
</f></Min>
				<Min public="1" set="method"><f a="val1:val2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></Min>
				<Min public="1" set="method"><f a="val1:val2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Min>
			</overloads>
		</Min>
		<Round public="1" set="method" static="1">
			<f a="d">
				<c path="cs.system.Decimal"/>
				<c path="cs.system.Decimal"/>
			</f>
			<overloads>
				<Round public="1" set="method"><f a="value:digits:mode">
	<x path="Float"/>
	<x path="Int"/>
	<e path="cs.system.MidpointRounding"/>
	<x path="Float"/>
</f></Round>
				<Round public="1" set="method"><f a="value:mode">
	<x path="Float"/>
	<e path="cs.system.MidpointRounding"/>
	<x path="Float"/>
</f></Round>
				<Round public="1" set="method"><f a="value:digits">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></Round>
				<Round public="1" set="method"><f a="a">
	<x path="Float"/>
	<x path="Float"/>
</f></Round>
				<Round public="1" set="method"><f a="d:decimals:mode">
	<c path="cs.system.Decimal"/>
	<x path="Int"/>
	<e path="cs.system.MidpointRounding"/>
	<c path="cs.system.Decimal"/>
</f></Round>
				<Round public="1" set="method"><f a="d:mode">
	<c path="cs.system.Decimal"/>
	<e path="cs.system.MidpointRounding"/>
	<c path="cs.system.Decimal"/>
</f></Round>
				<Round public="1" set="method"><f a="d:decimals">
	<c path="cs.system.Decimal"/>
	<x path="Int"/>
	<c path="cs.system.Decimal"/>
</f></Round>
			</overloads>
		</Round>
		<Truncate public="1" set="method" static="1">
			<f a="d">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<overloads><Truncate public="1" set="method"><f a="d">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Truncate></overloads>
		</Truncate>
		<Sign public="1" set="method" static="1">
			<f a="value">
				<c path="cs.system.Decimal"/>
				<x path="Int"/>
			</f>
			<overloads>
				<Sign public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<x path="Int"/>
</f></Sign>
				<Sign public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<x path="Int"/>
</f></Sign>
				<Sign public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Int"/>
</f></Sign>
				<Sign public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></Sign>
				<Sign public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="Int"/>
</f></Sign>
				<Sign public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Int"/>
</f></Sign>
			</overloads>
		</Sign>
		<Sin public="1" set="method" static="1"><f a="a">
	<x path="Float"/>
	<x path="Float"/>
</f></Sin>
		<Cos public="1" set="method" static="1"><f a="d">
	<x path="Float"/>
	<x path="Float"/>
</f></Cos>
		<Tan public="1" set="method" static="1"><f a="a">
	<x path="Float"/>
	<x path="Float"/>
</f></Tan>
		<Sinh public="1" set="method" static="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></Sinh>
		<Cosh public="1" set="method" static="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></Cosh>
		<Tanh public="1" set="method" static="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></Tanh>
		<Acos public="1" set="method" static="1"><f a="d">
	<x path="Float"/>
	<x path="Float"/>
</f></Acos>
		<Asin public="1" set="method" static="1"><f a="d">
	<x path="Float"/>
	<x path="Float"/>
</f></Asin>
		<Atan public="1" set="method" static="1"><f a="d">
	<x path="Float"/>
	<x path="Float"/>
</f></Atan>
		<Atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></Atan2>
		<Exp public="1" set="method" static="1"><f a="d">
	<x path="Float"/>
	<x path="Float"/>
</f></Exp>
		<Log10 public="1" set="method" static="1"><f a="d">
	<x path="Float"/>
	<x path="Float"/>
</f></Log10>
		<Pow public="1" set="method" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></Pow>
		<Sqrt public="1" set="method" static="1"><f a="d">
	<x path="Float"/>
	<x path="Float"/>
</f></Sqrt>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Math"</e></m>
		</meta>
	</class>
	<class path="cs.system.Random" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Random" extern="1">
		<Sample set="method">
			<f a=""><x path="Float"/></f>
			<meta><m n=":protected"/></meta>
		</Sample>
		<Next public="1" set="method">
			<f a=""><x path="Int"/></f>
			<overloads>
				<Next public="1" set="method"><f a="minValue:maxValue">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Next>
				<Next public="1" set="method"><f a="maxValue">
	<x path="Int"/>
	<x path="Int"/>
</f></Next>
			</overloads>
		</Next>
		<NextBytes public="1" set="method"><f a="buffer">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></NextBytes>
		<NextDouble public="1" set="method"><f a=""><x path="Float"/></f></NextDouble>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><new final="1" public="1" set="method"><f a="Seed">
	<x path="Int"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Random"</e></m>
		</meta>
	</class>
	<class path="Math" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/Math.hx">
		<rand expr="new cs.system.Random()" line="24" static="1">
			<c path="cs.system.Random"/>
			<meta>
				<m n=":value"><e>new cs.system.Random()</e></m>
				<m n=":readOnly"/>
			</meta>
		</rand>
		<PI public="1" set="null" expr="cs.system.Math.PI" line="27" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>cs.system.Math.PI</e></m>
				<m n=":readOnly"/>
			</meta>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, . `PI` is approximately `3.141592653589793`.</haxe_doc>
		</PI>
		<NaN public="1" set="null" expr="cs.system.Double.NaN" line="29" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>cs.system.Double.NaN</e></m>
				<m n=":readOnly"/>
			</meta>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		`NaN` stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: `Math.sqrt(-1)`.

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<NEGATIVE_INFINITY public="1" set="null" expr="cs.system.Double.NegativeInfinity" line="31" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>cs.system.Double.NegativeInfinity</e></m>
				<m n=":readOnly"/>
			</meta>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of `-1.0 / 0.0`.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" expr="cs.system.Double.PositiveInfinity" line="33" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>cs.system.Double.PositiveInfinity</e></m>
				<m n=":readOnly"/>
			</meta>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of `1.0 / 0.0`.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<abs public="1" get="inline" set="null" line="35" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		- If `v` is positive or `0`, the result is unchanged. Otherwise the result is `-v`.
		- If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" get="inline" set="null" line="39" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		- If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" get="inline" set="null" line="43" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" get="inline" set="null" line="47" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" get="inline" set="null" line="51" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<atan2 public="1" get="inline" set="null" line="55" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" get="inline" set="null" line="63" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		`exp(1.0)` is approximately `2.718281828459`.

		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<sqrt public="1" get="inline" set="null" line="71" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" line="87" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" get="inline" set="null" line="99" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" get="inline" set="null" line="103" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<asin public="1" get="inline" set="null" line="111" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<pow public="1" get="inline" set="null" line="119" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<random public="1" get="inline" set="null" line="123" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to `0.0`,
		and less than `1.0`.</haxe_doc>
		</random>
		<isFinite public="1" get="inline" set="null" line="127" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" get="inline" set="null" line="131" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is `Math.NaN`.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, `null`, `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":coreApi"/>
			<m n=":nativeGen"/>
		</meta>
	</class>
	<class path="ceramic.Lazy" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Lazy.hx" interface="1">
		<haxe_doc>* Lazy allows to mark any property as lazy.
 * Lazy properties are initialized only at first access.</haxe_doc>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="tracker.Events" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Events.hx" interface="1">
		<haxe_doc>Events allows to add strictly typed events to classes.
    Generates related methods: on|once|off|emit{EventName}()</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Entity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Entity.hx">
		<implements path="ceramic.Lazy"/>
		<implements path="tracker.Events"/>
		<_data expr="null" line="45">
			<d/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_data>
		<hasData public="1" get="accessor" set="null"><x path="Bool"/></hasData>
		<get_hasData get="inline" set="null" line="48"><f a=""><x path="Bool"/></f></get_hasData>
		<data public="1" get="accessor" set="accessor"><d/></data>
		<get_data set="method" line="53"><f a=""><d/></f></get_data>
		<set_data set="method" line="57"><f a="data">
	<d/>
	<d/>
</f></set_data>
		<id public="1" expr="null" line="61">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</id>
		<_lifecycleState expr="0" line="70">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Internal flag to keep track of current entity state:
     *  - 0: Entity is not destroyed, can be used normally
     *  - -1: Entity is marked destroyed still allowing calls to super.destroy()
     *  - -2: Entity is marked destroyed and additional calls to destroy() are ignored
     *  - -3: Entity root is destroyed (Entity.destroy() was called). Additional calls to destroy() are ignored</haxe_doc>
		</_lifecycleState>
		<destroyed public="1" get="accessor" set="null"><x path="Bool"/></destroyed>
		<get_destroyed get="inline" set="null" line="128"><f a=""><x path="Bool"/></f></get_destroyed>
		<disposed public="1" get="accessor" set="null"><x path="Bool"/></disposed>
		<get_disposed get="inline" set="null" line="133"><f a=""><x path="Bool"/></f></get_disposed>
		<_dox_event_dispose public="1" set="method" line="637">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_dispose>
		<emitDispose set="method" line="1095">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>dispose event</haxe_doc>
		</emitDispose>
		<onDispose public="1" set="method" line="1199">
			<f a="owner:handleEntity">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="entity">
					<c path="ceramic.Entity"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dispose event</haxe_doc>
		</onDispose>
		<onceDispose public="1" set="method" line="1298">
			<f a="owner:handleEntity">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="entity">
					<c path="ceramic.Entity"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dispose event</haxe_doc>
		</onceDispose>
		<offDispose public="1" set="method" line="1368">
			<f a="?handleEntity">
				<f a="entity">
					<c path="ceramic.Entity"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dispose event</haxe_doc>
		</offDispose>
		<listensDispose public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to dispose event</haxe_doc>
		</listensDispose>
		<_dox_event_destroy public="1" set="method" line="637">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_destroy>
		<emitDestroy set="method" line="1095">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>destroy event</haxe_doc>
		</emitDestroy>
		<onDestroy public="1" set="method" line="1199">
			<f a="owner:handleEntity">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="entity">
					<c path="ceramic.Entity"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>destroy event</haxe_doc>
		</onDestroy>
		<onceDestroy public="1" set="method" line="1298">
			<f a="owner:handleEntity">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="entity">
					<c path="ceramic.Entity"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>destroy event</haxe_doc>
		</onceDestroy>
		<offDestroy public="1" set="method" line="1368">
			<f a="?handleEntity">
				<f a="entity">
					<c path="ceramic.Entity"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>destroy event</haxe_doc>
		</offDestroy>
		<listensDestroy public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to destroy event</haxe_doc>
		</listensDestroy>
		<destroy public="1" set="method" line="320">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroy this entity. This method is automatically protected from duplicate calls. That means
     * calling multiple times an entity's `destroy()` method will run the destroy code only one time.
     * As soon as `destroy()` is called, the entity is marked `destroyed=true`, even when calling `destroy()`
     * method on a subclass (a macro is inserting a code to mark the object
     * as destroyed at the beginning of every `destroy()` override function.</haxe_doc>
		</destroy>
		<dispose public="1" set="method" line="370">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Schedules destroy, at the end of the current frame.</haxe_doc>
		</dispose>
		<unbindEvents public="1" set="method" line="384">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Remove all events handlers from this entity.</haxe_doc>
		</unbindEvents>
		<autoruns public="1" set="null" expr="null" line="393">
			<c path="Array"><c path="tracker.Autorun"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</autoruns>
		<autorun public="1" set="method" line="400">
			<f a="run:?afterRun">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<c path="tracker.Autorun"/>
			</f>
			<haxe_doc>* Creates a new `Autorun` instance with the given callback associated with the current entity.
     * @param run The run callback
     * @return The autorun instance</haxe_doc>
		</autorun>
		<checkAutoruns set="method" line="469"><f a="_">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></checkAutoruns>
		<tween public="1" set="method" line="482"><f a="?easing:duration:fromValue:toValue:update">
	<e path="ceramic.Easing"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<f a=":">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<c path="ceramic.Tween"/>
</f></tween>
		<className public="1" set="method" line="490"><f a=""><c path="String"/></f></className>
		<toString set="method" line="499"><f a=""><c path="String"/></f></toString>
		<clearComponents public="1" get="inline" set="null" line="513"><f a=""><x path="Void"/></f></clearComponents>
		<components public="1" get="accessor" set="accessor">
			<x path="ceramic.ReadOnlyMap">
				<c path="String"/>
				<c path="ceramic.Component"/>
			</x>
			<meta><m n="editable"/></meta>
			<haxe_doc>* Public components mapping. Contain components
     * created separately with `component()` or macro-based components as well.</haxe_doc>
		</components>
		<get_components get="inline" set="null" line="537"><f a=""><x path="ceramic.ReadOnlyMap">
	<c path="String"/>
	<c path="ceramic.Component"/>
</x></f></get_components>
		<set_components set="method" line="540"><f a="components">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</x>
</f></set_components>
		<_components expr="null" line="581">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.Component"/>
			</t>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Internal components representation.</haxe_doc>
		</_components>
		<component public="1" params="C" set="method" line="583"><f a="?name:?component">
	<c path="String"/>
	<x path="Null"><c path="component.C"/></x>
	<c path="component.C"/>
</f></component>
		<hasComponent public="1" set="method" line="643"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasComponent>
		<removeComponent public="1" set="method" line="649"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeComponent>
		<new public="1" set="method" line="161">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Create a new entity</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n="editable"/>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<class path="Project" params="" file="/home/runner/work/api-docs/api-docs/src/Project.hx">
		<extends path="ceramic.Entity"/>
		<ready set="method" line="25"><f a=""><x path="Void"/></f></ready>
		<new set="method" line="10"><f a="settings">
	<c path="ceramic.InitSettings"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="Reflect" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/Reflect.hx">
		<hasField public="1" set="method" line="34" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="43" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.</haxe_doc>
		</field>
		<setField public="1" set="method" line="52" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" line="60" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="71" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" line="81" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Call a method `func` with the given arguments `args`.

		The object `o` is ignored in most cases. It serves as the `this`-context in the following
		situations:

		* (neko) Allows switching the context to `o` in all cases.
		* (macro) Same as neko for Haxe 3. No context switching in Haxe 4.
		* (js, lua) Require the `o` argument if `func` does not, but should have a context.
			This can occur by accessing a function field natively, e.g. through `Reflect.field`
			or by using `(object : Dynamic).field`. However, if `func` has a context, `o` is
			ignored like on other targets.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="87" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<instanceFields set="method" line="100" static="1"><f a="c">
	<x path="Class"><d/></x>
	<c path="Array"><c path="String"/></c>
</f></instanceFields>
		<isFunction public="1" get="inline" set="null" line="111" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="115" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="120" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>cs.internal.Closure</e></m></meta>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are null, the result is false.
		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.

		If `f1` or `f2` are member method closures, the result is true if they
		are closures of the same method on the same object value, false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="134" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="138" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" line="142" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<makeVarArgs public="1" set="method" line="159" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method"><f a="f">
	<f a="">
		<c path="Array"><d/></c>
		<x path="Void"/>
	</f>
	<d/>
</f></makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/Std.hx">
		<isOfType public="1" set="method" line="34" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</isOfType>
		<string public="1" set="method" line="71" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="80" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<isSpaceChar get="inline" set="null" line="85" static="1"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isSpaceChar>
		<isHexPrefix get="inline" set="null" line="88" static="1"><f a="cur:next">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></isHexPrefix>
		<isDecimalDigit get="inline" set="null" line="91" static="1"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isDecimalDigit>
		<isHexadecimalDigit get="inline" set="null" line="94" static="1"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isHexadecimalDigit>
		<parseInt public="1" set="method" line="96" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		`x` may optionally start with a + or - to denote a postive or negative value respectively.

		If the optional sign is followed 0x or 0X, hexadecimal notation is recognized where the following
		digits may contain 0-9 and A-F. Both the prefix and digits are case insensitive.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. Octal and binary
		notations are not supported.

		Parsing continues until an invalid character is detected, in which case the result up to
		that point is returned. Scientific notation is not supported. That is `Std.parseInt('10e2')` produces `10`.

		If `x` is `null`, the result is `null`.
		If `x` cannot be parsed as integer or is empty, the result is `null`.

		If `x` starts with a hexadecimal prefix which is not followed by at least one valid hexadecimal
		digit, the result is unspecified.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="154" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of `null`. Also, hexadecimal support is **not** specified.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.

		It may also end with `e` or `E` followed by optional minus or plus sign and a sequence of
		digits (defines exponent to base 10).</haxe_doc>
		</parseFloat>
		<downcast public="1" params="T:S" get="inline" set="null" line="200" static="1">
			<f a="value:c">
				<c path="downcast.T"/>
				<x path="Class"><c path="downcast.S"/></x>
				<c path="downcast.S"/>
			</f>
			<haxe_doc>Checks if object `value` is an instance of class or interface `c`.

		Compiles only if the type specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the type specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with core types such as `String`,
		`Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</downcast>
		<instance public="1" params="T:S" get="inline" set="null" line="205" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<meta><m n=":deprecated"><e>"Std.instance() is deprecated. Use Std.downcast() instead."</e></m></meta>
		</instance>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":coreApi"/>
			<m n=":nativeGen"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Float" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":hxGen"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":hxGen"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Single" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><x path="Float"/></icast></from>
		<this><x path="Single"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc>Single-precision IEEE 32bit float (4-byte).</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":hxGen"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":hxGen"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="Iterable" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="ArrayAccess" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1">
		<haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="String" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/String.hx" extern="1">
		<Compare set="method" static="1">
			<f a="s1:s2">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":overload"/></meta>
			<overloads><Compare set="method">
	<f a="s1:s2:kind">
		<c path="String"/>
		<c path="String"/>
		<e path="cs.system.StringComparison"/>
		<x path="Int"/>
	</f>
	<meta><m n=":overload"/></meta>
</Compare></overloads>
		</Compare>
		<CompareOrdinal set="method" static="1"><f a="s1:s2">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
</f></CompareOrdinal>
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<IndexOf set="method"><f a="value:startIndex:comparisonType">
	<c path="String"/>
	<x path="Int"/>
	<e path="cs.system.StringComparison"/>
	<x path="Int"/>
</f></IndexOf>
		<Replace set="method"><f a="oldValue:newValue">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></Replace>
		<StartsWith set="method"><f a="value">
	<c path="String"/>
	<x path="Bool"/>
</f></StartsWith>
		<EndsWith set="method"><f a="value">
	<c path="String"/>
	<x path="Bool"/>
</f></EndsWith>
		<TrimStart set="method"><f a=""><c path="String"/></f></TrimStart>
		<TrimEnd set="method"><f a=""><c path="String"/></f></TrimEnd>
		<Trim set="method"><f a=""><c path="String"/></f></Trim>
		<CompareTo set="method"><f a="obj">
	<d/>
	<x path="Int"/>
</f></CompareTo>
		<Substring set="method">
			<f a="startIndex:length">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<overloads><Substring set="method"><f a="startIndex">
	<x path="Int"/>
	<c path="String"/>
</f></Substring></overloads>
		</Substring>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="StringBuf" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/StringBuf.hx">
		<b><c path="cs.system.text.StringBuilder"/></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="35"><f a=""><x path="Int"/></f></get_length>
		<add public="1" params="T" get="inline" set="null" line="39">
			<f a="x">
				<c path="add.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of `x` to `this` StringBuf.

		The exact representation of `x` may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).

		If `x` is null, the String "null" is appended.</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="43">
			<f a="s:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends a substring of `s` to `this` StringBuf.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.add(s.substr(pos,len))` can be used instead.

		If `s` or `pos` are null, the result is unspecified.

		If `len` is omitted or null, the substring ranges from `pos` to the end
		of `s`.</haxe_doc>
		</addSub>
		<addChar public="1" set="method" line="48">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Appends the character identified by `c` to `this` StringBuf.

		If `c` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="57">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of `this` StringBuf as String.

		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<new public="1" get="inline" set="null" line="31">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.SysTools" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/SysTools.hx">
		<winMetaCharacters final="1" public="1" set="null" expr="[&quot; &quot;.code, &quot;(&quot;.code, &quot;)&quot;.code, &quot;%&quot;.code, &quot;!&quot;.code, &quot;^&quot;.code, &quot;\&quot;&quot;.code, &quot;&lt;&quot;.code, &quot;&gt;&quot;.code, &quot;&amp;&quot;.code, &quot;|&quot;.code, &quot;\n&quot;.code, &quot;\r&quot;.code, &quot;,&quot;.code, &quot;;&quot;.code]" line="9" static="1">
			<x path="haxe.ds.ReadOnlyArray"><x path="Int"/></x>
			<meta><m n=":value"><e><![CDATA[[" ".code, "(".code, ")".code, "%".code, "!".code, "^".code, "\"".code, "<".code, ">".code, "&".code, "|".code, "\n".code, "\r".code, ",".code, ";".code]]]></e></m></meta>
			<haxe_doc>Character codes of the characters that will be escaped by `quoteWinArg(_, true)`.</haxe_doc>
		</winMetaCharacters>
		<quoteWinArg public="1" set="method" line="46" static="1">
			<f a="argument:escapeMetaCharacters">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Windows.
		The input will be quoted, or escaped if necessary, such that the output
		will be parsed as a single argument using the rule specified in
		http://msdn.microsoft.com/en-us/library/ms880421

		Examples:
		```haxe
		quoteWinArg("abc") == "abc";
		quoteWinArg("ab c") == '"ab c"';
		```</haxe_doc>
		</quoteWinArg>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/StringTools.hx">
		<urlEncode public="1" get="inline" set="null" line="42" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" get="inline" set="null" line="110" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="158" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:

		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;

		If `quotes` is true, the following characters are also replaced:

		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<startsWith public="1" get="inline" set="null" line="226" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is `null`, the result is unspecified.

		If `start` is the empty String `""`, the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" get="inline" set="null" line="251" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is `null`, the result is unspecified.

		If `end` is the empty String `""`, the result is true.</haxe_doc>
		</endsWith>
		<ltrim public="1" get="inline" set="null" line="300" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<trim public="1" get="inline" set="null" line="347" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for `ltrim(rtrim(s))`.</haxe_doc>
		</trim>
		<lpad public="1" set="method" line="369" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String `""` or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="416" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s` except the last one. If `by` is also the empty String `""`, `s`
		remains unchanged.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="438" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its `length` equals `digits`.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="480" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the character code at position `index` of String `s`, or an
		end-of-file indicator at if `position` equals `s.length`.

		This method is faster than `String.charCodeAt()` on some platforms, but
		the result is unspecified if `index` is negative or greater than
		`s.length`.

		End of file status can be checked by calling `StringTools.isEof()` with
		the returned value as argument.

		This operation is not guaranteed to work if `s` contains the `\0`
		character.</haxe_doc>
		</fastCodeAt>
		<unsafeCodeAt public="1" get="inline" set="null" line="519" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the character code at position `index` of String `s`, or an
		end-of-file indicator at if `position` equals `s.length`.

		This method is faster than `String.charCodeAt()` on some platforms, but
		the result is unspecified if `index` is negative or greater than
		`s.length`.

		This operation is not guaranteed to work if `s` contains the `\0`
		character.</haxe_doc>
		</unsafeCodeAt>
		<isEof public="1" get="inline" set="null" line="572" static="1">
			<f a="c">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>Tells if `c` represents the end-of-file (EOF) character.</haxe_doc>
		</isEof>
		<utf16CodePointAt get="inline" set="null" line="636" static="1"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></utf16CodePointAt>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="Sys" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/Sys.hx">
		<_args static="1"><c path="Array"><c path="String"/></c></_args>
		<println public="1" get="inline" set="null" line="35" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Prints any value to the standard output, followed by a newline.
		On Windows, this function outputs a CRLF newline.
		LF newlines are printed on all other platforms.</haxe_doc>
		</println>
		<args public="1" set="method" line="39" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed in the command line.
		This does not include the interpreter or the name of the program file.

		(java)(eval) On Windows, non-ASCII Unicode arguments will not work correctly.

		(cs) Non-ASCII Unicode arguments will not work correctly.</haxe_doc>
		</args>
		<getEnv public="1" get="inline" set="null" line="48" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable, or `null` if it
		doesn't exist.</haxe_doc>
		</getEnv>
		<sleep public="1" get="inline" set="null" line="65" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspends execution for the given length of time (in seconds).</haxe_doc>
		</sleep>
		<getCwd public="1" get="inline" set="null" line="74" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Gets the current working directory (usually the one in which the program was started).</haxe_doc>
		</getCwd>
		<setCwd public="1" get="inline" set="null" line="78" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the current working directory.

		(java) This functionality is not available on Java; calling this function will throw.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="82" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the type of the current system. Possible values are:
		 - `"Windows"`
		 - `"Linux"`
		 - `"BSD"`
		 - `"Mac"`</haxe_doc>
		</systemName>
		<exit public="1" get="inline" set="null" line="121" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exits the current process with the given exit code.

		(macro)(eval) Being invoked in a macro or eval context (e.g. with `-x` or `--run`) immediately terminates
		the compilation process, which also prevents the execution of any `--next` sections of compilation arguments.</haxe_doc>
		</exit>
		<epochTicks expr="new cs.system.DateTime(1970, 1, 1).Ticks" line="125" static="1">
			<x path="haxe.Int64"/>
			<meta>
				<m n=":value"><e>new cs.system.DateTime(1970, 1, 1).Ticks</e></m>
				<m n=":readOnly"/>
			</meta>
		</epochTicks>
		<time public="1" set="method" line="127" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value available (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" get="inline" set="null" line="131" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value available (in seconds),
		but only accounts for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<haxe_doc>This class provides access to various base functions of system platforms.
	Look in the `sys` package for more system APIs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<enum path="ValueType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<class path="cs.system.ICloneable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ICloneable" extern="1" interface="1">
		<Clone public="1" set="method"><f a=""><d/></f></Clone>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ICloneable"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.IEnumerable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.IEnumerable" extern="1" interface="1">
		<GetEnumerator public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.IEnumerable"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ICollection" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ICollection" extern="1" interface="1">
		<extends path="cs.system.collections.IEnumerable"/>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<get_Count public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_IsSynchronized public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_SyncRoot public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<CopyTo public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ICollection"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.IList" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.IList" extern="1" interface="1">
		<extends path="cs.system.collections.ICollection"/>
		<extends path="cs.system.collections.IEnumerable"/>
		<extends path="ArrayAccess"><d/></extends>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<IsFixedSize public="1" get="accessor" set="null"><x path="Bool"/></IsFixedSize>
		<get_IsFixedSize public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<get_IsReadOnly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_Item public="1" set="method"><f a="index">
	<x path="Int"/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<Add public="1" set="method"><f a="value">
	<d/>
	<x path="Int"/>
</f></Add>
		<Clear public="1" set="method"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></Contains>
		<IndexOf public="1" set="method"><f a="value">
	<d/>
	<x path="Int"/>
</f></IndexOf>
		<Insert public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></Insert>
		<Remove public="1" set="method"><f a="value">
	<d/>
	<x path="Void"/>
</f></Remove>
		<RemoveAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveAt>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.IList"</e></m>
		</meta>
	</class>
	<class path="cs.system.Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Array" extern="1" abstract="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<implements path="cs.system.collections.IList"/>
		<CreateInstance public="1" set="method" static="1">
			<f a="elementType:length">
				<c path="cs.system.Type"/>
				<x path="Int"/>
				<c path="cs.system.Array"/>
			</f>
			<overloads>
				<CreateInstance public="1" set="method"><f a="elementType:lengths">
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><x path="haxe.Int64"/></c>
	<c path="cs.system.Array"/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="elementType:lengths:lowerBounds">
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><x path="Int"/></c>
	<c path="cs.NativeArray"><x path="Int"/></c>
	<c path="cs.system.Array"/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="elementType:lengths">
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><x path="Int"/></c>
	<c path="cs.system.Array"/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="elementType:length1:length2:length3">
	<c path="cs.system.Type"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.Array"/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="elementType:length1:length2">
	<c path="cs.system.Type"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.Array"/>
</f></CreateInstance>
			</overloads>
		</CreateInstance>
		<BinarySearch public="1" set="method" static="1">
			<f a="array:value">
				<c path="cs.system.Array"/>
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<BinarySearch public="1" params="M0" set="method"><f a="array:index:length:value:comparer">
	<c path="cs.NativeArray"><c path="BinarySearch.M0"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="BinarySearch.M0"/>
	<c path="cs.system.collections.generic.IComparer_1"><c path="BinarySearch.M0"/></c>
	<x path="Int"/>
</f></BinarySearch>
				<BinarySearch public="1" params="M0" set="method"><f a="array:index:length:value">
	<c path="cs.NativeArray"><c path="BinarySearch.M0"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="BinarySearch.M0"/>
	<x path="Int"/>
</f></BinarySearch>
				<BinarySearch public="1" params="M0" set="method"><f a="array:value:comparer">
	<c path="cs.NativeArray"><c path="BinarySearch.M0"/></c>
	<c path="BinarySearch.M0"/>
	<c path="cs.system.collections.generic.IComparer_1"><c path="BinarySearch.M0"/></c>
	<x path="Int"/>
</f></BinarySearch>
				<BinarySearch public="1" params="M0" set="method"><f a="array:value">
	<c path="cs.NativeArray"><c path="BinarySearch.M0"/></c>
	<c path="BinarySearch.M0"/>
	<x path="Int"/>
</f></BinarySearch>
				<BinarySearch public="1" set="method"><f a="array:index:length:value:comparer">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Int"/>
</f></BinarySearch>
				<BinarySearch public="1" set="method"><f a="array:index:length:value">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<x path="Int"/>
</f></BinarySearch>
				<BinarySearch public="1" set="method"><f a="array:value:comparer">
	<c path="cs.system.Array"/>
	<d/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Int"/>
</f></BinarySearch>
			</overloads>
		</BinarySearch>
		<Clear public="1" set="method" static="1">
			<f a="array:index:length">
				<c path="cs.system.Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</Clear>
		<Copy public="1" set="method" static="1">
			<f a="sourceArray:destinationArray:length">
				<c path="cs.system.Array"/>
				<c path="cs.system.Array"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<Copy public="1" set="method"><f a="sourceArray:destinationArray:length">
	<c path="cs.system.Array"/>
	<c path="cs.system.Array"/>
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></Copy>
				<Copy public="1" set="method"><f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
	<c path="cs.system.Array"/>
	<x path="haxe.Int64"/>
	<c path="cs.system.Array"/>
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></Copy>
				<Copy public="1" set="method"><f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Copy>
			</overloads>
		</Copy>
		<IndexOf public="1" set="method" static="1">
			<f a="array:value">
				<c path="cs.system.Array"/>
				<d/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
			<overloads>
				<IndexOf public="1" params="M0" set="method">
					<f a="array:value:startIndex:count">
						<c path="cs.NativeArray"><c path="IndexOf.M0"/></c>
						<c path="IndexOf.M0"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<meta>
						<m n=":noCompletion"/>
						<m n=":skipReflection"/>
					</meta>
				</IndexOf>
				<IndexOf public="1" params="M0" set="method">
					<f a="array:value:startIndex">
						<c path="cs.NativeArray"><c path="IndexOf.M0"/></c>
						<c path="IndexOf.M0"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<meta>
						<m n=":noCompletion"/>
						<m n=":skipReflection"/>
					</meta>
				</IndexOf>
				<IndexOf public="1" params="M0" set="method">
					<f a="array:value">
						<c path="cs.NativeArray"><c path="IndexOf.M0"/></c>
						<c path="IndexOf.M0"/>
						<x path="Int"/>
					</f>
					<meta>
						<m n=":noCompletion"/>
						<m n=":skipReflection"/>
					</meta>
				</IndexOf>
				<IndexOf public="1" set="method">
					<f a="array:value:startIndex:count">
						<c path="cs.system.Array"/>
						<d/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<meta>
						<m n=":noCompletion"/>
						<m n=":skipReflection"/>
					</meta>
				</IndexOf>
				<IndexOf public="1" set="method">
					<f a="array:value:startIndex">
						<c path="cs.system.Array"/>
						<d/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<meta>
						<m n=":noCompletion"/>
						<m n=":skipReflection"/>
					</meta>
				</IndexOf>
			</overloads>
		</IndexOf>
		<LastIndexOf public="1" set="method" static="1">
			<f a="array:value">
				<c path="cs.system.Array"/>
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<LastIndexOf public="1" params="M0" set="method"><f a="array:value:startIndex:count">
	<c path="cs.NativeArray"><c path="LastIndexOf.M0"/></c>
	<c path="LastIndexOf.M0"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" params="M0" set="method"><f a="array:value:startIndex">
	<c path="cs.NativeArray"><c path="LastIndexOf.M0"/></c>
	<c path="LastIndexOf.M0"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" params="M0" set="method"><f a="array:value">
	<c path="cs.NativeArray"><c path="LastIndexOf.M0"/></c>
	<c path="LastIndexOf.M0"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="array:value:startIndex:count">
	<c path="cs.system.Array"/>
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="array:value:startIndex">
	<c path="cs.system.Array"/>
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
			</overloads>
		</LastIndexOf>
		<Reverse public="1" set="method" static="1">
			<f a="array">
				<c path="cs.system.Array"/>
				<x path="Void"/>
			</f>
			<overloads><Reverse public="1" set="method"><f a="array:index:length">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Reverse></overloads>
		</Reverse>
		<Sort public="1" set="method" static="1">
			<f a="array">
				<c path="cs.system.Array"/>
				<x path="Void"/>
			</f>
			<overloads>
				<Sort public="1" params="M0" set="method"><f a="array:comparison">
	<c path="cs.NativeArray"><c path="Sort.M0"/></c>
	<x path="cs.system.Comparison_1"><c path="Sort.M0"/></x>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" params="M0:M1" set="method"><f a="keys:items:index:length:comparer">
	<c path="cs.NativeArray"><c path="Sort.M0"/></c>
	<c path="cs.NativeArray"><c path="Sort.M1"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.generic.IComparer_1"><c path="Sort.M0"/></c>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" params="M0" set="method"><f a="array:index:length:comparer">
	<c path="cs.NativeArray"><c path="Sort.M0"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.generic.IComparer_1"><c path="Sort.M0"/></c>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" params="M0:M1" set="method"><f a="keys:items:index:length">
	<c path="cs.NativeArray"><c path="Sort.M0"/></c>
	<c path="cs.NativeArray"><c path="Sort.M1"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" params="M0" set="method"><f a="array:index:length">
	<c path="cs.NativeArray"><c path="Sort.M0"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" params="M0:M1" set="method"><f a="keys:items:comparer">
	<c path="cs.NativeArray"><c path="Sort.M0"/></c>
	<c path="cs.NativeArray"><c path="Sort.M1"/></c>
	<c path="cs.system.collections.generic.IComparer_1"><c path="Sort.M0"/></c>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" params="M0" set="method"><f a="array:comparer">
	<c path="cs.NativeArray"><c path="Sort.M0"/></c>
	<c path="cs.system.collections.generic.IComparer_1"><c path="Sort.M0"/></c>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" params="M0:M1" set="method"><f a="keys:items">
	<c path="cs.NativeArray"><c path="Sort.M0"/></c>
	<c path="cs.NativeArray"><c path="Sort.M1"/></c>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" params="M0" set="method"><f a="array">
	<c path="cs.NativeArray"><c path="Sort.M0"/></c>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="keys:items:index:length:comparer">
	<c path="cs.system.Array"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="array:index:length:comparer">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="keys:items:index:length">
	<c path="cs.system.Array"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="keys:items:comparer">
	<c path="cs.system.Array"/>
	<c path="cs.system.Array"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="array:index:length">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="array:comparer">
	<c path="cs.system.Array"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="keys:items">
	<c path="cs.system.Array"/>
	<c path="cs.system.Array"/>
	<x path="Void"/>
</f></Sort>
			</overloads>
		</Sort>
		<Resize public="1" params="M0" set="method" static="1"><f a="array:newSize">
	<t path="cs.Ref"><c path="cs.NativeArray"><c path="Resize.M0"/></c></t>
	<x path="Int"/>
	<x path="Void"/>
</f></Resize>
		<TrueForAll public="1" params="M0" set="method" static="1"><f a="array:match">
	<c path="cs.NativeArray"><c path="TrueForAll.M0"/></c>
	<x path="cs.system.Predicate_1"><c path="TrueForAll.M0"/></x>
	<x path="Bool"/>
</f></TrueForAll>
		<ForEach public="1" params="M0" set="method" static="1"><f a="array:action">
	<c path="cs.NativeArray"><c path="ForEach.M0"/></c>
	<x path="cs.system.Action_1"><c path="ForEach.M0"/></x>
	<x path="Void"/>
</f></ForEach>
		<ConvertAll public="1" params="M0:M1" set="method" static="1"><f a="array:converter">
	<c path="cs.NativeArray"><c path="ConvertAll.M0"/></c>
	<x path="cs.system.Converter_2">
		<c path="ConvertAll.M0"/>
		<c path="ConvertAll.M1"/>
	</x>
	<c path="cs.NativeArray"><c path="ConvertAll.M1"/></c>
</f></ConvertAll>
		<FindLastIndex public="1" params="M0" set="method" static="1">
			<f a="array:match">
				<c path="cs.NativeArray"><c path="FindLastIndex.M0"/></c>
				<x path="cs.system.Predicate_1"><c path="FindLastIndex.M0"/></x>
				<x path="Int"/>
			</f>
			<overloads>
				<FindLastIndex public="1" params="M0" set="method"><f a="array:startIndex:count:match">
	<c path="cs.NativeArray"><c path="FindLastIndex.M0"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="cs.system.Predicate_1"><c path="FindLastIndex.M0"/></x>
	<x path="Int"/>
</f></FindLastIndex>
				<FindLastIndex public="1" params="M0" set="method"><f a="array:startIndex:match">
	<c path="cs.NativeArray"><c path="FindLastIndex.M0"/></c>
	<x path="Int"/>
	<x path="cs.system.Predicate_1"><c path="FindLastIndex.M0"/></x>
	<x path="Int"/>
</f></FindLastIndex>
			</overloads>
		</FindLastIndex>
		<FindIndex public="1" params="M0" set="method" static="1">
			<f a="array:match">
				<c path="cs.NativeArray"><c path="FindIndex.M0"/></c>
				<x path="cs.system.Predicate_1"><c path="FindIndex.M0"/></x>
				<x path="Int"/>
			</f>
			<overloads>
				<FindIndex public="1" params="M0" set="method"><f a="array:startIndex:count:match">
	<c path="cs.NativeArray"><c path="FindIndex.M0"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="cs.system.Predicate_1"><c path="FindIndex.M0"/></x>
	<x path="Int"/>
</f></FindIndex>
				<FindIndex public="1" params="M0" set="method"><f a="array:startIndex:match">
	<c path="cs.NativeArray"><c path="FindIndex.M0"/></c>
	<x path="Int"/>
	<x path="cs.system.Predicate_1"><c path="FindIndex.M0"/></x>
	<x path="Int"/>
</f></FindIndex>
			</overloads>
		</FindIndex>
		<FindAll public="1" params="M0" set="method" static="1"><f a="array:match">
	<c path="cs.NativeArray"><c path="FindAll.M0"/></c>
	<x path="cs.system.Predicate_1"><c path="FindAll.M0"/></x>
	<c path="cs.NativeArray"><c path="FindAll.M0"/></c>
</f></FindAll>
		<Exists public="1" params="M0" set="method" static="1"><f a="array:match">
	<c path="cs.NativeArray"><c path="Exists.M0"/></c>
	<x path="cs.system.Predicate_1"><c path="Exists.M0"/></x>
	<x path="Bool"/>
</f></Exists>
		<AsReadOnly public="1" params="M0" set="method" static="1"><f a="array">
	<c path="cs.NativeArray"><c path="AsReadOnly.M0"/></c>
	<c path="cs.system.collections.objectmodel.ReadOnlyCollection_1"><c path="AsReadOnly.M0"/></c>
</f></AsReadOnly>
		<Find public="1" params="M0" set="method" static="1"><f a="array:match">
	<c path="cs.NativeArray"><c path="Find.M0"/></c>
	<x path="cs.system.Predicate_1"><c path="Find.M0"/></x>
	<c path="Find.M0"/>
</f></Find>
		<FindLast public="1" params="M0" set="method" static="1"><f a="array:match">
	<c path="cs.NativeArray"><c path="FindLast.M0"/></c>
	<x path="cs.system.Predicate_1"><c path="FindLast.M0"/></x>
	<c path="FindLast.M0"/>
</f></FindLast>
		<ConstrainedCopy public="1" set="method" static="1"><f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></ConstrainedCopy>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<IsFixedSize public="1" get="accessor" set="null"><x path="Bool"/></IsFixedSize>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<Rank public="1" get="accessor" set="null"><x path="Int"/></Rank>
		<LongLength public="1" get="accessor" set="null"><x path="haxe.Int64"/></LongLength>
		<Length public="1" get="accessor" set="null"><x path="Int"/></Length>
		<get_Length final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Length>
		<get_LongLength final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_LongLength>
		<get_Rank final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Rank>
		<GetLength final="1" public="1" set="method"><f a="dimension">
	<x path="Int"/>
	<x path="Int"/>
</f></GetLength>
		<GetLongLength final="1" public="1" set="method"><f a="dimension">
	<x path="Int"/>
	<x path="haxe.Int64"/>
</f></GetLongLength>
		<GetLowerBound final="1" public="1" set="method"><f a="dimension">
	<x path="Int"/>
	<x path="Int"/>
</f></GetLowerBound>
		<GetValue final="1" public="1" set="method">
			<f a="indices">
				<c path="cs.NativeArray"><x path="Int"/></c>
				<d/>
			</f>
			<overloads>
				<GetValue final="1" public="1" set="method"><f a="indices">
	<c path="cs.NativeArray"><x path="haxe.Int64"/></c>
	<d/>
</f></GetValue>
				<GetValue final="1" public="1" set="method"><f a="index1:index2:index3">
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
	<d/>
</f></GetValue>
				<GetValue final="1" public="1" set="method"><f a="index1:index2">
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
	<d/>
</f></GetValue>
				<GetValue final="1" public="1" set="method"><f a="index">
	<x path="haxe.Int64"/>
	<d/>
</f></GetValue>
				<GetValue final="1" public="1" set="method"><f a="index1:index2:index3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></GetValue>
				<GetValue final="1" public="1" set="method"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></GetValue>
				<GetValue final="1" public="1" set="method"><f a="index">
	<x path="Int"/>
	<d/>
</f></GetValue>
			</overloads>
		</GetValue>
		<SetValue final="1" public="1" set="method">
			<f a="value:indices">
				<d/>
				<c path="cs.NativeArray"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads>
				<SetValue final="1" public="1" set="method"><f a="value:indices">
	<d/>
	<c path="cs.NativeArray"><x path="haxe.Int64"/></c>
	<x path="Void"/>
</f></SetValue>
				<SetValue final="1" public="1" set="method"><f a="value:index1:index2:index3">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></SetValue>
				<SetValue final="1" public="1" set="method"><f a="value:index1:index2">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></SetValue>
				<SetValue final="1" public="1" set="method"><f a="value:index">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></SetValue>
				<SetValue final="1" public="1" set="method"><f a="value:index1:index2:index3">
	<d/>
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></SetValue>
				<SetValue final="1" public="1" set="method"><f a="value:index1:index2">
	<d/>
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></SetValue>
				<SetValue final="1" public="1" set="method"><f a="value:index">
	<d/>
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></SetValue>
			</overloads>
		</SetValue>
		<get_IsSynchronized final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_SyncRoot final="1" public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<get_IsFixedSize final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<get_IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<GetEnumerator final="1" public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<GetUpperBound final="1" public="1" set="method"><f a="dimension">
	<x path="Int"/>
	<x path="Int"/>
</f></GetUpperBound>
		<Clone final="1" public="1" set="method"><f a=""><d/></f></Clone>
		<Initialize final="1" public="1" set="method"><f a=""><x path="Void"/></f></Initialize>
		<CopyTo final="1" public="1" set="method">
			<f a="array:index">
				<c path="cs.system.Array"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads><CopyTo final="1" public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></CopyTo></overloads>
		</CopyTo>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Array"</e></m>
		</meta>
	</class>
	<class path="cs.NativeArray" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/NativeArray.hx" extern="1">
		<extends path="cs.system.Array"/>
		<make public="1" params="T" set="method" static="1">
			<f a="elements">
				<t path="haxe.extern.Rest"><c path="make.T"/></t>
				<c path="cs.NativeArray"><c path="make.T"/></c>
			</f>
			<haxe_doc>Creates a new array with the specified elements.

		Usage:
		```haxe
		var elements = NativeArray.make(1,2,3,4,5,6);
		```</haxe_doc>
		</make>
		<Reverse public="1" set="method" static="1"><f a="arr">
	<c path="cs.system.Array"/>
	<x path="Void"/>
</f></Reverse>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>Alias to array's `Length` property. Returns the size of the array</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="52"><f a=""><x path="Int"/></f></get_length>
		<iterator public="1" get="inline" set="null" line="60">
			<f a=""><c path="cs._NativeArray.NativeArrayIterator"><c path="cs.NativeArray.T"/></c></f>
			<haxe_doc>Returns an iterator so it's possible to use `for` with C#'s `NativeArray`</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allocates a new array with size `len`</haxe_doc>
		</new>
		<haxe_doc>Represents a C# fixed-size Array (`T[]`)</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
		</meta>
	</class>
	<enum path="cs.internal.EmptyObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/Runtime.hx" module="cs.internal.Runtime">
		<EMPTY/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":nativeGen"/>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.EmptyObject"</e></m>
		</meta>
	</enum>
	<class path="Type" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="46" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getSuperClass public="1" set="method" line="61" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="68" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="87" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="96" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="146" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="154" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<__createEmptyInstance_EMPTY_ARGS expr="cs.NativeArray.make(((cs.internal.Runtime.EmptyObject.EMPTY : Any)))" line="167" static="1">
			<c path="cs.NativeArray"><x path="Any"/></c>
			<meta>
				<m n=":value"><e>cs.NativeArray.make(((cs.internal.Runtime.EmptyObject.EMPTY : Any)))</e></m>
				<m n=":protected"/>
				<m n=":readOnly"/>
			</meta>
		</__createEmptyInstance_EMPTY_ARGS>
		<createEmptyInstance public="1" params="T" set="method" line="169" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="189" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<getInstanceFields public="1" set="method" line="205" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`, including
		inherited fields.

		This only includes fields which are known at compile-time. In
		particular, using `getInstanceFields(getClass(obj))` will not include
		any fields which were added to `obj` at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="228" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.

		This does not include static fields of parent classes.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="244" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="256" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="305" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"has_enum"</e></m>
			</meta>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="314" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="318" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" line="324" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<meta><m n=":ifFeature"><e>"has_enum"</e></m></meta>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="333" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":transitive"/>
		</meta>
		<impl><class path="_UInt.UInt_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/UInt.hx" private="1" module="UInt" final="1">
	<add get="inline" set="null" line="135" static="1">
		<f a="a:b">
			<x path="UInt"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</add>
	<gt get="inline" set="null" line="152" static="1">
		<f a="a:b">
			<x path="UInt"/>
			<x path="UInt"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gt>
	<gte get="inline" set="null" line="159" static="1">
		<f a="a:b">
			<x path="UInt"/>
			<x path="UInt"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gte>
	<lt get="inline" set="null" line="165" static="1">
		<f a="a:b">
			<x path="UInt"/>
			<x path="UInt"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</lt>
	<shl get="inline" set="null" line="185" static="1">
		<f a="a:b">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="UInt"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
	</shl>
	<equalsInt params="T" get="inline" set="null" line="229" static="1">
		<f a="a:b">
			<x path="UInt"/>
			<c path="equalsInt.T"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":commutative"/>
			<m n=":op"><e>A == B</e></m>
		</meta>
	</equalsInt>
	<equalsFloat params="T" get="inline" set="null" line="237" static="1">
		<f a="a:b">
			<x path="UInt"/>
			<c path="equalsFloat.T"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":commutative"/>
			<m n=":op"><e>A == B</e></m>
		</meta>
	</equalsFloat>
	<floatGte get="inline" set="null" line="253" static="1">
		<f a="a:b">
			<x path="Float"/>
			<x path="UInt"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</floatGte>
	<floatLte get="inline" set="null" line="269" static="1">
		<f a="a:b">
			<x path="Float"/>
			<x path="UInt"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</floatLte>
	<postfixIncrement get="inline" set="null" line="289" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="UInt"/>
		</f>
		<meta><m n=":op"><e>A++</e></m></meta>
	</postfixIncrement>
	<toInt get="inline" set="null" line="306" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></toInt>
	<toFloat get="inline" set="null" line="310" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":to"/></meta>
	</toFloat>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="_UInt.UInt_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/UInt.hx" private="1" module="UInt" final="1">
		<add get="inline" set="null" line="135" static="1">
			<f a="a:b">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</add>
		<gt get="inline" set="null" line="152" static="1">
			<f a="a:b">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gt>
		<gte get="inline" set="null" line="159" static="1">
			<f a="a:b">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gte>
		<lt get="inline" set="null" line="165" static="1">
			<f a="a:b">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</lt>
		<shl get="inline" set="null" line="185" static="1">
			<f a="a:b">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
		</shl>
		<equalsInt params="T" get="inline" set="null" line="229" static="1">
			<f a="a:b">
				<x path="UInt"/>
				<c path="equalsInt.T"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":commutative"/>
				<m n=":op"><e>A == B</e></m>
			</meta>
		</equalsInt>
		<equalsFloat params="T" get="inline" set="null" line="237" static="1">
			<f a="a:b">
				<x path="UInt"/>
				<c path="equalsFloat.T"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":commutative"/>
				<m n=":op"><e>A == B</e></m>
			</meta>
		</equalsFloat>
		<floatGte get="inline" set="null" line="253" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</floatGte>
		<floatLte get="inline" set="null" line="269" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</floatLte>
		<postfixIncrement get="inline" set="null" line="289" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":op"><e>A++</e></m></meta>
		</postfixIncrement>
		<toInt get="inline" set="null" line="306" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></toInt>
		<toFloat get="inline" set="null" line="310" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":to"/></meta>
		</toFloat>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="XmlType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Xml.hx" module="Xml">
		<this><x path="Int"/></this>
		<haxe_doc>Xml node types.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="_Xml.XmlType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Xml.hx" private="1" module="Xml" final="1">
	<toString public="1" set="method" line="64" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="_Xml.XmlType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Xml.hx" private="1" module="Xml" final="1">
		<toString public="1" set="method" line="64" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="Xml" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/Xml.hx">
		<Element public="1" set="null" expr="XmlType.Element" line="86" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Element</e></m></meta>
			<haxe_doc>XML element type.</haxe_doc>
		</Element>
		<PCData public="1" set="null" expr="XmlType.PCData" line="91" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.PCData</e></m></meta>
			<haxe_doc>XML parsed character data type.</haxe_doc>
		</PCData>
		<CData public="1" set="null" expr="XmlType.CData" line="96" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.CData</e></m></meta>
			<haxe_doc>XML character data type.</haxe_doc>
		</CData>
		<Comment public="1" set="null" expr="XmlType.Comment" line="101" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Comment</e></m></meta>
			<haxe_doc>XML comment type.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" expr="XmlType.DocType" line="106" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.DocType</e></m></meta>
			<haxe_doc>XML doctype element type.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" expr="XmlType.ProcessingInstruction" line="111" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.ProcessingInstruction</e></m></meta>
			<haxe_doc>XML processing instruction type.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" expr="XmlType.Document" line="116" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Document</e></m></meta>
			<haxe_doc>XML document type.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="121" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parses the String into an Xml document.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="182" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="191" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="200" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="209" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="218" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="227" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="236" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<x path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<nodeName public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<parent public="1" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be `null`, an Element or a Document.</haxe_doc>
		</parent>
		<children><c path="Array"><c path="Xml"/></c></children>
		<attributeMap><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></attributeMap>
		<get_nodeName get="inline" set="null" line="151"><f a=""><c path="String"/></f></get_nodeName>
		<set_nodeName get="inline" set="null" line="158"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeName>
		<get_nodeValue get="inline" set="null" line="165"><f a=""><c path="String"/></f></get_nodeValue>
		<set_nodeValue get="inline" set="null" line="172"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeValue>
		<get public="1" set="method" line="244">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns `null` if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<set public="1" set="method" line="255">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<exists public="1" set="method" line="277">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="287">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an `Iterator` on all the attribute names.</haxe_doc>
		</attributes>
		<iterator public="1" get="inline" set="null" line="298">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</iterator>
		<elements public="1" set="method" line="307">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="317">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<firstElement public="1" set="method" line="337">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="353">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		A child node can only be inside one given parent node, which is indicated by the `parent` property.
		If the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.
		If the child node was previously inside a different node, it will be moved to this Document or Element.</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="366">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<toString public="1" get="inline" set="null" line="393">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<ensureElementType get="inline" set="null" line="403"><f a=""><x path="Void"/></f></ensureElementType>
		<new set="method" line="397"><f a="nodeType">
	<x path="XmlType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Cross-platform Xml API.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.ds._Map.Map_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
		<_new public="1" set="method" static="1">
			<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
		</_new>
		<set public="1" get="inline" set="null" line="74" static="1">
			<f a="this:key:value">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Maps `key` to `value`.

		If `key` already has a mapping, the previous value disappears.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="92" static="1">
			<f a="this:key">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<x path="Null"><c path="haxe.ds.Map.V"/></x>
			</f>
			<meta><m n=":arrayAccess"/></meta>
			<haxe_doc>Returns the current mapping of `key`.

		If no such mapping exists, `null` is returned.

		Note that a check like `map.get(key) == null` can hold for two reasons:

		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`

		If it is important to distinguish these cases, `exists()` should be
		used.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="100" static="1">
			<f a="this:key">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `key` has a mapping, false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</exists>
		<remove public="1" get="inline" set="null" line="109" static="1">
			<f a="this:key">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="116" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<t path="Iterator"><c path="haxe.ds.Map.K"/></t>
			</f>
			<haxe_doc>Returns an Iterator over the keys of `this` Map.

		The order of keys is undefined.</haxe_doc>
		</keys>
		<iterator public="1" get="inline" set="null" line="125" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<t path="Iterator"><c path="haxe.ds.Map.V"/></t>
			</f>
			<haxe_doc>Returns an Iterator over the values of `this` Map.

		The order of values is undefined.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="134" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<t path="KeyValueIterator">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</t>
			</f>
			<haxe_doc>Returns an Iterator over the keys and values of `this` Map.

		The order of values is undefined.</haxe_doc>
		</keyValueIterator>
		<copy public="1" get="inline" set="null" line="143" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<x path="haxe.ds.Map">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</x>
			</f>
			<haxe_doc>Returns a shallow copy of `this` map.

		The order of values is undefined.</haxe_doc>
		</copy>
		<clear public="1" get="inline" set="null" line="159" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes all keys from `this` Map.</haxe_doc>
		</clear>
		<toStringMap params="K:V" get="inline" set="null" line="168" static="1">
			<f a="t">
				<c path="haxe.IMap">
					<c path="toStringMap.K"/>
					<c path="toStringMap.V"/>
				</c>
				<c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c>
			</f>
			<meta>
				<m n=":multiType"/>
				<m n=":to"/>
			</meta>
		</toStringMap>
		<toIntMap params="K:V" get="inline" set="null" line="172" static="1">
			<f a="t">
				<c path="haxe.IMap">
					<c path="toIntMap.K"/>
					<c path="toIntMap.V"/>
				</c>
				<c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c>
			</f>
			<meta>
				<m n=":multiType"/>
				<m n=":to"/>
			</meta>
		</toIntMap>
		<fromStringMap params="V" get="inline" set="null" line="184" static="1">
			<f a="map">
				<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
				<x path="haxe.ds.Map">
					<c path="String"/>
					<c path="fromStringMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromStringMap>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Assets" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Assets.hx">
		<extends path="ceramic.Entity"/>
		<instances public="1" expr="[]" line="14" static="1">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.Assets"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
		</instances>
		<all public="1" expr="[]" line="16" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</all>
		<allDirs public="1" expr="[]" line="18" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</allDirs>
		<allByName public="1" expr="new Map()" line="20" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</allByName>
		<allDirsByName public="1" expr="new Map()" line="22" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</allDirsByName>
		<customAssetKinds expr="new Map()" line="73" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.CustomAssetKind"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</customAssetKinds>
		<reloadCountByRealAssetPath expr="null" line="75" static="1">
			<t path="Map">
				<c path="String"/>
				<x path="Int"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</reloadCountByRealAssetPath>
		<lastModifiedByRealAssetPath expr="null" line="77" static="1">
			<t path="Map">
				<c path="String"/>
				<x path="Float"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastModifiedByRealAssetPath>
		<_instances expr="[]" line="89" static="1">
			<c path="Array"><c path="ceramic.Assets"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_instances>
		<flushAllInstancesImmediate public="1" set="method" line="91" static="1"><f a=""><x path="Void"/></f></flushAllInstancesImmediate>
		<decodePath public="1" set="method" line="1119" static="1"><f a="path">
	<c path="String"/>
	<c path="ceramic.AssetPathInfo"/>
</f></decodePath>
		<addAssetKind public="1" set="method" line="1125" static="1"><f a="kind:add:extensions:dir:types">
	<c path="String"/>
	<f a="assets:name:variant:options">
		<c path="ceramic.Assets"/>
		<c path="String"/>
		<c path="String"/>
		<t path="ceramic.AssetOptions"/>
		<x path="Void"/>
	</f>
	<c path="Array"><c path="String"/></c>
	<x path="Bool"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></addAssetKind>
		<getAssetsPath public="1" get="inline" set="null" line="1137" static="1"><f a=""><c path="String"/></f></getAssetsPath>
		<assetNameFromPath public="1" set="method" line="1143" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></assetNameFromPath>
		<realAssetPath public="1" set="method" line="1158" static="1"><f a="path:?runtimeAssets">
	<c path="String"/>
	<c path="ceramic.RuntimeAssets"/>
	<c path="String"/>
</f></realAssetPath>
		<incrementReloadCount set="method" line="1182" static="1"><f a="realAssetPath">
	<c path="String"/>
	<x path="Void"/>
</f></incrementReloadCount>
		<getReloadCount public="1" set="method" line="1196" static="1"><f a="realAssetPath">
	<c path="String"/>
	<x path="Int"/>
</f></getReloadCount>
		<_dox_event_complete public="1" set="method" line="637">
			<f a="success">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_complete>
		<emitComplete set="method" line="1095">
			<f a="success">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>complete event</haxe_doc>
		</emitComplete>
		<onComplete public="1" set="method" line="1199">
			<f a="owner:handleSuccess">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="success">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</onComplete>
		<onceComplete public="1" set="method" line="1298">
			<f a="owner:handleSuccess">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="success">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</onceComplete>
		<offComplete public="1" set="method" line="1368">
			<f a="?handleSuccess">
				<f a="success">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</offComplete>
		<listensComplete public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to complete event</haxe_doc>
		</listensComplete>
		<_dox_event_update public="1" set="method" line="637">
			<f a="asset">
				<c path="ceramic.Asset"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_update>
		<emitUpdate set="method" line="1095">
			<f a="asset">
				<c path="ceramic.Asset"/>
				<x path="Void"/>
			</f>
			<haxe_doc>update event</haxe_doc>
		</emitUpdate>
		<onUpdate public="1" set="method" line="1199">
			<f a="owner:handleAsset">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="asset">
					<c path="ceramic.Asset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onUpdate>
		<onceUpdate public="1" set="method" line="1298">
			<f a="owner:handleAsset">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="asset">
					<c path="ceramic.Asset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onceUpdate>
		<offUpdate public="1" set="method" line="1368">
			<f a="?handleAsset">
				<f a="asset">
					<c path="ceramic.Asset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</offUpdate>
		<listensUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to update event</haxe_doc>
		</listensUpdate>
		<_dox_event_progress public="1" set="method" line="637">
			<f a="loaded:total:success">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_progress>
		<emitProgress set="method" line="1095">
			<f a="loaded:total:success">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>progress event</haxe_doc>
		</emitProgress>
		<onProgress public="1" set="method" line="1199">
			<f a="owner:handleLoadedTotalSuccess">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="loaded:total:success">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>progress event</haxe_doc>
		</onProgress>
		<onceProgress public="1" set="method" line="1298">
			<f a="owner:handleLoadedTotalSuccess">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="loaded:total:success">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>progress event</haxe_doc>
		</onceProgress>
		<offProgress public="1" set="method" line="1368">
			<f a="?handleLoadedTotalSuccess">
				<f a="loaded:total:success">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>progress event</haxe_doc>
		</offProgress>
		<listensProgress public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to progress event</haxe_doc>
		</listensProgress>
		<_dox_event_assetFilesChange public="1" set="method" line="637">
			<f a="newFiles:previousFiles">
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_assetFilesChange>
		<emitAssetFilesChange set="method" line="1095">
			<f a="newFiles:previousFiles">
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>assetFilesChange event</haxe_doc>
		</emitAssetFilesChange>
		<onAssetFilesChange public="1" set="method" line="1199">
			<f a="owner:handleNewFilesPreviousFiles">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newFiles:previousFiles">
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>assetFilesChange event</haxe_doc>
		</onAssetFilesChange>
		<onceAssetFilesChange public="1" set="method" line="1298">
			<f a="owner:handleNewFilesPreviousFiles">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newFiles:previousFiles">
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>assetFilesChange event</haxe_doc>
		</onceAssetFilesChange>
		<offAssetFilesChange public="1" set="method" line="1368">
			<f a="?handleNewFilesPreviousFiles">
				<f a="newFiles:previousFiles">
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>assetFilesChange event</haxe_doc>
		</offAssetFilesChange>
		<listensAssetFilesChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to assetFilesChange event</haxe_doc>
		</listensAssetFilesChange>
		<addedAssets expr="[]" line="36">
			<c path="Array"><c path="ceramic.Asset"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</addedAssets>
		<assetsByKindAndName expr="new Map()" line="38">
			<t path="Map">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<c path="ceramic.Asset"/>
				</t>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</assetsByKindAndName>
		<immediate public="1" set="null" expr="new Immediate()" line="40">
			<c path="ceramic.Immediate"/>
			<meta><m n=":value"><e>new Immediate()</e></m></meta>
		</immediate>
		<runtimeAssets public="1" expr="null" line="45">
			<c path="ceramic.RuntimeAssets"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If set, will be provided to each added asset in this `Assets` instance.</haxe_doc>
		</runtimeAssets>
		<defaultImageOptions public="1" expr="null" line="47">
			<t path="ceramic.AssetOptions"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</defaultImageOptions>
		<loadMethod public="1" expr="SYNC" line="49">
			<x path="ceramic.AssetsLoadMethod"/>
			<meta><m n=":value"><e>SYNC</e></m></meta>
		</loadMethod>
		<scheduleMethod public="1" expr="PARALLEL" line="51">
			<x path="ceramic.AssetsScheduleMethod"/>
			<meta><m n=":value"><e>PARALLEL</e></m></meta>
		</scheduleMethod>
		<delayBetweenXAssets public="1" expr="-1" line="53">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</delayBetweenXAssets>
		<reloadOnTextureDensityChange public="1" expr="true" line="55">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</reloadOnTextureDensityChange>
		<parent public="1" expr="null" line="61">
			<c path="ceramic.Assets"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If provided, when requesting an asset, it will also check if the parent `Assets`
     * instance has it and return it if that's the case.</haxe_doc>
		</parent>
		<atlasPacker public="1" expr="null" line="67">
			<c path="ceramic.TextureAtlasPacker"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* A shared texture atlas packer that can be used to merge smaller textures together.
     * Also required when loading some kind of assets, like `.ase`/`.aseprite` files.</haxe_doc>
		</atlasPacker>
		<pendingAtlasPackers expr="null" line="71">
			<c path="Array"><c path="ceramic.TextureAtlasPacker"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</pendingAtlasPackers>
		<destroy public="1" set="method" line="107" override="1"><f a=""><x path="Void"/></f></destroy>
		<flush public="1" set="method" line="139">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroy assets that have their refCount at `0`.</haxe_doc>
		</flush>
		<add public="1" set="method" line="157"><f a="id:?variant:?options">
	<x path="ceramic.AssetId"><d/></x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></add>
		<addAll public="1" set="method" line="193">
			<f a="?pathPattern">
				<c path="EReg"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add all assets matching given path pattern (if provided)
     * @param pathPattern</haxe_doc>
		</addAll>
		<addImage public="1" set="method" line="335"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addImage>
		<addFont public="1" set="method" line="342"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addFont>
		<addAtlas public="1" set="method" line="349"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addAtlas>
		<addText public="1" set="method" line="356"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addText>
		<addBinary public="1" set="method" line="363"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addBinary>
		<addSound public="1" set="method" line="370"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addSound>
		<addDatabase public="1" set="method" line="377"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addDatabase>
		<addFragments public="1" set="method" line="384"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addFragments>
		<addShader public="1" set="method" line="391"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></addShader>
		<addAsset public="1" set="method" line="401">
			<f a="asset">
				<c path="ceramic.Asset"/>
				<c path="ceramic.Asset"/>
			</f>
			<haxe_doc>* Add the given asset. If a previous asset was replaced, return it.</haxe_doc>
		</addAsset>
		<assetDestroyed set="method" line="441"><f a="_">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></assetDestroyed>
		<imageAsset public="1" set="method" line="458"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.ImageAsset"/>
</f></imageAsset>
		<fontAsset public="1" set="method" line="462"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.FontAsset"/>
</f></fontAsset>
		<atlasAsset public="1" set="method" line="466"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.AtlasAsset"/>
</f></atlasAsset>
		<textAsset public="1" set="method" line="470"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.TextAsset"/>
</f></textAsset>
		<soundAsset public="1" set="method" line="474"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.SoundAsset"/>
</f></soundAsset>
		<databaseAsset public="1" set="method" line="478"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.DatabaseAsset"/>
</f></databaseAsset>
		<fragmentsAsset public="1" set="method" line="482"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.FragmentsAsset"/>
</f></fragmentsAsset>
		<shaderAsset public="1" set="method" line="486"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.ShaderAsset"/>
</f></shaderAsset>
		<asset public="1" set="method" line="490"><f a="idOrName:?kind:?variant">
	<d/>
	<c path="String"/>
	<c path="String"/>
	<c path="ceramic.Asset"/>
</f></asset>
		<removeAsset public="1" set="method" line="513"><f a="asset">
	<c path="ceramic.Asset"/>
	<x path="Void"/>
</f></removeAsset>
		<hasAnythingToLoad public="1" set="method" line="536">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if there are assets that should be loaded
     * @return Bool</haxe_doc>
		</hasAnythingToLoad>
		<countAssetsWithStatus public="1" set="method" line="549"><f a="status">
	<e path="ceramic.AssetStatus"/>
	<x path="Int"/>
</f></countAssetsWithStatus>
		<load public="1" set="method" line="562">
			<f a="?warnIfNothingToLoad:?pos" v="true:">
				<x path="Bool"/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ warnIfNothingToLoad : true }</e></m></meta>
		</load>
		<_prepareComplete set="method" line="652"><f a="allSuccess">
	<x path="Bool"/>
	<x path="Void"/>
</f></_prepareComplete>
		<_packNextAtlasPacker set="method" line="663"><f a="done">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></_packNextAtlasPacker>
		<addPendingAtlasPacker set="method" line="670"><f a="atlasPacker">
	<c path="ceramic.TextureAtlasPacker"/>
	<x path="Void"/>
</f></addPendingAtlasPacker>
		<_loadNextSerial set="method" line="680"><f a="toLoad:numComplete">
	<c path="Array"><c path="ceramic.Asset"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></_loadNextSerial>
		<_assetCompleteSerial set="method" line="697"><f a="success:toLoad:numComplete">
	<x path="Bool"/>
	<c path="Array"><c path="ceramic.Asset"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></_assetCompleteSerial>
		<_loadNextParallel set="method" line="713"><f a="toLoad:numStarted">
	<c path="Array"><c path="ceramic.Asset"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></_loadNextParallel>
		<ensure public="1" set="method" line="740">
			<f a="id:?variant:?options:done">
				<x path="ceramic.AssetId"><d/></x>
				<c path="String"/>
				<x path="Null"><t path="ceramic.AssetOptions"/></x>
				<f a="">
					<c path="ceramic.Asset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Ensures and asset is loaded and return it on the callback.
     * This will check if the requested asset is currently being loaded,
     * already loaded or should be added and loaded. In all cases, it will try
     * its best to deliver the requested asset or `null` if something went wrong.</haxe_doc>
		</ensure>
		<ensureImage public="1" set="method" line="789"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.ImageAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureImage>
		<ensureFont public="1" set="method" line="799"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.FontAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureFont>
		<ensureAtlas public="1" set="method" line="809"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.AtlasAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureAtlas>
		<ensureText public="1" set="method" line="819"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.TextAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureText>
		<ensureSound public="1" set="method" line="829"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.SoundAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureSound>
		<ensureDatabase public="1" set="method" line="839"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.DatabaseAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureDatabase>
		<ensureShader public="1" set="method" line="849"><f a="name:?variant:?options:done">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<f a="">
		<c path="ceramic.ShaderAsset"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensureShader>
		<texture public="1" set="method" line="861"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.Texture"/>
</f></texture>
		<font public="1" set="method" line="875"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.BitmapFont"/>
</f></font>
		<atlas public="1" set="method" line="889"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.TextureAtlas"/>
</f></atlas>
		<sound public="1" set="method" line="903"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.Sound"/>
</f></sound>
		<text public="1" set="method" line="917"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="String"/>
</f></text>
		<bytes public="1" set="method" line="931"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></bytes>
		<shader public="1" set="method" line="945"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="ceramic.Shader"/>
</f></shader>
		<database public="1" set="method" line="959"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
</f></database>
		<fragments public="1" set="method" line="973"><f a="name:?variant">
	<x path="ceramic.Either">
		<c path="String"/>
		<x path="ceramic.AssetId"><c path="String"/></x>
	</x>
	<c path="String"/>
	<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
</f></fragments>
		<iterator public="1" set="method" line="989"><f a=""><t path="Iterator"><c path="ceramic.Asset"/></t></f></iterator>
		<hotReload public="1" set="accessor" expr="false" line="1009">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Set to `true` to enable hot reload.
     * Note: this won't do anything unless used in pair with `watchDirectory(path)`</haxe_doc>
		</hotReload>
		<set_hotReload set="method" line="1011"><f a="hotReload">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_hotReload>
		<watchDirectory public="1" set="method" line="1033">
			<f a="?path:?hotReload" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="ceramic.WatchDirectory"/>
			</f>
			<meta><m n=":value"><e>{ hotReload : true }</e></m></meta>
			<haxe_doc>* Watch the given asset directory. Any change will fire `assetFilesChange` event.
     * If `hotReload` is set to `true` (its default), related assets will be hot reloaded
     * when their file changes on disk.
     * Behavior may differ depending on the platfom.
     * When using web target via electron, be sure to add `ceramic_use_electron` define.
     * @param path
     *     The assets path to watch. You could use `ceramic.macros.DefinesMacro.getDefine('assets_path')`
     *     to watch default asset path in project. It's the path that will be used if none is provided
     * @param hotReload
     *     `true` by default. Will enable hot reload of assets when related file changes on disk
     * @return WatchDirectory instance used internally</haxe_doc>
		</watchDirectory>
		<inheritRuntimeAssetsFromAssets public="1" set="method" line="1110">
			<f a="assets">
				<c path="ceramic.Assets"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Inherit runtime asset settings from parent assets instance.
     * Used internally to make sure sub-instances of `Assets` take owner live reload settings and related
     * @param assets</haxe_doc>
		</inheritRuntimeAssetsFromAssets>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="81"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.Asset</e></m>
		</meta>
	</class>
	<class path="assets.AllAssets" params="" file="/home/runner/work/api-docs/api-docs/gen/assets/AllAssets.hx">
		<bind public="1" set="method" line="16" static="1"><f a=""><x path="Void"/></f></bind>
		<all public="1" set="null" expr="[&quot;ceramic@2x.png&quot;, &quot;ceramic.png&quot;, &quot;blur.shader&quot;, &quot;textured.shader&quot;, &quot;tintBlack.shader&quot;, &quot;innerLight.shader&quot;, &quot;msdf.shader&quot;, &quot;glow.shader&quot;, &quot;gaussianBlur.shader&quot;, &quot;outline.shader&quot;, &quot;pixelArt.shader&quot;, &quot;stencil.shader&quot;, &quot;DualShock4GamepadHID-Gyro.json&quot;, &quot;bloom.shader&quot;, &quot;DualSenseGamepadHID-Gyro.json&quot;, &quot;tintBlack.frag&quot;, &quot;tintBlack.vert&quot;, &quot;textured.vert&quot;, &quot;RobotoMedium.png&quot;, &quot;RobotoMedium.fnt&quot;, &quot;white.png&quot;, &quot;textured.frag&quot;]" line="6" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["ceramic@2x.png", "ceramic.png", "blur.shader", "textured.shader", "tintBlack.shader", "innerLight.shader", "msdf.shader", "glow.shader", "gaussianBlur.shader", "outline.shader", "pixelArt.shader", "stencil.shader", "DualShock4GamepadHID-Gyro.json", "bloom.shader", "DualSenseGamepadHID-Gyro.json", "tintBlack.frag", "tintBlack.vert", "textured.vert", "RobotoMedium.png", "RobotoMedium.fnt", "white.png", "textured.frag"]</e></m></meta>
			<haxe_doc>All asset file paths array</haxe_doc>
		</all>
		<allDirs public="1" set="null" expr="[]" line="6" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>All asset directory paths array</haxe_doc>
		</allDirs>
		<allByName public="1" set="null" expr="[&quot;white&quot; =&gt; [&quot;white.png&quot;], &quot;tintBlack&quot; =&gt; [&quot;tintBlack.shader&quot;, &quot;tintBlack.frag&quot;, &quot;tintBlack.vert&quot;], &quot;textured&quot; =&gt; [&quot;textured.shader&quot;, &quot;textured.vert&quot;, &quot;textured.frag&quot;], &quot;stencil&quot; =&gt; [&quot;stencil.shader&quot;], &quot;pixelArt&quot; =&gt; [&quot;pixelArt.shader&quot;], &quot;outline&quot; =&gt; [&quot;outline.shader&quot;], &quot;msdf&quot; =&gt; [&quot;msdf.shader&quot;], &quot;innerLight&quot; =&gt; [&quot;innerLight.shader&quot;], &quot;glow&quot; =&gt; [&quot;glow.shader&quot;], &quot;gaussianBlur&quot; =&gt; [&quot;gaussianBlur.shader&quot;], &quot;ceramic&quot; =&gt; [&quot;ceramic@2x.png&quot;, &quot;ceramic.png&quot;], &quot;blur&quot; =&gt; [&quot;blur.shader&quot;], &quot;bloom&quot; =&gt; [&quot;bloom.shader&quot;], &quot;RobotoMedium&quot; =&gt; [&quot;RobotoMedium.png&quot;, &quot;RobotoMedium.fnt&quot;], &quot;DualShock4GamepadHID-Gyro&quot; =&gt; [&quot;DualShock4GamepadHID-Gyro.json&quot;], &quot;DualSenseGamepadHID-Gyro&quot; =&gt; [&quot;DualSenseGamepadHID-Gyro.json&quot;]]" line="6" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</t>
			<meta><m n=":value"><e><![CDATA[["white" => ["white.png"], "tintBlack" => ["tintBlack.shader", "tintBlack.frag", "tintBlack.vert"], "textured" => ["textured.shader", "textured.vert", "textured.frag"], "stencil" => ["stencil.shader"], "pixelArt" => ["pixelArt.shader"], "outline" => ["outline.shader"], "msdf" => ["msdf.shader"], "innerLight" => ["innerLight.shader"], "glow" => ["glow.shader"], "gaussianBlur" => ["gaussianBlur.shader"], "ceramic" => ["ceramic@2x.png", "ceramic.png"], "blur" => ["blur.shader"], "bloom" => ["bloom.shader"], "RobotoMedium" => ["RobotoMedium.png", "RobotoMedium.fnt"], "DualShock4GamepadHID-Gyro" => ["DualShock4GamepadHID-Gyro.json"], "DualSenseGamepadHID-Gyro" => ["DualSenseGamepadHID-Gyro.json"]]]]></e></m></meta>
			<haxe_doc>Assets by base name</haxe_doc>
		</allByName>
		<allDirsByName public="1" set="null" expr="new Map()" line="231" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
			<haxe_doc>Asset directories by base name</haxe_doc>
		</allDirsByName>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.AssetsMacro.buildLists()</e></m>
		</meta>
	</class>
	<class path="spec.Audio" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Audio.hx" interface="1">
		<load public="1" set="method"><f a="path:?options:done">
	<c path="String"/>
	<x path="Null"><t path="backend.LoadAudioOptions"/></x>
	<f a="">
		<t path="backend.AudioResource"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<supportsHotReloadPath public="1" set="method"><f a=""><x path="Bool"/></f></supportsHotReloadPath>
		<getDuration public="1" set="method"><f a="audio">
	<t path="backend.AudioResource"/>
	<x path="Float"/>
</f></getDuration>
		<resumeAudioContext public="1" set="method"><f a="done">
	<f a="">
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></resumeAudioContext>
		<destroy public="1" set="method"><f a="audio">
	<t path="backend.AudioResource"/>
	<x path="Void"/>
</f></destroy>
		<mute public="1" set="method"><f a="audio">
	<t path="backend.AudioResource"/>
	<t path="backend.AudioHandle"/>
</f></mute>
		<play public="1" set="method">
			<f a="audio:?volume:?pan:?pitch:?position:?loop" v=":0.5:0:1:0:false">
				<t path="backend.AudioResource"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="backend.AudioHandle"/>
			</f>
			<meta><m n=":value"><e>{ loop : false, position : 0, pitch : 1, pan : 0, volume : 0.5 }</e></m></meta>
		</play>
		<pause public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Void"/>
</f></pause>
		<resume public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Void"/>
</f></resume>
		<stop public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Void"/>
</f></stop>
		<getVolume public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getVolume>
		<setVolume public="1" set="method"><f a="handle:volume">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVolume>
		<getPan public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getPan>
		<setPan public="1" set="method"><f a="handle:pan">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPan>
		<getPitch public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getPitch>
		<setPitch public="1" set="method"><f a="handle:pitch">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPitch>
		<getPosition public="1" set="method"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getPosition>
		<setPosition public="1" set="method"><f a="handle:position">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="backend.Audio" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Audio.hx">
		<implements path="spec.Audio"/>
		<load public="1" set="method" line="16">
			<f a="path:?options:_done">
				<c path="String"/>
				<x path="Null"><t path="backend.LoadAudioOptions"/></x>
				<f a="">
					<t path="backend.AudioResource"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</load>
		<getDuration public="1" get="inline" set="null" line="112"><f a="audio">
	<t path="backend.AudioResource"/>
	<x path="Float"/>
</f></getDuration>
		<resumeAudioContext public="1" get="inline" set="null" line="118"><f a="done">
	<f a="">
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></resumeAudioContext>
		<destroy public="1" get="inline" set="null" line="124">
			<f a="audio">
				<t path="backend.AudioResource"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</destroy>
		<mute public="1" set="method" line="138"><f a="audio">
	<t path="backend.AudioResource"/>
	<t path="backend.AudioHandle"/>
</f></mute>
		<play public="1" set="method" line="144">
			<f a="audio:?volume:?pan:?pitch:?position:?loop" v=":0.5:0:1:0:false">
				<t path="backend.AudioResource"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="backend.AudioHandle"/>
			</f>
			<meta><m n=":value"><e>{ loop : false, position : 0, pitch : 1, pan : 0, volume : 0.5 }</e></m></meta>
		</play>
		<pause public="1" set="method" line="160"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Void"/>
</f></pause>
		<resume public="1" set="method" line="166"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Void"/>
</f></resume>
		<stop public="1" set="method" line="172"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Void"/>
</f></stop>
		<getVolume public="1" set="method" line="178"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getVolume>
		<setVolume public="1" set="method" line="184"><f a="handle:volume">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVolume>
		<getPan public="1" set="method" line="190"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getPan>
		<setPan public="1" set="method" line="196"><f a="handle:pan">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPan>
		<getPitch public="1" set="method" line="202"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getPitch>
		<setPitch public="1" set="method" line="208"><f a="handle:pitch">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPitch>
		<getPosition public="1" set="method" line="214"><f a="handle">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></getPosition>
		<setPosition public="1" set="method" line="220"><f a="handle:position">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<supportsHotReloadPath public="1" get="inline" set="null" line="226"><f a=""><x path="Bool"/></f></supportsHotReloadPath>
		<soundExtensions expr="null" line="234">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</soundExtensions>
		<loadingAudioCallbacks expr="new Map()" line="236">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><f a="">
	<t path="backend.AudioResource"/>
	<x path="Void"/>
</f></c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</loadingAudioCallbacks>
		<loadedAudioResources expr="new Map()" line="238">
			<t path="Map">
				<c path="String"/>
				<c path="backend.AudioResourceImpl"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</loadedAudioResources>
		<loadedAudioRetainCount expr="new Map()" line="240">
			<t path="Map">
				<c path="String"/>
				<x path="Int"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</loadedAudioRetainCount>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="backend.AudioHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/AudioHandle.hx">
		<c path="backend.AudioHandleImpl"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="backend.AudioHandleImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/AudioHandleImpl.hx">
		<_audioSources expr="null" line="9" static="1">
			<c path="backend.AudioSources"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_audioSources>
		<_handlesWithAudioSource expr="[]" line="11" static="1">
			<c path="Array"><c path="backend.AudioHandleImpl"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_handlesWithAudioSource>
		<_checkHandleAudioSources set="method" line="77" static="1"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></_checkHandleAudioSources>
		<volume public="1" set="accessor" expr="0.5" line="13">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</volume>
		<set_volume set="method" line="14"><f a="volume">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<pan public="1" set="accessor" expr="0" line="23">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pan>
		<set_pan set="method" line="24"><f a="pan">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
		<pitch public="1" set="accessor" expr="1" line="33">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</pitch>
		<set_pitch set="method" line="34"><f a="pitch">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pitch>
		<updateAudioSourceOnSetPosition expr="true" line="43">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</updateAudioSourceOnSetPosition>
		<position public="1" set="accessor" expr="0" line="45">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</position>
		<set_position set="method" line="46"><f a="position">
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
		<loop public="1" expr="false" line="57">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</loop>
		<resource public="1" expr="null" line="59">
			<c path="backend.AudioResourceImpl"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</resource>
		<audioSource expr="null" line="61">
			<c path="unityengine.AudioSource"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</audioSource>
		<length expr="0" line="63">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</length>
		<syncAudioSource get="inline" set="null" line="97"><f a=""><x path="Void"/></f></syncAudioSource>
		<recycleAudioSource set="method" line="114"><f a=""><x path="Void"/></f></recycleAudioSource>
		<addHandleInCheckedList get="inline" set="null" line="122"><f a=""><x path="Void"/></f></addHandleInCheckedList>
		<play public="1" set="method" line="140"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method" line="147"><f a=""><x path="Void"/></f></pause>
		<resume public="1" set="method" line="155"><f a=""><x path="Void"/></f></resume>
		<stop public="1" set="method" line="162"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method" line="65"><f a="resource">
	<c path="backend.AudioResourceImpl"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="backend.AudioResource" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/AudioResource.hx">
		<c path="backend.AudioResourceImpl"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="backend.AudioResourceImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/AudioResourceImpl.hx">
		<path public="1"><c path="String"/></path>
		<unityResource public="1"><c path="unityengine.AudioClip"/></unityResource>
		<new public="1" set="method" line="11"><f a="path:unityResource">
	<c path="String"/>
	<c path="unityengine.AudioClip"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="backend.AudioSources" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/AudioSources.hx">
		<gameObject>
			<c path="unityengine.GameObject"/>
			<haxe_doc>* GameObject on which audio sources are associated with</haxe_doc>
		</gameObject>
		<all expr="[]" line="21">
			<c path="Array"><c path="unityengine.AudioSource"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* All `AudioSource` instances associated with `gameObject`</haxe_doc>
		</all>
		<pool expr="[]" line="26">
			<c path="Array"><c path="unityengine.AudioSource"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* `AudioSource` instances currently available for reuse</haxe_doc>
		</pool>
		<removeExistingAudioSourceComponents set="method" line="36">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</removeExistingAudioSourceComponents>
		<get public="1" set="method" line="43">
			<f a=""><c path="unityengine.AudioSource"/></f>
			<meta><m n=":has_untyped"/></meta>
		</get>
		<recycle public="1" set="method" line="56"><f a="audioSource">
	<c path="unityengine.AudioSource"/>
	<x path="Void"/>
</f></recycle>
		<new public="1" set="method" line="28"><f a="gameObject">
	<c path="unityengine.GameObject"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="spec.Backend" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Backend.hx" interface="1">
		<init public="1" set="method"><f a="app">
	<c path="ceramic.App"/>
	<x path="Void"/>
</f></init>
		<setTargetFps public="1" set="method"><f a="fps">
	<x path="Int"/>
	<x path="Void"/>
</f></setTargetFps>
		<io public="1" set="null"><c path="backend.IO"/></io>
		<info public="1" set="null"><c path="backend.Info"/></info>
		<audio public="1" set="null"><c path="backend.Audio"/></audio>
		<draw public="1" set="null"><c path="backend.Draw"/></draw>
		<texts public="1" set="null"><c path="backend.Texts"/></texts>
		<binaries public="1" set="null"><c path="backend.Binaries"/></binaries>
		<textures public="1" set="null"><c path="backend.Textures"/></textures>
		<screen public="1" set="null"><c path="backend.Screen"/></screen>
		<textInput public="1" set="null"><c path="backend.TextInput"/></textInput>
		<clipboard public="1" set="null"><c path="backend.Clipboard"/></clipboard>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="backend.Backend" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Backend.hx">
		<implements path="spec.Backend"/>
		<implements path="tracker.Events"/>
		<io public="1" set="null" expr="new backend.IO()" line="14">
			<c path="backend.IO"/>
			<meta><m n=":value"><e>new backend.IO()</e></m></meta>
		</io>
		<info public="1" set="null" expr="new backend.Info()" line="16">
			<c path="backend.Info"/>
			<meta><m n=":value"><e>new backend.Info()</e></m></meta>
		</info>
		<audio public="1" set="null" expr="new backend.Audio()" line="18">
			<c path="backend.Audio"/>
			<meta><m n=":value"><e>new backend.Audio()</e></m></meta>
		</audio>
		<draw public="1" set="null" expr="new backend.Draw()" line="20">
			<c path="backend.Draw"/>
			<meta><m n=":value"><e>new backend.Draw()</e></m></meta>
		</draw>
		<texts public="1" set="null" expr="new backend.Texts()" line="22">
			<c path="backend.Texts"/>
			<meta><m n=":value"><e>new backend.Texts()</e></m></meta>
		</texts>
		<binaries public="1" set="null" expr="new backend.Binaries()" line="24">
			<c path="backend.Binaries"/>
			<meta><m n=":value"><e>new backend.Binaries()</e></m></meta>
		</binaries>
		<textures public="1" set="null" expr="new backend.Textures()" line="26">
			<c path="backend.Textures"/>
			<meta><m n=":value"><e>new backend.Textures()</e></m></meta>
		</textures>
		<shaders public="1" set="null" expr="new backend.Shaders()" line="28">
			<c path="backend.Shaders"/>
			<meta><m n=":value"><e>new backend.Shaders()</e></m></meta>
		</shaders>
		<screen public="1" set="null" expr="new backend.Screen()" line="30">
			<c path="backend.Screen"/>
			<meta><m n=":value"><e>new backend.Screen()</e></m></meta>
		</screen>
		<input public="1" set="null" expr="new backend.Input()" line="36">
			<c path="backend.Input"/>
			<meta><m n=":value"><e>new backend.Input()</e></m></meta>
		</input>
		<textInput public="1" set="null" expr="new backend.TextInput()" line="38">
			<c path="backend.TextInput"/>
			<meta><m n=":value"><e>new backend.TextInput()</e></m></meta>
		</textInput>
		<clipboard public="1" set="null" expr="new backend.Clipboard()" line="40">
			<c path="backend.Clipboard"/>
			<meta><m n=":value"><e>new backend.Clipboard()</e></m></meta>
		</clipboard>
		<init public="1" set="method" line="44"><f a="app">
	<c path="ceramic.App"/>
	<x path="Void"/>
</f></init>
		<setTargetFps public="1" set="method" line="50"><f a="fps">
	<x path="Int"/>
	<x path="Void"/>
</f></setTargetFps>
		<_dox_event_ready public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_ready>
		<emitReady set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>ready event</haxe_doc>
		</emitReady>
		<onReady public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>ready event</haxe_doc>
		</onReady>
		<onceReady public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>ready event</haxe_doc>
		</onceReady>
		<offReady public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>ready event</haxe_doc>
		</offReady>
		<listensReady public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to ready event</haxe_doc>
		</listensReady>
		<_dox_event_update public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_update>
		<emitUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>update event</haxe_doc>
		</emitUpdate>
		<onUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onUpdate>
		<onceUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onceUpdate>
		<offUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</offUpdate>
		<listensUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to update event</haxe_doc>
		</listensUpdate>
		<_dox_event_render public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_render>
		<emitRender set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>render event</haxe_doc>
		</emitRender>
		<onRender public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>render event</haxe_doc>
		</onRender>
		<onceRender public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>render event</haxe_doc>
		</onceRender>
		<offRender public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>render event</haxe_doc>
		</offRender>
		<listensRender public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to render event</haxe_doc>
		</listensRender>
		<willEmitUpdate get="inline" set="null" line="66"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitUpdate>
		<didEmitUpdate get="inline" set="null" line="72"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></didEmitUpdate>
		<_nextUpdateCallbacks expr="[]" line="78">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_nextUpdateCallbacks>
		<_nextUpdateCallbacksIterate expr="[]" line="79">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_nextUpdateCallbacksIterate>
		<onceNextUpdate set="method" line="81"><f a="cb">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></onceNextUpdate>
		<flushNextUpdateCallbacks set="method" line="87"><f a=""><x path="Void"/></f></flushNextUpdateCallbacks>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="42"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>Main</e></m>
			<m n=":allow"><e>backend.Textures</e></m>
		</meta>
	</class>
	<class path="spec.Binaries" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Binaries.hx" interface="1">
		<load public="1" set="method"><f a="path:?options:done">
	<c path="String"/>
	<x path="Null"><t path="backend.LoadBinaryOptions"/></x>
	<f a="">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<supportsHotReloadPath public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if paths with `?hot=...` are supported on this backend
     * @return Bool</haxe_doc>
		</supportsHotReloadPath>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="backend.Binaries" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Binaries.hx">
		<implements path="spec.Binaries"/>
		<load public="1" set="method" line="15">
			<f a="path:?options:_done">
				<c path="String"/>
				<x path="Null"><t path="backend.LoadBinaryOptions"/></x>
				<f a="">
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</load>
		<supportsHotReloadPath public="1" get="inline" set="null" line="84"><f a=""><x path="Bool"/></f></supportsHotReloadPath>
		<loadingBinaryCallbacks expr="new Map()" line="92">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><f a="">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</loadingBinaryCallbacks>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="backend.BlendMode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/BlendMode.hx">
		<x path="backend.BlendModeImpl"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<abstract path="backend.BlendModeImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/BlendMode.hx" module="backend.BlendMode">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="backend._BlendMode.BlendModeImpl_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/BlendMode.hx" private="1" module="backend.BlendMode" extern="1" final="1">
	<ZERO public="1" get="inline" set="null" expr="cast 0" line="9" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ZERO>
	<ONE public="1" get="inline" set="null" expr="cast 1" line="10" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ONE>
	<SRC_COLOR public="1" get="inline" set="null" expr="cast 2" line="11" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SRC_COLOR>
	<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" expr="cast 3" line="12" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ONE_MINUS_SRC_COLOR>
	<SRC_ALPHA public="1" get="inline" set="null" expr="cast 4" line="13" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SRC_ALPHA>
	<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" expr="cast 5" line="14" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ONE_MINUS_SRC_ALPHA>
	<DST_ALPHA public="1" get="inline" set="null" expr="cast 6" line="15" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DST_ALPHA>
	<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" expr="cast 7" line="16" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ONE_MINUS_DST_ALPHA>
	<DST_COLOR public="1" get="inline" set="null" expr="cast 8" line="17" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DST_COLOR>
	<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" expr="cast 9" line="18" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ONE_MINUS_DST_COLOR>
	<SRC_ALPHA_SATURATE public="1" get="inline" set="null" expr="cast 10" line="19" static="1">
		<x path="backend.BlendModeImpl"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SRC_ALPHA_SATURATE>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="backend._BlendMode.BlendModeImpl_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/BlendMode.hx" private="1" module="backend.BlendMode" extern="1" final="1">
		<ZERO public="1" get="inline" set="null" expr="cast 0" line="9" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ZERO>
		<ONE public="1" get="inline" set="null" expr="cast 1" line="10" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ONE>
		<SRC_COLOR public="1" get="inline" set="null" expr="cast 2" line="11" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" expr="cast 3" line="12" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1" get="inline" set="null" expr="cast 4" line="13" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" expr="cast 5" line="14" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1" get="inline" set="null" expr="cast 6" line="15" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" expr="cast 7" line="16" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1" get="inline" set="null" expr="cast 8" line="17" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" expr="cast 9" line="18" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1" get="inline" set="null" expr="cast 10" line="19" static="1">
			<x path="backend.BlendModeImpl"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SRC_ALPHA_SATURATE>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="unityengine.rendering.universal.ScriptableRenderPass" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/universal/ScriptableRenderPass.hx" extern="1"><meta>
	<m n=":nativeGen"/>
	<m n=":native"><e>"UnityEngine.Rendering.Universal.ScriptableRenderPass"</e></m>
</meta></class>
	<class path="backend.CeramicRenderPass" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/CeramicRenderPass.hx" extern="1">
		<extends path="unityengine.rendering.universal.ScriptableRenderPass"/>
		<GetCommandBuffer public="1" set="method"><f a=""><c path="unityengine.rendering.CommandBuffer"/></f></GetCommandBuffer>
		<SetCommandBuffer public="1" set="method"><f a="cmd">
	<c path="unityengine.rendering.CommandBuffer"/>
	<x path="Void"/>
</f></SetCommandBuffer>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"CeramicRenderPassFeature.CeramicRenderPass"</e></m>
		</meta>
	</class>
	<class path="spec.Clipboard" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Clipboard.hx" interface="1">
		<getText public="1" set="method"><f a=""><c path="String"/></f></getText>
		<setText public="1" set="method"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></setText>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="backend.Clipboard" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Clipboard.hx">
		<implements path="spec.Clipboard"/>
		<clipboardText expr="null" line="5">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</clipboardText>
		<getText public="1" set="method" line="9"><f a=""><c path="String"/></f></getText>
		<setText public="1" set="method" line="15"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></setText>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="backend.Materials" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Materials.hx">
		<repository><c path="Array"><c path="backend.MaterialData"/></c></repository>
		<get public="1" set="method" line="33">
			<f a="textures:shader:srcRgb:dstRgb:srcAlpha:dstAlpha:stencil">
				<c path="cs.NativeArray"><t path="backend.Texture"/></c>
				<x path="backend.Shader"/>
				<t path="backend.BlendMode"/>
				<t path="backend.BlendMode"/>
				<t path="backend.BlendMode"/>
				<t path="backend.BlendMode"/>
				<x path="backend.StencilState"/>
				<c path="backend.MaterialData"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* Provide a MaterialData object that matches the given params.
     * If such material doesn't exist yet, creates and instance</haxe_doc>
		</get>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="unityengine.MeshTopology" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/MeshTopology.hx" extern="1">
		<Triangles public="1" static="1"><c path="unityengine.MeshTopology"/></Triangles>
		<Quads public="1" static="1"><c path="unityengine.MeshTopology"/></Quads>
		<Lines public="1" static="1"><c path="unityengine.MeshTopology"/></Lines>
		<LineStrip public="1" static="1"><c path="unityengine.MeshTopology"/></LineStrip>
		<Points public="1" static="1"><c path="unityengine.MeshTopology"/></Points>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.MeshTopology"</e></m>
		</meta>
	</class>
	<class path="ceramic.DecomposedTransform" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/DecomposedTransform.hx">
		<pivotX public="1" expr="0" line="12">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pivotX>
		<pivotY public="1" expr="0" line="14">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pivotY>
		<x public="1" expr="0" line="16">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0" line="18">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<rotation public="1" expr="0" line="20">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</rotation>
		<scaleX public="1" expr="1" line="22">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</scaleX>
		<scaleY public="1" expr="1" line="24">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</scaleY>
		<skewX public="1" expr="0" line="26">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewX>
		<skewY public="1" expr="0" line="28">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewY>
		<toString set="method" line="30"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Decomposed transform holds rotation, translation, scale, skew and pivot informations.
 * Provided by Transform.decompose() method.
 * Angles are in radians.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Transform" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Transform.hx">
		<implements path="tracker.Events"/>
		<_decomposed1 expr="new DecomposedTransform()" line="18" static="1">
			<c path="ceramic.DecomposedTransform"/>
			<meta><m n=":value"><e>new DecomposedTransform()</e></m></meta>
		</_decomposed1>
		<_decomposed2 expr="new DecomposedTransform()" line="20" static="1">
			<c path="ceramic.DecomposedTransform"/>
			<meta><m n=":value"><e>new DecomposedTransform()</e></m></meta>
		</_decomposed2>
		<_tmp expr="new Transform()" line="58" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</_tmp>
		<_dox_event_change public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_change>
		<emitChange public="1" set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>change event</haxe_doc>
		</emitChange>
		<onChange public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onChange>
		<onceChange public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onceChange>
		<offChange public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</offChange>
		<listensChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to change event</haxe_doc>
		</listensChange>
		<_aPrev><x path="Float"/></_aPrev>
		<_bPrev><x path="Float"/></_bPrev>
		<_cPrev><x path="Float"/></_cPrev>
		<_dPrev><x path="Float"/></_dPrev>
		<_txPrev><x path="Float"/></_txPrev>
		<_tyPrev><x path="Float"/></_tyPrev>
		<changedDirty public="1"><x path="Bool"/></changedDirty>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<changed public="1" set="null"><x path="Bool"/></changed>
		<computeChanged public="1" get="inline" set="null" line="82"><f a=""><x path="Void"/></f></computeChanged>
		<didEmitChange get="inline" set="null" line="99"><f a=""><x path="Void"/></f></didEmitChange>
		<cleanChangedState public="1" get="inline" set="null" line="105"><f a=""><x path="Void"/></f></cleanChangedState>
		<clone public="1" get="inline" set="null" line="118"><f a=""><c path="ceramic.Transform"/></f></clone>
		<concat public="1" get="inline" set="null" line="124"><f a="m">
	<c path="ceramic.Transform"/>
	<x path="Void"/>
</f></concat>
		<decompose public="1" get="inline" set="null" line="143"><f a="?output">
	<c path="ceramic.DecomposedTransform"/>
	<c path="ceramic.DecomposedTransform"/>
</f></decompose>
		<setFromDecomposed public="1" get="inline" set="null" line="178"><f a="decomposed">
	<c path="ceramic.DecomposedTransform"/>
	<x path="Void"/>
</f></setFromDecomposed>
		<setFromValues public="1" get="inline" set="null" line="184">
			<f a="?x:?y:?scaleX:?scaleY:?rotation:?skewX:?skewY:?pivotX:?pivotY" v="0:0:1:1:0:0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pivotY : 0, pivotX : 0, skewY : 0, skewX : 0, rotation : 0, scaleY : 1, scaleX : 1, y : 0, x : 0 }</e></m></meta>
		</setFromValues>
		<setFromInterpolated public="1" get="inline" set="null" line="200"><f a="transform1:transform2:ratio">
	<c path="ceramic.Transform"/>
	<c path="ceramic.Transform"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFromInterpolated>
		<deltaTransformX public="1" get="inline" set="null" line="225"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></deltaTransformX>
		<deltaTransformY public="1" get="inline" set="null" line="231"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></deltaTransformY>
		<equals public="1" get="inline" set="null" line="237"><f a="transform">
	<c path="ceramic.Transform"/>
	<x path="Bool"/>
</f></equals>
		<identity public="1" get="inline" set="null" line="243"><f a=""><x path="Void"/></f></identity>
		<invert public="1" get="inline" set="null" line="256"><f a=""><x path="Void"/></f></invert>
		<rotate public="1" get="inline" set="null" line="288">
			<f a="angle">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Rotate by angle (in radians)</haxe_doc>
		</rotate>
		<scale public="1" get="inline" set="null" line="309"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<translate public="1" get="inline" set="null" line="324"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<skew public="1" get="inline" set="null" line="333"><f a="skewX:skewY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></skew>
		<setRotation public="1" get="inline" set="null" line="358">
			<f a="angle:?scale" v=":1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1 }</e></m></meta>
		</setRotation>
		<setTo public="1" get="inline" set="null" line="369"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<setToTransform public="1" get="inline" set="null" line="382"><f a="transform">
	<c path="ceramic.Transform"/>
	<x path="Void"/>
</f></setToTransform>
		<toString public="1" set="method" line="395"><f a=""><c path="String"/></f></toString>
		<transformX public="1" get="inline" set="null" line="403"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></transformX>
		<transformY public="1" get="inline" set="null" line="410"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></transformY>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="62">
			<f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, d : 1, c : 0, b : 0, a : 1 }</e></m></meta>
		</new>
		<haxe_doc>* Transform holds matrix data to make 2d rotate, translate, scale and skew transformations.
 * Angles are in degrees.
 * Representation:
 * | a | c | tx |
 * | b | d | ty |
 * | 0 | 0 | 1  |</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.TransformPool</e></m>
		</meta>
	</class>
	<class path="backend.Draw" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Draw.hx">
		<MAX_VERTS_SIZE get="inline" set="null" expr="65536" line="105" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65536</e></m></meta>
		</MAX_VERTS_SIZE>
		<MAX_INDICES get="inline" set="null" expr="16384" line="106" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16384</e></m></meta>
		</MAX_INDICES>
		<_stencilBufferDirty expr="false" line="108" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_stencilBufferDirty>
		<_maxVerts expr="0" line="110" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_maxVerts>
		<_meshes expr="null" line="112" static="1">
			<c path="Array"><c path="unityengine.Mesh"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</_meshes>
		<_meshesVertices expr="null" line="113" static="1">
			<c path="Array"><t path="backend.Float32Array"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</_meshesVertices>
		<_meshesIndices expr="null" line="114" static="1">
			<c path="Array"><t path="backend.UInt16Array"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</_meshesIndices>
		<_currentMeshIndex expr="-1" line="115" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</_currentMeshIndex>
		<_currentMesh expr="null" line="116" static="1">
			<c path="unityengine.Mesh"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_currentMesh>
		<_meshVertices expr="null" line="118" static="1">
			<t path="backend.Float32Array"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_meshVertices>
		<_meshIndices expr="null" line="119" static="1">
			<t path="backend.UInt16Array"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_meshIndices>
		<_materials expr="new Materials()" line="121" static="1">
			<c path="backend.Materials"/>
			<meta><m n=":value"><e>new Materials()</e></m></meta>
		</_materials>
		<_activeTextureSlot expr="0" line="123" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_activeTextureSlot>
		<_materialCurrentTextures expr="null" line="124" static="1">
			<c path="cs.NativeArray"><t path="backend.Texture"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</_materialCurrentTextures>
		<_materialCurrentShader expr="null" line="125" static="1">
			<x path="backend.Shader"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_materialCurrentShader>
		<_materialSrcRgb expr="ONE" line="126" static="1">
			<t path="backend.BlendMode"/>
			<meta><m n=":value"><e>ONE</e></m></meta>
		</_materialSrcRgb>
		<_materialDstRgb expr="ONE_MINUS_SRC_ALPHA" line="127" static="1">
			<t path="backend.BlendMode"/>
			<meta><m n=":value"><e>ONE_MINUS_SRC_ALPHA</e></m></meta>
		</_materialDstRgb>
		<_materialSrcAlpha expr="ONE" line="128" static="1">
			<t path="backend.BlendMode"/>
			<meta><m n=":value"><e>ONE</e></m></meta>
		</_materialSrcAlpha>
		<_materialDstAlpha expr="ONE_MINUS_SRC_ALPHA" line="129" static="1">
			<t path="backend.BlendMode"/>
			<meta><m n=":value"><e>ONE_MINUS_SRC_ALPHA</e></m></meta>
		</_materialDstAlpha>
		<_materialStencilTest expr="false" line="130" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_materialStencilTest>
		<_materialStencilWrite expr="0" line="131" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_materialStencilWrite>
		<_viewportDensity expr="1.0" line="133" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</_viewportDensity>
		<_viewportWidth expr="0.0" line="135" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</_viewportWidth>
		<_viewportHeight expr="0.0" line="137" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</_viewportHeight>
		<_stencilShader expr="null" line="139" static="1">
			<x path="backend.Shader"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_stencilShader>
		<_currentMatrix expr="null" line="141" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_currentMatrix>
		<_currentRenderTarget expr="null" line="143" static="1">
			<c path="ceramic.RenderTexture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_currentRenderTarget>
		<_projectionMatrix expr="null" line="145" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_projectionMatrix>
		<_modelViewMatrix expr="null" line="147" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_modelViewMatrix>
		<_modelViewTransform expr="new ceramic.Transform()" line="149" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new ceramic.Transform()</e></m></meta>
		</_modelViewTransform>
		<_renderTargetTransform expr="new ceramic.Transform()" line="151" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new ceramic.Transform()</e></m></meta>
		</_renderTargetTransform>
		<_vertexSize expr="0" line="153" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_vertexSize>
		<_numIndices expr="0" line="154" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numIndices>
		<_numPos expr="0" line="156" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numPos>
		<_posIndex expr="0" line="157" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_posIndex>
		<_numUVs expr="0" line="159" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numUVs>
		<_uvIndex expr="0" line="160" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_uvIndex>
		<_numColors expr="0" line="162" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numColors>
		<_colorIndex expr="0" line="163" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_colorIndex>
		<_floatAttributesIndex expr="0" line="165" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_floatAttributesIndex>
		<_meshTopology expr="MeshTopology.Triangles" line="166" static="1">
			<c path="unityengine.MeshTopology"/>
			<meta><m n=":value"><e>MeshTopology.Triangles</e></m></meta>
		</_meshTopology>
		<unityUrpAddRenderPasses public="1" set="method" line="908" static="1">
			<f a="renderer:renderingData">
				<c path="unityengine.rendering.universal.ScriptableRenderer"/>
				<c path="unityengine.rendering.universal.RenderingData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</unityUrpAddRenderPasses>
		<getItem public="1" get="inline" set="null" line="45"><f a="visual">
	<c path="ceramic.Visual"/>
	<e path="backend.VisualItem"/>
</f></getItem>
		<draw public="1" set="method" line="65">
			<f a="visuals">
				<c path="Array"><c path="ceramic.Visual"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</draw>
		<_draw set="method" line="80"><f a="visuals">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Void"/>
</f></_draw>
		<swap public="1" set="method" line="97"><f a=""><x path="Void"/></f></swap>
		<getNumPos public="1" get="inline" set="null" line="168"><f a=""><x path="Int"/></f></getNumPos>
		<putPos public="1" get="inline" set="null" line="174"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putPos>
		<putPosAndTextureSlot public="1" get="inline" set="null" line="184"><f a="x:y:z:textureSlot">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putPosAndTextureSlot>
		<putIndice public="1" get="inline" set="null" line="195">
			<f a="i">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</putIndice>
		<putUVs public="1" get="inline" set="null" line="202"><f a="uvX:uvY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putUVs>
		<putColor public="1" get="inline" set="null" line="211"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putColor>
		<beginFloatAttributes public="1" get="inline" set="null" line="222"><f a=""><x path="Void"/></f></beginFloatAttributes>
		<putFloatAttribute public="1" get="inline" set="null" line="228"><f a="index:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putFloatAttribute>
		<endFloatAttributes public="1" get="inline" set="null" line="234"><f a=""><x path="Void"/></f></endFloatAttributes>
		<initBuffers public="1" get="inline" set="null" line="240"><f a=""><x path="Void"/></f></initBuffers>
		<prepareNextMesh set="method" line="263"><f a=""><x path="Void"/></f></prepareNextMesh>
		<resetIndexes get="inline" set="null" line="281"><f a=""><x path="Void"/></f></resetIndexes>
		<beginRender public="1" get="inline" set="null" line="309">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</beginRender>
		<clearAndApplyBackground public="1" get="inline" set="null" line="333">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</clearAndApplyBackground>
		<setRenderTarget public="1" get="inline" set="null" line="341">
			<f a="renderTarget:?force" v=":false">
				<c path="ceramic.RenderTexture"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ force : false }</e></m>
			</meta>
		</setRenderTarget>
		<updateProjectionMatrix get="inline" set="null" line="438">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</updateProjectionMatrix>
		<updateViewMatrix get="inline" set="null" line="453">
			<f a="density:width:height:?transform:?flipX:?flipY" v="::::1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.Transform"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ flipY : 1, flipX : 1 }</e></m></meta>
		</updateViewMatrix>
		<updateCurrentMatrix get="inline" set="null" line="487">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</updateCurrentMatrix>
		<transformToMatrix4x4 get="inline" set="null" line="495">
			<f a="transform">
				<c path="ceramic.Transform"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</transformToMatrix4x4>
		<useShader public="1" get="inline" set="null" line="510"><f a="shader">
	<c path="backend.ShaderImpl"/>
	<x path="Void"/>
</f></useShader>
		<clear public="1" get="inline" set="null" line="527">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</clear>
		<enableBlending public="1" get="inline" set="null" line="534"><f a=""><x path="Void"/></f></enableBlending>
		<disableBlending public="1" get="inline" set="null" line="540"><f a=""><x path="Void"/></f></disableBlending>
		<setBlendFuncSeparate public="1" get="inline" set="null" line="546"><f a="srcRgb:dstRgb:srcAlpha:dstAlpha">
	<t path="backend.BlendMode"/>
	<t path="backend.BlendMode"/>
	<t path="backend.BlendMode"/>
	<t path="backend.BlendMode"/>
	<x path="Void"/>
</f></setBlendFuncSeparate>
		<getActiveTexture public="1" get="inline" set="null" line="555"><f a=""><x path="Int"/></f></getActiveTexture>
		<setActiveTexture public="1" get="inline" set="null" line="561"><f a="slot">
	<x path="Int"/>
	<x path="Void"/>
</f></setActiveTexture>
		<textureBackendItemMatchesId public="1" get="inline" set="null" line="567"><f a="backendItem:textureId">
	<t path="backend.Texture"/>
	<t path="backend.TextureId"/>
	<x path="Bool"/>
</f></textureBackendItemMatchesId>
		<getTextureId public="1" get="inline" set="null" line="573"><f a="backendItem">
	<t path="backend.Texture"/>
	<t path="backend.TextureId"/>
</f></getTextureId>
		<getTextureWidth public="1" get="inline" set="null" line="579"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureWidth>
		<getTextureHeight public="1" get="inline" set="null" line="585"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureHeight>
		<getTextureWidthActual public="1" get="inline" set="null" line="591"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureWidthActual>
		<getTextureHeightActual public="1" get="inline" set="null" line="597"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureHeightActual>
		<bindTexture public="1" get="inline" set="null" line="603"><f a="backendItem">
	<t path="backend.Texture"/>
	<x path="Void"/>
</f></bindTexture>
		<bindNoTexture public="1" get="inline" set="null" line="609"><f a=""><x path="Void"/></f></bindNoTexture>
		<setPrimitiveType public="1" get="inline" set="null" line="615"><f a="primitiveType">
	<x path="ceramic.RenderPrimitiveType"/>
	<x path="Void"/>
</f></setPrimitiveType>
		<beginDrawQuad public="1" get="inline" set="null" line="624"><f a="quad">
	<c path="ceramic.Quad"/>
	<x path="Void"/>
</f></beginDrawQuad>
		<endDrawQuad public="1" get="inline" set="null" line="628"><f a=""><x path="Void"/></f></endDrawQuad>
		<beginDrawMesh public="1" get="inline" set="null" line="632"><f a="mesh">
	<c path="ceramic.Mesh"/>
	<x path="Void"/>
</f></beginDrawMesh>
		<endDrawMesh public="1" get="inline" set="null" line="636"><f a=""><x path="Void"/></f></endDrawMesh>
		<enableScissor public="1" get="inline" set="null" line="640">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</enableScissor>
		<disableScissor public="1" get="inline" set="null" line="671">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</disableScissor>
		<beginDrawingInStencilBuffer public="1" set="method" line="678"><f a=""><x path="Void"/></f></beginDrawingInStencilBuffer>
		<endDrawingInStencilBuffer public="1" get="inline" set="null" line="720"><f a=""><x path="Void"/></f></endDrawingInStencilBuffer>
		<drawWithStencilTest public="1" get="inline" set="null" line="726"><f a=""><x path="Void"/></f></drawWithStencilTest>
		<drawWithoutStencilTest public="1" get="inline" set="null" line="732"><f a=""><x path="Void"/></f></drawWithoutStencilTest>
		<shouldFlush public="1" get="inline" set="null" line="738"><f a="numVerticesAfter:numIndicesAfter:customFloatAttributesSize">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></shouldFlush>
		<remainingVertices public="1" get="inline" set="null" line="744"><f a=""><x path="Int"/></f></remainingVertices>
		<remainingIndices public="1" get="inline" set="null" line="750"><f a=""><x path="Int"/></f></remainingIndices>
		<hasAnythingToFlush public="1" get="inline" set="null" line="756"><f a=""><x path="Bool"/></f></hasAnythingToFlush>
		<flush public="1" get="inline" set="null" line="762">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</flush>
		<urpRenderer expr="null" line="820">
			<c path="unityengine.rendering.universal.ScriptableRenderer"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</urpRenderer>
		<urpRenderingData><c path="unityengine.rendering.universal.RenderingData"/></urpRenderingData>
		<mainCameraRenderPasses expr="[]" line="824">
			<c path="Array"><c path="backend.CeramicRenderPass"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</mainCameraRenderPasses>
		<customTargetRenderPasses expr="[]" line="826">
			<c path="Array"><c path="backend.CeramicRenderPass"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</customTargetRenderPasses>
		<pendingCommandBuffers expr="[]" line="828">
			<c path="Array"><c path="unityengine.rendering.CommandBuffer"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pendingCommandBuffers>
		<pendingRenderTargets expr="[]" line="830">
			<c path="Array"><c path="ceramic.RenderTexture"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pendingRenderTargets>
		<widthOnDraw expr="-1" line="832">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</widthOnDraw>
		<heightOnDraw expr="-1" line="834">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</heightOnDraw>
		<clearPendingCommandBuffers set="method" line="836"><f a=""><x path="Void"/></f></clearPendingCommandBuffers>
		<configureNextCommandBuffer set="method" line="843"><f a="renderTarget">
	<c path="ceramic.RenderTexture"/>
	<x path="Void"/>
</f></configureNextCommandBuffer>
		<addRenderPasses set="method" line="851">
			<f a="renderer:renderingData">
				<c path="unityengine.rendering.universal.ScriptableRenderer"/>
				<c path="unityengine.rendering.universal.RenderingData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</addRenderPasses>
		<renderer><c path="ceramic.Renderer"/></renderer>
		<commandBuffer><c path="unityengine.rendering.CommandBuffer"/></commandBuffer>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>backend.Backend</e></m>
		</meta>
	</class>
	<class path="backend.FieldLookup" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/FieldLookup.hx">
		<keep public="1" set="method" line="13" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</keep>
		<loadFieldIds public="1" set="method" line="15" static="1">
			<f a="numFields:hash">
				<x path="Int"/>
				<c path="String"/>
				<c path="cs.NativeArray"><x path="Int"/></c>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</loadFieldIds>
		<loadFieldNames public="1" set="method" line="39" static="1">
			<f a="numFields:hash">
				<x path="Int"/>
				<c path="String"/>
				<c path="cs.NativeArray"><c path="String"/></c>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</loadFieldNames>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<typedef path="backend.Float32Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Float32Array.hx">
		<c path="cs.NativeArray"><x path="Single"/></c>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="spec.IO" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/IO.hx" interface="1">
		<saveString public="1" set="method"><f a="key:str">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></saveString>
		<appendString public="1" set="method"><f a="key:str">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></appendString>
		<readString public="1" set="method"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></readString>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="backend.IO" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/IO.hx">
		<implements path="spec.IO"/>
		<saveString public="1" set="method" line="16"><f a="key:str">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></saveString>
		<appendString public="1" set="method" line="34"><f a="key:str">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></appendString>
		<readString public="1" set="method" line="56"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></readString>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="backend.Info" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Info.hx">
		<_storageDirectory expr="null" line="5">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_storageDirectory>
		<storageDirectory public="1" set="method" line="17"><f a=""><c path="String"/></f></storageDirectory>
		<imageExtensions public="1" get="inline" set="null" line="25"><f a=""><c path="Array"><c path="String"/></c></f></imageExtensions>
		<textExtensions public="1" get="inline" set="null" line="29"><f a=""><c path="Array"><c path="String"/></c></f></textExtensions>
		<soundExtensions public="1" get="inline" set="null" line="33"><f a=""><c path="Array"><c path="String"/></c></f></soundExtensions>
		<shaderExtensions public="1" get="inline" set="null" line="37"><f a=""><c path="Array"><c path="String"/></c></f></shaderExtensions>
		<new public="1" set="method" line="7">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="spec.Input" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Input.hx" interface="1"><meta><m n=":hxGen"/></meta></class>
	<class path="backend.Input" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Input.hx">
		<implements path="spec.Input"/>
		<implements path="tracker.Events"/>
		<GAMEPAD_STORAGE_SIZE final="1" get="inline" set="null" expr="20" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
			<haxe_doc>* Internal value to store gamepad state</haxe_doc>
		</GAMEPAD_STORAGE_SIZE>
		<_dox_event_keyDown public="1" set="method" line="637">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_keyDown>
		<emitKeyDown set="method" line="1095">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<haxe_doc>keyDown event</haxe_doc>
		</emitKeyDown>
		<onKeyDown public="1" set="method" line="1199">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>keyDown event</haxe_doc>
		</onKeyDown>
		<onceKeyDown public="1" set="method" line="1298">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>keyDown event</haxe_doc>
		</onceKeyDown>
		<offKeyDown public="1" set="method" line="1368">
			<f a="?handleKey">
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>keyDown event</haxe_doc>
		</offKeyDown>
		<listensKeyDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to keyDown event</haxe_doc>
		</listensKeyDown>
		<_dox_event_keyUp public="1" set="method" line="637">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_keyUp>
		<emitKeyUp set="method" line="1095">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<haxe_doc>keyUp event</haxe_doc>
		</emitKeyUp>
		<onKeyUp public="1" set="method" line="1199">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>keyUp event</haxe_doc>
		</onKeyUp>
		<onceKeyUp public="1" set="method" line="1298">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>keyUp event</haxe_doc>
		</onceKeyUp>
		<offKeyUp public="1" set="method" line="1368">
			<f a="?handleKey">
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>keyUp event</haxe_doc>
		</offKeyUp>
		<listensKeyUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to keyUp event</haxe_doc>
		</listensKeyUp>
		<_dox_event_gamepadAxis public="1" set="method" line="637">
			<f a="gamepadId:axisId:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadAxis>
		<emitGamepadAxis set="method" line="1095">
			<f a="gamepadId:axisId:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</emitGamepadAxis>
		<onGamepadAxis public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdAxisIdValue">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:axisId:value">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</onGamepadAxis>
		<onceGamepadAxis public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdAxisIdValue">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:axisId:value">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</onceGamepadAxis>
		<offGamepadAxis public="1" set="method" line="1368">
			<f a="?handleGamepadIdAxisIdValue">
				<f a="gamepadId:axisId:value">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</offGamepadAxis>
		<listensGamepadAxis public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadAxis event</haxe_doc>
		</listensGamepadAxis>
		<_dox_event_gamepadDown public="1" set="method" line="637">
			<f a="gamepadId:buttonId">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadDown>
		<emitGamepadDown set="method" line="1095">
			<f a="gamepadId:buttonId">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadDown event</haxe_doc>
		</emitGamepadDown>
		<onGamepadDown public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdButtonId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:buttonId">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDown event</haxe_doc>
		</onGamepadDown>
		<onceGamepadDown public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdButtonId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:buttonId">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDown event</haxe_doc>
		</onceGamepadDown>
		<offGamepadDown public="1" set="method" line="1368">
			<f a="?handleGamepadIdButtonId">
				<f a="gamepadId:buttonId">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDown event</haxe_doc>
		</offGamepadDown>
		<listensGamepadDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadDown event</haxe_doc>
		</listensGamepadDown>
		<_dox_event_gamepadUp public="1" set="method" line="637">
			<f a="gamepadId:buttonId">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadUp>
		<emitGamepadUp set="method" line="1095">
			<f a="gamepadId:buttonId">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadUp event</haxe_doc>
		</emitGamepadUp>
		<onGamepadUp public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdButtonId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:buttonId">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadUp event</haxe_doc>
		</onGamepadUp>
		<onceGamepadUp public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdButtonId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:buttonId">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadUp event</haxe_doc>
		</onceGamepadUp>
		<offGamepadUp public="1" set="method" line="1368">
			<f a="?handleGamepadIdButtonId">
				<f a="gamepadId:buttonId">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadUp event</haxe_doc>
		</offGamepadUp>
		<listensGamepadUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadUp event</haxe_doc>
		</listensGamepadUp>
		<_dox_event_gamepadGyro public="1" set="method" line="637">
			<f a="gamepadId:dx:dy:dz">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadGyro>
		<emitGamepadGyro set="method" line="1095">
			<f a="gamepadId:dx:dy:dz">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</emitGamepadGyro>
		<onGamepadGyro public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdDxDyDz">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:dx:dy:dz">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</onGamepadGyro>
		<onceGamepadGyro public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdDxDyDz">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:dx:dy:dz">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</onceGamepadGyro>
		<offGamepadGyro public="1" set="method" line="1368">
			<f a="?handleGamepadIdDxDyDz">
				<f a="gamepadId:dx:dy:dz">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</offGamepadGyro>
		<listensGamepadGyro public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadGyro event</haxe_doc>
		</listensGamepadGyro>
		<_dox_event_gamepadEnable public="1" set="method" line="637">
			<f a="gamepadId:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadEnable>
		<emitGamepadEnable set="method" line="1095">
			<f a="gamepadId:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</emitGamepadEnable>
		<onGamepadEnable public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</onGamepadEnable>
		<onceGamepadEnable public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</onceGamepadEnable>
		<offGamepadEnable public="1" set="method" line="1368">
			<f a="?handleGamepadIdName">
				<f a="gamepadId:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</offGamepadEnable>
		<listensGamepadEnable public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadEnable event</haxe_doc>
		</listensGamepadEnable>
		<_dox_event_gamepadDisable public="1" set="method" line="637">
			<f a="gamepadId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadDisable>
		<emitGamepadDisable set="method" line="1095">
			<f a="gamepadId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</emitGamepadDisable>
		<onGamepadDisable public="1" set="method" line="1199">
			<f a="owner:handleGamepadId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</onGamepadDisable>
		<onceGamepadDisable public="1" set="method" line="1298">
			<f a="owner:handleGamepadId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</onceGamepadDisable>
		<offGamepadDisable public="1" set="method" line="1368">
			<f a="?handleGamepadId">
				<f a="gamepadId">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</offGamepadDisable>
		<listensGamepadDisable public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadDisable event</haxe_doc>
		</listensGamepadDisable>
		<update get="inline" set="null" line="44">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>backend.Backend</e></m></meta>
		</update>
		<registerInputSystemOverrides set="method" line="53">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</registerInputSystemOverrides>
		<keyCodeByName expr="null" line="74">
			<t path="Map">
				<c path="String"/>
				<x path="Int"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</keyCodeByName>
		<initKeyCodesMapping set="method" line="76"><f a=""><x path="Void"/></f></initKeyCodesMapping>
		<updateKeyboardInput set="method" line="119"><f a=""><x path="Void"/></f></updateKeyboardInput>
		<testKey get="inline" set="null" line="212">
			<f a="keyboard:value:scanCode:?keyCode">
				<c path="unityengine.inputsystem.Keyboard"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</testKey>
		<willEmitKeyDown set="method" line="252"><f a="key">
	<c path="ceramic.Key"/>
	<x path="Void"/>
</f></willEmitKeyDown>
		<willEmitKeyUp set="method" line="324"><f a="key">
	<c path="ceramic.Key"/>
	<x path="Void"/>
</f></willEmitKeyUp>
		<gamepads expr="[]" line="357">
			<c path="Array"><c path="unityengine.inputsystem.Gamepad"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</gamepads>
		<gamepadPressed expr="new IntIntMap(16, 0.5, false)" line="359">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</gamepadPressed>
		<gamepadAxis expr="new IntMap(16, 0.5, false)" line="361">
			<c path="ceramic.IntMap"><x path="Single"/></c>
			<meta><m n=":value"><e>new IntMap(16, 0.5, false)</e></m></meta>
		</gamepadAxis>
		<gamepadDualShockGyroControls expr="new IntMap(16, 0.5, false)" line="363">
			<c path="ceramic.IntMap"><c path="Array"><c path="unityengine.inputsystem.controls.ButtonControl"/></c></c>
			<meta><m n=":value"><e>new IntMap(16, 0.5, false)</e></m></meta>
		</gamepadDualShockGyroControls>
		<unusedGamepads expr="[]" line="365">
			<c path="Array"><c path="unityengine.inputsystem.Gamepad"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</unusedGamepads>
		<updateGamepadInput set="method" line="367">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</updateGamepadInput>
		<updateGamepadButton set="method" line="480"><f a="index:button:pressed">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></updateGamepadButton>
		<updateGamepadAxis set="method" line="499"><f a="index:axis:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Single"/>
	<x path="Void"/>
</f></updateGamepadAxis>
		<readDualShockGyro set="method" line="509">
			<f a="gyroControl0:gyroControl1">
				<c path="unityengine.inputsystem.controls.ButtonControl"/>
				<c path="unityengine.inputsystem.controls.ButtonControl"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</readDualShockGyro>
		<startGamepadRumble public="1" set="method" line="523"><f a="gamepadId:lowFrequency:highFrequency:duration">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></startGamepadRumble>
		<stopGamepadRumble public="1" set="method" line="529"><f a="gamepadId">
	<x path="Int"/>
	<x path="Void"/>
</f></stopGamepadRumble>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>Main</e></m>
		</meta>
	</class>
	<typedef path="backend.LoadAudioOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/LoadAudioOptions.hx">
		<a>
			<stream>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</stream>
			<loadMethod>
				<x path="Null"><x path="ceramic.AssetsLoadMethod"/></x>
				<meta><m n=":optional"/></meta>
			</loadMethod>
			<immediate>
				<x path="Null"><c path="ceramic.Immediate"/></x>
				<meta><m n=":optional"/></meta>
			</immediate>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="backend.LoadBinaryOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/LoadBinaryOptions.hx">
		<a>
			<loadMethod>
				<x path="Null"><x path="ceramic.AssetsLoadMethod"/></x>
				<meta><m n=":optional"/></meta>
			</loadMethod>
			<immediate>
				<x path="Null"><c path="ceramic.Immediate"/></x>
				<meta><m n=":optional"/></meta>
			</immediate>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="backend.LoadShaderOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/LoadShaderOptions.hx">
		<a>
			<loadMethod>
				<x path="Null"><x path="ceramic.AssetsLoadMethod"/></x>
				<meta><m n=":optional"/></meta>
			</loadMethod>
			<immediate>
				<x path="Null"><c path="ceramic.Immediate"/></x>
				<meta><m n=":optional"/></meta>
			</immediate>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="backend.LoadTextOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/LoadTextOptions.hx">
		<a>
			<loadMethod>
				<x path="Null"><x path="ceramic.AssetsLoadMethod"/></x>
				<meta><m n=":optional"/></meta>
			</loadMethod>
			<immediate>
				<x path="Null"><c path="ceramic.Immediate"/></x>
				<meta><m n=":optional"/></meta>
			</immediate>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="backend.LoadTextureOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/LoadTextureOptions.hx">
		<a>
			<loadMethod>
				<x path="Null"><x path="ceramic.AssetsLoadMethod"/></x>
				<meta><m n=":optional"/></meta>
			</loadMethod>
			<immediate>
				<x path="Null"><c path="ceramic.Immediate"/></x>
				<meta><m n=":optional"/></meta>
			</immediate>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="backend.MaterialData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/MaterialData.hx">
		<blendingToUnityBlending public="1" set="method" line="152" static="1"><f a="blending">
	<t path="backend.BlendMode"/>
	<c path="unityengine.rendering.BlendMode"/>
</f></blendingToUnityBlending>
		<material public="1" expr="null" line="8">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</material>
		<textures public="1" set="accessor" expr="null" line="10">
			<c path="cs.NativeArray"><t path="backend.Texture"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</textures>
		<set_textures get="inline" set="null" line="11"><f a="textures">
	<c path="cs.NativeArray"><t path="backend.Texture"/></c>
	<c path="cs.NativeArray"><t path="backend.Texture"/></c>
</f></set_textures>
		<shader public="1" expr="null" line="25">
			<x path="backend.Shader"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</shader>
		<srcRgb public="1" expr="ONE" line="27">
			<t path="backend.BlendMode"/>
			<meta><m n=":value"><e>ONE</e></m></meta>
		</srcRgb>
		<dstRgb public="1" expr="ONE_MINUS_SRC_ALPHA" line="29">
			<t path="backend.BlendMode"/>
			<meta><m n=":value"><e>ONE_MINUS_SRC_ALPHA</e></m></meta>
		</dstRgb>
		<srcAlpha public="1" expr="ONE" line="31">
			<t path="backend.BlendMode"/>
			<meta><m n=":value"><e>ONE</e></m></meta>
		</srcAlpha>
		<dstAlpha public="1" expr="ONE_MINUS_SRC_ALPHA" line="33">
			<t path="backend.BlendMode"/>
			<meta><m n=":value"><e>ONE_MINUS_SRC_ALPHA</e></m></meta>
		</dstAlpha>
		<stencil public="1" expr="NONE" line="35">
			<x path="backend.StencilState"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
		</stencil>
		<vertexBufferAttributes public="1" expr="null" line="37">
			<c path="cs.NativeArray"><c path="unityengine.rendering.VertexAttributeDescriptor"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</vertexBufferAttributes>
		<paramsVersion public="1" expr="-1" line="39">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</paramsVersion>
		<matches public="1" get="inline" set="null" line="51"><f a="textures:shader:srcRgb:dstRgb:srcAlpha:dstAlpha:stencil">
	<c path="cs.NativeArray"><t path="backend.Texture"/></c>
	<x path="backend.Shader"/>
	<t path="backend.BlendMode"/>
	<t path="backend.BlendMode"/>
	<t path="backend.BlendMode"/>
	<t path="backend.BlendMode"/>
	<x path="backend.StencilState"/>
	<x path="Bool"/>
</f></matches>
		<texturesEqualTextures public="1" get="inline" set="null" line="62"><f a="textures">
	<c path="cs.NativeArray"><t path="backend.Texture"/></c>
	<x path="Bool"/>
</f></texturesEqualTextures>
		<syncShaderParams public="1" get="inline" set="null" line="85">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</syncShaderParams>
		<new public="1" set="method" line="41"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="backend.Screen" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Screen.hx">
		<implements path="tracker.Events"/>
		<width expr="0" line="41">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</width>
		<height expr="0" line="43">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</height>
		<density expr="1" line="45">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</density>
		<isEditor expr="false" line="47">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isEditor>
		<_dox_event_resize public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_resize>
		<emitResize set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>resize event</haxe_doc>
		</emitResize>
		<onResize public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>resize event</haxe_doc>
		</onResize>
		<onceResize public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>resize event</haxe_doc>
		</onceResize>
		<offResize public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>resize event</haxe_doc>
		</offResize>
		<listensResize public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to resize event</haxe_doc>
		</listensResize>
		<_dox_event_mouseDown public="1" set="method" line="637">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseDown>
		<emitMouseDown set="method" line="1095">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseDown event</haxe_doc>
		</emitMouseDown>
		<onMouseDown public="1" set="method" line="1199">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseDown event</haxe_doc>
		</onMouseDown>
		<onceMouseDown public="1" set="method" line="1298">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseDown event</haxe_doc>
		</onceMouseDown>
		<offMouseDown public="1" set="method" line="1368">
			<f a="?handleButtonIdXY">
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseDown event</haxe_doc>
		</offMouseDown>
		<listensMouseDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseDown event</haxe_doc>
		</listensMouseDown>
		<_dox_event_mouseUp public="1" set="method" line="637">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseUp>
		<emitMouseUp set="method" line="1095">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseUp event</haxe_doc>
		</emitMouseUp>
		<onMouseUp public="1" set="method" line="1199">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseUp event</haxe_doc>
		</onMouseUp>
		<onceMouseUp public="1" set="method" line="1298">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseUp event</haxe_doc>
		</onceMouseUp>
		<offMouseUp public="1" set="method" line="1368">
			<f a="?handleButtonIdXY">
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseUp event</haxe_doc>
		</offMouseUp>
		<listensMouseUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseUp event</haxe_doc>
		</listensMouseUp>
		<_dox_event_mouseWheel public="1" set="method" line="637">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseWheel>
		<emitMouseWheel set="method" line="1095">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseWheel event</haxe_doc>
		</emitMouseWheel>
		<onMouseWheel public="1" set="method" line="1199">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseWheel event</haxe_doc>
		</onMouseWheel>
		<onceMouseWheel public="1" set="method" line="1298">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseWheel event</haxe_doc>
		</onceMouseWheel>
		<offMouseWheel public="1" set="method" line="1368">
			<f a="?handleXY">
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseWheel event</haxe_doc>
		</offMouseWheel>
		<listensMouseWheel public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseWheel event</haxe_doc>
		</listensMouseWheel>
		<_dox_event_mouseMove public="1" set="method" line="637">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseMove>
		<emitMouseMove set="method" line="1095">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseMove event</haxe_doc>
		</emitMouseMove>
		<onMouseMove public="1" set="method" line="1199">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseMove event</haxe_doc>
		</onMouseMove>
		<onceMouseMove public="1" set="method" line="1298">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseMove event</haxe_doc>
		</onceMouseMove>
		<offMouseMove public="1" set="method" line="1368">
			<f a="?handleXY">
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseMove event</haxe_doc>
		</offMouseMove>
		<listensMouseMove public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseMove event</haxe_doc>
		</listensMouseMove>
		<_dox_event_touchDown public="1" set="method" line="637">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_touchDown>
		<emitTouchDown set="method" line="1095">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>touchDown event</haxe_doc>
		</emitTouchDown>
		<onTouchDown public="1" set="method" line="1199">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchDown event</haxe_doc>
		</onTouchDown>
		<onceTouchDown public="1" set="method" line="1298">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchDown event</haxe_doc>
		</onceTouchDown>
		<offTouchDown public="1" set="method" line="1368">
			<f a="?handleTouchIndexXY">
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchDown event</haxe_doc>
		</offTouchDown>
		<listensTouchDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to touchDown event</haxe_doc>
		</listensTouchDown>
		<_dox_event_touchUp public="1" set="method" line="637">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_touchUp>
		<emitTouchUp set="method" line="1095">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>touchUp event</haxe_doc>
		</emitTouchUp>
		<onTouchUp public="1" set="method" line="1199">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchUp event</haxe_doc>
		</onTouchUp>
		<onceTouchUp public="1" set="method" line="1298">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchUp event</haxe_doc>
		</onceTouchUp>
		<offTouchUp public="1" set="method" line="1368">
			<f a="?handleTouchIndexXY">
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchUp event</haxe_doc>
		</offTouchUp>
		<listensTouchUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to touchUp event</haxe_doc>
		</listensTouchUp>
		<_dox_event_touchMove public="1" set="method" line="637">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_touchMove>
		<emitTouchMove set="method" line="1095">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>touchMove event</haxe_doc>
		</emitTouchMove>
		<onTouchMove public="1" set="method" line="1199">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchMove event</haxe_doc>
		</onTouchMove>
		<onceTouchMove public="1" set="method" line="1298">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchMove event</haxe_doc>
		</onceTouchMove>
		<offTouchMove public="1" set="method" line="1368">
			<f a="?handleTouchIndexXY">
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchMove event</haxe_doc>
		</offTouchMove>
		<listensTouchMove public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to touchMove event</haxe_doc>
		</listensTouchMove>
		<getWidth public="1" get="inline" set="null" line="64"><f a=""><x path="Int"/></f></getWidth>
		<getHeight public="1" get="inline" set="null" line="70"><f a=""><x path="Int"/></f></getHeight>
		<getDensity public="1" get="inline" set="null" line="76"><f a=""><x path="Float"/></f></getDensity>
		<setBackground public="1" set="method" line="82"><f a="background">
	<x path="Int"/>
	<x path="Void"/>
</f></setBackground>
		<setWindowTitle public="1" set="method" line="88"><f a="title">
	<c path="String"/>
	<x path="Void"/>
</f></setWindowTitle>
		<setWindowFullscreen public="1" set="method" line="94"><f a="fullscreen">
	<x path="Bool"/>
	<x path="Void"/>
</f></setWindowFullscreen>
		<update set="method" line="103">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":allow"><e>backend.Backend</e></m>
			</meta>
		</update>
		<mouseLeftPressed expr="false" line="136">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</mouseLeftPressed>
		<mouseMiddlePressed expr="false" line="138">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</mouseMiddlePressed>
		<mouseRightPressed expr="false" line="140">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</mouseRightPressed>
		<mouseX expr="-1" line="142">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</mouseX>
		<mouseY expr="-1" line="144">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</mouseY>
		<updateMouseInput set="method" line="146"><f a=""><x path="Void"/></f></updateMouseInput>
		<touchIdToIndex expr="new IntIntMap(16, 0.5, false)" line="213">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</touchIdToIndex>
		<usedTouchIndexes expr="new IntIntMap(16, 0.5, false)" line="215">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</usedTouchIndexes>
		<processedTouchIndexes expr="[]" line="217">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</processedTouchIndexes>
		<prevNumTouches expr="0" line="219">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</prevNumTouches>
		<prevProcessedTouchIndexes expr="[]" line="221">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</prevProcessedTouchIndexes>
		<processedTouchPositions expr="[]" line="223">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</processedTouchPositions>
		<prevProcessedTouchPositions expr="[]" line="225">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</prevProcessedTouchPositions>
		<touchHighestStartTime expr="-1" line="227">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</touchHighestStartTime>
		<updateTouchInput set="method" line="229">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</updateTouchInput>
		<nextScreenshotIndex expr="0" line="363">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextScreenshotIndex>
		<screenshotToTexture public="1" set="method" line="365"><f a="done">
	<f a="texture">
		<t path="backend.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></screenshotToTexture>
		<screenshotToPng public="1" set="method" line="379"><f a="?path:done">
	<c path="String"/>
	<f a="?data">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></screenshotToPng>
		<screenshotToPixels public="1" set="method" line="399"><f a="done">
	<f a="pixels:width:height">
		<t path="ceramic.UInt8Array"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></screenshotToPixels>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="19">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":keep"/>
			<m n=":allow"><e>Main</e></m>
		</meta>
	</class>
	<abstract path="backend.Shader" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Shader.hx">
		<from><icast><c path="backend.ShaderImpl"/></icast></from>
		<this><c path="backend.ShaderImpl"/></this>
		<to><icast><c path="backend.ShaderImpl"/></icast></to>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="backend._Shader.Shader_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Shader.hx" private="1" module="backend.Shader" extern="1" final="1"><meta><m n=":hxGen"/></meta></class></impl>
	</abstract>
	<class path="backend._Shader.Shader_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Shader.hx" private="1" module="backend.Shader" extern="1" final="1"><meta><m n=":hxGen"/></meta></class>
	<class path="backend.ShaderImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/ShaderImpl.hx">
		<MAX_PARAMS_DIRTY final="1" set="null" expr="999999999" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>999999999</e></m></meta>
		</MAX_PARAMS_DIRTY>
		<clone public="1" set="method" line="45" static="1"><f a="fromShader">
	<c path="backend.ShaderImpl"/>
	<c path="backend.ShaderImpl"/>
</f></clone>
		<path public="1" expr="null" line="10">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</path>
		<unityShader public="1" expr="null" line="12">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</unityShader>
		<customAttributes public="1" expr="null" line="14">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</customAttributes>
		<isBatchingMultiTexture public="1" expr="false" line="16">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isBatchingMultiTexture>
		<paramsVersion expr="0" line="18">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</paramsVersion>
		<intParams expr="null" line="20">
			<t path="Map">
				<c path="String"/>
				<x path="Int"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</intParams>
		<floatParams expr="null" line="22">
			<t path="Map">
				<c path="String"/>
				<x path="Float"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</floatParams>
		<colorParams expr="null" line="24">
			<t path="Map">
				<c path="String"/>
				<c path="unityengine.Color"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</colorParams>
		<vec2Params expr="null" line="26">
			<t path="Map">
				<c path="String"/>
				<c path="unityengine.Vector2"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</vec2Params>
		<vec3Params expr="null" line="28">
			<t path="Map">
				<c path="String"/>
				<c path="unityengine.Vector3"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</vec3Params>
		<vec4Params expr="null" line="30">
			<t path="Map">
				<c path="String"/>
				<c path="unityengine.Vector4"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</vec4Params>
		<floatArrayParams expr="null" line="32">
			<t path="Map">
				<c path="String"/>
				<c path="cs.NativeArray"><x path="Single"/></c>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</floatArrayParams>
		<textureParams expr="null" line="34">
			<t path="Map">
				<c path="String"/>
				<t path="backend.Texture"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</textureParams>
		<mat4Params expr="null" line="36">
			<t path="Map">
				<c path="String"/>
				<c path="unityengine.Matrix4x4"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</mat4Params>
		<setInt public="1" set="method" line="55"><f a="name:value">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setFloat public="1" set="method" line="71"><f a="name:value">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setColor public="1" set="method" line="87"><f a="name:r:g:b:a">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setColor>
		<setVec2 public="1" set="method" line="104"><f a="name:x:y">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec2>
		<setVec3 public="1" set="method" line="121"><f a="name:x:y:z">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec3>
		<setVec4 public="1" set="method" line="138"><f a="name:x:y:z:w">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec4>
		<setFloatArray public="1" set="method" line="155"><f a="name:array">
	<c path="String"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setFloatArray>
		<setTexture public="1" set="method" line="175"><f a="name:texture">
	<c path="String"/>
	<t path="backend.Texture"/>
	<x path="Void"/>
</f></setTexture>
		<setMat4FromTransform public="1" set="method" line="191">
			<f a="name:transform">
				<c path="String"/>
				<c path="ceramic.Transform"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setMat4FromTransform>
		<sanitizeUniformName set="method" line="218"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></sanitizeUniformName>
		<toString set="method" line="229"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="38"><f a="unityShader:?customAttributes">
	<d/>
	<x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>backend.MaterialData</e></m>
		</meta>
	</class>
	<class path="spec.Shaders" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Shaders.hx" interface="1">
		<destroy public="1" set="method"><f a="shader">
	<x path="backend.Shader"/>
	<x path="Void"/>
</f></destroy>
		<load public="1" set="method"><f a="path:?customAttributes:?options:done">
	<c path="String"/>
	<x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x>
	<x path="Null"><t path="backend.LoadShaderOptions"/></x>
	<f a="shader">
		<x path="backend.Shader"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<clone public="1" set="method"><f a="shader">
	<x path="backend.Shader"/>
	<x path="backend.Shader"/>
</f></clone>
		<setInt public="1" set="method"><f a="shader:name:value">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setFloat public="1" set="method"><f a="shader:name:value">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setColor public="1" set="method"><f a="shader:name:r:g:b:a">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setColor>
		<setVec2 public="1" set="method"><f a="shader:name:x:y">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec2>
		<setVec3 public="1" set="method"><f a="shader:name:x:y:z">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec3>
		<setVec4 public="1" set="method"><f a="shader:name:x:y:z:w">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec4>
		<setFloatArray public="1" set="method"><f a="shader:name:array">
	<x path="backend.Shader"/>
	<c path="String"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setFloatArray>
		<setTexture public="1" set="method"><f a="shader:name:slot:texture">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Int"/>
	<t path="backend.Texture"/>
	<x path="Void"/>
</f></setTexture>
		<customFloatAttributesSize public="1" set="method"><f a="shader">
	<x path="backend.Shader"/>
	<x path="Int"/>
</f></customFloatAttributesSize>
		<maxIfStatementsByFragmentShader public="1" set="method"><f a=""><x path="Int"/></f></maxIfStatementsByFragmentShader>
		<canBatchWithMultipleTextures public="1" set="method"><f a="shader">
	<x path="backend.Shader"/>
	<x path="Bool"/>
</f></canBatchWithMultipleTextures>
		<supportsHotReloadPath public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if paths with `?hot=...` are supported on this backend
     * @return Bool</haxe_doc>
		</supportsHotReloadPath>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="backend.Shaders" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Shaders.hx">
		<implements path="spec.Shaders"/>
		<load public="1" set="method" line="11">
			<f a="path:?customAttributes:?options:_done">
				<c path="String"/>
				<x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x>
				<x path="Null"><t path="backend.LoadShaderOptions"/></x>
				<f a="shader">
					<x path="backend.Shader"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</load>
		<destroy public="1" get="inline" set="null" line="49"><f a="shader">
	<x path="backend.Shader"/>
	<x path="Void"/>
</f></destroy>
		<clone public="1" get="inline" set="null" line="55"><f a="shader">
	<x path="backend.Shader"/>
	<x path="backend.Shader"/>
</f></clone>
		<customFloatAttributesSize public="1" get="inline" set="null" line="61"><f a="shader">
	<c path="backend.ShaderImpl"/>
	<x path="Int"/>
</f></customFloatAttributesSize>
		<setInt public="1" get="inline" set="null" line="79"><f a="shader:name:value">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setFloat public="1" get="inline" set="null" line="85"><f a="shader:name:value">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setColor public="1" get="inline" set="null" line="91"><f a="shader:name:r:g:b:a">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setColor>
		<setVec2 public="1" get="inline" set="null" line="97"><f a="shader:name:x:y">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec2>
		<setVec3 public="1" get="inline" set="null" line="103"><f a="shader:name:x:y:z">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec3>
		<setVec4 public="1" get="inline" set="null" line="109"><f a="shader:name:x:y:z:w">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec4>
		<setFloatArray public="1" get="inline" set="null" line="115"><f a="shader:name:array">
	<x path="backend.Shader"/>
	<c path="String"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setFloatArray>
		<setTexture public="1" get="inline" set="null" line="121"><f a="shader:name:slot:texture">
	<x path="backend.Shader"/>
	<c path="String"/>
	<x path="Int"/>
	<t path="backend.Texture"/>
	<x path="Void"/>
</f></setTexture>
		<setMat4FromTransform public="1" get="inline" set="null" line="127"><f a="shader:name:transform">
	<x path="backend.Shader"/>
	<c path="String"/>
	<c path="ceramic.Transform"/>
	<x path="Void"/>
</f></setMat4FromTransform>
		<maxIfStatementsByFragmentShader public="1" get="inline" set="null" line="133"><f a=""><x path="Int"/></f></maxIfStatementsByFragmentShader>
		<canBatchWithMultipleTextures public="1" get="inline" set="null" line="139"><f a="shader">
	<x path="backend.Shader"/>
	<x path="Bool"/>
</f></canBatchWithMultipleTextures>
		<supportsHotReloadPath public="1" get="inline" set="null" line="145"><f a=""><x path="Bool"/></f></supportsHotReloadPath>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="backend.StencilState" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/StencilState.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="backend._StencilState.StencilState_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/StencilState.hx" private="1" module="backend.StencilState" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="backend.StencilState"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<TEST public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="backend.StencilState"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TEST>
	<WRITE public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="backend.StencilState"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WRITE>
	<CLEAR public="1" get="inline" set="null" expr="cast 3" line="11" static="1">
		<x path="backend.StencilState"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CLEAR>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="backend._StencilState.StencilState_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/StencilState.hx" private="1" module="backend.StencilState" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="backend.StencilState"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<TEST public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="backend.StencilState"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TEST>
		<WRITE public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="backend.StencilState"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WRITE>
		<CLEAR public="1" get="inline" set="null" expr="cast 3" line="11" static="1">
			<x path="backend.StencilState"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CLEAR>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="spec.TextInput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/TextInput.hx" interface="1">
		<start public="1" set="method"><f a="initialText:x:y:w:h">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></start>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="backend.TextInput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/TextInput.hx">
		<implements path="spec.TextInput"/>
		<textInputActive public="1" set="null" expr="false" line="10">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</textInputActive>
		<bindTextInput set="method" line="18">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</bindTextInput>
		<handleTextInput set="method" line="26">
			<f a="csChar">
				<t path="cs.types.Char16"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</handleTextInput>
		<_handleTextInput set="method" line="34">
			<f a="csChar">
				<t path="cs.types.Char16"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</_handleTextInput>
		<start public="1" set="method" line="121"><f a="initialText:x:y:w:h">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></start>
		<stop public="1" set="method" line="129"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="spec.Texts" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Texts.hx" interface="1">
		<load public="1" set="method"><f a="path:?options:done">
	<c path="String"/>
	<x path="Null"><t path="backend.LoadTextOptions"/></x>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<supportsHotReloadPath public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if paths with `?hot=...` are supported on this backend
     * @return Bool</haxe_doc>
		</supportsHotReloadPath>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="backend.Texts" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Texts.hx">
		<implements path="spec.Texts"/>
		<load public="1" set="method" line="15">
			<f a="path:?options:_done">
				<c path="String"/>
				<x path="Null"><t path="backend.LoadTextOptions"/></x>
				<f a="">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</load>
		<supportsHotReloadPath public="1" get="inline" set="null" line="84"><f a=""><x path="Bool"/></f></supportsHotReloadPath>
		<loadingTextCallbacks expr="new Map()" line="92">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</loadingTextCallbacks>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="backend.Texture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Texture.hx">
		<c path="backend.TextureImpl"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="backend.TextureId" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/TextureId.hx">
		<x path="backend.TextureIdImpl"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<abstract path="backend.TextureIdImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/TextureId.hx" module="backend.TextureId">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="backend._TextureId.TextureIdImpl_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/TextureId.hx" private="1" module="backend.TextureId" final="1">
	<DEFAULT public="1" get="inline" set="null" expr="0" line="7" static="1">
		<t path="backend.TextureId"/>
		<meta><m n=":value"><e>0</e></m></meta>
	</DEFAULT>
	<meta><m n=":hxGen"/></meta>
</class></impl>
	</abstract>
	<class path="backend._TextureId.TextureIdImpl_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/TextureId.hx" private="1" module="backend.TextureId" final="1">
		<DEFAULT public="1" get="inline" set="null" expr="0" line="7" static="1">
			<t path="backend.TextureId"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</DEFAULT>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="backend.TextureImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/TextureImpl.hx">
		<_nextIndex expr="1" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</_nextIndex>
		<index public="1" expr="_nextIndex++" line="11">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>_nextIndex++</e></m>
				<m n=":noCompletion"/>
			</meta>
		</index>
		<usedAsRenderTarget public="1" expr="false" line="14">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</usedAsRenderTarget>
		<unityTexture public="1"><c path="unityengine.Texture2D"/></unityTexture>
		<unityRenderTexture public="1"><c path="unityengine.RenderTexture"/></unityRenderTexture>
		<path public="1"><c path="String"/></path>
		<textureId public="1"><t path="backend.TextureId"/></textureId>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<new public="1" set="method" line="28"><f a="path:unityTexture:unityRenderTexture">
	<c path="String"/>
	<c path="unityengine.Texture2D"/>
	<c path="unityengine.RenderTexture"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="spec.Textures" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/spec/Textures.hx" interface="1">
		<load public="1" set="method"><f a="path:?options:done">
	<c path="String"/>
	<x path="Null"><t path="backend.LoadTextureOptions"/></x>
	<f a="">
		<t path="backend.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<loadFromBytes public="1" set="method"><f a="bytes:type:?options:done">
	<c path="haxe.io.Bytes"/>
	<x path="ceramic.ImageType"/>
	<x path="Null"><t path="backend.LoadTextureOptions"/></x>
	<f a="">
		<t path="backend.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadFromBytes>
		<supportsHotReloadPath public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if paths with `?hot=...` are supported on this backend
     * @return Bool</haxe_doc>
		</supportsHotReloadPath>
		<createTexture public="1" set="method"><f a="width:height:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<t path="ceramic.UInt8Array"/>
	<t path="backend.Texture"/>
</f></createTexture>
		<destroyTexture public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Void"/>
</f></destroyTexture>
		<getTextureId public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<t path="backend.TextureId"/>
</f></getTextureId>
		<getTextureWidth public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureWidth>
		<getTextureHeight public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureHeight>
		<getTextureWidthActual public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureWidthActual>
		<getTextureHeightActual public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureHeightActual>
		<fetchTexturePixels public="1" set="method"><f a="texture:?result">
	<t path="backend.Texture"/>
	<x path="Null"><t path="ceramic.UInt8Array"/></x>
	<t path="ceramic.UInt8Array"/>
</f></fetchTexturePixels>
		<submitTexturePixels public="1" set="method"><f a="texture:pixels">
	<t path="backend.Texture"/>
	<t path="ceramic.UInt8Array"/>
	<x path="Void"/>
</f></submitTexturePixels>
		<setTextureFilter public="1" set="method"><f a="texture:filter">
	<t path="backend.Texture"/>
	<e path="ceramic.TextureFilter"/>
	<x path="Void"/>
</f></setTextureFilter>
		<setTextureWrapS public="1" set="method"><f a="texture:wrap">
	<t path="backend.Texture"/>
	<x path="ceramic.TextureWrap"/>
	<x path="Void"/>
</f></setTextureWrapS>
		<setTextureWrapT public="1" set="method"><f a="texture:wrap">
	<t path="backend.Texture"/>
	<x path="ceramic.TextureWrap"/>
	<x path="Void"/>
</f></setTextureWrapT>
		<createRenderTarget public="1" set="method"><f a="width:height:depth:stencil:antialiasing">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<t path="backend.Texture"/>
</f></createRenderTarget>
		<maxTexturesByBatch public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* If this returns a value above 1, that means this backend supports multi-texture batching.</haxe_doc>
		</maxTexturesByBatch>
		<getTextureIndex public="1" set="method"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureIndex>
		<textureToPng public="1" set="method">
			<f a="texture:?reversePremultiplyAlpha:?path:done" v=":true::">
				<t path="backend.Texture"/>
				<x path="Bool"/>
				<c path="String"/>
				<f a="?data">
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ reversePremultiplyAlpha : true }</e></m></meta>
		</textureToPng>
		<pixelsToPng public="1" set="method"><f a="width:height:pixels:?path:done">
	<x path="Int"/>
	<x path="Int"/>
	<t path="ceramic.UInt8Array"/>
	<c path="String"/>
	<f a="?data">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></pixelsToPng>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="backend.Textures" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/Textures.hx">
		<implements path="spec.Textures"/>
		<load public="1" set="method" line="20">
			<f a="path:?options:_done">
				<c path="String"/>
				<x path="Null"><t path="backend.LoadTextureOptions"/></x>
				<f a="">
					<t path="backend.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</load>
		<nextRenderIndex expr="0" line="143">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextRenderIndex>
		<nextPixelsIndex expr="0" line="145">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextPixelsIndex>
		<nextBytesIndex expr="0" line="147">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextBytesIndex>
		<loadFromBytes public="1" set="method" line="149">
			<f a="bytes:type:?options:_done">
				<c path="haxe.io.Bytes"/>
				<x path="ceramic.ImageType"/>
				<x path="Null"><t path="backend.LoadTextureOptions"/></x>
				<f a="">
					<t path="backend.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</loadFromBytes>
		<createTexture public="1" set="method" line="169">
			<f a="width:height:pixels">
				<x path="Int"/>
				<x path="Int"/>
				<t path="ceramic.UInt8Array"/>
				<t path="backend.Texture"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</createTexture>
		<createRenderTarget public="1" get="inline" set="null" line="186">
			<f a="width:height:depth:stencil:antialiasing">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<t path="backend.Texture"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</createRenderTarget>
		<destroyTexture public="1" set="method" line="210">
			<f a="texture">
				<t path="backend.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</destroyTexture>
		<getTextureId public="1" get="inline" set="null" line="233"><f a="texture">
	<t path="backend.Texture"/>
	<t path="backend.TextureId"/>
</f></getTextureId>
		<getTextureWidth public="1" get="inline" set="null" line="239"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureWidth>
		<getTextureHeight public="1" get="inline" set="null" line="245"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureHeight>
		<getTextureWidthActual public="1" get="inline" set="null" line="251"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureWidthActual>
		<getTextureHeightActual public="1" get="inline" set="null" line="257"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureHeightActual>
		<fetchTexturePixels public="1" set="method" line="263">
			<f a="texture:?result">
				<t path="backend.Texture"/>
				<x path="Null"><t path="ceramic.UInt8Array"/></x>
				<t path="ceramic.UInt8Array"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fetchTexturePixels>
		<submitTexturePixels public="1" set="method" line="323"><f a="texture:pixels">
	<t path="backend.Texture"/>
	<t path="ceramic.UInt8Array"/>
	<x path="Void"/>
</f></submitTexturePixels>
		<setTextureFilter public="1" get="inline" set="null" line="335">
			<f a="texture:filter">
				<t path="backend.Texture"/>
				<e path="ceramic.TextureFilter"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setTextureFilter>
		<setTextureWrapS public="1" get="inline" set="null" line="352"><f a="texture:wrap">
	<t path="backend.Texture"/>
	<x path="ceramic.TextureWrap"/>
	<x path="Void"/>
</f></setTextureWrapS>
		<setTextureWrapT public="1" get="inline" set="null" line="374"><f a="texture:wrap">
	<t path="backend.Texture"/>
	<x path="ceramic.TextureWrap"/>
	<x path="Void"/>
</f></setTextureWrapT>
		<supportsHotReloadPath public="1" get="inline" set="null" line="396"><f a=""><x path="Bool"/></f></supportsHotReloadPath>
		<maxTexturesByBatch public="1" set="method" line="405">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* If this returns a value above 1, that means this backend supports multi-texture batching.</haxe_doc>
		</maxTexturesByBatch>
		<getTextureIndex public="1" get="inline" set="null" line="412"><f a="texture">
	<t path="backend.Texture"/>
	<x path="Int"/>
</f></getTextureIndex>
		<textureToPng public="1" set="method" line="418">
			<f a="texture:?reversePremultiplyAlpha:?path:done" v=":true::">
				<t path="backend.Texture"/>
				<x path="Bool"/>
				<c path="String"/>
				<f a="?data">
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ reversePremultiplyAlpha : true }</e></m></meta>
		</textureToPng>
		<pixelsToPng public="1" set="method" line="453"><f a="width:height:pixels:?path:done">
	<x path="Int"/>
	<x path="Int"/>
	<t path="ceramic.UInt8Array"/>
	<c path="String"/>
	<f a="?data">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></pixelsToPng>
		<imageExtensions expr="null" line="479">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</imageExtensions>
		<loadingTextureCallbacks expr="new Map()" line="481">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><f a="">
	<t path="backend.Texture"/>
	<x path="Void"/>
</f></c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</loadingTextureCallbacks>
		<loadedTextures expr="new Map()" line="483">
			<t path="Map">
				<c path="String"/>
				<c path="backend.TextureImpl"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</loadedTextures>
		<loadedTexturesRetainCount expr="new Map()" line="485">
			<t path="Map">
				<c path="String"/>
				<x path="Int"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</loadedTexturesRetainCount>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="backend.UInt16Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/UInt16Array.hx">
		<c path="cs.NativeArray"><t path="cs.types.UInt16"/></c>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="backend.UInt8Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/UInt8Array.hx">
		<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<enum path="backend.VisualItem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/backend/VisualItem.hx">
		<NONE/>
		<QUAD/>
		<MESH/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="binpacking.IOccupancy" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/IOccupancy.hx" interface="1">
		<occupancy public="1" set="method"><f a=""><x path="Float"/></f></occupancy>
		<meta><m n=":hxGen"/></meta>
	</class>
	<abstract path="binpacking.FreeRectChoiceHeuristic" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/MaxRectsPacker.hx" module="binpacking.MaxRectsPacker">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="binpacking._MaxRectsPacker.FreeRectChoiceHeuristic_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/MaxRectsPacker.hx" private="1" module="binpacking.MaxRectsPacker" extern="1" final="1">
	<BestShortSideFit public="1" get="inline" set="null" expr="cast 1" line="4" static="1">
		<x path="binpacking.FreeRectChoiceHeuristic"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BestShortSideFit>
	<BestLongSideFit public="1" get="inline" set="null" expr="cast 2" line="5" static="1">
		<x path="binpacking.FreeRectChoiceHeuristic"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BestLongSideFit>
	<BestAreaFit public="1" get="inline" set="null" expr="cast 3" line="6" static="1">
		<x path="binpacking.FreeRectChoiceHeuristic"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BestAreaFit>
	<BottomLeftRule public="1" get="inline" set="null" expr="cast 4" line="7" static="1">
		<x path="binpacking.FreeRectChoiceHeuristic"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BottomLeftRule>
	<ContactPointRule public="1" get="inline" set="null" expr="cast 5" line="8" static="1">
		<x path="binpacking.FreeRectChoiceHeuristic"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ContactPointRule>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="binpacking._MaxRectsPacker.FreeRectChoiceHeuristic_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/MaxRectsPacker.hx" private="1" module="binpacking.MaxRectsPacker" extern="1" final="1">
		<BestShortSideFit public="1" get="inline" set="null" expr="cast 1" line="4" static="1">
			<x path="binpacking.FreeRectChoiceHeuristic"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BestShortSideFit>
		<BestLongSideFit public="1" get="inline" set="null" expr="cast 2" line="5" static="1">
			<x path="binpacking.FreeRectChoiceHeuristic"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BestLongSideFit>
		<BestAreaFit public="1" get="inline" set="null" expr="cast 3" line="6" static="1">
			<x path="binpacking.FreeRectChoiceHeuristic"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BestAreaFit>
		<BottomLeftRule public="1" get="inline" set="null" expr="cast 4" line="7" static="1">
			<x path="binpacking.FreeRectChoiceHeuristic"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BottomLeftRule>
		<ContactPointRule public="1" get="inline" set="null" expr="cast 5" line="8" static="1">
			<x path="binpacking.FreeRectChoiceHeuristic"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ContactPointRule>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="binpacking.MaxRectsPackerBestFitPosition" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/MaxRectsPacker.hx" module="binpacking.MaxRectsPacker">
		<bestNode public="1" expr="null" line="12">
			<c path="binpacking.Rect"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</bestNode>
		<bestAreaFit public="1" expr="-1" line="13">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bestAreaFit>
		<bestShortSideFit public="1" expr="-1" line="14">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bestShortSideFit>
		<bestLongSideFit public="1" expr="-1" line="15">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bestLongSideFit>
		<bestContactScore public="1" expr="-1" line="16">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bestContactScore>
		<bestX public="1" expr="-1" line="17">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bestX>
		<bestY public="1" expr="-1" line="18">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bestY>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="binpacking.MaxRectsPackerRectScore" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/MaxRectsPacker.hx" module="binpacking.MaxRectsPacker">
		<rect public="1"><c path="binpacking.Rect"/></rect>
		<primaryScore public="1"><x path="Int"/></primaryScore>
		<secondaryScore public="1"><x path="Int"/></secondaryScore>
		<new public="1" set="method" line="23">
			<f a="rect:primaryScore:secondaryScore">
				<c path="binpacking.Rect"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="binpacking.MaxRectsPacker" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/MaxRectsPacker.hx">
		<implements path="binpacking.IOccupancy"/>
		<binWidth public="1" set="null"><x path="Int"/></binWidth>
		<binHeight public="1" set="null"><x path="Int"/></binHeight>
		<binAllowFlip public="1" set="null"><x path="Bool"/></binAllowFlip>
		<usedRectangles public="1" set="null" expr="new Array&lt;Rect&gt;()" line="33">
			<c path="Array"><c path="binpacking.Rect"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Rect>()]]></e></m></meta>
		</usedRectangles>
		<freeRectangles public="1" set="null" expr="new Array&lt;Rect&gt;()" line="34">
			<c path="Array"><c path="binpacking.Rect"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Rect>()]]></e></m></meta>
		</freeRectangles>
		<_bestFitPosition expr="new MaxRectsPackerBestFitPosition()" line="36">
			<c path="binpacking.MaxRectsPackerBestFitPosition"/>
			<meta><m n=":value"><e>new MaxRectsPackerBestFitPosition()</e></m></meta>
		</_bestFitPosition>
		<insert public="1" set="method" line="48"><f a="width:height:method">
	<x path="Int"/>
	<x path="Int"/>
	<x path="binpacking.FreeRectChoiceHeuristic"/>
	<c path="binpacking.Rect"/>
</f></insert>
		<occupancy public="1" set="method" line="84"><f a=""><x path="Float"/></f></occupancy>
		<scoreRect set="method" line="98"><f a="width:height:method">
	<x path="Int"/>
	<x path="Int"/>
	<x path="binpacking.FreeRectChoiceHeuristic"/>
	<c path="binpacking.MaxRectsPackerRectScore"/>
</f></scoreRect>
		<contactPointScoreNode set="method" line="138"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></contactPointScoreNode>
		<findPositionForNewNodeBottomLeft set="method" line="160"><f a="width:height:result">
	<x path="Int"/>
	<x path="Int"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
</f></findPositionForNewNodeBottomLeft>
		<findPositionForNewNodeBestShortSideFit set="method" line="196"><f a="width:height:result">
	<x path="Int"/>
	<x path="Int"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
</f></findPositionForNewNodeBestShortSideFit>
		<findPositionForNewNodeBestLongSideFit set="method" line="243"><f a="width:height:result">
	<x path="Int"/>
	<x path="Int"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
</f></findPositionForNewNodeBestLongSideFit>
		<findPositionForNewNodeBestAreaFit set="method" line="290"><f a="width:height:result">
	<x path="Int"/>
	<x path="Int"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
</f></findPositionForNewNodeBestAreaFit>
		<findPositionForNewNodeContactPoint set="method" line="337"><f a="width:height:result">
	<x path="Int"/>
	<x path="Int"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
	<c path="binpacking.MaxRectsPackerBestFitPosition"/>
</f></findPositionForNewNodeContactPoint>
		<splitFreeNode set="method" line="372"><f a="freeNode:usedNode">
	<c path="binpacking.Rect"/>
	<c path="binpacking.Rect"/>
	<x path="Bool"/>
</f></splitFreeNode>
		<pruneFreeList set="method" line="411"><f a=""><x path="Void"/></f></pruneFreeList>
		<commonIntervalLength set="method" line="433"><f a="i1start:i1end:i2start:i2end">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></commonIntervalLength>
		<new public="1" set="method" line="38">
			<f a="?width:?height:?allowFlip" v="0:0:true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ allowFlip : true, height : 0, width : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="binpacking.RectSize" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/Rect.hx" module="binpacking.Rect">
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<new public="1" get="inline" set="null" line="7"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="binpacking.Rect" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/Rect.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<flipped public="1"><x path="Bool"/></flipped>
		<clone public="1" get="inline" set="null" line="28"><f a=""><c path="binpacking.Rect"/></f></clone>
		<isContainedIn public="1" get="inline" set="null" line="32"><f a="other">
	<c path="binpacking.Rect"/>
	<x path="Bool"/>
</f></isContainedIn>
		<new public="1" get="inline" set="null" line="20">
			<f a="?x:?y:?width:?height:?flipped" v="0:0:0:0:false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ flipped : false, height : 0, width : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="binpacking.DisjointRectCollection" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/bin-packing/binpacking/Rect.hx" module="binpacking.Rect">
		<rectsDisjoint public="1" set="method" line="76" static="1"><f a="a:b">
	<c path="binpacking.Rect"/>
	<c path="binpacking.Rect"/>
	<x path="Bool"/>
</f></rectsDisjoint>
		<rects public="1" expr="new Array&lt;Rect&gt;()" line="39">
			<c path="Array"><c path="binpacking.Rect"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Rect>()]]></e></m></meta>
		</rects>
		<add public="1" set="method" line="44"><f a="r">
	<c path="binpacking.Rect"/>
	<x path="Bool"/>
</f></add>
		<clear public="1" set="method" line="58"><f a=""><x path="Void"/></f></clear>
		<disjoint public="1" set="method" line="62"><f a="r">
	<c path="binpacking.Rect"/>
	<x path="Bool"/>
</f></disjoint>
		<new public="1" set="method" line="41"><f a=""><x path="Void"/></f></new>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.AllApi" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AllApi.hx">
		<apiCallCache public="1" set="method" line="403" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</apiCallCache>
		<configureHscript public="1" set="method" line="410" static="1"><f a="interp">
	<c path="hscript.Interp"/>
	<x path="Void"/>
</f></configureHscript>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":keep"/>
		</meta>
	</class>
	<abstract path="ceramic.AlphaColor" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AlphaColor.hx">
		<from>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
			<icast field="toColor"><x path="ceramic.Color"/></icast>
		</to>
		<haxe_doc>* Color (alpha included) stored as integer.
 * Can be decomposed to Color/Int (RGB) + Float (A) and
 * constructed from Color/Int (RGB) + Float (A).</haxe_doc>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="ceramic._AlphaColor.AlphaColor_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AlphaColor.hx" private="1" module="ceramic.AlphaColor" final="1">
	<NONE public="1" get="inline" set="null" expr="-1" line="19" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>-1</e></m></meta>
	</NONE>
	<TRANSPARENT public="1" get="inline" set="null" expr="0x00000000" line="21" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0x00000000</e></m></meta>
	</TRANSPARENT>
	<WHITE public="1" get="inline" set="null" expr="0xFFFFFFFF" line="23" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFFFFF</e></m></meta>
	</WHITE>
	<GRAY public="1" get="inline" set="null" expr="0xFF808080" line="24" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF808080</e></m></meta>
	</GRAY>
	<BLACK public="1" get="inline" set="null" expr="0xFF000000" line="25" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF000000</e></m></meta>
	</BLACK>
	<GREEN public="1" get="inline" set="null" expr="0xFF008000" line="27" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF008000</e></m></meta>
	</GREEN>
	<LIME public="1" get="inline" set="null" expr="0xFF00FF00" line="28" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF00FF00</e></m></meta>
	</LIME>
	<YELLOW public="1" get="inline" set="null" expr="0xFFFFFF00" line="29" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFFF00</e></m></meta>
	</YELLOW>
	<ORANGE public="1" get="inline" set="null" expr="0xFFFFA500" line="30" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFA500</e></m></meta>
	</ORANGE>
	<RED public="1" get="inline" set="null" expr="0xFFFF0000" line="31" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF0000</e></m></meta>
	</RED>
	<PURPLE public="1" get="inline" set="null" expr="0xFF800080" line="32" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF800080</e></m></meta>
	</PURPLE>
	<BLUE public="1" get="inline" set="null" expr="0xFF0000FF" line="33" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF0000FF</e></m></meta>
	</BLUE>
	<BROWN public="1" get="inline" set="null" expr="0xFF8B4513" line="34" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF8B4513</e></m></meta>
	</BROWN>
	<PINK public="1" get="inline" set="null" expr="0xFFFFC0CB" line="35" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFC0CB</e></m></meta>
	</PINK>
	<MAGENTA public="1" get="inline" set="null" expr="0xFFFF00FF" line="36" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
	</MAGENTA>
	<CYAN public="1" get="inline" set="null" expr="0xFF00FFFF" line="37" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
	</CYAN>
	<CORNFLOWERBLUE public="1" get="inline" set="null" expr="0xFF6495ED" line="39" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF6495ED</e></m></meta>
	</CORNFLOWERBLUE>
	<MEDIUMVIOLETRED public="1" get="inline" set="null" expr="0xFFC71585" line="40" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFC71585</e></m></meta>
	</MEDIUMVIOLETRED>
	<DEEPPINK public="1" get="inline" set="null" expr="0xFFFF1493" line="41" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF1493</e></m></meta>
	</DEEPPINK>
	<PALEVIOLETRED public="1" get="inline" set="null" expr="0xFFDB7093" line="42" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFDB7093</e></m></meta>
	</PALEVIOLETRED>
	<HOTPINK public="1" get="inline" set="null" expr="0xFFFF69B4" line="43" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF69B4</e></m></meta>
	</HOTPINK>
	<LIGHTPINK public="1" get="inline" set="null" expr="0xFFFFB6C1" line="44" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFB6C1</e></m></meta>
	</LIGHTPINK>
	<DARKRED public="1" get="inline" set="null" expr="0xFF8B0000" line="45" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF8B0000</e></m></meta>
	</DARKRED>
	<FIREBRICK public="1" get="inline" set="null" expr="0xFFB22222" line="46" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFB22222</e></m></meta>
	</FIREBRICK>
	<CRIMSON public="1" get="inline" set="null" expr="0xFFDC143C" line="47" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFDC143C</e></m></meta>
	</CRIMSON>
	<INDIANRED public="1" get="inline" set="null" expr="0xFFCD5C5C" line="48" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFCD5C5C</e></m></meta>
	</INDIANRED>
	<LIGHTCORAL public="1" get="inline" set="null" expr="0xFFF08080" line="49" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFF08080</e></m></meta>
	</LIGHTCORAL>
	<SALMON public="1" get="inline" set="null" expr="0xFFFA8072" line="50" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFA8072</e></m></meta>
	</SALMON>
	<DARKSALMON public="1" get="inline" set="null" expr="0xFFE9967A" line="51" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFE9967A</e></m></meta>
	</DARKSALMON>
	<LIGHTSALMON public="1" get="inline" set="null" expr="0xFFFFA07A" line="52" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFA07A</e></m></meta>
	</LIGHTSALMON>
	<ORANGERED public="1" get="inline" set="null" expr="0xFFFF4500" line="53" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF4500</e></m></meta>
	</ORANGERED>
	<TOMATO public="1" get="inline" set="null" expr="0xFFFF6347" line="54" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF6347</e></m></meta>
	</TOMATO>
	<DARKORANGE public="1" get="inline" set="null" expr="0xFFFF8C00" line="55" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF8C00</e></m></meta>
	</DARKORANGE>
	<CORAL public="1" get="inline" set="null" expr="0xFFFF7F50" line="56" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFF7F50</e></m></meta>
	</CORAL>
	<DARKKHAKI public="1" get="inline" set="null" expr="0xFFBDB76B" line="57" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFBDB76B</e></m></meta>
	</DARKKHAKI>
	<GOLD public="1" get="inline" set="null" expr="0xFFFFD700" line="58" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFD700</e></m></meta>
	</GOLD>
	<KHAKI public="1" get="inline" set="null" expr="0xFFF0E68C" line="59" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFF0E68C</e></m></meta>
	</KHAKI>
	<PEACHPUFF public="1" get="inline" set="null" expr="0xFFFFDAB9" line="60" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFDAB9</e></m></meta>
	</PEACHPUFF>
	<PALEGOLDENROD public="1" get="inline" set="null" expr="0xFFEEE8AA" line="61" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFEEE8AA</e></m></meta>
	</PALEGOLDENROD>
	<MOCCASIN public="1" get="inline" set="null" expr="0xFFFFE4B5" line="62" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFE4B5</e></m></meta>
	</MOCCASIN>
	<PAPAYAWHIP public="1" get="inline" set="null" expr="0xFFFFEFD5" line="63" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFEFD5</e></m></meta>
	</PAPAYAWHIP>
	<LEMONCHIFFON public="1" get="inline" set="null" expr="0xFFFFFACD" line="64" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFFACD</e></m></meta>
	</LEMONCHIFFON>
	<LIGHTYELLOW public="1" get="inline" set="null" expr="0xFFFFFFE0" line="65" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFFFE0</e></m></meta>
	</LIGHTYELLOW>
	<SIENNA public="1" get="inline" set="null" expr="0xFFA0522D" line="66" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFA0522D</e></m></meta>
	</SIENNA>
	<CHOCOLATE public="1" get="inline" set="null" expr="0xFFD2691E" line="67" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFD2691E</e></m></meta>
	</CHOCOLATE>
	<PERU public="1" get="inline" set="null" expr="0xFFCD853F" line="68" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFCD853F</e></m></meta>
	</PERU>
	<TAN public="1" get="inline" set="null" expr="0xFFD2B48C" line="69" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFD2B48C</e></m></meta>
	</TAN>
	<DARKOLIVEGREEN public="1" get="inline" set="null" expr="0xFF556B2F" line="70" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF556B2F</e></m></meta>
	</DARKOLIVEGREEN>
	<OLIVE public="1" get="inline" set="null" expr="0xFF808000" line="71" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF808000</e></m></meta>
	</OLIVE>
	<TEAL public="1" get="inline" set="null" expr="0xFF008080" line="72" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF008080</e></m></meta>
	</TEAL>
	<TURQUOISE public="1" get="inline" set="null" expr="0xFF40E0D0" line="73" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF40E0D0</e></m></meta>
	</TURQUOISE>
	<NAVY public="1" get="inline" set="null" expr="0xFF000080" line="74" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF000080</e></m></meta>
	</NAVY>
	<INDIGO public="1" get="inline" set="null" expr="0xFF4B0082" line="75" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF4B0082</e></m></meta>
	</INDIGO>
	<ORCHID public="1" get="inline" set="null" expr="0xFFDA70D6" line="76" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFDA70D6</e></m></meta>
	</ORCHID>
	<LAVENDER public="1" get="inline" set="null" expr="0xFFE6E6FA" line="77" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFE6E6FA</e></m></meta>
	</LAVENDER>
	<AZURE public="1" get="inline" set="null" expr="0xFFF0FFFF" line="78" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFF0FFFF</e></m></meta>
	</AZURE>
	<IVORY public="1" get="inline" set="null" expr="0xFFFFFFF0" line="79" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFFFF0</e></m></meta>
	</IVORY>
	<DIMGREY public="1" get="inline" set="null" expr="0xFF696969" line="80" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF696969</e></m></meta>
	</DIMGREY>
	<SLATEGREY public="1" get="inline" set="null" expr="0xFF708090" line="81" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFF708090</e></m></meta>
	</SLATEGREY>
	<SNOW public="1" get="inline" set="null" expr="0xFFFFFAFA" line="82" static="1">
		<x path="ceramic.AlphaColor"/>
		<meta><m n=":value"><e>0xFFFFFAFA</e></m></meta>
	</SNOW>
	<red public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Red color component as `Int` between `0` and `255`</haxe_doc>
	</red>
	<green public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Green color component as `Int` between `0` and `255`</haxe_doc>
	</green>
	<blue public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Blue color component as `Int` between `0` and `255`</haxe_doc>
	</blue>
	<alpha public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Alpha component as `Int` between `0` and `255`</haxe_doc>
	</alpha>
	<redFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Red color component as `Float` between `0.0` and `1.0`</haxe_doc>
	</redFloat>
	<greenFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Green color component as `Float` between `0.0` and `1.0`</haxe_doc>
	</greenFloat>
	<blueFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Blue color component as `Float` between `0.0` and `1.0`</haxe_doc>
	</blueFloat>
	<alphaFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Alpha component as `Float` between `0.0` and `1.0`</haxe_doc>
	</alphaFloat>
	<cyan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></cyan>
	<magenta public="1" get="accessor" set="accessor" static="1"><x path="Float"/></magenta>
	<yellow public="1" get="accessor" set="accessor" static="1"><x path="Float"/></yellow>
	<black public="1" get="accessor" set="accessor" static="1"><x path="Float"/></black>
	<hue public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hue>
	<saturation public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
	</saturation>
	<brightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
	</brightness>
	<lightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
	</lightness>
	<color public="1" get="accessor" set="accessor" static="1">
		<x path="ceramic.Color"/>
		<haxe_doc>* RGB color component typed as `ceramic.Color`</haxe_doc>
	</color>
	<rgb public="1" get="accessor" set="accessor" static="1">
		<x path="ceramic.Color"/>
		<haxe_doc>* RGB color component typed as `ceramic.Color` (alias of `color`)</haxe_doc>
	</rgb>
	<toColor public="1" get="inline" set="null" line="150" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":to"/></meta>
	</toColor>
	<random public="1" get="inline" set="null" line="159" static="1">
		<f a="?minSatutation:?minBrightness" v="0.5:0.5">
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":value"><e>{ minBrightness : 0.5, minSatutation : 0.5 }</e></m></meta>
		<haxe_doc>* Generate a random color (away from white or black)
     * @return The color as an AlphaColor</haxe_doc>
	</random>
	<fromInt public="1" get="inline" set="null" line="170" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Create a color from the least significant four bytes of an Int
     *
     * @param    value And Int with bytes in the format 0xAARRGGBB
     * @return    The color as an AlphaColor</haxe_doc>
	</fromInt>
	<fromRGB public="1" get="inline" set="null" line="183" static="1">
		<f a="red:green:blue">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from integer RGB values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return The color as a AlphaColor</haxe_doc>
	</fromRGB>
	<fromRGBFloat public="1" get="inline" set="null" line="196" static="1">
		<f a="red:green:blue">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from float RGB values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return The color as a AlphaColor</haxe_doc>
	</fromRGBFloat>
	<fromRGBA public="1" get="inline" set="null" line="211" static="1">
		<f a="red:green:blue:alpha">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from integer RGBA values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @param alpha    The alpha value of the color from 0 to 255
     * @return The color as a AlphaColor</haxe_doc>
	</fromRGBA>
	<fromRGBAFloat public="1" get="inline" set="null" line="225" static="1">
		<f a="red:green:blue:alpha">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from float RGBA values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @param alpha    The green value of the color from 0 to 1
     * @return The color as a AlphaColor</haxe_doc>
	</fromRGBAFloat>
	<fromCMYK public="1" get="inline" set="null" line="240" static="1">
		<f a="cyan:magenta:yellow:black">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from CMYK values (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return The color as a AlphaColor</haxe_doc>
	</fromCMYK>
	<fromHSB public="1" set="method" line="254" static="1">
		<f a="hue:saturation:brightness">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from HSB (aka HSV) components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    The color as a AlphaColor</haxe_doc>
	</fromHSB>
	<fromHSL public="1" get="inline" set="null" line="268" static="1">
		<f a="hue:saturation:lightness">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a AlphaColor</haxe_doc>
	</fromHSL>
	<fromString public="1" set="method" line="287" static="1">
		<f a="str">
			<c path="String"/>
			<x path="Null"><x path="ceramic.AlphaColor"/></x>
		</f>
		<haxe_doc><![CDATA[* Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.
     *
     * Examples (input -> output in hex):
     *
     * - `0xFF00FF00`    -> `0xFF00FF00`
     * - `#FF0000FF`     -> `0xFF0000FF`
     * - `GRAY`        -> `0xFF808080`
     * - `blue`        -> `0xFF0000FF`
     *
     * @param    str     The string to be parsed
     * @return    A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
	</fromString>
	<getHSBColorWheel public="1" set="method" line="329" static="1">
		<f a=""><c path="Array"><x path="ceramic.AlphaColor"/></c></f>
		<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
     *
     * @return    HSB color wheel as Array of AlphaColors</haxe_doc>
	</getHSBColorWheel>
	<interpolate public="1" get="inline" set="null" line="342" static="1">
		<f a="color1:color2:?factor" v="::0.5">
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":value"><e>{ factor : 0.5 }</e></m></meta>
		<haxe_doc>* Get an interpolated color based on two different colors.
     *
     * @param     color1 The first color
     * @param     color2 The second color
     * @param     factor value from 0 to 1 representing how much to shift color1 toward color2
     * @return    The interpolated color</haxe_doc>
	</interpolate>
	<gradient public="1" set="method" line="361" static="1">
		<f a="color1:color2:steps:?ease">
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
			<x path="Int"/>
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<c path="Array"><x path="ceramic.AlphaColor"/></c>
		</f>
		<haxe_doc>* Create a gradient from one color to another
     *
     * @param color1 The color to shift from
     * @param color2 The color to shift to
     * @param steps How many colors the gradient should have
     * @param ease An optional easing function, such as those provided in FlxEase
     * @return An array of colors of length steps, shifting from color1 to color2</haxe_doc>
	</gradient>
	<multiply public="1" get="inline" set="null" line="385" static="1">
		<f a="lhs:rhs">
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":op"><e>A * B</e></m></meta>
		<haxe_doc>* Multiply the RGB channels of two AlphaColors</haxe_doc>
	</multiply>
	<add public="1" get="inline" set="null" line="394" static="1">
		<f a="lhs:rhs">
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
		<haxe_doc>* Add the RGB channels of two AlphaColors</haxe_doc>
	</add>
	<subtract public="1" get="inline" set="null" line="403" static="1">
		<f a="lhs:rhs">
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
		<haxe_doc>* Subtract the RGB channels of one Color from another</haxe_doc>
	</subtract>
	<toHexString public="1" get="inline" set="null" line="414" static="1">
		<f a="this:?prefix" v=":true">
			<x path="Int"/>
			<x path="Bool"/>
			<c path="String"/>
		</f>
		<meta><m n=":value"><e>{ prefix : true }</e></m></meta>
		<haxe_doc>* Return a String representation of the color in the format
     *
     * @param prefix Whether to include "0x" prefix at start of string
     * @return    A string of length 10 in the format 0xAARRGGBB</haxe_doc>
	</toHexString>
	<toWebString public="1" get="inline" set="null" line="425" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Return a String representation of the color in the format #RRGGBB
     *
     * @return    A string of length 7 in the format #RRGGBB</haxe_doc>
	</toWebString>
	<getColorInfo public="1" set="method" line="435" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Get a string of color information about this color
     *
     * @return A string containing information about this color</haxe_doc>
	</getColorInfo>
	<getDarkened public="1" set="method" line="454" static="1">
		<f a="this:?factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
		<haxe_doc>* Get a darkened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward black.
     * @return     A darkened version of this color</haxe_doc>
	</getDarkened>
	<getLightened public="1" get="inline" set="null" line="468" static="1">
		<f a="this:?factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
		<haxe_doc>* Get a lightened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward white.
     * @return     A lightened version of this color</haxe_doc>
	</getLightened>
	<getInverted public="1" get="inline" set="null" line="481" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Get the inversion of this color
     *
     * @return The inversion of this color</haxe_doc>
	</getInverted>
	<setRGB public="1" get="inline" set="null" line="497" static="1">
		<f a="this:red:green:blue">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set RGB values as integers (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return This color</haxe_doc>
	</setRGB>
	<setRGBA public="1" get="inline" set="null" line="514" static="1">
		<f a="this:red:green:blue:alpha">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set RGB values as integers (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @param alpha    The alpha value of the color from 0 to 255
     * @return This color</haxe_doc>
	</setRGBA>
	<setRGBFloat public="1" get="inline" set="null" line="531" static="1">
		<f a="this:red:green:blue">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set RGB values as floats (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return This color</haxe_doc>
	</setRGBFloat>
	<setRGBAFloat public="1" get="inline" set="null" line="548" static="1">
		<f a="this:red:green:blue:alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set RGB values as floats (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @param alpha    The alpha value of the color from 0 to 1
     * @return This color</haxe_doc>
	</setRGBAFloat>
	<setCMYK public="1" get="inline" set="null" line="566" static="1">
		<f a="this:cyan:magenta:yellow:black">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set CMYK values as floats (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return This color</haxe_doc>
	</setCMYK>
	<setHSB public="1" get="inline" set="null" line="582" static="1">
		<f a="this:hue:saturation:brightness">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set HSB (aka HSV) components
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    This color</haxe_doc>
	</setHSB>
	<setHSL public="1" get="inline" set="null" line="597" static="1">
		<f a="this:hue:saturation:lightness">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
	</setHSL>
	<setHSChromaMatch get="inline" set="null" line="607" static="1">
		<f a="this:hue:saturation:chroma:match">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
	</setHSChromaMatch>
	<_new public="1" get="inline" set="null" line="631" static="1">
		<f a="color:?alpha" v=":255">
			<x path="ceramic.Color"/>
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta>
			<m n=":value"><e>{ alpha : 255 }</e></m>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>* Create a new `AlphaColor` (ARGB) object from a `ceramic.Color` object and the given `alpha`
     * @param color RGB color object (`ceramic.Color`)
     * @param alpha alpha component between `0` and `255`</haxe_doc>
	</_new>
	<get_color get="inline" set="null" line="637" static="1"><f a="this">
	<x path="Int"/>
	<x path="ceramic.Color"/>
</f></get_color>
	<set_color get="inline" set="null" line="640" static="1"><f a="this:color">
	<x path="Int"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
	<get_rgb get="inline" set="null" line="647" static="1"><f a="this">
	<x path="Int"/>
	<x path="ceramic.Color"/>
</f></get_rgb>
	<set_rgb get="inline" set="null" line="650" static="1"><f a="this:color">
	<x path="Int"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_rgb>
	<get_red get="inline" set="null" line="657" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_red>
	<get_green get="inline" set="null" line="661" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_green>
	<get_blue get="inline" set="null" line="665" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_blue>
	<get_alpha get="inline" set="null" line="669" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_alpha>
	<get_redFloat get="inline" set="null" line="673" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_redFloat>
	<get_greenFloat get="inline" set="null" line="677" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_greenFloat>
	<get_blueFloat get="inline" set="null" line="681" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_blueFloat>
	<get_alphaFloat get="inline" set="null" line="685" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_alphaFloat>
	<set_red get="inline" set="null" line="689" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_red>
	<set_green get="inline" set="null" line="695" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_green>
	<set_blue get="inline" set="null" line="701" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_blue>
	<set_alpha get="inline" set="null" line="707" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_alpha>
	<set_redFloat get="inline" set="null" line="713" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_redFloat>
	<set_greenFloat get="inline" set="null" line="718" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_greenFloat>
	<set_blueFloat get="inline" set="null" line="723" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_blueFloat>
	<set_alphaFloat get="inline" set="null" line="728" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_alphaFloat>
	<get_cyan get="inline" set="null" line="734" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_cyan>
	<get_magenta get="inline" set="null" line="739" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_magenta>
	<get_yellow get="inline" set="null" line="744" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_yellow>
	<get_black get="inline" set="null" line="749" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_black>
	<set_cyan get="inline" set="null" line="754" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_cyan>
	<set_magenta get="inline" set="null" line="760" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_magenta>
	<set_yellow get="inline" set="null" line="766" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_yellow>
	<set_black get="inline" set="null" line="772" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_black>
	<get_hue set="method" line="778" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hue>
	<get_brightness get="inline" set="null" line="790" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_brightness>
	<get_saturation get="inline" set="null" line="795" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturation>
	<get_lightness get="inline" set="null" line="800" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightness>
	<set_hue get="inline" set="null" line="805" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hue>
	<set_saturation get="inline" set="null" line="811" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturation>
	<set_brightness get="inline" set="null" line="817" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_brightness>
	<set_lightness get="inline" set="null" line="823" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightness>
	<maxColor get="inline" set="null" line="829" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></maxColor>
	<minColor get="inline" set="null" line="834" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></minColor>
	<boundChannel get="inline" set="null" line="839" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></boundChannel>
	<roundDecimal set="method" line="846" static="1"><f a="value:precision">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></roundDecimal>
	<bound get="inline" set="null" line="856" static="1"><f a="value:?min:?max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></bound>
	<toString public="1" get="inline" set="null" line="867" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Get this RGBA color as `String`.
     * Format: `0xAARRGGBB`</haxe_doc>
	</toString>
	<_hsluvTuple expr="[0, 0, 0]" line="877" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
	</_hsluvTuple>
	<_hsluvResult expr="[0, 0, 0]" line="879" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
	</_hsluvResult>
	<hueHSLuv public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The HSLuv hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hueHSLuv>
	<saturationHSLuv public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The HSLuv saturation of the color (from 0 to 1)</haxe_doc>
	</saturationHSLuv>
	<lightnessHSLuv public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The HSLuv lightness of the color (from 0 to 1)</haxe_doc>
	</lightnessHSLuv>
	<get_hueHSLuv set="method" line="895" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hueHSLuv>
	<set_hueHSLuv get="inline" set="null" line="900" static="1"><f a="this:hueHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hueHSLuv>
	<get_saturationHSLuv set="method" line="906" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturationHSLuv>
	<set_saturationHSLuv get="inline" set="null" line="911" static="1"><f a="this:saturationHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturationHSLuv>
	<get_lightnessHSLuv set="method" line="917" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightnessHSLuv>
	<set_lightnessHSLuv get="inline" set="null" line="922" static="1"><f a="this:lightnessHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightnessHSLuv>
	<_getOrCreateCachedHSLuvComponent get="inline" set="null" line="928" static="1"><f a="this:index">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></_getOrCreateCachedHSLuvComponent>
	<fromHSLuv public="1" get="inline" set="null" line="951" static="1">
		<f a="hue:saturation:lightness">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Generate a color from HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a AlphaColor</haxe_doc>
	</fromHSLuv>
	<setHSLuv public="1" get="inline" set="null" line="965" static="1">
		<f a="this:hue:saturation:lightness">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<haxe_doc>* Set HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
	</setHSLuv>
	<getHSLuv public="1" get="inline" set="null" line="997" static="1">
		<f a="this:?result">
			<x path="Int"/>
			<c path="Array"><x path="Float"/></c>
			<c path="Array"><x path="Float"/></c>
		</f>
		<haxe_doc>* Get HSLuv components from the color instance.
     *
     * @param result A pre-allocated array to store the result into.
     * @return    The HSLuv components as a float array</haxe_doc>
	</getHSLuv>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._AlphaColor.AlphaColor_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AlphaColor.hx" private="1" module="ceramic.AlphaColor" final="1">
		<NONE public="1" get="inline" set="null" expr="-1" line="19" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</NONE>
		<TRANSPARENT public="1" get="inline" set="null" expr="0x00000000" line="21" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
		</TRANSPARENT>
		<WHITE public="1" get="inline" set="null" expr="0xFFFFFFFF" line="23" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFFFFF</e></m></meta>
		</WHITE>
		<GRAY public="1" get="inline" set="null" expr="0xFF808080" line="24" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF808080</e></m></meta>
		</GRAY>
		<BLACK public="1" get="inline" set="null" expr="0xFF000000" line="25" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF000000</e></m></meta>
		</BLACK>
		<GREEN public="1" get="inline" set="null" expr="0xFF008000" line="27" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF008000</e></m></meta>
		</GREEN>
		<LIME public="1" get="inline" set="null" expr="0xFF00FF00" line="28" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF00FF00</e></m></meta>
		</LIME>
		<YELLOW public="1" get="inline" set="null" expr="0xFFFFFF00" line="29" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFFF00</e></m></meta>
		</YELLOW>
		<ORANGE public="1" get="inline" set="null" expr="0xFFFFA500" line="30" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFA500</e></m></meta>
		</ORANGE>
		<RED public="1" get="inline" set="null" expr="0xFFFF0000" line="31" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF0000</e></m></meta>
		</RED>
		<PURPLE public="1" get="inline" set="null" expr="0xFF800080" line="32" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF800080</e></m></meta>
		</PURPLE>
		<BLUE public="1" get="inline" set="null" expr="0xFF0000FF" line="33" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF0000FF</e></m></meta>
		</BLUE>
		<BROWN public="1" get="inline" set="null" expr="0xFF8B4513" line="34" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF8B4513</e></m></meta>
		</BROWN>
		<PINK public="1" get="inline" set="null" expr="0xFFFFC0CB" line="35" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFC0CB</e></m></meta>
		</PINK>
		<MAGENTA public="1" get="inline" set="null" expr="0xFFFF00FF" line="36" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
		</MAGENTA>
		<CYAN public="1" get="inline" set="null" expr="0xFF00FFFF" line="37" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
		</CYAN>
		<CORNFLOWERBLUE public="1" get="inline" set="null" expr="0xFF6495ED" line="39" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF6495ED</e></m></meta>
		</CORNFLOWERBLUE>
		<MEDIUMVIOLETRED public="1" get="inline" set="null" expr="0xFFC71585" line="40" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFC71585</e></m></meta>
		</MEDIUMVIOLETRED>
		<DEEPPINK public="1" get="inline" set="null" expr="0xFFFF1493" line="41" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF1493</e></m></meta>
		</DEEPPINK>
		<PALEVIOLETRED public="1" get="inline" set="null" expr="0xFFDB7093" line="42" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFDB7093</e></m></meta>
		</PALEVIOLETRED>
		<HOTPINK public="1" get="inline" set="null" expr="0xFFFF69B4" line="43" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF69B4</e></m></meta>
		</HOTPINK>
		<LIGHTPINK public="1" get="inline" set="null" expr="0xFFFFB6C1" line="44" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFB6C1</e></m></meta>
		</LIGHTPINK>
		<DARKRED public="1" get="inline" set="null" expr="0xFF8B0000" line="45" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF8B0000</e></m></meta>
		</DARKRED>
		<FIREBRICK public="1" get="inline" set="null" expr="0xFFB22222" line="46" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFB22222</e></m></meta>
		</FIREBRICK>
		<CRIMSON public="1" get="inline" set="null" expr="0xFFDC143C" line="47" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFDC143C</e></m></meta>
		</CRIMSON>
		<INDIANRED public="1" get="inline" set="null" expr="0xFFCD5C5C" line="48" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFCD5C5C</e></m></meta>
		</INDIANRED>
		<LIGHTCORAL public="1" get="inline" set="null" expr="0xFFF08080" line="49" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFF08080</e></m></meta>
		</LIGHTCORAL>
		<SALMON public="1" get="inline" set="null" expr="0xFFFA8072" line="50" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFA8072</e></m></meta>
		</SALMON>
		<DARKSALMON public="1" get="inline" set="null" expr="0xFFE9967A" line="51" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFE9967A</e></m></meta>
		</DARKSALMON>
		<LIGHTSALMON public="1" get="inline" set="null" expr="0xFFFFA07A" line="52" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFA07A</e></m></meta>
		</LIGHTSALMON>
		<ORANGERED public="1" get="inline" set="null" expr="0xFFFF4500" line="53" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF4500</e></m></meta>
		</ORANGERED>
		<TOMATO public="1" get="inline" set="null" expr="0xFFFF6347" line="54" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF6347</e></m></meta>
		</TOMATO>
		<DARKORANGE public="1" get="inline" set="null" expr="0xFFFF8C00" line="55" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF8C00</e></m></meta>
		</DARKORANGE>
		<CORAL public="1" get="inline" set="null" expr="0xFFFF7F50" line="56" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFF7F50</e></m></meta>
		</CORAL>
		<DARKKHAKI public="1" get="inline" set="null" expr="0xFFBDB76B" line="57" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFBDB76B</e></m></meta>
		</DARKKHAKI>
		<GOLD public="1" get="inline" set="null" expr="0xFFFFD700" line="58" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFD700</e></m></meta>
		</GOLD>
		<KHAKI public="1" get="inline" set="null" expr="0xFFF0E68C" line="59" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFF0E68C</e></m></meta>
		</KHAKI>
		<PEACHPUFF public="1" get="inline" set="null" expr="0xFFFFDAB9" line="60" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFDAB9</e></m></meta>
		</PEACHPUFF>
		<PALEGOLDENROD public="1" get="inline" set="null" expr="0xFFEEE8AA" line="61" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFEEE8AA</e></m></meta>
		</PALEGOLDENROD>
		<MOCCASIN public="1" get="inline" set="null" expr="0xFFFFE4B5" line="62" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFE4B5</e></m></meta>
		</MOCCASIN>
		<PAPAYAWHIP public="1" get="inline" set="null" expr="0xFFFFEFD5" line="63" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFEFD5</e></m></meta>
		</PAPAYAWHIP>
		<LEMONCHIFFON public="1" get="inline" set="null" expr="0xFFFFFACD" line="64" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFFACD</e></m></meta>
		</LEMONCHIFFON>
		<LIGHTYELLOW public="1" get="inline" set="null" expr="0xFFFFFFE0" line="65" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFFFE0</e></m></meta>
		</LIGHTYELLOW>
		<SIENNA public="1" get="inline" set="null" expr="0xFFA0522D" line="66" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFA0522D</e></m></meta>
		</SIENNA>
		<CHOCOLATE public="1" get="inline" set="null" expr="0xFFD2691E" line="67" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFD2691E</e></m></meta>
		</CHOCOLATE>
		<PERU public="1" get="inline" set="null" expr="0xFFCD853F" line="68" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFCD853F</e></m></meta>
		</PERU>
		<TAN public="1" get="inline" set="null" expr="0xFFD2B48C" line="69" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFD2B48C</e></m></meta>
		</TAN>
		<DARKOLIVEGREEN public="1" get="inline" set="null" expr="0xFF556B2F" line="70" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF556B2F</e></m></meta>
		</DARKOLIVEGREEN>
		<OLIVE public="1" get="inline" set="null" expr="0xFF808000" line="71" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF808000</e></m></meta>
		</OLIVE>
		<TEAL public="1" get="inline" set="null" expr="0xFF008080" line="72" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF008080</e></m></meta>
		</TEAL>
		<TURQUOISE public="1" get="inline" set="null" expr="0xFF40E0D0" line="73" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF40E0D0</e></m></meta>
		</TURQUOISE>
		<NAVY public="1" get="inline" set="null" expr="0xFF000080" line="74" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF000080</e></m></meta>
		</NAVY>
		<INDIGO public="1" get="inline" set="null" expr="0xFF4B0082" line="75" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF4B0082</e></m></meta>
		</INDIGO>
		<ORCHID public="1" get="inline" set="null" expr="0xFFDA70D6" line="76" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFDA70D6</e></m></meta>
		</ORCHID>
		<LAVENDER public="1" get="inline" set="null" expr="0xFFE6E6FA" line="77" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFE6E6FA</e></m></meta>
		</LAVENDER>
		<AZURE public="1" get="inline" set="null" expr="0xFFF0FFFF" line="78" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFF0FFFF</e></m></meta>
		</AZURE>
		<IVORY public="1" get="inline" set="null" expr="0xFFFFFFF0" line="79" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFFFF0</e></m></meta>
		</IVORY>
		<DIMGREY public="1" get="inline" set="null" expr="0xFF696969" line="80" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF696969</e></m></meta>
		</DIMGREY>
		<SLATEGREY public="1" get="inline" set="null" expr="0xFF708090" line="81" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFF708090</e></m></meta>
		</SLATEGREY>
		<SNOW public="1" get="inline" set="null" expr="0xFFFFFAFA" line="82" static="1">
			<x path="ceramic.AlphaColor"/>
			<meta><m n=":value"><e>0xFFFFFAFA</e></m></meta>
		</SNOW>
		<red public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Red color component as `Int` between `0` and `255`</haxe_doc>
		</red>
		<green public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Green color component as `Int` between `0` and `255`</haxe_doc>
		</green>
		<blue public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Blue color component as `Int` between `0` and `255`</haxe_doc>
		</blue>
		<alpha public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Alpha component as `Int` between `0` and `255`</haxe_doc>
		</alpha>
		<redFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Red color component as `Float` between `0.0` and `1.0`</haxe_doc>
		</redFloat>
		<greenFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Green color component as `Float` between `0.0` and `1.0`</haxe_doc>
		</greenFloat>
		<blueFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Blue color component as `Float` between `0.0` and `1.0`</haxe_doc>
		</blueFloat>
		<alphaFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Alpha component as `Float` between `0.0` and `1.0`</haxe_doc>
		</alphaFloat>
		<cyan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></cyan>
		<magenta public="1" get="accessor" set="accessor" static="1"><x path="Float"/></magenta>
		<yellow public="1" get="accessor" set="accessor" static="1"><x path="Float"/></yellow>
		<black public="1" get="accessor" set="accessor" static="1"><x path="Float"/></black>
		<hue public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hue>
		<saturation public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
		</saturation>
		<brightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
		</brightness>
		<lightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
		</lightness>
		<color public="1" get="accessor" set="accessor" static="1">
			<x path="ceramic.Color"/>
			<haxe_doc>* RGB color component typed as `ceramic.Color`</haxe_doc>
		</color>
		<rgb public="1" get="accessor" set="accessor" static="1">
			<x path="ceramic.Color"/>
			<haxe_doc>* RGB color component typed as `ceramic.Color` (alias of `color`)</haxe_doc>
		</rgb>
		<toColor public="1" get="inline" set="null" line="150" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":to"/></meta>
		</toColor>
		<random public="1" get="inline" set="null" line="159" static="1">
			<f a="?minSatutation:?minBrightness" v="0.5:0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":value"><e>{ minBrightness : 0.5, minSatutation : 0.5 }</e></m></meta>
			<haxe_doc>* Generate a random color (away from white or black)
     * @return The color as an AlphaColor</haxe_doc>
		</random>
		<fromInt public="1" get="inline" set="null" line="170" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Create a color from the least significant four bytes of an Int
     *
     * @param    value And Int with bytes in the format 0xAARRGGBB
     * @return    The color as an AlphaColor</haxe_doc>
		</fromInt>
		<fromRGB public="1" get="inline" set="null" line="183" static="1">
			<f a="red:green:blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from integer RGB values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return The color as a AlphaColor</haxe_doc>
		</fromRGB>
		<fromRGBFloat public="1" get="inline" set="null" line="196" static="1">
			<f a="red:green:blue">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from float RGB values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return The color as a AlphaColor</haxe_doc>
		</fromRGBFloat>
		<fromRGBA public="1" get="inline" set="null" line="211" static="1">
			<f a="red:green:blue:alpha">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from integer RGBA values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @param alpha    The alpha value of the color from 0 to 255
     * @return The color as a AlphaColor</haxe_doc>
		</fromRGBA>
		<fromRGBAFloat public="1" get="inline" set="null" line="225" static="1">
			<f a="red:green:blue:alpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from float RGBA values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @param alpha    The green value of the color from 0 to 1
     * @return The color as a AlphaColor</haxe_doc>
		</fromRGBAFloat>
		<fromCMYK public="1" get="inline" set="null" line="240" static="1">
			<f a="cyan:magenta:yellow:black">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from CMYK values (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return The color as a AlphaColor</haxe_doc>
		</fromCMYK>
		<fromHSB public="1" set="method" line="254" static="1">
			<f a="hue:saturation:brightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from HSB (aka HSV) components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    The color as a AlphaColor</haxe_doc>
		</fromHSB>
		<fromHSL public="1" get="inline" set="null" line="268" static="1">
			<f a="hue:saturation:lightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a AlphaColor</haxe_doc>
		</fromHSL>
		<fromString public="1" set="method" line="287" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Null"><x path="ceramic.AlphaColor"/></x>
			</f>
			<haxe_doc><![CDATA[* Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.
     *
     * Examples (input -> output in hex):
     *
     * - `0xFF00FF00`    -> `0xFF00FF00`
     * - `#FF0000FF`     -> `0xFF0000FF`
     * - `GRAY`        -> `0xFF808080`
     * - `blue`        -> `0xFF0000FF`
     *
     * @param    str     The string to be parsed
     * @return    A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
		</fromString>
		<getHSBColorWheel public="1" set="method" line="329" static="1">
			<f a=""><c path="Array"><x path="ceramic.AlphaColor"/></c></f>
			<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
     *
     * @return    HSB color wheel as Array of AlphaColors</haxe_doc>
		</getHSBColorWheel>
		<interpolate public="1" get="inline" set="null" line="342" static="1">
			<f a="color1:color2:?factor" v="::0.5">
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.5 }</e></m></meta>
			<haxe_doc>* Get an interpolated color based on two different colors.
     *
     * @param     color1 The first color
     * @param     color2 The second color
     * @param     factor value from 0 to 1 representing how much to shift color1 toward color2
     * @return    The interpolated color</haxe_doc>
		</interpolate>
		<gradient public="1" set="method" line="361" static="1">
			<f a="color1:color2:steps:?ease">
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
				<x path="Int"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<c path="Array"><x path="ceramic.AlphaColor"/></c>
			</f>
			<haxe_doc>* Create a gradient from one color to another
     *
     * @param color1 The color to shift from
     * @param color2 The color to shift to
     * @param steps How many colors the gradient should have
     * @param ease An optional easing function, such as those provided in FlxEase
     * @return An array of colors of length steps, shifting from color1 to color2</haxe_doc>
		</gradient>
		<multiply public="1" get="inline" set="null" line="385" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":op"><e>A * B</e></m></meta>
			<haxe_doc>* Multiply the RGB channels of two AlphaColors</haxe_doc>
		</multiply>
		<add public="1" get="inline" set="null" line="394" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
			<haxe_doc>* Add the RGB channels of two AlphaColors</haxe_doc>
		</add>
		<subtract public="1" get="inline" set="null" line="403" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
			<haxe_doc>* Subtract the RGB channels of one Color from another</haxe_doc>
		</subtract>
		<toHexString public="1" get="inline" set="null" line="414" static="1">
			<f a="this:?prefix" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ prefix : true }</e></m></meta>
			<haxe_doc>* Return a String representation of the color in the format
     *
     * @param prefix Whether to include "0x" prefix at start of string
     * @return    A string of length 10 in the format 0xAARRGGBB</haxe_doc>
		</toHexString>
		<toWebString public="1" get="inline" set="null" line="425" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a String representation of the color in the format #RRGGBB
     *
     * @return    A string of length 7 in the format #RRGGBB</haxe_doc>
		</toWebString>
		<getColorInfo public="1" set="method" line="435" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Get a string of color information about this color
     *
     * @return A string containing information about this color</haxe_doc>
		</getColorInfo>
		<getDarkened public="1" set="method" line="454" static="1">
			<f a="this:?factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
			<haxe_doc>* Get a darkened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward black.
     * @return     A darkened version of this color</haxe_doc>
		</getDarkened>
		<getLightened public="1" get="inline" set="null" line="468" static="1">
			<f a="this:?factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
			<haxe_doc>* Get a lightened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward white.
     * @return     A lightened version of this color</haxe_doc>
		</getLightened>
		<getInverted public="1" get="inline" set="null" line="481" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Get the inversion of this color
     *
     * @return The inversion of this color</haxe_doc>
		</getInverted>
		<setRGB public="1" get="inline" set="null" line="497" static="1">
			<f a="this:red:green:blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set RGB values as integers (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return This color</haxe_doc>
		</setRGB>
		<setRGBA public="1" get="inline" set="null" line="514" static="1">
			<f a="this:red:green:blue:alpha">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set RGB values as integers (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @param alpha    The alpha value of the color from 0 to 255
     * @return This color</haxe_doc>
		</setRGBA>
		<setRGBFloat public="1" get="inline" set="null" line="531" static="1">
			<f a="this:red:green:blue">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set RGB values as floats (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return This color</haxe_doc>
		</setRGBFloat>
		<setRGBAFloat public="1" get="inline" set="null" line="548" static="1">
			<f a="this:red:green:blue:alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set RGB values as floats (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @param alpha    The alpha value of the color from 0 to 1
     * @return This color</haxe_doc>
		</setRGBAFloat>
		<setCMYK public="1" get="inline" set="null" line="566" static="1">
			<f a="this:cyan:magenta:yellow:black">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set CMYK values as floats (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return This color</haxe_doc>
		</setCMYK>
		<setHSB public="1" get="inline" set="null" line="582" static="1">
			<f a="this:hue:saturation:brightness">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set HSB (aka HSV) components
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    This color</haxe_doc>
		</setHSB>
		<setHSL public="1" get="inline" set="null" line="597" static="1">
			<f a="this:hue:saturation:lightness">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
		</setHSL>
		<setHSChromaMatch get="inline" set="null" line="607" static="1">
			<f a="this:hue:saturation:chroma:match">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
		</setHSChromaMatch>
		<_new public="1" get="inline" set="null" line="631" static="1">
			<f a="color:?alpha" v=":255">
				<x path="ceramic.Color"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta>
				<m n=":value"><e>{ alpha : 255 }</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Create a new `AlphaColor` (ARGB) object from a `ceramic.Color` object and the given `alpha`
     * @param color RGB color object (`ceramic.Color`)
     * @param alpha alpha component between `0` and `255`</haxe_doc>
		</_new>
		<get_color get="inline" set="null" line="637" static="1"><f a="this">
	<x path="Int"/>
	<x path="ceramic.Color"/>
</f></get_color>
		<set_color get="inline" set="null" line="640" static="1"><f a="this:color">
	<x path="Int"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
		<get_rgb get="inline" set="null" line="647" static="1"><f a="this">
	<x path="Int"/>
	<x path="ceramic.Color"/>
</f></get_rgb>
		<set_rgb get="inline" set="null" line="650" static="1"><f a="this:color">
	<x path="Int"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_rgb>
		<get_red get="inline" set="null" line="657" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_red>
		<get_green get="inline" set="null" line="661" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_green>
		<get_blue get="inline" set="null" line="665" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_blue>
		<get_alpha get="inline" set="null" line="669" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_alpha>
		<get_redFloat get="inline" set="null" line="673" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_redFloat>
		<get_greenFloat get="inline" set="null" line="677" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_greenFloat>
		<get_blueFloat get="inline" set="null" line="681" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_blueFloat>
		<get_alphaFloat get="inline" set="null" line="685" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_alphaFloat>
		<set_red get="inline" set="null" line="689" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_red>
		<set_green get="inline" set="null" line="695" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_green>
		<set_blue get="inline" set="null" line="701" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_blue>
		<set_alpha get="inline" set="null" line="707" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_alpha>
		<set_redFloat get="inline" set="null" line="713" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_redFloat>
		<set_greenFloat get="inline" set="null" line="718" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_greenFloat>
		<set_blueFloat get="inline" set="null" line="723" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_blueFloat>
		<set_alphaFloat get="inline" set="null" line="728" static="1"><f a="this:Value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_alphaFloat>
		<get_cyan get="inline" set="null" line="734" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_cyan>
		<get_magenta get="inline" set="null" line="739" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_magenta>
		<get_yellow get="inline" set="null" line="744" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_yellow>
		<get_black get="inline" set="null" line="749" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_black>
		<set_cyan get="inline" set="null" line="754" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_cyan>
		<set_magenta get="inline" set="null" line="760" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_magenta>
		<set_yellow get="inline" set="null" line="766" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_yellow>
		<set_black get="inline" set="null" line="772" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_black>
		<get_hue set="method" line="778" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hue>
		<get_brightness get="inline" set="null" line="790" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_brightness>
		<get_saturation get="inline" set="null" line="795" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturation>
		<get_lightness get="inline" set="null" line="800" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightness>
		<set_hue get="inline" set="null" line="805" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hue>
		<set_saturation get="inline" set="null" line="811" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturation>
		<set_brightness get="inline" set="null" line="817" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_brightness>
		<set_lightness get="inline" set="null" line="823" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightness>
		<maxColor get="inline" set="null" line="829" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></maxColor>
		<minColor get="inline" set="null" line="834" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></minColor>
		<boundChannel get="inline" set="null" line="839" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></boundChannel>
		<roundDecimal set="method" line="846" static="1"><f a="value:precision">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></roundDecimal>
		<bound get="inline" set="null" line="856" static="1"><f a="value:?min:?max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></bound>
		<toString public="1" get="inline" set="null" line="867" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Get this RGBA color as `String`.
     * Format: `0xAARRGGBB`</haxe_doc>
		</toString>
		<_hsluvTuple expr="[0, 0, 0]" line="877" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
		</_hsluvTuple>
		<_hsluvResult expr="[0, 0, 0]" line="879" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
		</_hsluvResult>
		<hueHSLuv public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The HSLuv hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hueHSLuv>
		<saturationHSLuv public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The HSLuv saturation of the color (from 0 to 1)</haxe_doc>
		</saturationHSLuv>
		<lightnessHSLuv public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The HSLuv lightness of the color (from 0 to 1)</haxe_doc>
		</lightnessHSLuv>
		<get_hueHSLuv set="method" line="895" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hueHSLuv>
		<set_hueHSLuv get="inline" set="null" line="900" static="1"><f a="this:hueHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hueHSLuv>
		<get_saturationHSLuv set="method" line="906" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturationHSLuv>
		<set_saturationHSLuv get="inline" set="null" line="911" static="1"><f a="this:saturationHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturationHSLuv>
		<get_lightnessHSLuv set="method" line="917" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightnessHSLuv>
		<set_lightnessHSLuv get="inline" set="null" line="922" static="1"><f a="this:lightnessHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightnessHSLuv>
		<_getOrCreateCachedHSLuvComponent get="inline" set="null" line="928" static="1"><f a="this:index">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></_getOrCreateCachedHSLuvComponent>
		<fromHSLuv public="1" get="inline" set="null" line="951" static="1">
			<f a="hue:saturation:lightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Generate a color from HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a AlphaColor</haxe_doc>
		</fromHSLuv>
		<setHSLuv public="1" get="inline" set="null" line="965" static="1">
			<f a="this:hue:saturation:lightness">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Set HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
		</setHSLuv>
		<getHSLuv public="1" get="inline" set="null" line="997" static="1">
			<f a="this:?result">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Get HSLuv components from the color instance.
     *
     * @param result A pre-allocated array to store the result into.
     * @return    The HSLuv components as a float array</haxe_doc>
		</getHSLuv>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.App" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/App.hx">
		<extends path="ceramic.Entity"/>
		<app public="1" get="accessor" set="null" static="1">
			<c path="ceramic.App"/>
			<haxe_doc>* Shared `App` instance singleton.</haxe_doc>
		</app>
		<get_app get="inline" set="null" line="51" static="1"><f a=""><c path="ceramic.App"/></f></get_app>
		<preInitCallbacks static="1"><c path="Array"><f a=""><x path="Void"/></f></c></preInitCallbacks>
		<oncePreInit set="method" line="484" static="1"><f a="handle">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></oncePreInit>
		<init public="1" set="method" line="687" static="1">
			<f a=""><c path="ceramic.InitSettings"/></f>
			<meta><m n=":noCompletion"/></meta>
		</init>
		<_dox_event_ready public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app is ready
     * and the game logic can be started.</haxe_doc>
		</_dox_event_ready>
		<emitReady set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when the app is ready
     * and the game logic can be started.</haxe_doc>
		</emitReady>
		<onReady public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app is ready
     * and the game logic can be started.</haxe_doc>
		</onReady>
		<onceReady public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app is ready
     * and the game logic can be started.</haxe_doc>
		</onceReady>
		<offReady public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app is ready
     * and the game logic can be started.</haxe_doc>
		</offReady>
		<listensReady public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app is ready
     * and the game logic can be started.</haxe_doc>
		</listensReady>
		<_dox_event_update public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired as many times as there are frames per seconds.
     * It is in sync with screen FPS but used for everything that needs
     * to get updated depending on time (ceramic.Timer relies on it).
     * Use this event to update your contents before they get drawn again.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</_dox_event_update>
		<emitUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired as many times as there are frames per seconds.
     * It is in sync with screen FPS but used for everything that needs
     * to get updated depending on time (ceramic.Timer relies on it).
     * Use this event to update your contents before they get drawn again.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</emitUpdate>
		<onUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired as many times as there are frames per seconds.
     * It is in sync with screen FPS but used for everything that needs
     * to get updated depending on time (ceramic.Timer relies on it).
     * Use this event to update your contents before they get drawn again.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</onUpdate>
		<onceUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired as many times as there are frames per seconds.
     * It is in sync with screen FPS but used for everything that needs
     * to get updated depending on time (ceramic.Timer relies on it).
     * Use this event to update your contents before they get drawn again.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</onceUpdate>
		<offUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired as many times as there are frames per seconds.
     * It is in sync with screen FPS but used for everything that needs
     * to get updated depending on time (ceramic.Timer relies on it).
     * Use this event to update your contents before they get drawn again.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</offUpdate>
		<listensUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired as many times as there are frames per seconds.
     * It is in sync with screen FPS but used for everything that needs
     * to get updated depending on time (ceramic.Timer relies on it).
     * Use this event to update your contents before they get drawn again.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</listensUpdate>
		<_dox_event_preUpdate public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right before update event and
     * can be used when you want to run garantee your code
     * will be run before regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</_dox_event_preUpdate>
		<emitPreUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired right before update event and
     * can be used when you want to run garantee your code
     * will be run before regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</emitPreUpdate>
		<onPreUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before update event and
     * can be used when you want to run garantee your code
     * will be run before regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</onPreUpdate>
		<oncePreUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before update event and
     * can be used when you want to run garantee your code
     * will be run before regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</oncePreUpdate>
		<offPreUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before update event and
     * can be used when you want to run garantee your code
     * will be run before regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</offPreUpdate>
		<listensPreUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before update event and
     * can be used when you want to run garantee your code
     * will be run before regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</listensPreUpdate>
		<_dox_event_postUpdate public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right after update event and
     * can be used when you want to run garantee your code
     * will be run after regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</_dox_event_postUpdate>
		<emitPostUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired right after update event and
     * can be used when you want to run garantee your code
     * will be run after regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</emitPostUpdate>
		<onPostUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after update event and
     * can be used when you want to run garantee your code
     * will be run after regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</onPostUpdate>
		<oncePostUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after update event and
     * can be used when you want to run garantee your code
     * will be run after regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</oncePostUpdate>
		<offPostUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after update event and
     * can be used when you want to run garantee your code
     * will be run after regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</offPostUpdate>
		<listensPostUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after update event and
     * can be used when you want to run garantee your code
     * will be run after regular update event.
     * @param delta The elapsed delta time since last frame</haxe_doc>
		</listensPostUpdate>
		<_dox_event_defaultAssetsLoad public="1" set="method" line="637">
			<f a="assets">
				<c path="ceramic.Assets"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right before default assets are being loaded.
     * @param assets
     *      The `Assets` instance used to load default assets.
     *      If you add custom assets to this instance, they will be loaded as well.</haxe_doc>
		</_dox_event_defaultAssetsLoad>
		<emitDefaultAssetsLoad set="method" line="1095">
			<f a="assets">
				<c path="ceramic.Assets"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired right before default assets are being loaded.
     * @param assets
     *      The `Assets` instance used to load default assets.
     *      If you add custom assets to this instance, they will be loaded as well.</haxe_doc>
		</emitDefaultAssetsLoad>
		<onDefaultAssetsLoad public="1" set="method" line="1199">
			<f a="owner:handleAssets">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="assets">
					<c path="ceramic.Assets"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before default assets are being loaded.
     * @param assets
     *      The `Assets` instance used to load default assets.
     *      If you add custom assets to this instance, they will be loaded as well.</haxe_doc>
		</onDefaultAssetsLoad>
		<onceDefaultAssetsLoad public="1" set="method" line="1298">
			<f a="owner:handleAssets">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="assets">
					<c path="ceramic.Assets"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before default assets are being loaded.
     * @param assets
     *      The `Assets` instance used to load default assets.
     *      If you add custom assets to this instance, they will be loaded as well.</haxe_doc>
		</onceDefaultAssetsLoad>
		<offDefaultAssetsLoad public="1" set="method" line="1368">
			<f a="?handleAssets">
				<f a="assets">
					<c path="ceramic.Assets"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before default assets are being loaded.
     * @param assets
     *      The `Assets` instance used to load default assets.
     *      If you add custom assets to this instance, they will be loaded as well.</haxe_doc>
		</offDefaultAssetsLoad>
		<listensDefaultAssetsLoad public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before default assets are being loaded.
     * @param assets
     *      The `Assets` instance used to load default assets.
     *      If you add custom assets to this instance, they will be loaded as well.</haxe_doc>
		</listensDefaultAssetsLoad>
		<_dox_event_criticalError public="1" set="method" line="637">
			<f a="error:stack">
				<d/>
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app hits an critical (uncaught) error.
     * Can be used to perform custom crash reporting.
     * If this even is handled, app exit should be performed by the event handler.
     * @param error The error
     * @param stack The stack trace of the error</haxe_doc>
		</_dox_event_criticalError>
		<emitCriticalError set="method" line="1095">
			<f a="error:stack">
				<d/>
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired when the app hits an critical (uncaught) error.
     * Can be used to perform custom crash reporting.
     * If this even is handled, app exit should be performed by the event handler.
     * @param error The error
     * @param stack The stack trace of the error</haxe_doc>
		</emitCriticalError>
		<onCriticalError public="1" set="method" line="1199">
			<f a="owner:handleErrorStack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="error:stack">
					<d/>
					<c path="Array"><e path="haxe.StackItem"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app hits an critical (uncaught) error.
     * Can be used to perform custom crash reporting.
     * If this even is handled, app exit should be performed by the event handler.
     * @param error The error
     * @param stack The stack trace of the error</haxe_doc>
		</onCriticalError>
		<onceCriticalError public="1" set="method" line="1298">
			<f a="owner:handleErrorStack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="error:stack">
					<d/>
					<c path="Array"><e path="haxe.StackItem"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app hits an critical (uncaught) error.
     * Can be used to perform custom crash reporting.
     * If this even is handled, app exit should be performed by the event handler.
     * @param error The error
     * @param stack The stack trace of the error</haxe_doc>
		</onceCriticalError>
		<offCriticalError public="1" set="method" line="1368">
			<f a="?handleErrorStack">
				<f a="error:stack">
					<d/>
					<c path="Array"><e path="haxe.StackItem"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app hits an critical (uncaught) error.
     * Can be used to perform custom crash reporting.
     * If this even is handled, app exit should be performed by the event handler.
     * @param error The error
     * @param stack The stack trace of the error</haxe_doc>
		</offCriticalError>
		<listensCriticalError public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app hits an critical (uncaught) error.
     * Can be used to perform custom crash reporting.
     * If this even is handled, app exit should be performed by the event handler.
     * @param error The error
     * @param stack The stack trace of the error</haxe_doc>
		</listensCriticalError>
		<_dox_event_beginEnterBackground public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app will enter background state.</haxe_doc>
		</_dox_event_beginEnterBackground>
		<emitBeginEnterBackground set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when the app will enter background state.</haxe_doc>
		</emitBeginEnterBackground>
		<onBeginEnterBackground public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter background state.</haxe_doc>
		</onBeginEnterBackground>
		<onceBeginEnterBackground public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter background state.</haxe_doc>
		</onceBeginEnterBackground>
		<offBeginEnterBackground public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter background state.</haxe_doc>
		</offBeginEnterBackground>
		<listensBeginEnterBackground public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter background state.</haxe_doc>
		</listensBeginEnterBackground>
		<_dox_event_finishEnterBackground public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering background state.</haxe_doc>
		</_dox_event_finishEnterBackground>
		<emitFinishEnterBackground set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when the app did finish entering background state.</haxe_doc>
		</emitFinishEnterBackground>
		<onFinishEnterBackground public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering background state.</haxe_doc>
		</onFinishEnterBackground>
		<onceFinishEnterBackground public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering background state.</haxe_doc>
		</onceFinishEnterBackground>
		<offFinishEnterBackground public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering background state.</haxe_doc>
		</offFinishEnterBackground>
		<listensFinishEnterBackground public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering background state.</haxe_doc>
		</listensFinishEnterBackground>
		<_dox_event_beginEnterForeground public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app will enter foreground state.</haxe_doc>
		</_dox_event_beginEnterForeground>
		<emitBeginEnterForeground set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when the app will enter foreground state.</haxe_doc>
		</emitBeginEnterForeground>
		<onBeginEnterForeground public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter foreground state.</haxe_doc>
		</onBeginEnterForeground>
		<onceBeginEnterForeground public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter foreground state.</haxe_doc>
		</onceBeginEnterForeground>
		<offBeginEnterForeground public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter foreground state.</haxe_doc>
		</offBeginEnterForeground>
		<listensBeginEnterForeground public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app will enter foreground state.</haxe_doc>
		</listensBeginEnterForeground>
		<_dox_event_finishEnterForeground public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering foreground state.</haxe_doc>
		</_dox_event_finishEnterForeground>
		<emitFinishEnterForeground set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when the app did finish entering foreground state.</haxe_doc>
		</emitFinishEnterForeground>
		<onFinishEnterForeground public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering foreground state.</haxe_doc>
		</onFinishEnterForeground>
		<onceFinishEnterForeground public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering foreground state.</haxe_doc>
		</onceFinishEnterForeground>
		<offFinishEnterForeground public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering foreground state.</haxe_doc>
		</offFinishEnterForeground>
		<listensFinishEnterForeground public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app did finish entering foreground state.</haxe_doc>
		</listensFinishEnterForeground>
		<_dox_event_beginSortVisuals public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right before sorting all visuals.
     * Visual are sorted at each frame depending on their properties:
     * depth, texture, blending, shader...</haxe_doc>
		</_dox_event_beginSortVisuals>
		<emitBeginSortVisuals set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired right before sorting all visuals.
     * Visual are sorted at each frame depending on their properties:
     * depth, texture, blending, shader...</haxe_doc>
		</emitBeginSortVisuals>
		<onBeginSortVisuals public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before sorting all visuals.
     * Visual are sorted at each frame depending on their properties:
     * depth, texture, blending, shader...</haxe_doc>
		</onBeginSortVisuals>
		<onceBeginSortVisuals public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before sorting all visuals.
     * Visual are sorted at each frame depending on their properties:
     * depth, texture, blending, shader...</haxe_doc>
		</onceBeginSortVisuals>
		<offBeginSortVisuals public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before sorting all visuals.
     * Visual are sorted at each frame depending on their properties:
     * depth, texture, blending, shader...</haxe_doc>
		</offBeginSortVisuals>
		<listensBeginSortVisuals public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before sorting all visuals.
     * Visual are sorted at each frame depending on their properties:
     * depth, texture, blending, shader...</haxe_doc>
		</listensBeginSortVisuals>
		<_dox_event_finishSortVisuals public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right after all visuals have been sort.</haxe_doc>
		</_dox_event_finishSortVisuals>
		<emitFinishSortVisuals set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired right after all visuals have been sort.</haxe_doc>
		</emitFinishSortVisuals>
		<onFinishSortVisuals public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after all visuals have been sort.</haxe_doc>
		</onFinishSortVisuals>
		<onceFinishSortVisuals public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after all visuals have been sort.</haxe_doc>
		</onceFinishSortVisuals>
		<offFinishSortVisuals public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after all visuals have been sort.</haxe_doc>
		</offFinishSortVisuals>
		<listensFinishSortVisuals public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after all visuals have been sort.</haxe_doc>
		</listensFinishSortVisuals>
		<_dox_event_beginDraw public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right before drawing phase of visuals.</haxe_doc>
		</_dox_event_beginDraw>
		<emitBeginDraw set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired right before drawing phase of visuals.</haxe_doc>
		</emitBeginDraw>
		<onBeginDraw public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before drawing phase of visuals.</haxe_doc>
		</onBeginDraw>
		<onceBeginDraw public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before drawing phase of visuals.</haxe_doc>
		</onceBeginDraw>
		<offBeginDraw public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before drawing phase of visuals.</haxe_doc>
		</offBeginDraw>
		<listensBeginDraw public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right before drawing phase of visuals.</haxe_doc>
		</listensBeginDraw>
		<_dox_event_finishDraw public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired right after drawing phase of visuals.</haxe_doc>
		</_dox_event_finishDraw>
		<emitFinishDraw set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired right after drawing phase of visuals.</haxe_doc>
		</emitFinishDraw>
		<onFinishDraw public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after drawing phase of visuals.</haxe_doc>
		</onFinishDraw>
		<onceFinishDraw public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after drawing phase of visuals.</haxe_doc>
		</onceFinishDraw>
		<offFinishDraw public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after drawing phase of visuals.</haxe_doc>
		</offFinishDraw>
		<listensFinishDraw public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired right after drawing phase of visuals.</haxe_doc>
		</listensFinishDraw>
		<_dox_event_lowMemory public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired if the app is running low on memory.
     * (not be implemented by all platforms/targets).</haxe_doc>
		</_dox_event_lowMemory>
		<emitLowMemory set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired if the app is running low on memory.
     * (not be implemented by all platforms/targets).</haxe_doc>
		</emitLowMemory>
		<onLowMemory public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired if the app is running low on memory.
     * (not be implemented by all platforms/targets).</haxe_doc>
		</onLowMemory>
		<onceLowMemory public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired if the app is running low on memory.
     * (not be implemented by all platforms/targets).</haxe_doc>
		</onceLowMemory>
		<offLowMemory public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired if the app is running low on memory.
     * (not be implemented by all platforms/targets).</haxe_doc>
		</offLowMemory>
		<listensLowMemory public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired if the app is running low on memory.
     * (not be implemented by all platforms/targets).</haxe_doc>
		</listensLowMemory>
		<_dox_event_terminate public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when the app terminates.</haxe_doc>
		</_dox_event_terminate>
		<emitTerminate set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when the app terminates.</haxe_doc>
		</emitTerminate>
		<onTerminate public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app terminates.</haxe_doc>
		</onTerminate>
		<onceTerminate public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app terminates.</haxe_doc>
		</onceTerminate>
		<offTerminate public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app terminates.</haxe_doc>
		</offTerminate>
		<listensTerminate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when the app terminates.</haxe_doc>
		</listensTerminate>
		<immediateCallbacks expr="[]" line="158">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</immediateCallbacks>
		<immediateCallbacksCapacity expr="0" line="160">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</immediateCallbacksCapacity>
		<immediateCallbacksLen expr="0" line="162">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</immediateCallbacksLen>
		<postFlushImmediateCallbacks expr="[]" line="164">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</postFlushImmediateCallbacks>
		<postFlushImmediateCallbacksCapacity expr="0" line="166">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</postFlushImmediateCallbacksCapacity>
		<postFlushImmediateCallbacksLen expr="0" line="168">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</postFlushImmediateCallbacksLen>
		<loaders public="1" expr="[]" line="178">
			<c path="Array"><f a="done">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":noCompletion"/>
			</meta>
		</loaders>
		<onceImmediate public="1" get="inline" set="null" line="186">
			<f a="owner:handleImmediate">
				<c path="ceramic.Entity"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Schedule immediate callback that is garanteed to be executed before the next time frame
     * (before elements are drawn onto screen)
     * @param owner Owner of this callback, allowing to cancel callback if owner is destroyed
     * @param handleImmediate The callback to execute</haxe_doc>
			<overloads><onceImmediate public="1" get="inline" set="null" line="197">
	<f a="handleImmediate">
		<f a=""><x path="Void"/></f>
		<x path="Void"/>
	</f>
	<haxe_doc>* Schedule immediate callback that is garanteed to be executed before the next time frame
     * (before elements are drawn onto screen)
     * @param handleImmediate The callback to execute</haxe_doc>
</onceImmediate></overloads>
		</onceImmediate>
		<_onceImmediateWithOwner set="method" line="203"><f a="owner:handleImmediate">
	<c path="ceramic.Entity"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></_onceImmediateWithOwner>
		<_onceImmediate set="method" line="213"><f a="handleImmediate">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></_onceImmediate>
		<oncePostFlushImmediate public="1" get="inline" set="null" line="243">
			<f a="owner:handlePostFlushImmediate:?defer" v="::true">
				<c path="ceramic.Entity"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ defer : true }</e></m></meta>
			<haxe_doc>* Schedule callback that is garanteed to be executed when no immediate callback are pending anymore.
     * @param owner Owner of this callback, allowing to cancel callback if owner is destroyed
     * @param handlePostFlushImmediate The callback to execute
     * @param defer if `true` (default), will box this call into an immediate callback</haxe_doc>
			<overloads><oncePostFlushImmediate public="1" get="inline" set="null" line="254">
	<f a="handlePostFlushImmediate:?defer" v=":true">
		<f a=""><x path="Void"/></f>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{ defer : true }</e></m></meta>
	<haxe_doc>* Schedule callback that is garanteed to be executed when no immediate callback are pending anymore.
     * @param handlePostFlushImmediate The callback to execute
     * @param defer if `true` (default), will box this call into an immediate callback</haxe_doc>
</oncePostFlushImmediate></overloads>
		</oncePostFlushImmediate>
		<_oncePostFlushImmediateWithOwner set="method" line="260"><f a="owner:handlePostFlushImmediate:defer">
	<c path="ceramic.Entity"/>
	<f a=""><x path="Void"/></f>
	<x path="Bool"/>
	<x path="Void"/>
</f></_oncePostFlushImmediateWithOwner>
		<_oncePostFlushImmediate set="method" line="275">
			<f a="handlePostFlushImmediate:defer">
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Schedule callback that is garanteed to be executed when no immediate callback are pending anymore.
     * @param handlePostFlushImmediate The callback to execute
     * @param defer if `true` (default), will box this call into an immediate callback</haxe_doc>
		</_oncePostFlushImmediate>
		<flushImmediate public="1" set="method" line="306">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Execute and flush every awaiting immediate callback, including the ones that
     * could have been added with `onceImmediate()` after executing the existing callbacks.
     * @return `true` if anything was flushed</haxe_doc>
		</flushImmediate>
		<_xUpdatesHandlersPool expr="new Pool&lt;AppXUpdatesHandler&gt;()" line="360">
			<c path="ceramic.Pool"><c path="ceramic.AppXUpdatesHandler"/></c>
			<meta><m n=":value"><e><![CDATA[new Pool<AppXUpdatesHandler>()]]></e></m></meta>
		</_xUpdatesHandlersPool>
		<_xUpdatesHandlers expr="[]" line="362">
			<c path="Array"><c path="ceramic.AppXUpdatesHandler"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_xUpdatesHandlers>
		<_xUpdatesToCallNow expr="[]" line="364">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_xUpdatesToCallNow>
		<onceXUpdates public="1" set="method" line="366"><f a="owner:numUpdates:callback">
	<c path="ceramic.Entity"/>
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></onceXUpdates>
		<offXUpdates public="1" set="method" line="389"><f a="callback">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></offXUpdates>
		<tickOnceXUpdates set="method" line="408"><f a=""><x path="Void"/></f></tickOnceXUpdates>
		<cleanXUpdatesNullValues set="method" line="442"><f a=""><x path="Void"/></f></cleanXUpdatesNullValues>
		<inUpdate public="1" set="null" expr="false" line="479">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* `true` if the app is currently running its update phase.</haxe_doc>
		</inUpdate>
		<computedFps public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Computed fps of the app. Read only.
     * Value is automatically computed from last second of frame updates.</haxe_doc>
		</computedFps>
		<get_computedFps get="inline" set="null" line="496"><f a=""><x path="Int"/></f></get_computedFps>
		<_computeFps expr="new ComputeFps()" line="499">
			<c path="ceramic.ComputeFps"/>
			<meta><m n=":value"><e>new ComputeFps()</e></m></meta>
		</_computeFps>
		<frame public="1" set="null" expr="0" line="504">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current frame number</haxe_doc>
		</frame>
		<delta public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Current frame delta time (never above `settings.maxDelta`)</haxe_doc>
		</delta>
		<realDelta public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Current frame real delta time (the actual elapsed time since last frame update)</haxe_doc>
		</realDelta>
		<backend public="1" set="null">
			<c path="backend.Backend"/>
			<haxe_doc>* Backend instance</haxe_doc>
		</backend>
		<screen public="1" set="null">
			<c path="ceramic.Screen"/>
			<haxe_doc>* Screen instance</haxe_doc>
		</screen>
		<audio public="1" set="null">
			<c path="ceramic.Audio"/>
			<haxe_doc>* Audio instance</haxe_doc>
		</audio>
		<settings public="1" set="null">
			<c path="ceramic.Settings"/>
			<haxe_doc>* App settings</haxe_doc>
		</settings>
		<systems public="1" set="null">
			<c path="ceramic.Systems"/>
			<haxe_doc>* Systems are objects to structure app work/phases and update cycle</haxe_doc>
		</systems>
		<logger public="1" set="null" expr="new Logger()" line="544">
			<c path="ceramic.Logger"/>
			<meta><m n=":value"><e>new Logger()</e></m></meta>
			<haxe_doc>* Logger. Used by log shortcut</haxe_doc>
		</logger>
		<visuals public="1" set="null" expr="[]" line="553">
			<c path="Array"><c path="ceramic.Visual"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Visuals (ordered)
     * Active list of visuals being managed by ceramic.
     * This list is ordered and updated at every frame.
     * In between, it could contain destroyed visuals as they
     * are removed only at the end of the frame for performance reasons.</haxe_doc>
		</visuals>
		<pendingVisuals public="1" set="null" expr="[]" line="559">
			<c path="Array"><c path="ceramic.Visual"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Pending visuals: visuals that have been created this frame
     * but were not added to the `visual` list yet</haxe_doc>
		</pendingVisuals>
		<destroyedVisuals public="1" set="null" expr="[]" line="565">
			<c path="Array"><c path="ceramic.Visual"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Pending destroyed visuals: visuals that have been destroyed this frame
     * but were not removed to the `visual` list yet</haxe_doc>
		</destroyedVisuals>
		<groups public="1" set="null" expr="[]" line="570">
			<c path="Array"><c path="ceramic.Group"><c path="ceramic.Entity"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* All groups of entities in this app</haxe_doc>
		</groups>
		<input public="1" set="null">
			<c path="ceramic.Input"/>
			<haxe_doc>* Shared instance of `Input`</haxe_doc>
		</input>
		<renderTextures public="1" set="null" expr="[]" line="580">
			<c path="Array"><c path="ceramic.RenderTexture"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* All active render textures in this app</haxe_doc>
		</renderTextures>
		<assets public="1" set="null">
			<c path="ceramic.Assets"/>
			<haxe_doc>* App level assets. Used to load default assets (font, texture, shader)
     * required to make ceramic work properly.</haxe_doc>
		</assets>
		<defaultTexturedShader public="1" set="null" expr="null" line="592">
			<c path="ceramic.Shader"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Default textured shader.
     * This is the shader used for any visual (quad or mesh) that don't have a custom shader assigned.</haxe_doc>
		</defaultTexturedShader>
		<defaultWhiteTexture public="1" set="null" expr="null" line="600">
			<c path="ceramic.Texture"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc><![CDATA[* Default white texture.
     * When a quad or mesh doesn't have a texture assigned, it will use the default white texture
     * instead to render as plain flat coloured object. This means that the same default shader
     * is used and everything can be batched together (textured & non-textured in the same batch).]]></haxe_doc>
		</defaultWhiteTexture>
		<defaultFont public="1" set="null" expr="null" line="605">
			<c path="ceramic.BitmapFont"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Default font used by `Text` instances.</haxe_doc>
		</defaultFont>
		<projectDir public="1" expr="null" line="610">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Project directory. May be null depending on the platform.</haxe_doc>
		</projectDir>
		<persistent public="1" set="null" expr="null" line="617">
			<c path="ceramic.PersistentData"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* App level persistent data.
     * This is a simple key-value store ready to be used.
     * Don't forget to call `persistent.save()` to apply changes permanently.</haxe_doc>
		</persistent>
		<textInput public="1" set="null" expr="null" line="623">
			<c path="ceramic.TextInput"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Shared text input manager. Usually not used directly as is.
     * You might want to use `EditText` component instead.</haxe_doc>
		</textInput>
		<converters public="1" expr="new Map()" line="632">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.ConvertField">
					<d/>
					<d/>
				</c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
			<haxe_doc><![CDATA[* Converters are used to transform field data in `Fragment` instances.
     * This map is matching a type (as string, like `"Array<Float>"`) with an instance
     * of a `ConvertField` subclass.]]></haxe_doc>
		</converters>
		<timelines public="1" expr="new Timelines()" line="637">
			<c path="ceramic.Timelines"/>
			<meta><m n=":value"><e>new Timelines()</e></m></meta>
			<haxe_doc>* All active timelines in this app.</haxe_doc>
		</timelines>
		<scenes public="1" expr="SceneSystem.shared" line="662">
			<c path="ceramic.SceneSystem"/>
			<meta>
				<m n=":value"><e>SceneSystem.shared</e></m>
				<m n="lazy"/>
			</meta>
			<haxe_doc>* Shared scene system.</haxe_doc>
		</scenes>
		<hierarchyDirty expr="false" line="666">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hierarchyDirty>
		<visualsContentDirty expr="false" line="668">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</visualsContentDirty>
		<beginUpdateCallbacks expr="[]" line="674">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* List of functions that will be called and purged when update iteration begins.
     * Useful to run some specific code once exactly before update event is sent.</haxe_doc>
		</beginUpdateCallbacks>
		<disposedEntities expr="[]" line="676">
			<c path="Array"><c path="ceramic.Entity"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</disposedEntities>
		<numBlockingDefaultScroll public="1" expr="0" line="682">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</numBlockingDefaultScroll>
		<quit public="1" set="method" line="752">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Quit the application.
     * Works on desktop (windows, mac, linux), unity.
     * Can also work on web by closing the window if **electron** plugin is enabled
     * and the app is running via electron instead of a regular browser.</haxe_doc>
		</quit>
		<backendReady set="method" line="758"><f a=""><x path="Void"/></f></backendReady>
		<bindSettings set="method" line="857"><f a=""><x path="Void"/></f></bindSettings>
		<initFieldConverters set="method" line="868"><f a=""><x path="Void"/></f></initFieldConverters>
		<initCollections set="method" line="889"><f a="collections:?info">
	<c path="ceramic.AutoCollections"/>
	<d/>
	<x path="Void"/>
</f></initCollections>
		<assetsLoaded set="method" line="952"><f a=""><x path="Void"/></f></assetsLoaded>
		<runNextLoader set="method" line="958"><f a=""><x path="Void"/></f></runNextLoader>
		<runReady set="method" line="975"><f a=""><x path="Void"/></f></runReady>
		<updatePreReady set="method" line="1089"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></updatePreReady>
		<_pendingFinishDraw expr="false" line="1097">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_pendingFinishDraw>
		<update set="method" line="1100">
			<f a="realDelta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</update>
		<render set="method" line="1235"><f a=""><x path="Void"/></f></render>
		<addVisual public="1" get="inline" set="null" line="1256">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</addVisual>
		<removeVisual public="1" get="inline" set="null" line="1263">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</removeVisual>
		<syncPendingVisuals set="method" line="1269"><f a=""><x path="Bool"/></f></syncPendingVisuals>
		<syncDestroyedVisuals set="method" line="1288"><f a=""><x path="Void"/></f></syncDestroyedVisuals>
		<updateVisuals public="1" get="inline" set="null" line="1331">
			<f a="visuals">
				<c path="Array"><c path="ceramic.Visual"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</updateVisuals>
		<computeHierarchy public="1" set="method" line="1457">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</computeHierarchy>
		<computeRenderTexturesPriority public="1" get="inline" set="null" line="1483">
			<f a="renderTextures">
				<c path="Array"><c path="ceramic.RenderTexture"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</computeRenderTexturesPriority>
		<sortVisuals public="1" get="inline" set="null" line="1510">
			<f a="visuals">
				<c path="Array"><c path="ceramic.Visual"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</sortVisuals>
		<group public="1" set="method" line="1531">
			<f a="id:?createIfNeeded" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="ceramic.Group"><c path="ceramic.Entity"/></c>
			</f>
			<meta><m n=":value"><e>{ createIfNeeded : true }</e></m></meta>
			<haxe_doc>* Get a group with the given id.
     * @param id The id of the group
     * @param createIfNeeded `true` (default) to create a group if not created already for this id
     * @return the group or null if no group was found and none created.</haxe_doc>
		</group>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<info public="1" expr="{ editable : { item11 : &quot;ceramic.Particles&quot;, item3 : &quot;ceramic.Fragment&quot;, item10 : &quot;ceramic.Line&quot;, item5 : &quot;ceramic.Text&quot;, item7 : &quot;ceramic.Shape&quot;, item2 : &quot;ceramic.Layer&quot;, item6 : &quot;ceramic.Mesh&quot;, item9 : &quot;ceramic.Arc&quot;, item1 : &quot;ceramic.Visual&quot;, item4 : &quot;ceramic.Quad&quot;, item8 : &quot;ceramic.Ngon&quot;, item0 : &quot;ceramic.Entity&quot; }, name : &quot;ceramic-docs&quot;, collections : {  }, version : &quot;1.0&quot;, author : &quot;My Company&quot;, displayName : &quot;ceramic-docs&quot; }" line="33">
			<a>
				<version><c path="String"/></version>
				<name><c path="String"/></name>
				<editable><a>
	<item9><c path="String"/></item9>
	<item8><c path="String"/></item8>
	<item7><c path="String"/></item7>
	<item6><c path="String"/></item6>
	<item5><c path="String"/></item5>
	<item4><c path="String"/></item4>
	<item3><c path="String"/></item3>
	<item2><c path="String"/></item2>
	<item11><c path="String"/></item11>
	<item10><c path="String"/></item10>
	<item1><c path="String"/></item1>
	<item0><c path="String"/></item0>
</a></editable>
				<displayName><c path="String"/></displayName>
				<collections><a/></collections>
				<author><c path="String"/></author>
			</a>
			<meta>
				<m n=":value"><e>{ editable : { item11 : "ceramic.Particles", item3 : "ceramic.Fragment", item10 : "ceramic.Line", item5 : "ceramic.Text", item7 : "ceramic.Shape", item2 : "ceramic.Layer", item6 : "ceramic.Mesh", item9 : "ceramic.Arc", item1 : "ceramic.Visual", item4 : "ceramic.Quad", item8 : "ceramic.Ngon", item0 : "ceramic.Entity" }, name : "ceramic-docs", collections : {  }, version : "1.0", author : "My Company", displayName : "ceramic-docs" }</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>App info extracted from `ceramic.yml`</haxe_doc>
		</info>
		<new set="method" line="712"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* `App` class is the root instance of any ceramic app.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.AppMacro.build()</e></m>
			<m n=":allow"><e>ceramic.Visual</e></m>
			<m n=":allow"><e>ceramic.Screen</e></m>
			<m n=":allow"><e>ceramic.Entity</e></m>
			<m n=":allow"><e>ceramic.Timer</e></m>
		</meta>
	</class>
	<class path="ceramic.AppXUpdatesHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AppXUpdatesHandler.hx">
		<owner public="1" expr="null" line="6">
			<c path="ceramic.Entity"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</owner>
		<numUpdates public="1" expr="-1" line="8">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</numUpdates>
		<callback public="1" expr="null" line="10">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</callback>
		<reset set="method" line="14"><f a=""><x path="Void"/></f></reset>
		<new set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<class path="ceramic.Pool" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Pool.hx">
		<availableItems expr="[]" line="10">
			<c path="Array"><c path="ceramic.Pool.T"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</availableItems>
		<get public="1" get="inline" set="null" line="17">
			<f a=""><c path="ceramic.Pool.T"/></f>
			<haxe_doc>* Get an available item if any is ready to be used or `null` if none is available.</haxe_doc>
		</get>
		<recycle public="1" set="method" line="26">
			<f a="item">
				<c path="ceramic.Pool.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Recycle an existing item so that it can be reused later</haxe_doc>
		</recycle>
		<clear public="1" set="method" line="32"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A generic object pool utility.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Point" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Point.hx">
		<get public="1" get="inline" set="null" line="35" static="1">
			<f a="?x:?y:?z" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.Point"/>
			</f>
			<meta><m n=":value"><e>{ z : 0, y : 0, x : 0 }</e></m></meta>
		</get>
		<pool expr="new Pool&lt;Point&gt;()" line="52" static="1">
			<c path="ceramic.Pool"><c path="ceramic.Point"/></c>
			<meta><m n=":value"><e><![CDATA[new Pool<Point>()]]></e></m></meta>
		</pool>
		<x public="1" expr="0" line="6">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0" line="8">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<z public="1" expr="0" line="10">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</z>
		<toString set="method" line="12"><f a=""><c path="String"/></f></toString>
		<recycle public="1" set="method" line="26"><f a=""><x path="Void"/></f></recycle>
		<new public="1" set="method" line="18">
			<f a="?x:?y:?z" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.Visual" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Visual.hx">
		<extends path="ceramic.Entity"/>
		<DEPTH_FACTOR final="1" get="inline" set="null" expr="1000" line="48" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1000</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* A factor applied to every computed depth. This factor is used to avoid having
     * all computed depth values being too small and risking to create precision issues.
     * It is expected to work best with use of `depthRange = 1` on visuals (default)</haxe_doc>
		</DEPTH_FACTOR>
		<DEPTH_MARGIN final="1" get="inline" set="null" expr="0.01" line="55" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.01</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* A garanteed margin between max inner computed depth and container depth range,
     * and min inner depth and container's computed depth.</haxe_doc>
		</DEPTH_MARGIN>
		<FLAG_NOT_ACTIVE final="1" get="inline" set="null" expr="1" line="1553" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</FLAG_NOT_ACTIVE>
		<FLAG_VISIBLE_WHEN_ACTIVE final="1" get="inline" set="null" expr="2" line="1554" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</FLAG_VISIBLE_WHEN_ACTIVE>
		<FLAG_TOUCHABLE_WHEN_ACTIVE final="1" get="inline" set="null" expr="4" line="1555" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</FLAG_TOUCHABLE_WHEN_ACTIVE>
		<FLAG_IS_HIT_VISUAL final="1" get="inline" set="null" expr="8" line="1556" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</FLAG_IS_HIT_VISUAL>
		<_degToRad get="inline" set="null" expr="0.017453292519943295" line="1699" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.017453292519943295</e></m></meta>
		</_degToRad>
		<_matrix expr="new Transform()" line="1701" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</_matrix>
		<_point expr="new Point()" line="1703" static="1">
			<c path="ceramic.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
		</_point>
		<_minDepth expr="0" line="2522" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_minDepth>
		<_maxDepth expr="0" line="2524" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_maxDepth>
		<computeChildrenDepth set="method" line="2581" static="1">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Compute children depth. The result depends on whether
     * a parent defines a custom `depthRange` value or not.</haxe_doc>
		</computeChildrenDepth>
		<_computeChildrenDepth0 get="inline" set="null" line="2587" static="1"><f a="visual:step">
	<c path="ceramic.Visual"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_computeChildrenDepth0>
		<_computeChildrenDepth1 get="inline" set="null" line="2615" static="1"><f a="visual:step">
	<c path="ceramic.Visual"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_computeChildrenDepth1>
		<_computeChildrenDepthApplyDepthRange get="inline" set="null" line="2641" static="1"><f a="visual:children">
	<c path="ceramic.Visual"/>
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Void"/>
</f></_computeChildrenDepthApplyDepthRange>
		<computeMinMaxDepths set="method" line="2665" static="1"><f a="visual">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></computeMinMaxDepths>
		<_computeMinMaxDepths0 get="inline" set="null" line="2671" static="1"><f a="visual:step">
	<c path="ceramic.Visual"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_computeMinMaxDepths0>
		<_computeMinMaxDepths1 get="inline" set="null" line="2699" static="1"><f a="visual:step">
	<c path="ceramic.Visual"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_computeMinMaxDepths1>
		<multiplyDepths set="method" line="2725" static="1"><f a="visual:startDepth:targetRange">
	<c path="ceramic.Visual"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></multiplyDepths>
		<_multiplyDepths0 get="inline" set="null" line="2731" static="1"><f a="visual:startDepth:targetRange:step">
	<c path="ceramic.Visual"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_multiplyDepths0>
		<_multiplyDepths1 get="inline" set="null" line="2762" static="1"><f a="visual:startDepth:targetRange:step">
	<c path="ceramic.Visual"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_multiplyDepths1>
		<_dox_event_pointerDown public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is down on the visual
     * @param info The info related to this pointer event</haxe_doc>
		</_dox_event_pointerDown>
		<emitPointerDown set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired when a pointer (touch or mouse) is down on the visual
     * @param info The info related to this pointer event</haxe_doc>
		</emitPointerDown>
		<onPointerDown public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is down on the visual
     * @param info The info related to this pointer event</haxe_doc>
		</onPointerDown>
		<oncePointerDown public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is down on the visual
     * @param info The info related to this pointer event</haxe_doc>
		</oncePointerDown>
		<offPointerDown public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is down on the visual
     * @param info The info related to this pointer event</haxe_doc>
		</offPointerDown>
		<listensPointerDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is down on the visual
     * @param info The info related to this pointer event</haxe_doc>
		</listensPointerDown>
		<_dox_event_pointerUp public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was down on the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</_dox_event_pointerUp>
		<emitPointerUp set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired when a pointer (touch or mouse) was down on the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</emitPointerUp>
		<onPointerUp public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was down on the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</onPointerUp>
		<oncePointerUp public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was down on the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</oncePointerUp>
		<offPointerUp public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was down on the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</offPointerUp>
		<listensPointerUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was down on the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</listensPointerUp>
		<_dox_event_pointerOver public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is over the visual
     * @param info The info related to this pointer event</haxe_doc>
		</_dox_event_pointerOver>
		<emitPointerOver set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired when a pointer (touch or mouse) is over the visual
     * @param info The info related to this pointer event</haxe_doc>
		</emitPointerOver>
		<onPointerOver public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is over the visual
     * @param info The info related to this pointer event</haxe_doc>
		</onPointerOver>
		<oncePointerOver public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is over the visual
     * @param info The info related to this pointer event</haxe_doc>
		</oncePointerOver>
		<offPointerOver public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is over the visual
     * @param info The info related to this pointer event</haxe_doc>
		</offPointerOver>
		<listensPointerOver public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) is over the visual
     * @param info The info related to this pointer event</haxe_doc>
		</listensPointerOver>
		<_dox_event_pointerOut public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was over the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</_dox_event_pointerOut>
		<emitPointerOut set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fired when a pointer (touch or mouse) was over the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</emitPointerOut>
		<onPointerOut public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was over the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</onPointerOut>
		<oncePointerOut public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was over the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</oncePointerOut>
		<offPointerOut public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was over the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</offPointerOut>
		<listensPointerOut public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when a pointer (touch or mouse) was over the visual and is not anymore
     * @param info The info related to this pointer event</haxe_doc>
		</listensPointerOut>
		<_dox_event_focus public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when this visual gains focus (after handling a pointer event)</haxe_doc>
		</_dox_event_focus>
		<emitFocus set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when this visual gains focus (after handling a pointer event)</haxe_doc>
		</emitFocus>
		<onFocus public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual gains focus (after handling a pointer event)</haxe_doc>
		</onFocus>
		<onceFocus public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual gains focus (after handling a pointer event)</haxe_doc>
		</onceFocus>
		<offFocus public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual gains focus (after handling a pointer event)</haxe_doc>
		</offFocus>
		<listensFocus public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual gains focus (after handling a pointer event)</haxe_doc>
		</listensFocus>
		<_dox_event_blur public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Fired when this visual loses focus</haxe_doc>
		</_dox_event_blur>
		<emitBlur set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fired when this visual loses focus</haxe_doc>
		</emitBlur>
		<onBlur public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual loses focus</haxe_doc>
		</onBlur>
		<onceBlur public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual loses focus</haxe_doc>
		</onceBlur>
		<offBlur public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual loses focus</haxe_doc>
		</offBlur>
		<listensBlur public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Fired when this visual loses focus</haxe_doc>
		</listensBlur>
		<willListenPointerOver get="inline" set="null" line="94"><f a=""><x path="Void"/></f></willListenPointerOver>
		<asQuad public="1" expr="null" line="939">
			<c path="ceramic.Quad"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Get this visual typed as `Quad` or null if it isn't a `Quad`</haxe_doc>
		</asQuad>
		<asMesh public="1" expr="null" line="944">
			<c path="ceramic.Mesh"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Get this visual typed as `Mesh` or null if it isn't a `Mesh`</haxe_doc>
		</asMesh>
		<multiTouch public="1" expr="false" line="956">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* When enabled, this visual will receive as many up/down/click/over/out events as
     * there are fingers or mouse pointer interacting with it.
     * Default is `false`, ensuring there is never multiple up/down/click/over/out that
     * overlap each other. In that case, it triggers `pointer down` when the first finger/pointer hits
     * the visual and trigger `pointer up` when the last finger/pointer stops touching it. Behavior is
     * similar for `pointer over` and `pointer out` events.</haxe_doc>
		</multiTouch>
		<isPointerDown public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether this visual is between a `pointer down` and an `pointer up` event or not.</haxe_doc>
		</isPointerDown>
		<_numPointerDown expr="0" line="962">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numPointerDown>
		<get_isPointerDown get="inline" set="null" line="963"><f a=""><x path="Bool"/></f></get_isPointerDown>
		<isPointerOver public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether this visual is between a `pointer over` and an `pointer out` event or not.</haxe_doc>
		</isPointerOver>
		<_numPointerOver expr="0" line="969">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numPointerOver>
		<get_isPointerOver get="inline" set="null" line="970"><f a=""><x path="Bool"/></f></get_isPointerOver>
		<clip public="1" set="accessor" expr="null" line="978">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Use the given visual's bounds as clipping area for itself and **every children**.
     * Clipping areas cannot be combined. That means if `clip` is not null and current
     * visual instance is already clipped by a parent visual, its children's won't be clipped
     * by it anymore as they are instead clipped by this `clip` property instead.</haxe_doc>
		</clip>
		<set_clip get="inline" set="null" line="979"><f a="clip">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
</f></set_clip>
		<inheritAlpha public="1" set="accessor" expr="false" line="990">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this visual should inherit its parent alpha value or not.
     * If it inherits, parent alpha value will be multiplied with current visual's own `alpha` property.</haxe_doc>
		</inheritAlpha>
		<set_inheritAlpha get="inline" set="null" line="991"><f a="inheritAlpha">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_inheritAlpha>
		<stop public="1" set="method" line="1002">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stop this visual, whatever that means (override in subclasses).
     * When arcade physics are enabled, visual's body is stopped from this call.</haxe_doc>
		</stop>
		<translatesOnly public="1" expr="true" line="1038">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Computed flag that tells whether this visual is only translated,
     * thus not rotated, skewed nor scaled.
     * When this is `true`, matrix computation may be a bit faster as it
     * will skip some unneeded matrix computation.</haxe_doc>
		</translatesOnly>
		<translatesOnlyDirty public="1" expr="false" line="1043">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether we should re-check if this visual is only translating or having a more complex transform</haxe_doc>
		</translatesOnlyDirty>
		<contentDirty public="1" set="accessor" expr="true" line="1048">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Setting this to true will force the visual to recompute its displayed content</haxe_doc>
		</contentDirty>
		<set_contentDirty get="inline" set="null" line="1049"><f a="contentDirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_contentDirty>
		<matrixDirty public="1" set="accessor" expr="true" line="1060">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Setting this to true will force the visual's matrix to be re-computed</haxe_doc>
		</matrixDirty>
		<set_matrixDirty get="inline" set="null" line="1061"><f a="matrixDirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_matrixDirty>
		<renderTargetDirty public="1" set="accessor" expr="true" line="1077">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Setting this to true will force the visual's computed render target to be re-computed</haxe_doc>
		</renderTargetDirty>
		<set_renderTargetDirty get="inline" set="null" line="1078"><f a="renderTargetDirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_renderTargetDirty>
		<visibilityDirty public="1" set="accessor" expr="true" line="1095">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Setting this to true will force the visual to compute it's visility in hierarchy</haxe_doc>
		</visibilityDirty>
		<set_visibilityDirty get="inline" set="null" line="1096"><f a="visibilityDirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visibilityDirty>
		<touchableDirty public="1" set="accessor" expr="true" line="1112">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Setting this to true will force the visual to compute it's touchability in hierarchy</haxe_doc>
		</touchableDirty>
		<set_touchableDirty get="inline" set="null" line="1113"><f a="touchableDirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_touchableDirty>
		<clipDirty public="1" set="accessor" expr="true" line="1129">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Setting this to true will force the visual to compute it's clipping state in hierarchy</haxe_doc>
		</clipDirty>
		<set_clipDirty get="inline" set="null" line="1130"><f a="clipDirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clipDirty>
		<renderTarget public="1" set="accessor" expr="null" line="1146">
			<c path="ceramic.RenderTexture"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If set, the visual will be rendered into this target RenderTexture instance
     * instead of being drawn onto screen directly.</haxe_doc>
		</renderTarget>
		<set_renderTarget set="method" line="1147"><f a="renderTarget">
	<c path="ceramic.RenderTexture"/>
	<c path="ceramic.RenderTexture"/>
</f></set_renderTarget>
		<blending public="1" set="accessor" expr="Blending.AUTO" line="1155">
			<x path="ceramic.Blending"/>
			<meta><m n=":value"><e>Blending.AUTO</e></m></meta>
		</blending>
		<set_blending set="method" line="1156"><f a="blending">
	<x path="ceramic.Blending"/>
	<x path="ceramic.Blending"/>
</f></set_blending>
		<visible public="1" set="accessor" expr="true" line="1164">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="editable"><e>{ group : "active" }</e></m>
			</meta>
			<haxe_doc>* Set to `false` to make this visual (and all of its children) invisible and not rendered.</haxe_doc>
		</visible>
		<set_visible set="method" line="1165"><f a="visible">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<touchable public="1" set="accessor" expr="true" line="1176">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="editable"><e>{ group : "active" }</e></m>
			</meta>
			<haxe_doc>* Set to `false` to make this visual (and all of its children) not touchable</haxe_doc>
		</touchable>
		<set_touchable set="method" line="1177"><f a="touchable">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_touchable>
		<depth public="1" set="accessor" expr="0" line="1192">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "depth" }</e></m>
			</meta>
			<haxe_doc>* Set this visual's depth.
     * Visuals are rendered from back to front of the screen.
     * Given two visuals, a visual with higher depth will be rendered **above** a visual with lower depth.
     * In practice, it is advised to use integer values like `1`, `2`, `3`... to order your visuals,
     * like you would do with z-index on CSS elements.</haxe_doc>
		</depth>
		<set_depth set="method" line="1193"><f a="depth">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depth>
		<depthRange public="1" set="accessor" expr="1" line="1240">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n="editable"><e>{ group : "depth", label : "Range" }</e></m>
			</meta>
			<haxe_doc>* If set to `1` (default), children will be sort by depth and their computed depth
     * will be within range [parent.depth, parent.depth + depthRange].
     * You'll usually won't need to change this value,
     * unless you want to do advanced drawing where different
     * hierarchies of visuals are blending with each other.
     *
     * ```haxe
     * // Children computed depths will be relative to their parent visual depth.
     * // This is the default value and recommended approach in most situations as
     * // its behaviour is similar to display trees, z-index etc...
     * visual.depthRange = 1;
     *
     * // More advanced, two visuals: visual2 above visual1 because of higher depth, but
     * // visual1's depth range is `8`, so its children computed depths will be distributed
     * // between `1` and `1 + 8` (9 excluded). That means some of visual1's children
     * // can be above visual2's children. Can be useful on some specific edge cases,
     * // but not recommended in general.
     * visual1.depthRange = 8;
     * visual1.depth = 1;
     * visual2.depth = 2;
     *
     * // Another case: two visuals with the same depth and depthRange.
     * // There children will share the same computed depth space, so a child of visual1 at `depth = 6`
     * // will be above a child of visual2 at `depth = 4`.
     * // Resulting computed depths will be between `1` and `1 + 16` (17 excluded).
     * visual1.depthRange = 16
     * visual2.depthRange = 16
     * visual1.depth = 1;
     * visual2.depth = 1;
     *
     * // Children computed depths won't be relative to their parent visual depth.
     * // Instead, it will be relative to the higher parent (of the parent) in hierarchy that has a positive `depthRange` value,
     * visual.depthRange = -1;
     * ```</haxe_doc>
		</depthRange>
		<set_depthRange set="method" line="1242"><f a="depthRange">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depthRange>
		<x public="1" set="accessor" expr="0" line="1254">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "position" }</e></m>
			</meta>
			<haxe_doc>* The **x** position of this visual.
     * Relative to its parent, or screen if this visual has no parent.</haxe_doc>
		</x>
		<set_x set="method" line="1255"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<y public="1" set="accessor" expr="0" line="1267">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "position" }</e></m>
			</meta>
			<haxe_doc>* The **y** position of this visual.
     * Relative to its parent, or screen if this visual has no parent.</haxe_doc>
		</y>
		<set_y set="method" line="1268"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<scaleX public="1" set="accessor" expr="1" line="1279">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n="editable"><e>{ group : "scale" }</e></m>
			</meta>
			<haxe_doc>* The **scaleX** value of this visual.</haxe_doc>
		</scaleX>
		<set_scaleX set="method" line="1280"><f a="scaleX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<scaleY public="1" set="accessor" expr="1" line="1292">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n="editable"><e>{ group : "scale" }</e></m>
			</meta>
			<haxe_doc>* The **scaleY** value of this visual.</haxe_doc>
		</scaleY>
		<set_scaleY set="method" line="1293"><f a="scaleY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<skewX public="1" set="accessor" expr="0" line="1305">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "skew" }</e></m>
			</meta>
			<haxe_doc>* The **skewX** value of this visual.</haxe_doc>
		</skewX>
		<set_skewX set="method" line="1306"><f a="skewX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_skewX>
		<skewY public="1" set="accessor" expr="0" line="1318">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "skew" }</e></m>
			</meta>
			<haxe_doc>* The **skewY** value of this visual.</haxe_doc>
		</skewY>
		<set_skewY set="method" line="1319"><f a="skewY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_skewY>
		<anchorX public="1" set="accessor" expr="0" line="1335">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "anchor" }</e></m>
			</meta>
			<haxe_doc>* The **anchorX** value of this visual.
     * Affects how position, scale, rotation and skew of the visual are rendered.
     * Default is `0`, which means: anchor relative to the **left** of the visual.
     * Use `1` to make it relative to the **right** of the visual, or `0.5` to make it
     * relative to the **horizontal center** of the visual.</haxe_doc>
		</anchorX>
		<set_anchorX set="method" line="1336"><f a="anchorX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_anchorX>
		<anchorY public="1" set="accessor" expr="0" line="1351">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ group : "anchor" }</e></m>
			</meta>
			<haxe_doc>* The **anchorY** value of this visual.
     * Affects how position, scale, rotation and skew of the visual are rendered.
     * Default is `0`, which means: anchor relative to the **top** of the visual.
     * Use `1` to make it relative to the **bottom** of the visual, or `0.5` to make it
     * relative to the **vertical center** of the visual.</haxe_doc>
		</anchorY>
		<set_anchorY set="method" line="1352"><f a="anchorY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_anchorY>
		<width public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ min : 0, group : "size" }</e></m></meta>
			<haxe_doc>* The **width** of the visual.
     * Default is `0`. Can be set to an explicit value.
     * Some subclasses of `Visual` are computing it automatically
     * like `Text` from its textual content or `Quad` when a texture is assigned to it.</haxe_doc>
		</width>
		<_width expr="0" line="1367">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_width>
		<get_width set="method" line="1368"><f a=""><x path="Float"/></f></get_width>
		<set_width set="method" line="1371"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<height public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ min : 0, group : "size" }</e></m></meta>
			<haxe_doc>* The **height** of the visual.
     * Default is `0`. Can be set to an explicit value.
     * Some subclasses of `Visual` are computing it automatically
     * like `Text` from its textual content or `Quad` when a texture is assigned to it.</haxe_doc>
		</height>
		<_height expr="0" line="1386">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_height>
		<get_height set="method" line="1387"><f a=""><x path="Float"/></f></get_height>
		<set_height set="method" line="1390"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<roundTranslation public="1" set="accessor" expr="-1" line="1409">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc><![CDATA[* If set to a value above zero, matrix translation (tx & ty) will be rounded.
     *
     * ```haxe
     * roundTranslation = 0; // No rounding (default)
     * roundTranslation = 1; // Pixel perfect rounding
     * roundTranslation = 2; // Half-pixel rounding
     * ```
     *
     * May be useful to render pixel perfect scenes onto `ceramic.Filter`.]]></haxe_doc>
		</roundTranslation>
		<set_roundTranslation set="method" line="1410"><f a="roundTranslation">
	<x path="Int"/>
	<x path="Int"/>
</f></set_roundTranslation>
		<rotation public="1" set="accessor" expr="0" line="1422">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="editable"><e>{ slider : [0, 360], degrees : true }</e></m>
			</meta>
			<haxe_doc>* Rotation of the visual in degrees.
     * The center of the rotation depends on `anchorX` and `anchorY`.</haxe_doc>
		</rotation>
		<set_rotation set="method" line="1423"><f a="rotation">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<alpha public="1" set="accessor" expr="1" line="1435">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n="editable"><e>{ slider : [0, 1] }</e></m>
			</meta>
			<haxe_doc>* Alpha of the visual. Must be a value between `0` (transparent) and `1` (fully opaque)</haxe_doc>
		</alpha>
		<set_alpha set="method" line="1436"><f a="alpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<translateX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ group : "translate" }</e></m></meta>
			<haxe_doc>* Visual X translation.
     * This is a shorthand equivalent to assigning a `Transform` object to
     * the visual with a `tx` value of `translateX`.
     * Only recommended for advanced usage as `x` property should be used in general instead.</haxe_doc>
		</translateX>
		<get_translateX get="inline" set="null" line="1451"><f a=""><x path="Float"/></f></get_translateX>
		<set_translateX get="inline" set="null" line="1454"><f a="translateX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_translateX>
		<translateY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ group : "translate" }</e></m></meta>
			<haxe_doc>* Visual Y translation.
     * This is a shorthand equivalent to assigning a `Transform` object to
     * the visual with a `ty` value of `translateY`.
     * Only recommended for advanced usage as `y` property should be used in general instead.</haxe_doc>
		</translateY>
		<get_translateY get="inline" set="null" line="1481"><f a=""><x path="Float"/></f></get_translateY>
		<set_translateY get="inline" set="null" line="1484"><f a="translateY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_translateY>
		<transform public="1" set="accessor" expr="null" line="1508">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Set additional matrix-based transform to this visual. Default is `null`.
     * A `Transform` object will affect of the visual is rendered.
     * The transform is applied after visual's properties (position, rotation, scale, skew).</haxe_doc>
		</transform>
		<set_transform set="method" line="1509"><f a="transform">
	<c path="ceramic.Transform"/>
	<c path="ceramic.Transform"/>
</f></set_transform>
		<shader public="1" set="accessor" expr="null" line="1532">
			<c path="ceramic.Shader"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* Assign a shader to this visual.
     * When none is assigned, default shader will be used.</haxe_doc>
		</shader>
		<set_shader set="method" line="1533"><f a="shader">
	<c path="ceramic.Shader"/>
	<c path="ceramic.Shader"/>
</f></set_shader>
		<flag public="1" get="inline" set="null" line="1546">
			<f a="index:?value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Read and write arbitrary boolean flags on this visual.
     * Index should be between 0 (included) and 16 (excluded) or result is undefined.
     * @param index The index of the flag to change, between 0 (included) and 16 (excluded)
     * @param value (optional) The boolean value to set, or no value to simply read current value
     * @return The existing value if just reading, or the new value if writing</haxe_doc>
		</flag>
		<internalFlag get="inline" set="null" line="1571">
			<f a="index:?value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Read and write arbitrary boolean flags on this visual.
     * Index should be between 0 (included) and 16 (excluded) or result is undefined.
     * /!\ Reserved for internal use</haxe_doc>
		</internalFlag>
		<flags expr="new Flags()" line="1581">
			<x path="ceramic.Flags"/>
			<meta><m n=":value"><e>new Flags()</e></m></meta>
			<haxe_doc>* Just a way to store some flags.
     * 32 boolean values stored inside an `Int`.</haxe_doc>
		</flags>
		<active public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether this visual is `active`. Default is **true**. When setting it to **false**,
     * the visual won't be `visible` nor `touchable` anymore (these get set to **false**).
     * When restoring `active` to **true**, `visible` and `touchable` will also get back
     * their previous state.
     * If you want to keep a visual around without it being displayed or interactive, simply
     * set its `active` property to `false`. It will be almost like it doesn't exist and its
     * impact on rendering will be minimal.</haxe_doc>
		</active>
		<get_active get="inline" set="null" line="1593"><f a=""><x path="Bool"/></f></get_active>
		<set_active set="method" line="1596"><f a="active">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_active>
		<matA public="1" expr="1" line="1629">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matA>
		<matB public="1" expr="0" line="1631">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matB>
		<matC public="1" expr="0" line="1633">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matC>
		<matD public="1" expr="1" line="1635">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matD>
		<matTX public="1" expr="0" line="1637">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matTX>
		<matTY public="1" expr="0" line="1639">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matTY>
		<computedVisible public="1" set="null" expr="true" line="1649">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Computed visible value. This is `true` if this visual is `visible` and all
     * of its parents are `visible`. If you want to know if a visual is visible on screen,
     * you should check with this property and not `visible` property, which doesn't account
     * for parent visibility.</haxe_doc>
		</computedVisible>
		<computedAlpha public="1" set="null" expr="1" line="1655">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Computed alpha value. This is the combination of this visual's alpha and its parent alpha
     * if `inheritAlpha` is `true`</haxe_doc>
		</computedAlpha>
		<computedDepth public="1" set="null" expr="0" line="1661">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Computed depth value. This is the final depth used by rendering, computed from this visual's `depth`
     * and `depthRange` properties and its hierarchy of parent visuals.</haxe_doc>
		</computedDepth>
		<computedRenderTarget public="1" set="null" expr="null" line="1667">
			<c path="ceramic.RenderTexture"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Computed render target. When a visual has a `renderTarget` assigned, its `computedRenderTarget` will
     * be assigned with the same instance, and its children's `computedRenderTarget` property as well.</haxe_doc>
		</computedRenderTarget>
		<computedTouchable public="1" set="null" expr="true" line="1673">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Computed touchable value. This is `true` if this visual is `touchable` and all
     * of its parents are `touchable`.</haxe_doc>
		</computedTouchable>
		<computedClip public="1" set="null" expr="null" line="1678">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If any parent of this visual has a `clip` visual assigned, this will be the computed/resolved visual.</haxe_doc>
		</computedClip>
		<children public="1" set="null" expr="null" line="1690">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.Visual"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* A visual can have **children**.
     * Children positions and transformations are relative to their parent.
     * This property is read only. Use `add()` to add children to this visual
     * and `remove()` to remove them.
     * The order on the visuals in `children` should not be used to predict the order in which visuals are rendered.
     * If you want to control the order of rendering of visuals, use `depth` property on the children instead.</haxe_doc>
		</children>
		<parent public="1" set="null" expr="null" line="1695">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The **parent visual** if there is any, or `null` if this visual doesn't have any parent.</haxe_doc>
		</parent>
		<size public="1" get="inline" set="null" line="1712">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand to set `width` and `height` in a single call.
     * @param width The width to set to the visual
     * @param height The height to set to the visual</haxe_doc>
		</size>
		<anchor public="1" get="inline" set="null" line="1724">
			<f a="anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand to set `anchorX` and `anchorY` in a single call.
     * @param anchorX The anchor to set to the visual on **x** axis
     * @param anchorY The anchor to set to the visual on **y** axis</haxe_doc>
		</anchor>
		<pos public="1" get="inline" set="null" line="1736">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand to set `x` and `y` in a single call.
     * @param x The x position to set to the visual
     * @param y The y position to set to the visual</haxe_doc>
		</pos>
		<scale public="1" get="inline" set="null" line="1748">
			<f a="scaleX">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand to set `scaleX` and `scaleY` in a single call.
     * @param scaleX The scale to set to the visual on **x** axis
     * @param scaleY (optional) The scale to set to the visual on **y** axis. If not provided, will use scaleX value.</haxe_doc>
			<overloads><scale public="1" get="inline" set="null" line="1759">
	<f a="scaleX:scaleY">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* Shorthand to set `scaleX` and `scaleY` in a single call.
     * @param scaleX The scale to set to the visual on **x** axis
     * @param scaleY (optional) The scale to set to the visual on **y** axis. If not provided, will use scaleX value.</haxe_doc>
</scale></overloads>
		</scale>
		<_scale get="inline" set="null" line="1765"><f a="scaleX:scaleY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></_scale>
		<skew public="1" get="inline" set="null" line="1777">
			<f a="skewX:skewY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand to set `skewX` and `skewY` in a single call.
     * @param skewX The skew to set to the visual on **x** axis
     * @param skewY The skew to set to the visual on **y** axis</haxe_doc>
		</skew>
		<translate public="1" get="inline" set="null" line="1789">
			<f a="translateX:translateY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand to set `translateX` and `translateY` in a single call.
     * @param translateX The translation to set to the visual on **x** axis
     * @param translateY The translation to set to the visual on **y** axis</haxe_doc>
		</translate>
		<anchorKeepPosition public="1" set="method" line="1805">
			<f a="anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the visual's anchor but ensure the visual keeps its current position.
     * This is similar to `anchor(anchorX, anchorY)` but visual with have its `x` and `y` properties
     * updated to ensure it stays at the same position as before changing anchor.
     * @param anchorX The anchor to set to the visual on **x** axis
     * @param anchorY The anchor to set to the visual on **y** axis</haxe_doc>
		</anchorKeepPosition>
		<childWithId public="1" set="method" line="1838">
			<f a="id:?recursive" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="ceramic.Visual"/>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
			<haxe_doc>* Returns the first child matching the requested `id` or `null` otherwise.
     * @param id The requested id
     * @param recursive (optional) Recursive search in children
     * @return A matching visual or `null`</haxe_doc>
		</childWithId>
		<destroy public="1" set="method" line="1884" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroy the visual.
     * When a visual is destroyed, `clear()` is called,
     * which means all children are removed and destroyed.
     * Events owned by this visual and events on this visual are
     * unbound so they don't need to be unbound explicitly.
     * As soon as `destroy()` is called, the `destroyed` property
     * becomes `true`.</haxe_doc>
		</destroy>
		<clear public="1" set="method" line="1922">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Remove and destroy all children.</haxe_doc>
		</clear>
		<transformDidChange set="method" line="1946">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when this visual's transform has changed</haxe_doc>
		</transformDidChange>
		<computeMatrix set="method" line="1955">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when this visual's matrix needs to be recomputed</haxe_doc>
		</computeMatrix>
		<computeTranslatesOnly get="inline" set="null" line="1967"><f a=""><x path="Void"/></f></computeTranslatesOnly>
		<doComputeMatrix get="inline" set="null" line="1974"><f a=""><x path="Void"/></f></doComputeMatrix>
		<hits public="1" get="inline" set="null" line="2123">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if screen (x, y) screen coordinates hit/intersect this visual visible bounds
     * @param x Screen **x** coordinate
     * @param y Screen **y** coordinate
     * @return `true` if it hits</haxe_doc>
			<overloads><hits public="1" get="inline" set="null" line="2136">
	<f a="x:y:ignoreRenderTarget">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Bool"/>
		<x path="Bool"/>
	</f>
	<haxe_doc>* Returns true if screen (x, y) screen coordinates hit/intersect this visual visible bounds
     * @param x Screen **x** coordinate
     * @param y Screen **y** coordinate
     * @param ignoreRenderTarget
     *      If `true`, hit test will be performed like the visual
     *      doesn't have a render target even if it has in reality
     * @return `true` if it hits</haxe_doc>
</hits></overloads>
		</hits>
		<_hits set="method" line="2140"><f a="x:y:ignoreRenderTarget">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></_hits>
		<hitTest set="method" line="2190">
			<f a="x:y:matrix">
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.Transform"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* The actual hit test performed on the visual.
     * If needed to change how hit test is performed
     * on a visual subclass, this is the method to override.
     * @param x Screen **x** coordinate
     * @param y Screen **y** coordinate
     * @param matrix The matrix being applied to visual, relative to screen space
     * @return `true` if it hits</haxe_doc>
		</hitTest>
		<isHitVisual get="accessor" set="accessor"><x path="Bool"/></isHitVisual>
		<get_isHitVisual get="inline" set="null" line="2203"><f a=""><x path="Bool"/></f></get_isHitVisual>
		<set_isHitVisual get="inline" set="null" line="2207"><f a="isHitVisual">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isHitVisual>
		<interceptPointerDown set="method" line="2224">
			<f a="hittingVisual:x:y:touchIndex:buttonId">
				<c path="ceramic.Visual"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Override this method in subclasses to intercept hitting pointer down events on this visual's children (any level in sub-hierarchy).
     * Return `true` to stop an event from being triggered on the hitting child, `false` (default) otherwise.
     * @param hittingVisual The hitting visual, meaning the visual on which the event applies
     * @param x The **x** coordinate of the event
     * @param y The **y** coordinate of the event
     * @param touchIndex The **touch index** of the event (or `-1` if it is not a touch event)
     * @param buttonId The **button id** of the event (or `-1` if it is not a mouse event)
     * @return `true` if the event is intercepted</haxe_doc>
		</interceptPointerDown>
		<interceptPointerOver set="method" line="2239">
			<f a="hittingVisual:x:y">
				<c path="ceramic.Visual"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Override this method in subclasses to intercept hitting pointer over events on this visual's children (any level in sub-hierarchy).
     * Return `true` to stop an event from being triggered on the hitting child, `false` (default) otherwise.
     * @param hittingVisual The hitting visual, meaning the visual on which the event applies
     * @param x The **x** coordinate of the event
     * @param y The **y** coordinate of the event
     * @return `true` if the event is intercepted</haxe_doc>
		</interceptPointerOver>
		<screenToVisual public="1" set="method" line="2254">
			<f a="x:y:point:?handleFilters" v=":::true">
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.Point"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ handleFilters : true }</e></m></meta>
			<haxe_doc>* Assign **x** and **y** to given point after converting them from screen coordinates to current visual coordinates.
     * @param x The **x** coordinate
     * @param y The **y** coordinate
     * @param point The point in which resulting x and y coordinate are stored
     * @param handleFilters (optional) Make it `false` if you want to skip nested filter transformations</haxe_doc>
		</screenToVisual>
		<visualToScreen public="1" set="method" line="2304">
			<f a="x:y:point:?handleFilters" v=":::true">
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.Point"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ handleFilters : true }</e></m></meta>
			<haxe_doc>* Assign **x** and **y** to given point after converting them from current visual coordinates to screen coordinates.
     * @param x The **x** coordinate
     * @param y The **y** coordinate
     * @param point The point in which resulting x and y coordinate are stored
     * @param handleFilters (optional) Make it `false` if you want to skip nested filter transformations</haxe_doc>
		</visualToScreen>
		<visualToTransform public="1" set="method" line="2350">
			<f a="transform">
				<c path="ceramic.Transform"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Extract current visual transformation and write it into the given `transform`
     * @param transform The transform object to write data into</haxe_doc>
		</visualToTransform>
		<computeVisibility set="method" line="2362"><f a=""><x path="Void"/></f></computeVisibility>
		<computeClip set="method" line="2400"><f a=""><x path="Void"/></f></computeClip>
		<computeTouchable set="method" line="2436"><f a=""><x path="Void"/></f></computeTouchable>
		<computeRenderTarget set="method" line="2460"><f a=""><x path="Void"/></f></computeRenderTarget>
		<computeContent public="1" set="method" line="2514">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Compute content on this visual.
     * This method is expected to be overrided in `Visual` subclasses
     * to compute actual content (raw `Visual` class doesn't do anything).</haxe_doc>
		</computeContent>
		<autoChildrenDepth public="1" set="method" line="2532">
			<f a="?start:?step" v="1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ step : 1, start : 1 }</e></m></meta>
			<haxe_doc>* Will walk on every children and set their depths starting from
     * `start` and incrementing depth by `step`.
     * @param start The depth starting value (default 1). First child will have this depth, next child `depthStart + depthStep` etc...
     * @param step The depth step to use when increment depth for each child</haxe_doc>
		</autoChildrenDepth>
		<sortChildrenByDepth public="1" set="method" line="2551">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sort children by depth in ascending order.
     * This will simply reorder children in `children` array.
     * No depth value will be changed on any child.</haxe_doc>
		</sortChildrenByDepth>
		<normalizeChildrenDepth public="1" set="method" line="2566">
			<f a="?start:?step" v="1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ step : 1, start : 1 }</e></m></meta>
			<haxe_doc>* This is the equivalent of calling `sortChildrenByDepth()` followed with `autoChildrenDepth()`
     * @param start The depth starting value (default 1). First child will have this depth, next child `depthStart + depthStep` etc...
     * @param step The depth step to use when increment depth for each child</haxe_doc>
		</normalizeChildrenDepth>
		<hasIndirectParent public="1" set="method" line="2797">
			<f a="targetParent">
				<c path="ceramic.Visual"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if current visual has `targetParent` as parent visual. The parent can possibly
     * be indirect, meaning it can be the parent of the parent of the visual etc...
     * @param targetParent The target parent to check
     * @return `true` if the visual has the given target parent as indirect parent</haxe_doc>
		</hasIndirectParent>
		<firstParentWithClass public="1" params="T" set="method" line="2815">
			<f a="clazz">
				<x path="Class"><c path="firstParentWithClass.T"/></x>
				<c path="firstParentWithClass.T"/>
			</f>
			<haxe_doc>* Returns the first parent (can be indirect) of this visual that matches
     * the given class or `null` if none is matching
     * @param clazz The requested class
     * @return A matching parent or `null`</haxe_doc>
		</firstParentWithClass>
		<add public="1" set="method" line="2833">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add the given visual as a child.
     * When a visual is added as a child, it's `parent` property is updated
     * and it will follow parent transformation in addition to its own.
     * @param visual The visual to add</haxe_doc>
		</add>
		<remove public="1" set="method" line="2864">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove the child from current visual.
     * @param visual The child to remove</haxe_doc>
		</remove>
		<contains public="1" set="method" line="2894">
			<f a="child:?recursive" v=":false">
				<c path="ceramic.Visual"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ recursive : false }</e></m></meta>
			<haxe_doc>* Returns `true` if the current visual contains this child.
     * When `recursive` option is `true`, will return `true` if
     * the current visual contains this child or one of
     * its direct or indirect children does.
     * @param child The child to check in hierarchy
     * @param recursive (optional) Set to `true` to search recursively on indirect children
     * @return `true` if the current visual contains this child</haxe_doc>
		</contains>
		<computeBounds public="1" set="method" line="2917">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Compute bounds from children this visual contains.
     * This overwrites width, height, anchorX and anchorY properties accordingly.
     * Warning: this may be an expensive operation.</haxe_doc>
		</computeBounds>
		<bindToNativeScreenSize public="1" set="method" line="3037">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Will set this visual size to native screen size.
     * This is different than `bindToScreenSize()` because it will ignore
     * logical screen scaling. Use that if you want to provide visuals
     * that should keep the same pixel size when the window changes size and scales its content.
     * If needed, a `Transform` instance will be created and assigned to `transform` property.</haxe_doc>
		</bindToNativeScreenSize>
		<_bindToNativeScreenSizeCallback set="method" line="3045"><f a=""><x path="Void"/></f></_bindToNativeScreenSizeCallback>
		<bindToScreenSize public="1" set="method" line="3064">
			<f a="?factor" v="1.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ factor : 1.0 }</e></m></meta>
			<haxe_doc>* Will set this visual size to screen size</haxe_doc>
		</bindToScreenSize>
		<_bindToScreenSizeCallback set="method" line="3072"><f a="factor">
	<x path="Float"/>
	<x path="Void"/>
</f></_bindToScreenSizeCallback>
		<bindToTargetSize public="1" set="method" line="3081">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Will set this visual size to target size (`settings.targetWidth` and `settings.targetHeight`)</haxe_doc>
		</bindToTargetSize>
		<_bindToTargetSizeCallback set="method" line="3089"><f a=""><x path="Void"/></f></_bindToTargetSizeCallback>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="1863">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Create a new `Visual`</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Visuals are the building blocks to display things on screen.
 * A raw visual doesn't display anything but can have children
 * that can be more specialized visuals like `Quad`, `Mesh` or `Text` etc...
 *
 * ```haxe
 * var visual = new Visual();
 * visual.pos(x, y);
 * visual.size(someWidth, someHeight);
 * visual.onPointerDown(this, info -> {
 *     trace('clicked');
 * });
 * ```]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
			<m n=":allow"><e>ceramic.Screen</e></m>
			<m n=":allow"><e>ceramic.MeshPool</e></m>
			<m n="editable"/>
		</meta>
	</class>
	<class path="ceramic.Mesh" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Mesh.hx">
		<extends path="ceramic.Visual"/>
		<_matrix expr="Visual._matrix" line="50" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>Visual._matrix</e></m></meta>
		</_matrix>
		<colorMapping public="1" expr="MeshColorMapping.MESH" line="54">
			<x path="ceramic.MeshColorMapping"/>
			<meta><m n=":value"><e>MeshColorMapping.MESH</e></m></meta>
		</colorMapping>
		<customFloatAttributesSize public="1" expr="0" line="60">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The number of floats to add to fill float attributes in vertices array.
     * Default is zero: no custom attributes. Update this value when using shaders with custom attributes.</haxe_doc>
		</customFloatAttributesSize>
		<complexHit public="1" expr="false" line="68">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* When set to `true` hit test on this mesh will be performed at vertices level instead
     * of simply using bounds. This make the test substancially more expensive however.
     * Use only when needed.</haxe_doc>
		</complexHit>
		<destroy public="1" set="method" line="80" override="1"><f a=""><x path="Void"/></f></destroy>
		<color public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<meta><m n="editable"/></meta>
			<haxe_doc>* On `Mesh` instances, can be used instead of colors array when the mesh is only composed of a single color.</haxe_doc>
		</color>
		<get_color set="method" line="96"><f a=""><x path="ceramic.Color"/></f></get_color>
		<set_color set="method" line="108"><f a="color">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
		<vertices public="1" expr="[]" line="128">
			<c path="Array"><x path="Float"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* An array of floats where each pair of numbers is treated as a coordinate location (x,y)</haxe_doc>
		</vertices>
		<indices public="1" expr="[]" line="134">
			<c path="Array"><x path="Int"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* An array of integers or indexes, where every three indexes define a triangle.</haxe_doc>
		</indices>
		<colors public="1" expr="[]" line="140">
			<c path="Array"><x path="ceramic.AlphaColor"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* An array of colors for each vertex.
     * Each color is stored in a single `AlphaColor`(`Int`) value.</haxe_doc>
		</colors>
		<floatColors public="1" expr="null" line="149">
			<t path="ceramic.Float32Array"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* An array of colors for each vertex stored are four float32 values for each color.
     * Generally not needed unless you need extra precision for each color value.
     * If provided (not `null`), it will be used instead of `colors`.
     * When using `floatColors` instead of `colors`, no additional operation
     * related to premultiplied alpha will be done on the CPU.</haxe_doc>
		</floatColors>
		<texture public="1" set="accessor" expr="null" line="157">
			<c path="ceramic.Texture"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* The texture used on the mesh (optional)</haxe_doc>
		</texture>
		<set_texture get="inline" set="null" line="158"><f a="texture">
	<c path="ceramic.Texture"/>
	<c path="ceramic.Texture"/>
</f></set_texture>
		<uvs public="1" expr="[]" line="206">
			<c path="Array"><x path="Float"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* An array of normalized coordinates used to apply texture mapping.
     * Required if the texture is set.</haxe_doc>
		</uvs>
		<textureDestroyed set="method" line="216"><f a="_">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></textureDestroyed>
		<hitTest set="method" line="225" override="1"><f a="x:y:matrix">
	<x path="Float"/>
	<x path="Float"/>
	<c path="ceramic.Transform"/>
	<x path="Bool"/>
</f></hitTest>
		<set_shader set="method" line="290" override="1"><f a="shader">
	<c path="ceramic.Shader"/>
	<c path="ceramic.Shader"/>
</f></set_shader>
		<computeSize public="1" set="method" line="303">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Compute width and height from vertices</haxe_doc>
		</computeSize>
		<grid public="1" set="method" line="353">
			<f a="cols:rows:?width:?height" v="::-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : -1, width : -1 }</e></m></meta>
			<haxe_doc>* Compute vertices and indices to obtain a grid with `cols` columns
     * and `rows` rows at the requested `width` and `height`.
     * @param cols The number of columnns in the grid
     * @param rows The number of rows in the grid
     * @param width The width of the grid
     * @param height The height of the grid</haxe_doc>
		</grid>
		<gridFromTexture public="1" set="method" line="418">
			<f a="cols:rows:?texture">
				<x path="Int"/>
				<x path="Int"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Compute vertices, indices and uvs to obtain a grid with `cols` columns
     * and `rows` rows to fit the given texture or mesh's current texture.
     * @param cols The number of columnns in the grid
     * @param rows The number of rows in the grid
     * @param texture The texture used to generate the grid. If not provided, will use mesh's current texture</haxe_doc>
		</gridFromTexture>
		<new public="1" set="method" line="72"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Draw anything composed of triangles/vertices.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n="editable"><e>{ highlight : { points : "vertices" }, helpers : [{ name : "Grid", method : "grid", params : [{ name : "Columns", type : "Int", value : 1, slider : [1, 64] }, { name : "Rows", type : "Int", value : 1, slider : [1, 64] }] }, { name : "Grid From Texture", method : "gridFromTexture", params : [{ name : "Columns", type : "Int", value : 1, slider : [1, 64] }, { name : "Rows", type : "Int", value : 1, slider : [1, 64] }] }] }</e></m>
			<m n=":allow"><e>ceramic.MeshPool</e></m>
		</meta>
	</class>
	<class path="ceramic.Arc" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Arc.hx">
		<extends path="ceramic.Mesh"/>
		<sides public="1" set="accessor" expr="32" line="15">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>32</e></m>
				<m n="editable"><e>{ slider : [3, 100] }</e></m>
			</meta>
			<haxe_doc>* Number of sides. Higher is smoother but needs more vertices</haxe_doc>
		</sides>
		<set_sides get="inline" set="null" line="16"><f a="sides">
	<x path="Int"/>
	<x path="Int"/>
</f></set_sides>
		<radius public="1" set="accessor" expr="64" line="27">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>64</e></m>
				<m n="editable"><e>{ slider : [0, 999] }</e></m>
			</meta>
			<haxe_doc>* Radius of the arc</haxe_doc>
		</radius>
		<set_radius set="method" line="28"><f a="radius">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius>
		<angle public="1" set="accessor" expr="270" line="39">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>270</e></m>
				<m n="editable"><e>{ slider : [0, 360] }</e></m>
			</meta>
			<haxe_doc>* Angle (from 0 to 360). 360 will make it draw a full circle/ring</haxe_doc>
		</angle>
		<set_angle set="method" line="40"><f a="angle">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<borderPosition public="1" set="accessor" expr="MIDDLE" line="51">
			<e path="ceramic.BorderPosition"/>
			<meta>
				<m n=":value"><e>MIDDLE</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* Position of the drawn border</haxe_doc>
		</borderPosition>
		<set_borderPosition get="inline" set="null" line="52"><f a="borderPosition">
	<e path="ceramic.BorderPosition"/>
	<e path="ceramic.BorderPosition"/>
</f></set_borderPosition>
		<thickness public="1" set="accessor" expr="16" line="63">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>16</e></m>
				<m n="editable"><e>{ slider : [1, 120] }</e></m>
			</meta>
			<haxe_doc>* Thickness of the arc. If same value as radius and borderPosition is `INSIDE`, will draw a pie.</haxe_doc>
		</thickness>
		<set_thickness set="method" line="64"><f a="thickness">
	<x path="Float"/>
	<x path="Float"/>
</f></set_thickness>
		<computeContent public="1" set="method" line="79" override="1"><f a=""><x path="Void"/></f></computeContent>
		<new public="1" set="method" line="71"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Convenience mesh subclass to draw arc, pie, ring or disc geometry</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n="editable"><e>{ implicitSize : true }</e></m>
		</meta>
	</class>
	<class path="ceramic.ArrayPool" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ArrayPool.hx">
		<ALLOC_STEP expr="10" line="5" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</ALLOC_STEP>
		<dynPool10 expr="new ArrayPool(10)" line="9" static="1">
			<c path="ceramic.ArrayPool"/>
			<meta><m n=":value"><e>new ArrayPool(10)</e></m></meta>
		</dynPool10>
		<dynPool100 expr="new ArrayPool(100)" line="11" static="1">
			<c path="ceramic.ArrayPool"/>
			<meta><m n=":value"><e>new ArrayPool(100)</e></m></meta>
		</dynPool100>
		<dynPool1000 expr="new ArrayPool(1000)" line="13" static="1">
			<c path="ceramic.ArrayPool"/>
			<meta><m n=":value"><e>new ArrayPool(1000)</e></m></meta>
		</dynPool1000>
		<dynPool10000 expr="new ArrayPool(10000)" line="15" static="1">
			<c path="ceramic.ArrayPool"/>
			<meta><m n=":value"><e>new ArrayPool(10000)</e></m></meta>
		</dynPool10000>
		<dynPool100000 expr="new ArrayPool(100000)" line="17" static="1">
			<c path="ceramic.ArrayPool"/>
			<meta><m n=":value"><e>new ArrayPool(100000)</e></m></meta>
		</dynPool100000>
		<didNotifyLargePool expr="false" line="19" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</didNotifyLargePool>
		<pool public="1" set="method" line="21" static="1"><f a="size">
	<x path="Int"/>
	<c path="ceramic.ArrayPool"/>
</f></pool>
		<arrays expr="null" line="54">
			<c path="ceramic.ReusableArray"><x path="Any"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</arrays>
		<nextFree expr="0" line="56">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextFree>
		<arrayLengths><x path="Int"/></arrayLengths>
		<get public="1" set="method" line="70"><f a=""><c path="ceramic.ReusableArray"><x path="Any"/></c></f></get>
		<release public="1" set="method" line="99"><f a="array">
	<c path="ceramic.ReusableArray"><x path="Any"/></c>
	<x path="Void"/>
</f></release>
		<new public="1" set="method" line="62"><f a="arrayLengths">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Assert" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Assert.hx">
		<assert public="1" set="method" static="1">
			<f a="expr:?reason">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>* Assert the expression evaluates to `true`.
     * This check is only done in `debug` builds and doesn't affect `release` builds.</haxe_doc>
		</assert>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="tracker.Observable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Observable.hx" interface="1">
		<haxe_doc>Observable allows to observe properties of an object.</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Asset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Asset.hx">
		<extends path="ceramic.Entity"/>
		<implements path="tracker.Observable"/>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Asset"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Asset"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Asset"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Asset"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.Asset"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false" line="131">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<_dox_event_complete public="1" set="method" line="637">
			<f a="success">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_complete>
		<emitComplete set="method" line="1095">
			<f a="success">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>complete event</haxe_doc>
		</emitComplete>
		<onComplete public="1" set="method" line="1199">
			<f a="owner:handleSuccess">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="success">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</onComplete>
		<onceComplete public="1" set="method" line="1298">
			<f a="owner:handleSuccess">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="success">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</onceComplete>
		<offComplete public="1" set="method" line="1368">
			<f a="?handleSuccess">
				<f a="success">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</offComplete>
		<listensComplete public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to complete event</haxe_doc>
		</listensComplete>
		<kind public="1" set="null">
			<c path="String"/>
			<haxe_doc>* Asset kind</haxe_doc>
		</kind>
		<name public="1" set="accessor">
			<c path="String"/>
			<haxe_doc>* Asset name</haxe_doc>
		</name>
		<variant public="1" set="accessor">
			<c path="String"/>
			<haxe_doc>* Asset variant</haxe_doc>
		</variant>
		<fullName public="1" set="null">
			<c path="String"/>
			<haxe_doc>* Asset full name (including variant, if provided)</haxe_doc>
		</fullName>
		<path public="1" set="accessor">
			<c path="String"/>
			<haxe_doc>* Asset path</haxe_doc>
		</path>
		<allPaths public="1" set="null">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* All paths related to this asset</haxe_doc>
		</allPaths>
		<density public="1" set="null" expr="1.0" line="52">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Asset target density. Some assets depend on current screen density,
     * like bitmap fonts, textures. Default is 1.0</haxe_doc>
		</density>
		<owner public="1" set="null">
			<c path="ceramic.Assets"/>
			<haxe_doc>* Asset owner. The owner is a group of assets (Assets instance). When the owner gets
     * destroyed, every asset it owns get destroyed as well.</haxe_doc>
		</owner>
		<runtimeAssets public="1" set="accessor">
			<c path="ceramic.RuntimeAssets"/>
			<haxe_doc>* Optional runtime assets, used to compute path.</haxe_doc>
		</runtimeAssets>
		<options public="1" set="null">
			<t path="ceramic.AssetOptions"/>
			<haxe_doc>* Asset options. Depends on asset kind and even backend in some cases.</haxe_doc>
		</options>
		<assets public="1" set="null" expr="null" line="73">
			<c path="ceramic.Assets"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Sub assets-list. Defaults to null but some kind of assets (like bitmap fonts) instanciate it to load sub-assets it depends on.</haxe_doc>
		</assets>
		<refCount public="1" set="null" expr="0" line="80">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Manage asset retain count. Increase it by calling `retain()` and decrease it by calling `release()`.
     * This can be used when mutliple objects are using the same assets
     * without knowing in advance when they will be needed.</haxe_doc>
		</refCount>
		<invalidateStatus public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateStatus>
		<status public="1" expr="NONE" line="82">
			<e path="ceramic.AssetStatus"/>
			<meta>
				<m n=":value"><e>NONE</e></m>
				<m n="observe"/>
			</meta>
		</status>
		<unobservedStatus>
			<e path="ceramic.AssetStatus"/>
			<haxe_doc></haxe_doc>
		</unobservedStatus>
		<_dox_event_statusChange public="1" set="method" line="637">
			<f a="current:previous">
				<e path="ceramic.AssetStatus"/>
				<e path="ceramic.AssetStatus"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</_dox_event_statusChange>
		<emitStatusChange set="method" line="1095">
			<f a="current:previous">
				<e path="ceramic.AssetStatus"/>
				<e path="ceramic.AssetStatus"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</emitStatusChange>
		<onStatusChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.AssetStatus"/>
					<e path="ceramic.AssetStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</onStatusChange>
		<onceStatusChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.AssetStatus"/>
					<e path="ceramic.AssetStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</onceStatusChange>
		<offStatusChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<e path="ceramic.AssetStatus"/>
					<e path="ceramic.AssetStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</offStatusChange>
		<listensStatusChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</listensStatusChange>
		<handleTexturesDensityChange set="accessor" expr="false" line="84">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</handleTexturesDensityChange>
		<hotReload set="accessor" expr="false" line="86">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hotReload>
		<customExtensions set="null" expr="null" line="88">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</customExtensions>
		<load public="1" set="method" line="105"><f a=""><x path="Void"/></f></load>
		<destroy public="1" set="method" line="113" override="1"><f a=""><x path="Void"/></f></destroy>
		<computePath public="1" set="method" line="129"><f a="?extensions:?dir:?runtimeAssets">
	<c path="Array"><c path="String"/></c>
	<x path="Bool"/>
	<c path="ceramic.RuntimeAssets"/>
	<x path="Void"/>
</f></computePath>
		<set_path set="method" line="257"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></set_path>
		<set_name set="method" line="276"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></set_name>
		<set_variant set="method" line="289"><f a="variant">
	<c path="String"/>
	<c path="String"/>
</f></set_variant>
		<set_runtimeAssets set="method" line="302"><f a="runtimeAssets">
	<c path="ceramic.RuntimeAssets"/>
	<c path="ceramic.RuntimeAssets"/>
</f></set_runtimeAssets>
		<set_handleTexturesDensityChange set="method" line="313"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_handleTexturesDensityChange>
		<texturesDensityDidChange set="method" line="329"><f a="newDensity:prevDensity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texturesDensityDidChange>
		<set_hotReload set="method" line="335"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_hotReload>
		<assetFilesDidChange set="method" line="351"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<toString set="method" line="359" override="1"><f a=""><c path="String"/></f></toString>
		<willEmitComplete get="inline" set="null" line="373"><f a="success">
	<x path="Bool"/>
	<x path="Void"/>
</f></willEmitComplete>
		<retain public="1" set="method" line="383"><f a=""><x path="Void"/></f></retain>
		<release public="1" set="method" line="393"><f a=""><x path="Void"/></f></release>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="92"><f a="kind:name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.Assets</e></m>
		</meta>
	</class>
	<abstract path="ceramic.AssetId" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetId.hx">
		<from><icast><c path="ceramic.AssetId.T"/></icast></from>
		<this><c path="ceramic.AssetId.T"/></this>
		<to><icast><c path="ceramic.AssetId.T"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="ceramic._AssetId.AssetId_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetId.hx" private="1" module="ceramic.AssetId" final="1">
	<_new public="1" get="inline" set="null" line="6" static="1">
		<f a="value">
			<c path="ceramic.AssetId.T"/>
			<x path="ceramic.AssetId"><c path="ceramic.AssetId.T"/></x>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<meta><m n=":hxGen"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._AssetId.AssetId_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetId.hx" private="1" module="ceramic.AssetId" final="1">
		<_new public="1" get="inline" set="null" line="6" static="1">
			<f a="value">
				<c path="ceramic.AssetId.T"/>
				<x path="ceramic.AssetId"><c path="ceramic.AssetId.T"/></x>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<meta><m n=":hxGen"/></meta>
	</class>
	<typedef path="ceramic.AssetOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetOptions.hx">
		<d/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="ceramic.AssetPathInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetPathInfo.hx">
		<density public="1">
			<x path="Float"/>
			<haxe_doc>* Density value resolved from file name.
     * Example: If file is named `someImage@2x.png`, density will be `2`.
     * Default density is `1`</haxe_doc>
		</density>
		<extension public="1">
			<c path="String"/>
			<haxe_doc>* File extension (always converted to lowercase for convenience)</haxe_doc>
		</extension>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* Normalized asset name (includes subdirectories relative to asset root).
     * Example: both `someImage.png` and `someImage@2x.png` will resolve to a same asset name `someImage`</haxe_doc>
		</name>
		<path public="1">
			<c path="String"/>
			<haxe_doc>* Original path used to generated path info</haxe_doc>
		</path>
		<flags public="1">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<haxe_doc>* Flags are extracted from file path.
     * Example: file `someFile+myTag.txt` will generate `myTag` flag.</haxe_doc>
		</flags>
		<toString set="method" line="86"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="43"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Information extracted from a raw asset path</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<enum path="ceramic.AssetStatus" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetStatus.hx">
		<NONE/>
		<LOADING/>
		<READY/>
		<BROKEN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="ceramic.AssetsLoadMethod" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetsLoadMethod.hx">
		<this><x path="Int"/></this>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._AssetsLoadMethod.AssetsLoadMethod_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetsLoadMethod.hx" private="1" module="ceramic.AssetsLoadMethod" extern="1" final="1">
	<ASYNC public="1" get="inline" set="null" expr="cast 1" line="10" static="1">
		<x path="ceramic.AssetsLoadMethod"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Ensure asset loading is non blocking, at least between each asset.
     * This is useful when we need to update screen during asset loading.
     * Backends may adapt how they load assets from this setting as well</haxe_doc>
	</ASYNC>
	<SYNC public="1" get="inline" set="null" expr="cast 2" line="16" static="1">
		<x path="ceramic.AssetsLoadMethod"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Try to load assets synchronously (if supported on the current backend).
     * This means calling `assets.load()` will trigger `complete` event synchronously if possible.</haxe_doc>
	</SYNC>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._AssetsLoadMethod.AssetsLoadMethod_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetsLoadMethod.hx" private="1" module="ceramic.AssetsLoadMethod" extern="1" final="1">
		<ASYNC public="1" get="inline" set="null" expr="cast 1" line="10" static="1">
			<x path="ceramic.AssetsLoadMethod"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Ensure asset loading is non blocking, at least between each asset.
     * This is useful when we need to update screen during asset loading.
     * Backends may adapt how they load assets from this setting as well</haxe_doc>
		</ASYNC>
		<SYNC public="1" get="inline" set="null" expr="cast 2" line="16" static="1">
			<x path="ceramic.AssetsLoadMethod"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Try to load assets synchronously (if supported on the current backend).
     * This means calling `assets.load()` will trigger `complete` event synchronously if possible.</haxe_doc>
		</SYNC>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="ceramic.AssetsScheduleMethod" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetsScheduleMethod.hx">
		<this><x path="Int"/></this>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._AssetsScheduleMethod.AssetsScheduleMethod_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetsScheduleMethod.hx" private="1" module="ceramic.AssetsScheduleMethod" extern="1" final="1">
	<PARALLEL public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
		<x path="ceramic.AssetsScheduleMethod"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Assets are all loaded in parallel (if not blocked by their thread)</haxe_doc>
	</PARALLEL>
	<SERIAL public="1" get="inline" set="null" expr="cast 2" line="13" static="1">
		<x path="ceramic.AssetsScheduleMethod"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Assets are loaded one after another</haxe_doc>
	</SERIAL>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._AssetsScheduleMethod.AssetsScheduleMethod_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AssetsScheduleMethod.hx" private="1" module="ceramic.AssetsScheduleMethod" extern="1" final="1">
		<PARALLEL public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
			<x path="ceramic.AssetsScheduleMethod"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Assets are all loaded in parallel (if not blocked by their thread)</haxe_doc>
		</PARALLEL>
		<SERIAL public="1" get="inline" set="null" expr="cast 2" line="13" static="1">
			<x path="ceramic.AssetsScheduleMethod"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Assets are loaded one after another</haxe_doc>
		</SERIAL>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="ceramic.AtlasAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AtlasAsset.hx">
		<extends path="ceramic.Asset"/>
		<_dox_event_replaceAtlas public="1" set="method" line="637">
			<f a="newAtlas:prevAtlas">
				<c path="ceramic.TextureAtlas"/>
				<c path="ceramic.TextureAtlas"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_replaceAtlas>
		<emitReplaceAtlas set="method" line="1095">
			<f a="newAtlas:prevAtlas">
				<c path="ceramic.TextureAtlas"/>
				<c path="ceramic.TextureAtlas"/>
				<x path="Void"/>
			</f>
			<haxe_doc>replaceAtlas event</haxe_doc>
		</emitReplaceAtlas>
		<onReplaceAtlas public="1" set="method" line="1199">
			<f a="owner:handleNewAtlasPrevAtlas">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newAtlas:prevAtlas">
					<c path="ceramic.TextureAtlas"/>
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceAtlas event</haxe_doc>
		</onReplaceAtlas>
		<onceReplaceAtlas public="1" set="method" line="1298">
			<f a="owner:handleNewAtlasPrevAtlas">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newAtlas:prevAtlas">
					<c path="ceramic.TextureAtlas"/>
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceAtlas event</haxe_doc>
		</onceReplaceAtlas>
		<offReplaceAtlas public="1" set="method" line="1368">
			<f a="?handleNewAtlasPrevAtlas">
				<f a="newAtlas:prevAtlas">
					<c path="ceramic.TextureAtlas"/>
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceAtlas event</haxe_doc>
		</offReplaceAtlas>
		<listensReplaceAtlas public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to replaceAtlas event</haxe_doc>
		</listensReplaceAtlas>
		<invalidateAtlas public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateAtlas>
		<atlas public="1" expr="null" line="14">
			<c path="ceramic.TextureAtlas"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</atlas>
		<unobservedAtlas>
			<c path="ceramic.TextureAtlas"/>
			<haxe_doc></haxe_doc>
		</unobservedAtlas>
		<_dox_event_atlasChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.TextureAtlas"/>
				<c path="ceramic.TextureAtlas"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when atlas field changes.</haxe_doc>
		</_dox_event_atlasChange>
		<emitAtlasChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.TextureAtlas"/>
				<c path="ceramic.TextureAtlas"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when atlas field changes.</haxe_doc>
		</emitAtlasChange>
		<onAtlasChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.TextureAtlas"/>
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when atlas field changes.</haxe_doc>
		</onAtlasChange>
		<onceAtlasChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.TextureAtlas"/>
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when atlas field changes.</haxe_doc>
		</onceAtlasChange>
		<offAtlasChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.TextureAtlas"/>
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when atlas field changes.</haxe_doc>
		</offAtlasChange>
		<listensAtlasChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when atlas field changes.</haxe_doc>
		</listensAtlasChange>
		<invalidateText public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateText>
		<text public="1" expr="null" line="16">
			<c path="String"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</text>
		<unobservedText>
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</unobservedText>
		<_dox_event_textChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</_dox_event_textChange>
		<emitTextChange set="method" line="1095">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</emitTextChange>
		<onTextChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</onTextChange>
		<onceTextChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</onceTextChange>
		<offTextChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</offTextChange>
		<listensTextChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</listensTextChange>
		<parseAtlas expr="null" line="23">
			<f a="text">
				<c path="String"/>
				<c path="ceramic.TextureAtlas"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* A custom atlas parsing method. Will be used over the default parsing if not null</haxe_doc>
		</parseAtlas>
		<load public="1" set="method" line="36" override="1"><f a=""><x path="Void"/></f></load>
		<texturesDensityDidChange set="method" line="214" override="1"><f a="newDensity:prevDensity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texturesDensityDidChange>
		<checkTexturesDensity set="method" line="225"><f a=""><x path="Void"/></f></checkTexturesDensity>
		<assetFilesDidChange set="method" line="240" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="261" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="27"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Audio" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Audio.hx">
		<extends path="ceramic.Entity"/>
		<mixers>
			<c path="ceramic.IntMap"><c path="ceramic.AudioMixer"/></c>
			<meta><m n=":allow"><e>ceramic.Sound</e></m></meta>
		</mixers>
		<initMixerIfNeeded get="inline" set="null" line="19">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>ceramic.Sound</e></m></meta>
		</initMixerIfNeeded>
		<mixer public="1" set="method" line="27"><f a="index">
	<x path="Int"/>
	<c path="ceramic.AudioMixer"/>
</f></mixer>
		<new set="method" line="9">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>ceramic.App</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.AudioMixer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AudioMixer.hx">
		<extends path="ceramic.Entity"/>
		<volume public="1" expr="0.5" line="5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</volume>
		<pan public="1" expr="0" line="7">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pan>
		<pitch public="1" expr="1" line="9">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</pitch>
		<mute public="1" expr="false" line="11">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</mute>
		<index public="1"><x path="Int"/></index>
		<new set="method" line="16">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>ceramic.Audio</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.AutoCollections" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/AutoCollections.hx" interface="1"><meta>
	<m n=":hxGen"/>
	<m n=":keep"/>
	<m n=":keepSub"/>
	<m n=":autoBuild"><e>ceramic.macros.CollectionsMacro.build()</e></m>
</meta></class>
	<class path="ceramic.BackgroundQueue" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BackgroundQueue.hx">
		<extends path="ceramic.Entity"/>
		<checkInterval public="1" expr="0.1" line="21">
			<x path="Float"/>
			<meta><m n=":value"><e>0.1</e></m></meta>
			<haxe_doc>* Time interval between each checks to see if there is something to run.</haxe_doc>
		</checkInterval>
		<runsInBackground expr="false" line="23">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</runsInBackground>
		<stop expr="false" line="25">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</stop>
		<pending expr="[]" line="27">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pending>
		<mutex><c path="sys.thread.Mutex"/></mutex>
		<schedule public="1" set="method" line="47"><f a="fn">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></schedule>
		<internalRunInBackground set="method" line="67">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</internalRunInBackground>
		<destroy public="1" set="method" line="103" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="33">
			<f a="?checkInterval" v="0.1">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkInterval : 0.1 }</e></m></meta>
		</new>
		<haxe_doc>* An utility to enqueue functions and execute them in bbackground, in a serialized way,
 * meaning it is garanteed that no function in this queue will be run in parallel. An enqueued
 * function will always be started after every previous function has finished executing.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.BezierEasing" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BezierEasing.hx">
		<SPLINE_TABLE_SIZE expr="11" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</SPLINE_TABLE_SIZE>
		<SAMPLE_STEP_SIZE expr="1.0 / (SPLINE_TABLE_SIZE - 1.0)" line="14" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0 / (SPLINE_TABLE_SIZE - 1.0)</e></m></meta>
		</SAMPLE_STEP_SIZE>
		<NEWTON_ITERATIONS expr="4" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</NEWTON_ITERATIONS>
		<NEWTON_MIN_SLOPE expr="0.001" line="16" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.001</e></m></meta>
		</NEWTON_MIN_SLOPE>
		<SUBDIVISION_PRECISION expr="0.0000001" line="17" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0000001</e></m></meta>
		</SUBDIVISION_PRECISION>
		<SUBDIVISION_MAX_ITERATIONS expr="10" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</SUBDIVISION_MAX_ITERATIONS>
		<TWO_THIRD expr="2.0 / 3.0" line="19" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2.0 / 3.0</e></m></meta>
		</TWO_THIRD>
		<CACHE_SIZE expr="10000" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10000</e></m></meta>
		</CACHE_SIZE>
		<quadraticToCubicCP1 get="inline" set="null" line="195" static="1"><f a="p">
	<x path="Float"/>
	<x path="Float"/>
</f></quadraticToCubicCP1>
		<quadraticToCubicCP2 get="inline" set="null" line="201" static="1"><f a="p">
	<x path="Float"/>
	<x path="Float"/>
</f></quadraticToCubicCP2>
		<cachedInstances expr="null" line="209" static="1">
			<c path="ceramic.IntMap"><c path="Array"><c path="ceramic.BezierEasing"/></c></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</cachedInstances>
		<numCachedInstances expr="0" line="211" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numCachedInstances>
		<cacheKey get="inline" set="null" line="232" static="1"><f a="x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></cacheKey>
		<clearCache public="1" set="method" line="239" static="1"><f a=""><x path="Void"/></f></clearCache>
		<get public="1" set="method" line="250" static="1">
			<f a="x1:y1:?x2:?y2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.BezierEasing"/>
			</f>
			<haxe_doc>* Get or create a `BezierEasing` instance with the given parameters.
     * Created instances are cached and reused.</haxe_doc>
		</get>
		<linearEasing expr="false" line="23">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</linearEasing>
		<sampleValues><c path="Array"><x path="Float"/></c></sampleValues>
		<cached expr="false" line="27">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</cached>
		<quadratic expr="false" line="29">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</quadratic>
		<mQuadraticX1><x path="Float"/></mQuadraticX1>
		<mQuadraticX2><x path="Float"/></mQuadraticX2>
		<mX1><x path="Float"/></mX1>
		<mY1><x path="Float"/></mY1>
		<mX2><x path="Float"/></mX2>
		<mY2><x path="Float"/></mY2>
		<configure public="1" set="method" line="61">
			<f a="x1:y1:?x2:?y2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Configure the instance with the given arguments.
     * If only `x1` and `y1` are provided, the curve is treated as quadratic.
     * If all four values `x1`, `y1`, `x2`, `y2` are provided,
     * the curve is treated as cubic.</haxe_doc>
		</configure>
		<ease public="1" set="method" line="102"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<getTForX get="inline" set="null" line="111"><f a="aX">
	<x path="Float"/>
	<x path="Float"/>
</f></getTForX>
		<calcBezier get="inline" set="null" line="141">
			<f a="aT:aA1:aA2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2</haxe_doc>
		</calcBezier>
		<getSlope get="inline" set="null" line="150">
			<f a="aT:aA1:aA2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2</haxe_doc>
		</getSlope>
		<binarySubdivide get="inline" set="null" line="156"><f a="aX:aA:aB:mX1:mX2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></binarySubdivide>
		<newtonRaphsonIterate set="method" line="176"><f a="aX:aGuessT:mX1:mX2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></newtonRaphsonIterate>
		<A get="inline" set="null" line="191"><f a="aA1:aA2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></A>
		<B get="inline" set="null" line="192"><f a="aA1:aA2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></B>
		<C get="inline" set="null" line="193"><f a="aA1">
	<x path="Float"/>
	<x path="Float"/>
</f></C>
		<removeFromCache set="method" line="213"><f a="x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></removeFromCache>
		<new public="1" set="method" line="49">
			<f a="x1:y1:?x2:?y2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new instance with the given arguments.
     * If only `x1` and `y1` are provided, the curve is treated as quadratic.
     * If all four values `x1`, `y1`, `x2`, `y2` are provided,
     * the curve is treated as cubic.</haxe_doc>
		</new>
		<haxe_doc>* Bezier curve easing, ported from https://github.com/gre/bezier-easing
 * then extended to work with both cubic and quadratic settings</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.BinaryAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BinaryAsset.hx">
		<extends path="ceramic.Asset"/>
		<invalidateBytes public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateBytes>
		<bytes public="1" expr="null" line="8">
			<c path="haxe.io.Bytes"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</bytes>
		<unobservedBytes>
			<c path="haxe.io.Bytes"/>
			<haxe_doc></haxe_doc>
		</unobservedBytes>
		<_dox_event_bytesChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when bytes field changes.</haxe_doc>
		</_dox_event_bytesChange>
		<emitBytesChange set="method" line="1095">
			<f a="current:previous">
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when bytes field changes.</haxe_doc>
		</emitBytesChange>
		<onBytesChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="haxe.io.Bytes"/>
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when bytes field changes.</haxe_doc>
		</onBytesChange>
		<onceBytesChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="haxe.io.Bytes"/>
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when bytes field changes.</haxe_doc>
		</onceBytesChange>
		<offBytesChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="haxe.io.Bytes"/>
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when bytes field changes.</haxe_doc>
		</offBytesChange>
		<listensBytesChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when bytes field changes.</haxe_doc>
		</listensBytesChange>
		<load public="1" set="method" line="16" override="1"><f a=""><x path="Void"/></f></load>
		<assetFilesDidChange set="method" line="65" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="86" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="10"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.BitmapFont" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BitmapFont.hx">
		<extends path="ceramic.Entity"/>
		<pages public="1" expr="new IntMap(16, 0.5, true)" line="14">
			<c path="ceramic.IntMap"><c path="ceramic.Texture"/></c>
			<meta><m n=":value"><e>new IntMap(16, 0.5, true)</e></m></meta>
			<haxe_doc>* The map of font texture pages to their id.</haxe_doc>
		</pages>
		<fontData set="accessor">
			<c path="ceramic.BitmapFontData"/>
			<haxe_doc>* The bitmap font fontData.</haxe_doc>
		</fontData>
		<set_fontData set="method" line="20"><f a="fontData">
	<c path="ceramic.BitmapFontData"/>
	<c path="ceramic.BitmapFontData"/>
</f></set_fontData>
		<face public="1" get="accessor" set="accessor"><c path="String"/></face>
		<get_face get="inline" set="null" line="39"><f a=""><c path="String"/></f></get_face>
		<set_face get="inline" set="null" line="40"><f a="face">
	<c path="String"/>
	<c path="String"/>
</f></set_face>
		<pointSize public="1" get="accessor" set="accessor"><x path="Float"/></pointSize>
		<get_pointSize get="inline" set="null" line="43"><f a=""><x path="Float"/></f></get_pointSize>
		<set_pointSize get="inline" set="null" line="44"><f a="pointSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pointSize>
		<baseSize public="1" get="accessor" set="accessor"><x path="Float"/></baseSize>
		<get_baseSize get="inline" set="null" line="47"><f a=""><x path="Float"/></f></get_baseSize>
		<set_baseSize get="inline" set="null" line="48"><f a="baseSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_baseSize>
		<chars public="1" get="accessor" set="accessor"><c path="ceramic.IntMap"><c path="ceramic.BitmapFontCharacter"/></c></chars>
		<get_chars get="inline" set="null" line="51"><f a=""><c path="ceramic.IntMap"><c path="ceramic.BitmapFontCharacter"/></c></f></get_chars>
		<set_chars get="inline" set="null" line="52"><f a="chars">
	<c path="ceramic.IntMap"><c path="ceramic.BitmapFontCharacter"/></c>
	<c path="ceramic.IntMap"><c path="ceramic.BitmapFontCharacter"/></c>
</f></set_chars>
		<charCount public="1" get="accessor" set="accessor"><x path="Int"/></charCount>
		<get_charCount get="inline" set="null" line="55"><f a=""><x path="Int"/></f></get_charCount>
		<set_charCount get="inline" set="null" line="56"><f a="charCount">
	<x path="Int"/>
	<x path="Int"/>
</f></set_charCount>
		<lineHeight public="1" get="accessor" set="accessor"><x path="Float"/></lineHeight>
		<get_lineHeight get="inline" set="null" line="59"><f a=""><x path="Float"/></f></get_lineHeight>
		<set_lineHeight get="inline" set="null" line="60"><f a="lineHeight">
	<x path="Float"/>
	<x path="Float"/>
</f></set_lineHeight>
		<kernings public="1" get="accessor" set="accessor"><c path="ceramic.IntMap"><c path="ceramic.IntFloatMap"/></c></kernings>
		<get_kernings get="inline" set="null" line="63"><f a=""><c path="ceramic.IntMap"><c path="ceramic.IntFloatMap"/></c></f></get_kernings>
		<set_kernings get="inline" set="null" line="64"><f a="kernings">
	<c path="ceramic.IntMap"><c path="ceramic.IntFloatMap"/></c>
	<c path="ceramic.IntMap"><c path="ceramic.IntFloatMap"/></c>
</f></set_kernings>
		<msdf public="1" get="accessor" set="null"><x path="Bool"/></msdf>
		<get_msdf get="inline" set="null" line="67"><f a=""><x path="Bool"/></f></get_msdf>
		<spaceChar public="1">
			<c path="ceramic.BitmapFontCharacter"/>
			<haxe_doc>* Cached reference of the ' '(32) character, for sizing on tabs/spaces</haxe_doc>
		</spaceChar>
		<pageShaders public="1" expr="null" line="79">
			<t path="Map">
				<x path="Int"/>
				<c path="ceramic.Shader"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Shaders used to render the characters. If null, uses default shader.
     * When loading MSDF fonts, ceramic's MSDF shader will be assigned here.
     * Stored per page</haxe_doc>
		</pageShaders>
		<preRenderedPages public="1" expr="null" line="86">
			<t path="Map">
				<x path="Int"/>
				<t path="Map">
					<x path="Int"/>
					<c path="ceramic.Texture"/>
				</t>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* When using MSDF fonts, or fonts with custom shaders, it is possible to pre-render characters
     * onto a RenderTexture to use it like a regular texture later with default shader.
     * Useful in some situations to reduce draw calls.</haxe_doc>
		</preRenderedPages>
		<_preRenderingPages expr="null" line="92">
			<t path="Map">
				<x path="Int"/>
				<t path="Map">
					<x path="Int"/>
					<c path="Array"><f a=""><x path="Void"/></f></c>
				</t>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* When a page is being pre-rendered, it will be referenced here, until the rendering is finished.
     * This is needed to prevent parallel renders of the same requested texture, giving us unexpected duplicate textures</haxe_doc>
		</_preRenderingPages>
		<asset public="1"><c path="ceramic.Asset"/></asset>
		<destroy public="1" set="method" line="138" override="1"><f a=""><x path="Void"/></f></destroy>
		<needsToPreRenderAtSize public="1" set="method" line="174"><f a="pixelSize">
	<x path="Int"/>
	<x path="Bool"/>
</f></needsToPreRenderAtSize>
		<preRenderAtSize public="1" set="method" line="189"><f a="pixelSize:done">
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></preRenderAtSize>
		<preRenderPage set="method" line="207"><f a="id:pixelsSize:done">
	<x path="Int"/>
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></preRenderPage>
		<kerning public="1" get="inline" set="null" line="302">
			<f a="first:second">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the kerning between two glyphs, or 0 if none.
     * A glyph int id is the value from 'c'.charCodeAt(0)</haxe_doc>
		</kerning>
		<new public="1" set="method" line="98"><f a="fontData:pages">
	<c path="ceramic.BitmapFontData"/>
	<t path="Map">
		<c path="String"/>
		<c path="ceramic.Texture"/>
	</t>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.BitmapFontCharacter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BitmapFontCharacter.hx">
		<id public="1"><x path="Int"/></id>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<xOffset public="1"><x path="Float"/></xOffset>
		<yOffset public="1"><x path="Float"/></yOffset>
		<xAdvance public="1"><x path="Float"/></xAdvance>
		<page public="1"><x path="Int"/></page>
		<new public="1" set="method" line="4">
			<f a="id:x:y:width:height:xOffset:yOffset:xAdvance:page">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.BitmapFontData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BitmapFontData.hx">
		<face public="1"><c path="String"/></face>
		<path public="1"><c path="String"/></path>
		<pointSize public="1"><x path="Float"/></pointSize>
		<baseSize public="1"><x path="Float"/></baseSize>
		<chars public="1"><c path="ceramic.IntMap"><c path="ceramic.BitmapFontCharacter"/></c></chars>
		<charCount public="1"><x path="Int"/></charCount>
		<distanceField public="1"><x path="Null"><c path="ceramic.BitmapFontDistanceFieldData"/></x></distanceField>
		<pages public="1"><c path="Array"><c path="ceramic.BitmapFontDataPage"/></c></pages>
		<lineHeight public="1"><x path="Float"/></lineHeight>
		<kernings public="1"><c path="ceramic.IntMap"><c path="ceramic.IntFloatMap"/></c></kernings>
		<new public="1" set="method" line="4">
			<f a="face:path:pointSize:baseSize:chars:charCount:distanceField:pages:lineHeight:kernings">
				<c path="String"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="ceramic.IntMap"><c path="ceramic.BitmapFontCharacter"/></c>
				<x path="Int"/>
				<x path="Null"><c path="ceramic.BitmapFontDistanceFieldData"/></x>
				<c path="Array"><c path="ceramic.BitmapFontDataPage"/></c>
				<x path="Float"/>
				<c path="ceramic.IntMap"><c path="ceramic.IntFloatMap"/></c>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.BitmapFontDataPage" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BitmapFontData.hx" module="ceramic.BitmapFontData">
		<id public="1"><x path="Int"/></id>
		<file public="1"><c path="String"/></file>
		<new public="1" set="method" line="18">
			<f a="id:file">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.BitmapFontDistanceFieldData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BitmapFontDistanceFieldData.hx">
		<fieldType public="1"><c path="String"/></fieldType>
		<distanceRange public="1"><x path="Int"/></distanceRange>
		<new public="1" set="method" line="4">
			<f a="fieldType:distanceRange">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.BitmapFontParser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BitmapFontParser.hx">
		<parse public="1" set="method" line="11" static="1"><f a="rawFontData">
	<c path="String"/>
	<c path="ceramic.BitmapFontData"/>
</f></parse>
		<convertXmlFontData set="method" line="62" static="1"><f a="rawFontData">
	<c path="String"/>
	<c path="String"/>
</f></convertXmlFontData>
		<parseLine set="method" line="111" static="1"><f a="line:info">
	<c path="String"/>
	<c path="ceramic.BitmapFontData"/>
	<x path="Void"/>
</f></parseLine>
		<extractLineTokens set="method" line="190" static="1"><f a="line:map">
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
	<c path="String"/>
</f></extractLineTokens>
		<unquote get="inline" set="null" line="272" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></unquote>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="ceramic.Blending" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Blending.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._Blending.Blending_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Blending.hx" private="1" module="ceramic.Blending" extern="1" final="1">
	<AUTO public="1" get="inline" set="null" expr="cast 0" line="10" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Automatic/default blending in ceramic. Internally, this translates to premultiplied alpha blending as textures
     * are already transformed for this blending at asset copy phase, except in some situations (render to texture) where
     * ceramic may use some more specific blendings as needed.</haxe_doc>
	</AUTO>
	<PREMULTIPLIED_ALPHA public="1" get="inline" set="null" expr="cast 1" line="15" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Explicit premultiplied alpha blending</haxe_doc>
	</PREMULTIPLIED_ALPHA>
	<ADD public="1" get="inline" set="null" expr="cast 2" line="20" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Additive blending</haxe_doc>
	</ADD>
	<SET public="1" get="inline" set="null" expr="cast 4" line="25" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Set blending</haxe_doc>
	</SET>
	<RENDER_TO_TEXTURE public="1" get="inline" set="null" expr="cast 5" line="30" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Blending used by ceramic when rendering to texture.</haxe_doc>
	</RENDER_TO_TEXTURE>
	<RENDER_TO_TEXTURE_ALPHA public="1" get="inline" set="null" expr="cast 6" line="35" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Blending used by ceramic when rendering to texture.</haxe_doc>
	</RENDER_TO_TEXTURE_ALPHA>
	<ALPHA public="1" get="inline" set="null" expr="cast 3" line="41" static="1">
		<x path="ceramic.Blending"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Traditional alpha blending. This should only be used on very specific cases. Used instead of `NORMAL` blending
     * when the visual is drawing a RenderTexture.</haxe_doc>
	</ALPHA>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._Blending.Blending_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Blending.hx" private="1" module="ceramic.Blending" extern="1" final="1">
		<AUTO public="1" get="inline" set="null" expr="cast 0" line="10" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Automatic/default blending in ceramic. Internally, this translates to premultiplied alpha blending as textures
     * are already transformed for this blending at asset copy phase, except in some situations (render to texture) where
     * ceramic may use some more specific blendings as needed.</haxe_doc>
		</AUTO>
		<PREMULTIPLIED_ALPHA public="1" get="inline" set="null" expr="cast 1" line="15" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Explicit premultiplied alpha blending</haxe_doc>
		</PREMULTIPLIED_ALPHA>
		<ADD public="1" get="inline" set="null" expr="cast 2" line="20" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Additive blending</haxe_doc>
		</ADD>
		<SET public="1" get="inline" set="null" expr="cast 4" line="25" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Set blending</haxe_doc>
		</SET>
		<RENDER_TO_TEXTURE public="1" get="inline" set="null" expr="cast 5" line="30" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Blending used by ceramic when rendering to texture.</haxe_doc>
		</RENDER_TO_TEXTURE>
		<RENDER_TO_TEXTURE_ALPHA public="1" get="inline" set="null" expr="cast 6" line="35" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Blending used by ceramic when rendering to texture.</haxe_doc>
		</RENDER_TO_TEXTURE_ALPHA>
		<ALPHA public="1" get="inline" set="null" expr="cast 3" line="41" static="1">
			<x path="ceramic.Blending"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Traditional alpha blending. This should only be used on very specific cases. Used instead of `NORMAL` blending
     * when the visual is drawing a RenderTexture.</haxe_doc>
		</ALPHA>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="ceramic.Border" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Border.hx">
		<extends path="ceramic.Mesh"/>
		<autoComputeVertices public="1" set="accessor" expr="true" line="10">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</autoComputeVertices>
		<set_autoComputeVertices get="inline" set="null" line="11"><f a="autoComputeVertices">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoComputeVertices>
		<autoComputeColors public="1" set="accessor" expr="true" line="20">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</autoComputeColors>
		<set_autoComputeColors get="inline" set="null" line="21"><f a="autoComputeColors">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoComputeColors>
		<set_width set="method" line="30" override="1"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="36" override="1"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<borderPosition public="1" set="accessor" expr="INSIDE" line="42">
			<e path="ceramic.BorderPosition"/>
			<meta><m n=":value"><e>INSIDE</e></m></meta>
		</borderPosition>
		<set_borderPosition get="inline" set="null" line="43"><f a="borderPosition">
	<e path="ceramic.BorderPosition"/>
	<e path="ceramic.BorderPosition"/>
</f></set_borderPosition>
		<borderSize public="1" set="accessor" expr="1" line="50">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</borderSize>
		<set_borderSize get="inline" set="null" line="51"><f a="borderSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderSize>
		<borderTopSize public="1" set="accessor" expr="-1" line="58">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</borderTopSize>
		<set_borderTopSize get="inline" set="null" line="59"><f a="borderTopSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderTopSize>
		<borderBottomSize public="1" set="accessor" expr="-1" line="66">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</borderBottomSize>
		<set_borderBottomSize get="inline" set="null" line="67"><f a="borderBottomSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderBottomSize>
		<borderLeftSize public="1" set="accessor" expr="-1" line="74">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</borderLeftSize>
		<set_borderLeftSize get="inline" set="null" line="75"><f a="borderLeftSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderLeftSize>
		<borderRightSize public="1" set="accessor" expr="-1" line="82">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</borderRightSize>
		<set_borderRightSize get="inline" set="null" line="83"><f a="borderRightSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderRightSize>
		<borderColor public="1" set="accessor" expr="Color.GRAY" line="90">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.GRAY</e></m></meta>
		</borderColor>
		<set_borderColor get="inline" set="null" line="91"><f a="borderColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_borderColor>
		<borderTopColor public="1" set="accessor" expr="Color.NONE" line="98">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</borderTopColor>
		<set_borderTopColor get="inline" set="null" line="99"><f a="borderTopColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_borderTopColor>
		<borderBottomColor public="1" set="accessor" expr="Color.NONE" line="106">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</borderBottomColor>
		<set_borderBottomColor get="inline" set="null" line="107"><f a="borderBottomColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_borderBottomColor>
		<borderLeftColor public="1" set="accessor" expr="Color.NONE" line="114">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</borderLeftColor>
		<set_borderLeftColor get="inline" set="null" line="115"><f a="borderLeftColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_borderLeftColor>
		<borderRightColor public="1" set="accessor" expr="Color.NONE" line="122">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</borderRightColor>
		<set_borderRightColor get="inline" set="null" line="123"><f a="borderRightColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_borderRightColor>
		<computeColors set="method" line="181"><f a=""><x path="Void"/></f></computeColors>
		<computeVertices set="method" line="218"><f a=""><x path="Void"/></f></computeVertices>
		<new public="1" set="method" line="130"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A rectangle visual that display a border</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<enum path="ceramic.BorderPosition" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/BorderPosition.hx">
		<INSIDE/>
		<OUTSIDE/>
		<MIDDLE/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.Camera" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Camera.hx">
		<extends path="ceramic.Entity"/>
		<angleTo get="inline" set="null" line="294" static="1"><f a="x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></angleTo>
		<x public="1" expr="0" line="11">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Camera x position</haxe_doc>
		</x>
		<y public="1" expr="0" line="16">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Camera y position</haxe_doc>
		</y>
		<pos public="1" get="inline" set="null" line="23">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set camera x & y position
     * @param x
     * @param y]]></haxe_doc>
		</pos>
		<followTarget public="1" expr="false" line="31">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* `true` if the camera should follow its target</haxe_doc>
		</followTarget>
		<clampToContentBounds public="1" expr="true" line="36">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If `true`, camera will try to stay inside content bounds. If not possible, it will be centered.</haxe_doc>
		</clampToContentBounds>
		<brakeNearBoundsX public="1" expr="0.02" line="41">
			<x path="Float"/>
			<meta><m n=":value"><e>0.02</e></m></meta>
			<haxe_doc>* Percentage of viewport width where camera will "brake" to stay inside content bounds</haxe_doc>
		</brakeNearBoundsX>
		<brakeNearBoundsY public="1" expr="0.03" line="46">
			<x path="Float"/>
			<meta><m n=":value"><e>0.03</e></m></meta>
			<haxe_doc>* Percentage of viewport height where camera will "brake" to stay inside content bounds</haxe_doc>
		</brakeNearBoundsY>
		<brakeNearBounds public="1" get="inline" set="null" line="53">
			<f a="brakeNearBoundsX:brakeNearBoundsY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set `brakeNearBoundsX`& `brakeNearBoundsY`
     * @param brakeNearBoundsX
     * @param brakeNearBoundsY]]></haxe_doc>
		</brakeNearBounds>
		<targetX public="1" expr="0" line="61">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Target x position</haxe_doc>
		</targetX>
		<targetY public="1" expr="0" line="66">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Target y position</haxe_doc>
		</targetY>
		<target public="1" get="inline" set="null" line="73">
			<f a="targetX:targetY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set `targetX` & `targetY`, which define the position the camera may follow if `followTarget` is `true`
     * @param targetX
     * @param targetY]]></haxe_doc>
		</target>
		<trackSpeedX public="1" expr="20.0" line="81">
			<x path="Float"/>
			<meta><m n=":value"><e>20.0</e></m></meta>
			<haxe_doc>* Tracking x speed factor</haxe_doc>
		</trackSpeedX>
		<trackSpeedY public="1" expr="15.0" line="86">
			<x path="Float"/>
			<meta><m n=":value"><e>15.0</e></m></meta>
			<haxe_doc>* Tracking y speed factor</haxe_doc>
		</trackSpeedY>
		<trackCurve public="1" expr="0.8" line="91">
			<x path="Float"/>
			<meta><m n=":value"><e>0.8</e></m></meta>
			<haxe_doc>* Affects tracking curve. Should be above 0 and below or equal to 1.</haxe_doc>
		</trackCurve>
		<zoom public="1" expr="1.0" line="96">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Zoom scaling factor</haxe_doc>
		</zoom>
		<deadZoneX public="1" expr="0.04" line="101">
			<x path="Float"/>
			<meta><m n=":value"><e>0.04</e></m></meta>
			<haxe_doc>* Horizontal dead zone (percentage between 0 and 1 relative to viewport width)</haxe_doc>
		</deadZoneX>
		<deadZoneY public="1" expr="0.1" line="106">
			<x path="Float"/>
			<meta><m n=":value"><e>0.1</e></m></meta>
			<haxe_doc>* Horizontal dead zone (percentage between 0 and 1 relative to viewport height)</haxe_doc>
		</deadZoneY>
		<frictionX public="1" expr="1.0" line="112">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Horizontal friction.
     * More the value is below 1.0, higher is the friction.</haxe_doc>
		</frictionX>
		<frictionY public="1" expr="1.0" line="118">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Vertical friction.
     * More the value is below 1.0, higher is the friction.</haxe_doc>
		</frictionY>
		<contentX public="1" expr="0" line="123">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Content x (top left corner) position</haxe_doc>
		</contentX>
		<contentY public="1" expr="0" line="128">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Content y (top left corner) position</haxe_doc>
		</contentY>
		<contentWidth public="1" expr="0" line="133">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Content width</haxe_doc>
		</contentWidth>
		<contentHeight public="1" expr="0" line="138">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Content height</haxe_doc>
		</contentHeight>
		<viewportWidth public="1" expr="0" line="143">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Viewport width: the actual visible with on this camera</haxe_doc>
		</viewportWidth>
		<viewportHeight public="1" expr="0" line="148">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Viewport height: the actual visible height on this camera</haxe_doc>
		</viewportHeight>
		<movementThreshold public="1" expr="0.00001" line="153">
			<x path="Float"/>
			<meta><m n=":value"><e>0.00001</e></m></meta>
			<haxe_doc>* A threshold value to stop the camera if its movement is lower than this value</haxe_doc>
		</movementThreshold>
		<contentTranslateX public="1" expr="0.0" line="160">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
			<haxe_doc>* Translation X that should be applied to the
     * content so that the camera is pointing to the correct area.
     * This value is computed by the camera when it is updated.</haxe_doc>
		</contentTranslateX>
		<contentTranslateY public="1" expr="0.0" line="167">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
			<haxe_doc>* Translation Y that should be applied to the
     * content so that the camera is pointing to the correct area
     * This value is computed by the camera when it is updated.</haxe_doc>
		</contentTranslateY>
		<hasPrevTransform expr="false" line="169">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasPrevTransform>
		<dx expr="0" line="171">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dx>
		<dy expr="0" line="173">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dy>
		<averageFrameTime final="1" expr="1.0 / 60" line="175">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0 / 60</e></m></meta>
		</averageFrameTime>
		<update public="1" set="method" line="183"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="177"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Component" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Component.hx" interface="1">
		<initializerName public="1" set="null">
			<c path="String"/>
			<haxe_doc>* If this component was created from an initializer,
     * its initializer name is provided to retrieve the
     * initializer from the component.
     * This field is automatically added to implementing class by ComponentMacro</haxe_doc>
		</initializerName>
		<setEntity set="method">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called by target entity to assign itself to the component
     * @param entity</haxe_doc>
		</setEntity>
		<getEntity set="method">
			<f a=""><c path="ceramic.Entity"/></f>
			<haxe_doc>* Called to retrieve entity in a generic way that works with all components</haxe_doc>
		</getEntity>
		<bindAsComponent set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the component is bound to an entity. At this stage, the `entity` property
     * should be assigned and work properly. Use this method to run initialization code once
     * the component has been plugged to a target entity.
     * When the target entity is destroyed, our instance (the component) will be unbound and destroyed as well.</haxe_doc>
		</bindAsComponent>
		<haxe_doc>* A Component is and Entity that can be bound to another Entity.
 * Any Entity can be used as a Component, given that it implement Component interface.
 * A Component must be an Entity subclass.</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<class path="ceramic.Click" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Click.hx">
		<extends path="ceramic.Entity"/>
		<implements path="tracker.Observable"/>
		<implements path="ceramic.Component"/>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Click"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Click"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Click"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Click"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.Click"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false" line="131">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<_dox_event_click public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_click>
		<emitClick set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>click event</haxe_doc>
		</emitClick>
		<onClick public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>click event</haxe_doc>
		</onClick>
		<onceClick public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>click event</haxe_doc>
		</onceClick>
		<offClick public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>click event</haxe_doc>
		</offClick>
		<listensClick public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to click event</haxe_doc>
		</listensClick>
		<threshold public="1" expr="-1" line="14">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</threshold>
		<entity public="1">
			<c path="ceramic.Visual"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<invalidatePressed public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidatePressed>
		<pressed public="1" set="null" expr="false" line="18">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="observe"/>
			</meta>
		</pressed>
		<unobservedPressed>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedPressed>
		<_dox_event_pressedChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when pressed field changes.</haxe_doc>
		</_dox_event_pressedChange>
		<emitPressedChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when pressed field changes.</haxe_doc>
		</emitPressedChange>
		<onPressedChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pressed field changes.</haxe_doc>
		</onPressedChange>
		<oncePressedChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pressed field changes.</haxe_doc>
		</oncePressedChange>
		<offPressedChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pressed field changes.</haxe_doc>
		</offPressedChange>
		<listensPressedChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pressed field changes.</haxe_doc>
		</listensPressedChange>
		<pointerStartX expr="0.0" line="22">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</pointerStartX>
		<pointerStartY expr="0.0" line="23">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</pointerStartY>
		<bindAsComponent set="method" line="27"><f a=""><x path="Void"/></f></bindAsComponent>
		<cancel public="1" set="method" line="39"><f a=""><x path="Void"/></f></cancel>
		<handlePointerDown set="method" line="47"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerDown>
		<handlePointerUp set="method" line="58"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerUp>
		<handlePointerMove set="method" line="69"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerMove>
		<handleBlur set="method" line="78"><f a=""><x path="Void"/></f></handleBlur>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<setEntity set="method" line="6">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="6">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Closure" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Closure.hx">
		<method public="1"><x path="Any"/></method>
		<args public="1"><c path="Array"><x path="Any"/></c></args>
		<call public="1" set="method" line="16"><f a=""><d/></f></call>
		<new public="1" set="method" line="9"><f a="method:?args">
	<x path="Any"/>
	<c path="Array"><x path="Any"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":hxGen"/></meta>
	</class>
	<abstract path="ceramic.Collection" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Collection.hx">
		<this><c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c></this>
		<meta>
			<m n=":hxGen"/>
			<m n=":forward"/>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
		<impl><class path="ceramic._Collection.Collection_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Collection.hx" private="1" module="ceramic.Collection" final="1">
	<_new public="1" get="inline" set="null" line="12" static="1">
		<f a=""><x path="ceramic.Collection"><c path="ceramic.Collection.T"/></x></f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<arrayAccess public="1" get="inline" set="null" line="18" static="1">
		<f a="this:index">
			<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
			<x path="Int"/>
			<c path="ceramic.Collection.T"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</arrayAccess>
	<randomElement public="1" set="method" line="27" static="1">
		<f a="this">
			<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
			<c path="ceramic.Collection.T"/>
		</f>
		<haxe_doc>* Return a random element contained in the collection</haxe_doc>
	</randomElement>
	<randomElementExcept public="1" set="method" line="42" static="1">
		<f a="this:except:?unsafe" v="::false">
			<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
			<c path="ceramic.Collection.T"/>
			<x path="Bool"/>
			<c path="ceramic.Collection.T"/>
		</f>
		<meta><m n=":value"><e>{ unsafe : false }</e></m></meta>
		<haxe_doc>* Return a random element contained in the given array that is not equal to the `except` arg.
     * @param except The element we don't want
     * @param unsafe If set to `true`, will prevent allocating a new array (and may be faster) but will loop forever if there is no element except the one we don't want
     * @return The random element or `null` if nothing was found</haxe_doc>
	</randomElementExcept>
	<randomElementMatchingValidator public="1" set="method" line="58" static="1">
		<f a="this:validator">
			<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
			<f a="">
				<c path="ceramic.Collection.T"/>
				<x path="Bool"/>
			</f>
			<c path="ceramic.Collection.T"/>
		</f>
		<haxe_doc>* Return a random element contained in the given array that is validated by the provided validator.
     * If no item is valid, returns null.
     * @param array  The array in which we extract the element from
     * @param validator A function that returns true if the item is valid, false if not
     * @return The random element or `null` if nothing was found</haxe_doc>
	</randomElementMatchingValidator>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._Collection.Collection_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Collection.hx" private="1" module="ceramic.Collection" final="1">
		<_new public="1" get="inline" set="null" line="12" static="1">
			<f a=""><x path="ceramic.Collection"><c path="ceramic.Collection.T"/></x></f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<arrayAccess public="1" get="inline" set="null" line="18" static="1">
			<f a="this:index">
				<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
				<x path="Int"/>
				<c path="ceramic.Collection.T"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</arrayAccess>
		<randomElement public="1" set="method" line="27" static="1">
			<f a="this">
				<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
				<c path="ceramic.Collection.T"/>
			</f>
			<haxe_doc>* Return a random element contained in the collection</haxe_doc>
		</randomElement>
		<randomElementExcept public="1" set="method" line="42" static="1">
			<f a="this:except:?unsafe" v="::false">
				<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
				<c path="ceramic.Collection.T"/>
				<x path="Bool"/>
				<c path="ceramic.Collection.T"/>
			</f>
			<meta><m n=":value"><e>{ unsafe : false }</e></m></meta>
			<haxe_doc>* Return a random element contained in the given array that is not equal to the `except` arg.
     * @param except The element we don't want
     * @param unsafe If set to `true`, will prevent allocating a new array (and may be faster) but will loop forever if there is no element except the one we don't want
     * @return The random element or `null` if nothing was found</haxe_doc>
		</randomElementExcept>
		<randomElementMatchingValidator public="1" set="method" line="58" static="1">
			<f a="this:validator">
				<c path="ceramic.CollectionImpl"><c path="ceramic.Collection.T"/></c>
				<f a="">
					<c path="ceramic.Collection.T"/>
					<x path="Bool"/>
				</f>
				<c path="ceramic.Collection.T"/>
			</f>
			<haxe_doc>* Return a random element contained in the given array that is validated by the provided validator.
     * If no item is valid, returns null.
     * @param array  The array in which we extract the element from
     * @param validator A function that returns true if the item is valid, false if not
     * @return The random element or `null` if nothing was found</haxe_doc>
		</randomElementMatchingValidator>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.CollectionImpl" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Collection.hx" module="ceramic.Collection">
		<implements path="tracker.Events"/>
		<_lastCheckedCombined expr="null" line="73" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_lastCheckedCombined>
		<_nextInternalId expr="0" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_nextInternalId>
		<internalId expr="_nextInternalId++" line="77">
			<x path="Int"/>
			<meta><m n=":value"><e>_nextInternalId++</e></m></meta>
		</internalId>
		<lastChange expr="0" line="79">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastChange>
		<entries public="1" set="null" expr="[]" line="81">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.CollectionImpl.T"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
		</entries>
		<indexDirty expr="true" line="83">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</indexDirty>
		<entriesDirty expr="false" line="85">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</entriesDirty>
		<byId expr="null" line="87">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.CollectionImpl.T"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</byId>
		<filter expr="null" line="89">
			<f a="">
				<c path="Array"><c path="ceramic.CollectionImpl.T"/></c>
				<c path="Array"><c path="ceramic.CollectionImpl.T"/></c>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</filter>
		<combinedCollections expr="null" line="91">
			<c path="Array"><c path="ceramic.CollectionImpl"><c path="ceramic.CollectionImpl.T"/></c></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</combinedCollections>
		<combinedCollectionLastChanges expr="null" line="92">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</combinedCollectionLastChanges>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<get_length set="method" line="95"><f a=""><x path="Int"/></f></get_length>
		<pushAll public="1" set="method" line="103"><f a="entries">
	<c path="Array"><c path="ceramic.CollectionImpl.T"/></c>
	<x path="Void"/>
</f></pushAll>
		<clear public="1" set="method" line="117"><f a=""><x path="Void"/></f></clear>
		<push public="1" set="method" line="132"><f a="entry">
	<c path="ceramic.CollectionImpl.T"/>
	<x path="Void"/>
</f></push>
		<remove public="1" set="method" line="143"><f a="entry">
	<c path="ceramic.CollectionImpl.T"/>
	<x path="Void"/>
</f></remove>
		<synchronize public="1" set="method" line="154"><f a=""><x path="Void"/></f></synchronize>
		<get public="1" set="method" line="161"><f a="id">
	<c path="String"/>
	<c path="ceramic.CollectionImpl.T"/>
</f></get>
		<getByIndex public="1" set="method" line="183"><f a="index">
	<x path="Int"/>
	<c path="ceramic.CollectionImpl.T"/>
</f></getByIndex>
		<indexOfId public="1" set="method" line="193"><f a="id">
	<c path="String"/>
	<x path="Int"/>
</f></indexOfId>
		<indexOf public="1" set="method" line="203"><f a="entry">
	<c path="ceramic.CollectionImpl.T"/>
	<x path="Int"/>
</f></indexOf>
		<iterator public="1" get="inline" set="null" line="213"><f a=""><t path="Iterator"><c path="ceramic.CollectionImpl.T"/></t></f></iterator>
		<checkCombined get="inline" set="null" line="225"><f a=""><x path="Void"/></f></checkCombined>
		<computeIndex set="method" line="244"><f a=""><x path="Void"/></f></computeIndex>
		<computeEntries set="method" line="260"><f a=""><x path="Void"/></f></computeEntries>
		<new public="1" set="method" line="101"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.Collection</e></m>
			<m n=":allow"><e>ceramic.CollectionUtils</e></m>
		</meta>
	</class>
	<class path="ceramic.CollectionEntry" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/CollectionEntry.hx">
		<_nextId expr="1" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</_nextId>
		<_nextIndex expr="1" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</_nextIndex>
		<id public="1">
			<c path="String"/>
			<meta><m n="editable"/></meta>
		</id>
		<name public="1">
			<c path="String"/>
			<meta><m n="editable"/></meta>
		</name>
		<index public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* A unique index for this collection entry instance.
     * Warning:
     *     this index is in no way predictable and may vary
     *     for each entry between each run of the app!
     *     This is intended to be used as a fast integer-typed runtime identifier,
     *     but do not use this to identify entries when persisting data to disk etc...</haxe_doc>
		</index>
		<setRawData public="1" set="method" line="55">
			<f a="data">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set entry fields from given raw data.
     * Takes care of converting types when needed, and possible.
     * It's ok if raw field are strings, like when stored in CSV files.
     * Raw types can be converted to: `Bool`, `Int`, `Float`, `Color` (`Int`), `String` and `enum` types</haxe_doc>
		</setRawData>
		<setRawField public="1" set="method" line="141">
			<f a="name:rawValue">
				<c path="String"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Override this method to perform custom deserialisation on a specific field. If the overrided method
     * returns `true`, default behavior will be skipped for the related field.</haxe_doc>
		</setRawField>
		<new public="1" set="method" line="41">
			<f a="?id:?name">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor</haxe_doc>
		</new>
		<meta>
			<m n=":hxGen"/>
			<m n=":structInit"/>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<class path="ceramic.CollectionUtils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/CollectionUtils.hx">
		<combinedCollections expr="new Map()" line="13" static="1">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</combinedCollections>
		<filteredCollections expr="new Map()" line="15" static="1">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</filteredCollections>
		<toCollection public="1" params="T" set="method" line="22" static="1">
			<f a="array">
				<c path="Array"><c path="toCollection.T"/></c>
				<x path="ceramic.Collection"><c path="ceramic.ValueEntry"><c path="toCollection.T"/></c></x>
			</f>
			<haxe_doc>* Converts an array to an equivalent collection</haxe_doc>
		</toCollection>
		<filtered public="1" params="T" set="method" line="36" static="1">
			<f a="collection:filter:?cacheKey">
				<x path="ceramic.Collection"><c path="filtered.T"/></x>
				<f a="">
					<c path="Array"><c path="filtered.T"/></c>
					<c path="Array"><c path="filtered.T"/></c>
				</f>
				<c path="String"/>
				<x path="ceramic.Collection"><c path="filtered.T"/></x>
			</f>
			<haxe_doc>* Returns a filtered collection from the provided collection and filter.</haxe_doc>
		</filtered>
		<combined public="1" params="T" set="method" line="68" static="1">
			<f a="collections:?cache" v=":true">
				<c path="Array"><x path="ceramic.Collection"><c path="combined.T"/></x></c>
				<x path="Bool"/>
				<x path="ceramic.Collection"><c path="combined.T"/></x>
			</f>
			<meta><m n=":value"><e>{ cache : true }</e></m></meta>
			<haxe_doc>* Returns a combined collection from the provided ones.</haxe_doc>
		</combined>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":hxGen"/>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<abstract path="ceramic.Color" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Color.hx">
		<from>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
			<icast field="toAlphaColor"><x path="ceramic.AlphaColor"/></icast>
		</to>
		<haxe_doc>* Class representing a color, based on Int. Provides a variety of methods for creating and converting colors.
 *
 * Colors can be written as Ints. This means you can pass a hex value such as
 * 0x123456 to a function expecting a Color, and it will automatically become a Color "object".
 * Similarly, Colors may be treated as Ints.
 *
 * Note that when using properties of a Color other than RGB, the values are ultimately stored as
 * RGB values, so repeatedly manipulating HSB/HSL/CMYK values may result in a gradual loss of precision.
 *
 * @author Joe Williamson (JoeCreates)
 * @author Edited by Jeremy Faivre for Ceramic engine (jeremyfa)</haxe_doc>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="ceramic._Color.Color_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Color.hx" private="1" module="ceramic.Color" final="1">
	<NONE public="1" get="inline" set="null" expr="-1" line="22" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>-1</e></m></meta>
	</NONE>
	<WHITE public="1" get="inline" set="null" expr="0xFFFFFF" line="24" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFFFFF</e></m></meta>
	</WHITE>
	<GRAY public="1" get="inline" set="null" expr="0x808080" line="25" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x808080</e></m></meta>
	</GRAY>
	<BLACK public="1" get="inline" set="null" expr="0x000000" line="26" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x000000</e></m></meta>
	</BLACK>
	<GREEN public="1" get="inline" set="null" expr="0x008000" line="28" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x008000</e></m></meta>
	</GREEN>
	<LIME public="1" get="inline" set="null" expr="0x00FF00" line="29" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x00FF00</e></m></meta>
	</LIME>
	<YELLOW public="1" get="inline" set="null" expr="0xFFFF00" line="30" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFFF00</e></m></meta>
	</YELLOW>
	<ORANGE public="1" get="inline" set="null" expr="0xFFA500" line="31" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFA500</e></m></meta>
	</ORANGE>
	<RED public="1" get="inline" set="null" expr="0xFF0000" line="32" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF0000</e></m></meta>
	</RED>
	<PURPLE public="1" get="inline" set="null" expr="0x800080" line="33" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x800080</e></m></meta>
	</PURPLE>
	<BLUE public="1" get="inline" set="null" expr="0x0000FF" line="34" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x0000FF</e></m></meta>
	</BLUE>
	<BROWN public="1" get="inline" set="null" expr="0x8B4513" line="35" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x8B4513</e></m></meta>
	</BROWN>
	<PINK public="1" get="inline" set="null" expr="0xFFC0CB" line="36" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFC0CB</e></m></meta>
	</PINK>
	<MAGENTA public="1" get="inline" set="null" expr="0xFF00FF" line="37" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF00FF</e></m></meta>
	</MAGENTA>
	<CYAN public="1" get="inline" set="null" expr="0x00FFFF" line="38" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x00FFFF</e></m></meta>
	</CYAN>
	<CORNFLOWERBLUE public="1" get="inline" set="null" expr="0x6495ED" line="40" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x6495ED</e></m></meta>
	</CORNFLOWERBLUE>
	<MEDIUMVIOLETRED public="1" get="inline" set="null" expr="0xC71585" line="41" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xC71585</e></m></meta>
	</MEDIUMVIOLETRED>
	<DEEPPINK public="1" get="inline" set="null" expr="0xFF1493" line="42" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF1493</e></m></meta>
	</DEEPPINK>
	<PALEVIOLETRED public="1" get="inline" set="null" expr="0xDB7093" line="43" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xDB7093</e></m></meta>
	</PALEVIOLETRED>
	<HOTPINK public="1" get="inline" set="null" expr="0xFF69B4" line="44" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF69B4</e></m></meta>
	</HOTPINK>
	<LIGHTPINK public="1" get="inline" set="null" expr="0xFFB6C1" line="45" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFB6C1</e></m></meta>
	</LIGHTPINK>
	<DARKRED public="1" get="inline" set="null" expr="0x8B0000" line="46" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x8B0000</e></m></meta>
	</DARKRED>
	<FIREBRICK public="1" get="inline" set="null" expr="0xB22222" line="47" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xB22222</e></m></meta>
	</FIREBRICK>
	<CRIMSON public="1" get="inline" set="null" expr="0xDC143C" line="48" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xDC143C</e></m></meta>
	</CRIMSON>
	<INDIANRED public="1" get="inline" set="null" expr="0xCD5C5C" line="49" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xCD5C5C</e></m></meta>
	</INDIANRED>
	<LIGHTCORAL public="1" get="inline" set="null" expr="0xF08080" line="50" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xF08080</e></m></meta>
	</LIGHTCORAL>
	<SALMON public="1" get="inline" set="null" expr="0xFA8072" line="51" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFA8072</e></m></meta>
	</SALMON>
	<DARKSALMON public="1" get="inline" set="null" expr="0xE9967A" line="52" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xE9967A</e></m></meta>
	</DARKSALMON>
	<LIGHTSALMON public="1" get="inline" set="null" expr="0xFFA07A" line="53" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFA07A</e></m></meta>
	</LIGHTSALMON>
	<ORANGERED public="1" get="inline" set="null" expr="0xFF4500" line="54" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF4500</e></m></meta>
	</ORANGERED>
	<TOMATO public="1" get="inline" set="null" expr="0xFF6347" line="55" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF6347</e></m></meta>
	</TOMATO>
	<DARKORANGE public="1" get="inline" set="null" expr="0xFF8C00" line="56" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF8C00</e></m></meta>
	</DARKORANGE>
	<CORAL public="1" get="inline" set="null" expr="0xFF7F50" line="57" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFF7F50</e></m></meta>
	</CORAL>
	<DARKKHAKI public="1" get="inline" set="null" expr="0xBDB76B" line="58" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xBDB76B</e></m></meta>
	</DARKKHAKI>
	<GOLD public="1" get="inline" set="null" expr="0xFFD700" line="59" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFD700</e></m></meta>
	</GOLD>
	<KHAKI public="1" get="inline" set="null" expr="0xF0E68C" line="60" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xF0E68C</e></m></meta>
	</KHAKI>
	<PEACHPUFF public="1" get="inline" set="null" expr="0xFFDAB9" line="61" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFDAB9</e></m></meta>
	</PEACHPUFF>
	<PALEGOLDENROD public="1" get="inline" set="null" expr="0xEEE8AA" line="62" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xEEE8AA</e></m></meta>
	</PALEGOLDENROD>
	<MOCCASIN public="1" get="inline" set="null" expr="0xFFE4B5" line="63" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFE4B5</e></m></meta>
	</MOCCASIN>
	<PAPAYAWHIP public="1" get="inline" set="null" expr="0xFFEFD5" line="64" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFEFD5</e></m></meta>
	</PAPAYAWHIP>
	<LEMONCHIFFON public="1" get="inline" set="null" expr="0xFFFACD" line="65" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFFACD</e></m></meta>
	</LEMONCHIFFON>
	<LIGHTYELLOW public="1" get="inline" set="null" expr="0xFFFFE0" line="66" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFFFE0</e></m></meta>
	</LIGHTYELLOW>
	<SIENNA public="1" get="inline" set="null" expr="0xA0522D" line="67" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xA0522D</e></m></meta>
	</SIENNA>
	<CHOCOLATE public="1" get="inline" set="null" expr="0xD2691E" line="68" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xD2691E</e></m></meta>
	</CHOCOLATE>
	<PERU public="1" get="inline" set="null" expr="0xCD853F" line="69" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xCD853F</e></m></meta>
	</PERU>
	<TAN public="1" get="inline" set="null" expr="0xD2B48C" line="70" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xD2B48C</e></m></meta>
	</TAN>
	<DARKOLIVEGREEN public="1" get="inline" set="null" expr="0x556B2F" line="71" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x556B2F</e></m></meta>
	</DARKOLIVEGREEN>
	<OLIVE public="1" get="inline" set="null" expr="0x808000" line="72" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x808000</e></m></meta>
	</OLIVE>
	<TEAL public="1" get="inline" set="null" expr="0x008080" line="73" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x008080</e></m></meta>
	</TEAL>
	<TURQUOISE public="1" get="inline" set="null" expr="0x40E0D0" line="74" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x40E0D0</e></m></meta>
	</TURQUOISE>
	<NAVY public="1" get="inline" set="null" expr="0x000080" line="75" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x000080</e></m></meta>
	</NAVY>
	<INDIGO public="1" get="inline" set="null" expr="0x4B0082" line="76" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x4B0082</e></m></meta>
	</INDIGO>
	<ORCHID public="1" get="inline" set="null" expr="0xDA70D6" line="77" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xDA70D6</e></m></meta>
	</ORCHID>
	<LAVENDER public="1" get="inline" set="null" expr="0xE6E6FA" line="78" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xE6E6FA</e></m></meta>
	</LAVENDER>
	<AZURE public="1" get="inline" set="null" expr="0xF0FFFF" line="79" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xF0FFFF</e></m></meta>
	</AZURE>
	<IVORY public="1" get="inline" set="null" expr="0xFFFFF0" line="80" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFFFF0</e></m></meta>
	</IVORY>
	<DIMGREY public="1" get="inline" set="null" expr="0x696969" line="81" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x696969</e></m></meta>
	</DIMGREY>
	<SLATEGREY public="1" get="inline" set="null" expr="0x708090" line="82" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0x708090</e></m></meta>
	</SLATEGREY>
	<SNOW public="1" get="inline" set="null" expr="0xFFFAFA" line="83" static="1">
		<x path="ceramic.Color"/>
		<meta><m n=":value"><e>0xFFFAFA</e></m></meta>
	</SNOW>
	<colorLookup public="1" set="null" expr="[&quot;NONE&quot; =&gt; -1, &quot;WHITE&quot; =&gt; 0xFFFFFF, &quot;GRAY&quot; =&gt; 0x808080, &quot;BLACK&quot; =&gt; 0x000000, &quot;GREEN&quot; =&gt; 0x008000, &quot;LIME&quot; =&gt; 0x00FF00, &quot;YELLOW&quot; =&gt; 0xFFFF00, &quot;ORANGE&quot; =&gt; 0xFFA500, &quot;RED&quot; =&gt; 0xFF0000, &quot;PURPLE&quot; =&gt; 0x800080, &quot;BLUE&quot; =&gt; 0x0000FF, &quot;BROWN&quot; =&gt; 0x8B4513, &quot;PINK&quot; =&gt; 0xFFC0CB, &quot;MAGENTA&quot; =&gt; 0xFF00FF, &quot;CYAN&quot; =&gt; 0x00FFFF, &quot;CORNFLOWERBLUE&quot; =&gt; 0x6495ED, &quot;MEDIUMVIOLETRED&quot; =&gt; 0xC71585, &quot;DEEPPINK&quot; =&gt; 0xFF1493, &quot;PALEVIOLETRED&quot; =&gt; 0xDB7093, &quot;HOTPINK&quot; =&gt; 0xFF69B4, &quot;LIGHTPINK&quot; =&gt; 0xFFB6C1, &quot;DARKRED&quot; =&gt; 0x8B0000, &quot;FIREBRICK&quot; =&gt; 0xB22222, &quot;CRIMSON&quot; =&gt; 0xDC143C, &quot;INDIANRED&quot; =&gt; 0xCD5C5C, &quot;LIGHTCORAL&quot; =&gt; 0xF08080, &quot;SALMON&quot; =&gt; 0xFA8072, &quot;DARKSALMON&quot; =&gt; 0xE9967A, &quot;LIGHTSALMON&quot; =&gt; 0xFFA07A, &quot;ORANGERED&quot; =&gt; 0xFF4500, &quot;TOMATO&quot; =&gt; 0xFF6347, &quot;DARKORANGE&quot; =&gt; 0xFF8C00, &quot;CORAL&quot; =&gt; 0xFF7F50, &quot;DARKKHAKI&quot; =&gt; 0xBDB76B, &quot;GOLD&quot; =&gt; 0xFFD700, &quot;KHAKI&quot; =&gt; 0xF0E68C, &quot;PEACHPUFF&quot; =&gt; 0xFFDAB9, &quot;PALEGOLDENROD&quot; =&gt; 0xEEE8AA, &quot;MOCCASIN&quot; =&gt; 0xFFE4B5, &quot;PAPAYAWHIP&quot; =&gt; 0xFFEFD5, &quot;LEMONCHIFFON&quot; =&gt; 0xFFFACD, &quot;LIGHTYELLOW&quot; =&gt; 0xFFFFE0, &quot;SIENNA&quot; =&gt; 0xA0522D, &quot;CHOCOLATE&quot; =&gt; 0xD2691E, &quot;PERU&quot; =&gt; 0xCD853F, &quot;TAN&quot; =&gt; 0xD2B48C, &quot;DARKOLIVEGREEN&quot; =&gt; 0x556B2F, &quot;OLIVE&quot; =&gt; 0x808000, &quot;TEAL&quot; =&gt; 0x008080, &quot;TURQUOISE&quot; =&gt; 0x40E0D0, &quot;NAVY&quot; =&gt; 0x000080, &quot;INDIGO&quot; =&gt; 0x4B0082, &quot;ORCHID&quot; =&gt; 0xDA70D6, &quot;LAVENDER&quot; =&gt; 0xE6E6FA, &quot;AZURE&quot; =&gt; 0xF0FFFF, &quot;IVORY&quot; =&gt; 0xFFFFF0, &quot;DIMGREY&quot; =&gt; 0x696969, &quot;SLATEGREY&quot; =&gt; 0x708090, &quot;SNOW&quot; =&gt; 0xFFFAFA]" line="85" static="1">
		<t path="Map">
			<c path="String"/>
			<x path="Int"/>
		</t>
		<meta><m n=":value"><e><![CDATA[["NONE" => -1, "WHITE" => 0xFFFFFF, "GRAY" => 0x808080, "BLACK" => 0x000000, "GREEN" => 0x008000, "LIME" => 0x00FF00, "YELLOW" => 0xFFFF00, "ORANGE" => 0xFFA500, "RED" => 0xFF0000, "PURPLE" => 0x800080, "BLUE" => 0x0000FF, "BROWN" => 0x8B4513, "PINK" => 0xFFC0CB, "MAGENTA" => 0xFF00FF, "CYAN" => 0x00FFFF, "CORNFLOWERBLUE" => 0x6495ED, "MEDIUMVIOLETRED" => 0xC71585, "DEEPPINK" => 0xFF1493, "PALEVIOLETRED" => 0xDB7093, "HOTPINK" => 0xFF69B4, "LIGHTPINK" => 0xFFB6C1, "DARKRED" => 0x8B0000, "FIREBRICK" => 0xB22222, "CRIMSON" => 0xDC143C, "INDIANRED" => 0xCD5C5C, "LIGHTCORAL" => 0xF08080, "SALMON" => 0xFA8072, "DARKSALMON" => 0xE9967A, "LIGHTSALMON" => 0xFFA07A, "ORANGERED" => 0xFF4500, "TOMATO" => 0xFF6347, "DARKORANGE" => 0xFF8C00, "CORAL" => 0xFF7F50, "DARKKHAKI" => 0xBDB76B, "GOLD" => 0xFFD700, "KHAKI" => 0xF0E68C, "PEACHPUFF" => 0xFFDAB9, "PALEGOLDENROD" => 0xEEE8AA, "MOCCASIN" => 0xFFE4B5, "PAPAYAWHIP" => 0xFFEFD5, "LEMONCHIFFON" => 0xFFFACD, "LIGHTYELLOW" => 0xFFFFE0, "SIENNA" => 0xA0522D, "CHOCOLATE" => 0xD2691E, "PERU" => 0xCD853F, "TAN" => 0xD2B48C, "DARKOLIVEGREEN" => 0x556B2F, "OLIVE" => 0x808000, "TEAL" => 0x008080, "TURQUOISE" => 0x40E0D0, "NAVY" => 0x000080, "INDIGO" => 0x4B0082, "ORCHID" => 0xDA70D6, "LAVENDER" => 0xE6E6FA, "AZURE" => 0xF0FFFF, "IVORY" => 0xFFFFF0, "DIMGREY" => 0x696969, "SLATEGREY" => 0x708090, "SNOW" => 0xFFFAFA]]]></e></m></meta>
	</colorLookup>
	<red public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Red color component as `Int` between `0` and `255`</haxe_doc>
	</red>
	<green public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Green color component as `Int` between `0` and `255`</haxe_doc>
	</green>
	<blue public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>* Blue color component as `Int` between `0` and `255`</haxe_doc>
	</blue>
	<redFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Red color component as `Float` between `0.0` and `1.0`</haxe_doc>
	</redFloat>
	<greenFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Green color component as `Float` between `0.0` and `1.0`</haxe_doc>
	</greenFloat>
	<blueFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* Blue color component as `Float` between `0.0` and `1.0`</haxe_doc>
	</blueFloat>
	<cyan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></cyan>
	<magenta public="1" get="accessor" set="accessor" static="1"><x path="Float"/></magenta>
	<yellow public="1" get="accessor" set="accessor" static="1"><x path="Float"/></yellow>
	<black public="1" get="accessor" set="accessor" static="1"><x path="Float"/></black>
	<hue public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hue>
	<saturation public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
	</saturation>
	<brightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
	</brightness>
	<lightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
	</lightness>
	<toAlphaColor public="1" get="inline" set="null" line="201" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="ceramic.AlphaColor"/>
		</f>
		<meta><m n=":to"/></meta>
		<haxe_doc>* Get the color as AlphaColor</haxe_doc>
	</toAlphaColor>
	<random public="1" get="inline" set="null" line="210" static="1">
		<f a="?minSatutation:?minBrightness" v="0.5:0.5">
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":value"><e>{ minBrightness : 0.5, minSatutation : 0.5 }</e></m></meta>
		<haxe_doc>* Generate a random color (away from white or black)
     * @return The color as a Color</haxe_doc>
	</random>
	<fromInt public="1" get="inline" set="null" line="224" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Create a color from the least significant three bytes of an Int
     *
     * @param    value And Int with bytes in the format 0xRRGGBB
     * @return    The color as a Color</haxe_doc>
	</fromInt>
	<fromRGB public="1" get="inline" set="null" line="237" static="1">
		<f a="red:green:blue">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Generate a color from integer RGB values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return The color as a Color</haxe_doc>
	</fromRGB>
	<fromRGBFloat public="1" get="inline" set="null" line="251" static="1">
		<f a="red:green:blue">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Generate a color from float RGB values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return The color as a Color</haxe_doc>
	</fromRGBFloat>
	<fromCMYK public="1" get="inline" set="null" line="266" static="1">
		<f a="cyan:magenta:yellow:black">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Generate a color from CMYK values (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return The color as a Color</haxe_doc>
	</fromCMYK>
	<fromHSB public="1" set="method" line="280" static="1">
		<f a="hue:saturation:brightness">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Generate a color from HSB (aka HSV) components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    The color as a Color</haxe_doc>
	</fromHSB>
	<fromHSL public="1" get="inline" set="null" line="294" static="1">
		<f a="hue:saturation:lightness">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Generate a color from HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a Color</haxe_doc>
	</fromHSL>
	<fromString public="1" set="method" line="313" static="1">
		<f a="str">
			<c path="String"/>
			<x path="Null"><x path="ceramic.Color"/></x>
		</f>
		<haxe_doc><![CDATA[* Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.
     *
     * Examples (input -> output in hex):
     *
     * - `0x00FF00`    -> `0x00FF00`
     * - `#0000FF`     -> `0x0000FF`
     * - `GRAY`        -> `0x808080`
     * - `blue`        -> `0x0000FF`
     *
     * @param    str     The string to be parsed
     * @return    A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
	</fromString>
	<getHSBColorWheel public="1" set="method" line="355" static="1">
		<f a=""><c path="Array"><x path="ceramic.Color"/></c></f>
		<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
     *
     * @return    HSB color wheel as Array of Colors</haxe_doc>
	</getHSBColorWheel>
	<interpolate public="1" get="inline" set="null" line="368" static="1">
		<f a="color1:color2:?factor" v="::0.5">
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":value"><e>{ factor : 0.5 }</e></m></meta>
		<haxe_doc>* Get an interpolated color based on two different colors.
     *
     * @param     color1 The first color
     * @param     color2 The second color
     * @param     factor value from 0 to 1 representing how much to shift color1 toward color2
     * @return    The interpolated color</haxe_doc>
	</interpolate>
	<gradient public="1" set="method" line="386" static="1">
		<f a="color1:color2:steps:?ease">
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
			<x path="Int"/>
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<c path="Array"><x path="ceramic.Color"/></c>
		</f>
		<haxe_doc>* Create a gradient from one color to another
     *
     * @param color1 The color to shift from
     * @param color2 The color to shift to
     * @param steps How many colors the gradient should have
     * @param ease An optional easing function, such as those provided in FlxEase
     * @return An array of colors of length steps, shifting from color1 to color2</haxe_doc>
	</gradient>
	<multiply public="1" get="inline" set="null" line="410" static="1">
		<f a="lhs:rhs">
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":op"><e>A * B</e></m></meta>
		<haxe_doc>* Multiply the RGB channels of two Colors</haxe_doc>
	</multiply>
	<add public="1" get="inline" set="null" line="419" static="1">
		<f a="lhs:rhs">
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
		<haxe_doc>* Add the RGB channels of two Colors</haxe_doc>
	</add>
	<subtract public="1" get="inline" set="null" line="428" static="1">
		<f a="lhs:rhs">
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
		<haxe_doc>* Subtract the RGB channels of one Color from another</haxe_doc>
	</subtract>
	<toHexString public="1" get="inline" set="null" line="439" static="1">
		<f a="this:?prefix" v=":true">
			<x path="Int"/>
			<x path="Bool"/>
			<c path="String"/>
		</f>
		<meta><m n=":value"><e>{ prefix : true }</e></m></meta>
		<haxe_doc>* Return a String representation of the color in the format
     *
     * @param prefix Whether to include "0x" prefix at start of string
     * @return    A string of length 8 in the format 0xRRGGBB</haxe_doc>
	</toHexString>
	<toWebString public="1" get="inline" set="null" line="450" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Return a String representation of the color in the format #RRGGBB
     *
     * @return    A string of length 7 in the format #RRGGBB</haxe_doc>
	</toWebString>
	<getColorInfo public="1" set="method" line="460" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Get a string of color information about this color
     *
     * @return A string containing information about this color</haxe_doc>
	</getColorInfo>
	<getDarkened public="1" set="method" line="479" static="1">
		<f a="this:?factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
		<haxe_doc>* Get a darkened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward black.
     * @return     A darkened version of this color</haxe_doc>
	</getDarkened>
	<getLightened public="1" get="inline" set="null" line="493" static="1">
		<f a="this:?factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
		<haxe_doc>* Get a lightened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward white.
     * @return     A lightened version of this color</haxe_doc>
	</getLightened>
	<getInverted public="1" get="inline" set="null" line="506" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Get the inversion of this color
     *
     * @return The inversion of this color</haxe_doc>
	</getInverted>
	<setRGB public="1" get="inline" set="null" line="520" static="1">
		<f a="this:red:green:blue">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Set RGB values as integers (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return This color</haxe_doc>
	</setRGB>
	<setRGBFloat public="1" get="inline" set="null" line="536" static="1">
		<f a="this:red:green:blue">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Set RGB values as floats (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return This color</haxe_doc>
	</setRGBFloat>
	<setCMYK public="1" get="inline" set="null" line="553" static="1">
		<f a="this:cyan:magenta:yellow:black">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Set CMYK values as floats (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return This color</haxe_doc>
	</setCMYK>
	<setHSB public="1" get="inline" set="null" line="569" static="1">
		<f a="this:hue:saturation:brightness">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Set HSB (aka HSV) components
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    This color</haxe_doc>
	</setHSB>
	<setHSL public="1" get="inline" set="null" line="584" static="1">
		<f a="this:hue:saturation:lightness">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Set HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
	</setHSL>
	<setHSChromaMatch get="inline" set="null" line="594" static="1">
		<f a="this:hue:saturation:chroma:match">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
	</setHSChromaMatch>
	<_new public="1" get="inline" set="null" line="613" static="1">
		<f a="?value" v="0">
			<x path="Int"/>
			<x path="ceramic.Color"/>
		</f>
		<meta>
			<m n=":value"><e>{ value : 0 }</e></m>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get_red get="inline" set="null" line="619" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_red>
	<get_green get="inline" set="null" line="624" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_green>
	<get_blue get="inline" set="null" line="629" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_blue>
	<get_redFloat get="inline" set="null" line="634" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_redFloat>
	<get_greenFloat get="inline" set="null" line="639" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_greenFloat>
	<get_blueFloat get="inline" set="null" line="644" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_blueFloat>
	<set_red get="inline" set="null" line="649" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_red>
	<set_green get="inline" set="null" line="656" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_green>
	<set_blue get="inline" set="null" line="663" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_blue>
	<set_redFloat get="inline" set="null" line="670" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_redFloat>
	<set_greenFloat get="inline" set="null" line="676" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_greenFloat>
	<set_blueFloat get="inline" set="null" line="682" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_blueFloat>
	<get_cyan get="inline" set="null" line="688" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_cyan>
	<get_magenta get="inline" set="null" line="693" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_magenta>
	<get_yellow get="inline" set="null" line="698" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_yellow>
	<get_black get="inline" set="null" line="703" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_black>
	<set_cyan get="inline" set="null" line="708" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_cyan>
	<set_magenta get="inline" set="null" line="714" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_magenta>
	<set_yellow get="inline" set="null" line="720" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_yellow>
	<set_black get="inline" set="null" line="726" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_black>
	<get_hue set="method" line="732" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hue>
	<get_brightness get="inline" set="null" line="744" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_brightness>
	<get_saturation get="inline" set="null" line="749" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturation>
	<get_lightness get="inline" set="null" line="754" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightness>
	<set_hue get="inline" set="null" line="759" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hue>
	<set_saturation get="inline" set="null" line="765" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturation>
	<set_brightness get="inline" set="null" line="771" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_brightness>
	<set_lightness get="inline" set="null" line="777" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightness>
	<maxColor get="inline" set="null" line="783" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></maxColor>
	<minColor get="inline" set="null" line="788" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></minColor>
	<boundChannel get="inline" set="null" line="793" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></boundChannel>
	<roundDecimal set="method" line="800" static="1"><f a="value:precision">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></roundDecimal>
	<bound get="inline" set="null" line="810" static="1"><f a="value:?min:?max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></bound>
	<toString public="1" get="inline" set="null" line="817" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<_hsluvTuple expr="[0, 0, 0]" line="827" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
	</_hsluvTuple>
	<_hsluvResult expr="[0, 0, 0]" line="829" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
	</_hsluvResult>
	<_hsluvCacheMap expr="new IntIntMap()" line="831" static="1">
		<c path="ceramic.IntIntMap"/>
		<meta><m n=":value"><e>new IntIntMap()</e></m></meta>
	</_hsluvCacheMap>
	<_hsluvCacheValues expr="[]" line="833" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[]</e></m></meta>
	</_hsluvCacheValues>
	<hueHSLuv public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The HSLuv hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hueHSLuv>
	<saturationHSLuv public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The HSLuv saturation of the color (from 0 to 1)</haxe_doc>
	</saturationHSLuv>
	<lightnessHSLuv public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The HSLuv lightness of the color (from 0 to 1)</haxe_doc>
	</lightnessHSLuv>
	<get_hueHSLuv set="method" line="849" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hueHSLuv>
	<set_hueHSLuv get="inline" set="null" line="854" static="1"><f a="this:hueHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hueHSLuv>
	<get_saturationHSLuv set="method" line="860" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturationHSLuv>
	<set_saturationHSLuv get="inline" set="null" line="865" static="1"><f a="this:saturationHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturationHSLuv>
	<get_lightnessHSLuv set="method" line="871" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightnessHSLuv>
	<set_lightnessHSLuv get="inline" set="null" line="876" static="1"><f a="this:lightnessHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightnessHSLuv>
	<_getOrCreateCachedHSLuvComponent get="inline" set="null" line="882" static="1"><f a="this:index">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></_getOrCreateCachedHSLuvComponent>
	<fromHSLuv public="1" get="inline" set="null" line="905" static="1">
		<f a="hue:saturation:lightness">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Generate a color from HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a Color</haxe_doc>
	</fromHSLuv>
	<setHSLuv public="1" get="inline" set="null" line="919" static="1">
		<f a="this:hue:saturation:lightness">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="ceramic.Color"/>
		</f>
		<haxe_doc>* Set HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
	</setHSLuv>
	<getHSLuv public="1" get="inline" set="null" line="951" static="1">
		<f a="this:?result">
			<x path="Int"/>
			<c path="Array"><x path="Float"/></c>
			<c path="Array"><x path="Float"/></c>
		</f>
		<haxe_doc>* Get HSLuv components from the color instance.
     *
     * @param result A pre-allocated array to store the result into.
     * @return    The HSLuv components as a float array</haxe_doc>
	</getHSLuv>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic.IntIntMap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntIntMap.hx">
		<intMap>
			<t path="Map">
				<x path="Int"/>
				<x path="Int"/>
			</t>
			<haxe_doc>* Backing map</haxe_doc>
		</intMap>
		<iterableKeys public="1" set="null" expr="null" line="469">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* When this map is marked as iterable, this array will contain every key.</haxe_doc>
		</iterableKeys>
		<iterableKeysUsed expr="null" line="470">
			<x path="ceramic.IntBoolMap"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</iterableKeysUsed>
		<size public="1" set="null" expr="0" line="472">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</size>
		<clear public="1" set="method" line="483"><f a=""><x path="Void"/></f></clear>
		<exists public="1" get="inline" set="null" line="492"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></exists>
		<set public="1" set="method" line="496"><f a="key:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set>
		<get public="1" get="inline" set="null" line="509"><f a="key">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<remove public="1" set="method" line="513"><f a="key">
	<x path="Int"/>
	<x path="Int"/>
</f></remove>
		<getInline public="1" get="inline" set="null" line="528"><f a="key">
	<x path="Int"/>
	<x path="Int"/>
</f></getInline>
		<existsInline public="1" get="inline" set="null" line="533"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></existsInline>
		<copy public="1" get="inline" set="null" line="537"><f a=""><c path="ceramic.IntIntMap"/></f></copy>
		<iterator public="1" get="inline" set="null" line="550"><f a=""><c path="ceramic.IntIntMapIterator"/></f></iterator>
		<keys public="1" get="inline" set="null" line="554"><f a=""><c path="ceramic.IntIntMapKeyIterator"/></f></keys>
		<keyValueIterator public="1" get="inline" set="null" line="558"><f a=""><c path="ceramic.IntIntMapKeyValueIterator"/></f></keyValueIterator>
		<new public="1" set="method" line="474">
			<f a="?size:?fillFactor:?iterable" v="16:0.5:false">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ iterable : false, fillFactor : 0.5, size : 16 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic._IntBoolMap.IntBoolMap_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntBoolMap.hx" private="1" module="ceramic.IntBoolMap" final="1">
		<size public="1" get="accessor" set="null" static="1"><x path="Int"/></size>
		<get_size public="1" get="inline" set="null" line="11" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
</f></get_size>
		<iterableKeys public="1" get="accessor" set="null" static="1"><c path="Array"><x path="Int"/></c></iterableKeys>
		<get_iterableKeys get="inline" set="null" line="14" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="Array"><x path="Int"/></c>
</f></get_iterableKeys>
		<_asIntBoolMap get="inline" set="null" line="16" static="1">
			<f a="this">
				<c path="ceramic.IntIntMap"/>
				<x path="ceramic.IntBoolMap"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_asIntBoolMap>
		<_new public="1" get="inline" set="null" line="20" static="1">
			<f a="?size:?fillFactor:?iterable" v="16:0.5:false">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="ceramic.IntBoolMap"/>
			</f>
			<meta>
				<m n=":value"><e>{ iterable : false, fillFactor : 0.5, size : 16 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<exists public="1" get="inline" set="null" line="24" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></exists>
		<existsInline public="1" get="inline" set="null" line="28" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></existsInline>
		<get public="1" get="inline" set="null" line="32" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></get>
		<getInline public="1" get="inline" set="null" line="36" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getInline>
		<set public="1" get="inline" set="null" line="40" static="1"><f a="this:key:value">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></set>
		<remove public="1" get="inline" set="null" line="44" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></remove>
		<clear public="1" get="inline" set="null" line="48" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<x path="Void"/>
</f></clear>
		<copy public="1" set="method" line="52" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<x path="ceramic.IntBoolMap"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="56" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="ceramic.IntBoolMapIterator"/>
</f></iterator>
		<keys public="1" get="inline" set="null" line="60" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="ceramic.IntBoolMapKeyIterator"/>
</f></keys>
		<keyValueIterator public="1" get="inline" set="null" line="64" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="ceramic.IntBoolMapKeyValueIterator"/>
</f></keyValueIterator>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic._Color.Color_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Color.hx" private="1" module="ceramic.Color" final="1">
		<NONE public="1" get="inline" set="null" expr="-1" line="22" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</NONE>
		<WHITE public="1" get="inline" set="null" expr="0xFFFFFF" line="24" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFFFF</e></m></meta>
		</WHITE>
		<GRAY public="1" get="inline" set="null" expr="0x808080" line="25" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x808080</e></m></meta>
		</GRAY>
		<BLACK public="1" get="inline" set="null" expr="0x000000" line="26" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x000000</e></m></meta>
		</BLACK>
		<GREEN public="1" get="inline" set="null" expr="0x008000" line="28" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x008000</e></m></meta>
		</GREEN>
		<LIME public="1" get="inline" set="null" expr="0x00FF00" line="29" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x00FF00</e></m></meta>
		</LIME>
		<YELLOW public="1" get="inline" set="null" expr="0xFFFF00" line="30" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFF00</e></m></meta>
		</YELLOW>
		<ORANGE public="1" get="inline" set="null" expr="0xFFA500" line="31" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFA500</e></m></meta>
		</ORANGE>
		<RED public="1" get="inline" set="null" expr="0xFF0000" line="32" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF0000</e></m></meta>
		</RED>
		<PURPLE public="1" get="inline" set="null" expr="0x800080" line="33" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x800080</e></m></meta>
		</PURPLE>
		<BLUE public="1" get="inline" set="null" expr="0x0000FF" line="34" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x0000FF</e></m></meta>
		</BLUE>
		<BROWN public="1" get="inline" set="null" expr="0x8B4513" line="35" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x8B4513</e></m></meta>
		</BROWN>
		<PINK public="1" get="inline" set="null" expr="0xFFC0CB" line="36" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFC0CB</e></m></meta>
		</PINK>
		<MAGENTA public="1" get="inline" set="null" expr="0xFF00FF" line="37" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF00FF</e></m></meta>
		</MAGENTA>
		<CYAN public="1" get="inline" set="null" expr="0x00FFFF" line="38" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x00FFFF</e></m></meta>
		</CYAN>
		<CORNFLOWERBLUE public="1" get="inline" set="null" expr="0x6495ED" line="40" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x6495ED</e></m></meta>
		</CORNFLOWERBLUE>
		<MEDIUMVIOLETRED public="1" get="inline" set="null" expr="0xC71585" line="41" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xC71585</e></m></meta>
		</MEDIUMVIOLETRED>
		<DEEPPINK public="1" get="inline" set="null" expr="0xFF1493" line="42" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF1493</e></m></meta>
		</DEEPPINK>
		<PALEVIOLETRED public="1" get="inline" set="null" expr="0xDB7093" line="43" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xDB7093</e></m></meta>
		</PALEVIOLETRED>
		<HOTPINK public="1" get="inline" set="null" expr="0xFF69B4" line="44" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF69B4</e></m></meta>
		</HOTPINK>
		<LIGHTPINK public="1" get="inline" set="null" expr="0xFFB6C1" line="45" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFB6C1</e></m></meta>
		</LIGHTPINK>
		<DARKRED public="1" get="inline" set="null" expr="0x8B0000" line="46" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x8B0000</e></m></meta>
		</DARKRED>
		<FIREBRICK public="1" get="inline" set="null" expr="0xB22222" line="47" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xB22222</e></m></meta>
		</FIREBRICK>
		<CRIMSON public="1" get="inline" set="null" expr="0xDC143C" line="48" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xDC143C</e></m></meta>
		</CRIMSON>
		<INDIANRED public="1" get="inline" set="null" expr="0xCD5C5C" line="49" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xCD5C5C</e></m></meta>
		</INDIANRED>
		<LIGHTCORAL public="1" get="inline" set="null" expr="0xF08080" line="50" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xF08080</e></m></meta>
		</LIGHTCORAL>
		<SALMON public="1" get="inline" set="null" expr="0xFA8072" line="51" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFA8072</e></m></meta>
		</SALMON>
		<DARKSALMON public="1" get="inline" set="null" expr="0xE9967A" line="52" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xE9967A</e></m></meta>
		</DARKSALMON>
		<LIGHTSALMON public="1" get="inline" set="null" expr="0xFFA07A" line="53" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFA07A</e></m></meta>
		</LIGHTSALMON>
		<ORANGERED public="1" get="inline" set="null" expr="0xFF4500" line="54" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF4500</e></m></meta>
		</ORANGERED>
		<TOMATO public="1" get="inline" set="null" expr="0xFF6347" line="55" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF6347</e></m></meta>
		</TOMATO>
		<DARKORANGE public="1" get="inline" set="null" expr="0xFF8C00" line="56" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF8C00</e></m></meta>
		</DARKORANGE>
		<CORAL public="1" get="inline" set="null" expr="0xFF7F50" line="57" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF7F50</e></m></meta>
		</CORAL>
		<DARKKHAKI public="1" get="inline" set="null" expr="0xBDB76B" line="58" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xBDB76B</e></m></meta>
		</DARKKHAKI>
		<GOLD public="1" get="inline" set="null" expr="0xFFD700" line="59" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFD700</e></m></meta>
		</GOLD>
		<KHAKI public="1" get="inline" set="null" expr="0xF0E68C" line="60" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xF0E68C</e></m></meta>
		</KHAKI>
		<PEACHPUFF public="1" get="inline" set="null" expr="0xFFDAB9" line="61" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFDAB9</e></m></meta>
		</PEACHPUFF>
		<PALEGOLDENROD public="1" get="inline" set="null" expr="0xEEE8AA" line="62" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xEEE8AA</e></m></meta>
		</PALEGOLDENROD>
		<MOCCASIN public="1" get="inline" set="null" expr="0xFFE4B5" line="63" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFE4B5</e></m></meta>
		</MOCCASIN>
		<PAPAYAWHIP public="1" get="inline" set="null" expr="0xFFEFD5" line="64" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFEFD5</e></m></meta>
		</PAPAYAWHIP>
		<LEMONCHIFFON public="1" get="inline" set="null" expr="0xFFFACD" line="65" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFACD</e></m></meta>
		</LEMONCHIFFON>
		<LIGHTYELLOW public="1" get="inline" set="null" expr="0xFFFFE0" line="66" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFFE0</e></m></meta>
		</LIGHTYELLOW>
		<SIENNA public="1" get="inline" set="null" expr="0xA0522D" line="67" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xA0522D</e></m></meta>
		</SIENNA>
		<CHOCOLATE public="1" get="inline" set="null" expr="0xD2691E" line="68" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xD2691E</e></m></meta>
		</CHOCOLATE>
		<PERU public="1" get="inline" set="null" expr="0xCD853F" line="69" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xCD853F</e></m></meta>
		</PERU>
		<TAN public="1" get="inline" set="null" expr="0xD2B48C" line="70" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xD2B48C</e></m></meta>
		</TAN>
		<DARKOLIVEGREEN public="1" get="inline" set="null" expr="0x556B2F" line="71" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x556B2F</e></m></meta>
		</DARKOLIVEGREEN>
		<OLIVE public="1" get="inline" set="null" expr="0x808000" line="72" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x808000</e></m></meta>
		</OLIVE>
		<TEAL public="1" get="inline" set="null" expr="0x008080" line="73" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x008080</e></m></meta>
		</TEAL>
		<TURQUOISE public="1" get="inline" set="null" expr="0x40E0D0" line="74" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x40E0D0</e></m></meta>
		</TURQUOISE>
		<NAVY public="1" get="inline" set="null" expr="0x000080" line="75" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x000080</e></m></meta>
		</NAVY>
		<INDIGO public="1" get="inline" set="null" expr="0x4B0082" line="76" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x4B0082</e></m></meta>
		</INDIGO>
		<ORCHID public="1" get="inline" set="null" expr="0xDA70D6" line="77" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xDA70D6</e></m></meta>
		</ORCHID>
		<LAVENDER public="1" get="inline" set="null" expr="0xE6E6FA" line="78" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xE6E6FA</e></m></meta>
		</LAVENDER>
		<AZURE public="1" get="inline" set="null" expr="0xF0FFFF" line="79" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xF0FFFF</e></m></meta>
		</AZURE>
		<IVORY public="1" get="inline" set="null" expr="0xFFFFF0" line="80" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFFF0</e></m></meta>
		</IVORY>
		<DIMGREY public="1" get="inline" set="null" expr="0x696969" line="81" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x696969</e></m></meta>
		</DIMGREY>
		<SLATEGREY public="1" get="inline" set="null" expr="0x708090" line="82" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x708090</e></m></meta>
		</SLATEGREY>
		<SNOW public="1" get="inline" set="null" expr="0xFFFAFA" line="83" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFAFA</e></m></meta>
		</SNOW>
		<colorLookup public="1" set="null" expr="[&quot;NONE&quot; =&gt; -1, &quot;WHITE&quot; =&gt; 0xFFFFFF, &quot;GRAY&quot; =&gt; 0x808080, &quot;BLACK&quot; =&gt; 0x000000, &quot;GREEN&quot; =&gt; 0x008000, &quot;LIME&quot; =&gt; 0x00FF00, &quot;YELLOW&quot; =&gt; 0xFFFF00, &quot;ORANGE&quot; =&gt; 0xFFA500, &quot;RED&quot; =&gt; 0xFF0000, &quot;PURPLE&quot; =&gt; 0x800080, &quot;BLUE&quot; =&gt; 0x0000FF, &quot;BROWN&quot; =&gt; 0x8B4513, &quot;PINK&quot; =&gt; 0xFFC0CB, &quot;MAGENTA&quot; =&gt; 0xFF00FF, &quot;CYAN&quot; =&gt; 0x00FFFF, &quot;CORNFLOWERBLUE&quot; =&gt; 0x6495ED, &quot;MEDIUMVIOLETRED&quot; =&gt; 0xC71585, &quot;DEEPPINK&quot; =&gt; 0xFF1493, &quot;PALEVIOLETRED&quot; =&gt; 0xDB7093, &quot;HOTPINK&quot; =&gt; 0xFF69B4, &quot;LIGHTPINK&quot; =&gt; 0xFFB6C1, &quot;DARKRED&quot; =&gt; 0x8B0000, &quot;FIREBRICK&quot; =&gt; 0xB22222, &quot;CRIMSON&quot; =&gt; 0xDC143C, &quot;INDIANRED&quot; =&gt; 0xCD5C5C, &quot;LIGHTCORAL&quot; =&gt; 0xF08080, &quot;SALMON&quot; =&gt; 0xFA8072, &quot;DARKSALMON&quot; =&gt; 0xE9967A, &quot;LIGHTSALMON&quot; =&gt; 0xFFA07A, &quot;ORANGERED&quot; =&gt; 0xFF4500, &quot;TOMATO&quot; =&gt; 0xFF6347, &quot;DARKORANGE&quot; =&gt; 0xFF8C00, &quot;CORAL&quot; =&gt; 0xFF7F50, &quot;DARKKHAKI&quot; =&gt; 0xBDB76B, &quot;GOLD&quot; =&gt; 0xFFD700, &quot;KHAKI&quot; =&gt; 0xF0E68C, &quot;PEACHPUFF&quot; =&gt; 0xFFDAB9, &quot;PALEGOLDENROD&quot; =&gt; 0xEEE8AA, &quot;MOCCASIN&quot; =&gt; 0xFFE4B5, &quot;PAPAYAWHIP&quot; =&gt; 0xFFEFD5, &quot;LEMONCHIFFON&quot; =&gt; 0xFFFACD, &quot;LIGHTYELLOW&quot; =&gt; 0xFFFFE0, &quot;SIENNA&quot; =&gt; 0xA0522D, &quot;CHOCOLATE&quot; =&gt; 0xD2691E, &quot;PERU&quot; =&gt; 0xCD853F, &quot;TAN&quot; =&gt; 0xD2B48C, &quot;DARKOLIVEGREEN&quot; =&gt; 0x556B2F, &quot;OLIVE&quot; =&gt; 0x808000, &quot;TEAL&quot; =&gt; 0x008080, &quot;TURQUOISE&quot; =&gt; 0x40E0D0, &quot;NAVY&quot; =&gt; 0x000080, &quot;INDIGO&quot; =&gt; 0x4B0082, &quot;ORCHID&quot; =&gt; 0xDA70D6, &quot;LAVENDER&quot; =&gt; 0xE6E6FA, &quot;AZURE&quot; =&gt; 0xF0FFFF, &quot;IVORY&quot; =&gt; 0xFFFFF0, &quot;DIMGREY&quot; =&gt; 0x696969, &quot;SLATEGREY&quot; =&gt; 0x708090, &quot;SNOW&quot; =&gt; 0xFFFAFA]" line="85" static="1">
			<t path="Map">
				<c path="String"/>
				<x path="Int"/>
			</t>
			<meta><m n=":value"><e><![CDATA[["NONE" => -1, "WHITE" => 0xFFFFFF, "GRAY" => 0x808080, "BLACK" => 0x000000, "GREEN" => 0x008000, "LIME" => 0x00FF00, "YELLOW" => 0xFFFF00, "ORANGE" => 0xFFA500, "RED" => 0xFF0000, "PURPLE" => 0x800080, "BLUE" => 0x0000FF, "BROWN" => 0x8B4513, "PINK" => 0xFFC0CB, "MAGENTA" => 0xFF00FF, "CYAN" => 0x00FFFF, "CORNFLOWERBLUE" => 0x6495ED, "MEDIUMVIOLETRED" => 0xC71585, "DEEPPINK" => 0xFF1493, "PALEVIOLETRED" => 0xDB7093, "HOTPINK" => 0xFF69B4, "LIGHTPINK" => 0xFFB6C1, "DARKRED" => 0x8B0000, "FIREBRICK" => 0xB22222, "CRIMSON" => 0xDC143C, "INDIANRED" => 0xCD5C5C, "LIGHTCORAL" => 0xF08080, "SALMON" => 0xFA8072, "DARKSALMON" => 0xE9967A, "LIGHTSALMON" => 0xFFA07A, "ORANGERED" => 0xFF4500, "TOMATO" => 0xFF6347, "DARKORANGE" => 0xFF8C00, "CORAL" => 0xFF7F50, "DARKKHAKI" => 0xBDB76B, "GOLD" => 0xFFD700, "KHAKI" => 0xF0E68C, "PEACHPUFF" => 0xFFDAB9, "PALEGOLDENROD" => 0xEEE8AA, "MOCCASIN" => 0xFFE4B5, "PAPAYAWHIP" => 0xFFEFD5, "LEMONCHIFFON" => 0xFFFACD, "LIGHTYELLOW" => 0xFFFFE0, "SIENNA" => 0xA0522D, "CHOCOLATE" => 0xD2691E, "PERU" => 0xCD853F, "TAN" => 0xD2B48C, "DARKOLIVEGREEN" => 0x556B2F, "OLIVE" => 0x808000, "TEAL" => 0x008080, "TURQUOISE" => 0x40E0D0, "NAVY" => 0x000080, "INDIGO" => 0x4B0082, "ORCHID" => 0xDA70D6, "LAVENDER" => 0xE6E6FA, "AZURE" => 0xF0FFFF, "IVORY" => 0xFFFFF0, "DIMGREY" => 0x696969, "SLATEGREY" => 0x708090, "SNOW" => 0xFFFAFA]]]></e></m></meta>
		</colorLookup>
		<red public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Red color component as `Int` between `0` and `255`</haxe_doc>
		</red>
		<green public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Green color component as `Int` between `0` and `255`</haxe_doc>
		</green>
		<blue public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* Blue color component as `Int` between `0` and `255`</haxe_doc>
		</blue>
		<redFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Red color component as `Float` between `0.0` and `1.0`</haxe_doc>
		</redFloat>
		<greenFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Green color component as `Float` between `0.0` and `1.0`</haxe_doc>
		</greenFloat>
		<blueFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Blue color component as `Float` between `0.0` and `1.0`</haxe_doc>
		</blueFloat>
		<cyan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></cyan>
		<magenta public="1" get="accessor" set="accessor" static="1"><x path="Float"/></magenta>
		<yellow public="1" get="accessor" set="accessor" static="1"><x path="Float"/></yellow>
		<black public="1" get="accessor" set="accessor" static="1"><x path="Float"/></black>
		<hue public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hue>
		<saturation public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
		</saturation>
		<brightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
		</brightness>
		<lightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
		</lightness>
		<toAlphaColor public="1" get="inline" set="null" line="201" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<meta><m n=":to"/></meta>
			<haxe_doc>* Get the color as AlphaColor</haxe_doc>
		</toAlphaColor>
		<random public="1" get="inline" set="null" line="210" static="1">
			<f a="?minSatutation:?minBrightness" v="0.5:0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ minBrightness : 0.5, minSatutation : 0.5 }</e></m></meta>
			<haxe_doc>* Generate a random color (away from white or black)
     * @return The color as a Color</haxe_doc>
		</random>
		<fromInt public="1" get="inline" set="null" line="224" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Create a color from the least significant three bytes of an Int
     *
     * @param    value And Int with bytes in the format 0xRRGGBB
     * @return    The color as a Color</haxe_doc>
		</fromInt>
		<fromRGB public="1" get="inline" set="null" line="237" static="1">
			<f a="red:green:blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from integer RGB values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return The color as a Color</haxe_doc>
		</fromRGB>
		<fromRGBFloat public="1" get="inline" set="null" line="251" static="1">
			<f a="red:green:blue">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from float RGB values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return The color as a Color</haxe_doc>
		</fromRGBFloat>
		<fromCMYK public="1" get="inline" set="null" line="266" static="1">
			<f a="cyan:magenta:yellow:black">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from CMYK values (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return The color as a Color</haxe_doc>
		</fromCMYK>
		<fromHSB public="1" set="method" line="280" static="1">
			<f a="hue:saturation:brightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from HSB (aka HSV) components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    The color as a Color</haxe_doc>
		</fromHSB>
		<fromHSL public="1" get="inline" set="null" line="294" static="1">
			<f a="hue:saturation:lightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a Color</haxe_doc>
		</fromHSL>
		<fromString public="1" set="method" line="313" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Null"><x path="ceramic.Color"/></x>
			</f>
			<haxe_doc><![CDATA[* Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.
     *
     * Examples (input -> output in hex):
     *
     * - `0x00FF00`    -> `0x00FF00`
     * - `#0000FF`     -> `0x0000FF`
     * - `GRAY`        -> `0x808080`
     * - `blue`        -> `0x0000FF`
     *
     * @param    str     The string to be parsed
     * @return    A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
		</fromString>
		<getHSBColorWheel public="1" set="method" line="355" static="1">
			<f a=""><c path="Array"><x path="ceramic.Color"/></c></f>
			<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
     *
     * @return    HSB color wheel as Array of Colors</haxe_doc>
		</getHSBColorWheel>
		<interpolate public="1" get="inline" set="null" line="368" static="1">
			<f a="color1:color2:?factor" v="::0.5">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.5 }</e></m></meta>
			<haxe_doc>* Get an interpolated color based on two different colors.
     *
     * @param     color1 The first color
     * @param     color2 The second color
     * @param     factor value from 0 to 1 representing how much to shift color1 toward color2
     * @return    The interpolated color</haxe_doc>
		</interpolate>
		<gradient public="1" set="method" line="386" static="1">
			<f a="color1:color2:steps:?ease">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Int"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<c path="Array"><x path="ceramic.Color"/></c>
			</f>
			<haxe_doc>* Create a gradient from one color to another
     *
     * @param color1 The color to shift from
     * @param color2 The color to shift to
     * @param steps How many colors the gradient should have
     * @param ease An optional easing function, such as those provided in FlxEase
     * @return An array of colors of length steps, shifting from color1 to color2</haxe_doc>
		</gradient>
		<multiply public="1" get="inline" set="null" line="410" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":op"><e>A * B</e></m></meta>
			<haxe_doc>* Multiply the RGB channels of two Colors</haxe_doc>
		</multiply>
		<add public="1" get="inline" set="null" line="419" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
			<haxe_doc>* Add the RGB channels of two Colors</haxe_doc>
		</add>
		<subtract public="1" get="inline" set="null" line="428" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
			<haxe_doc>* Subtract the RGB channels of one Color from another</haxe_doc>
		</subtract>
		<toHexString public="1" get="inline" set="null" line="439" static="1">
			<f a="this:?prefix" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ prefix : true }</e></m></meta>
			<haxe_doc>* Return a String representation of the color in the format
     *
     * @param prefix Whether to include "0x" prefix at start of string
     * @return    A string of length 8 in the format 0xRRGGBB</haxe_doc>
		</toHexString>
		<toWebString public="1" get="inline" set="null" line="450" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a String representation of the color in the format #RRGGBB
     *
     * @return    A string of length 7 in the format #RRGGBB</haxe_doc>
		</toWebString>
		<getColorInfo public="1" set="method" line="460" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Get a string of color information about this color
     *
     * @return A string containing information about this color</haxe_doc>
		</getColorInfo>
		<getDarkened public="1" set="method" line="479" static="1">
			<f a="this:?factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
			<haxe_doc>* Get a darkened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward black.
     * @return     A darkened version of this color</haxe_doc>
		</getDarkened>
		<getLightened public="1" get="inline" set="null" line="493" static="1">
			<f a="this:?factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
			<haxe_doc>* Get a lightened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward white.
     * @return     A lightened version of this color</haxe_doc>
		</getLightened>
		<getInverted public="1" get="inline" set="null" line="506" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Get the inversion of this color
     *
     * @return The inversion of this color</haxe_doc>
		</getInverted>
		<setRGB public="1" get="inline" set="null" line="520" static="1">
			<f a="this:red:green:blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Set RGB values as integers (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return This color</haxe_doc>
		</setRGB>
		<setRGBFloat public="1" get="inline" set="null" line="536" static="1">
			<f a="this:red:green:blue">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Set RGB values as floats (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return This color</haxe_doc>
		</setRGBFloat>
		<setCMYK public="1" get="inline" set="null" line="553" static="1">
			<f a="this:cyan:magenta:yellow:black">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Set CMYK values as floats (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return This color</haxe_doc>
		</setCMYK>
		<setHSB public="1" get="inline" set="null" line="569" static="1">
			<f a="this:hue:saturation:brightness">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Set HSB (aka HSV) components
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    This color</haxe_doc>
		</setHSB>
		<setHSL public="1" get="inline" set="null" line="584" static="1">
			<f a="this:hue:saturation:lightness">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Set HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
		</setHSL>
		<setHSChromaMatch get="inline" set="null" line="594" static="1">
			<f a="this:hue:saturation:chroma:match">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
		</setHSChromaMatch>
		<_new public="1" get="inline" set="null" line="613" static="1">
			<f a="?value" v="0">
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<meta>
				<m n=":value"><e>{ value : 0 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get_red get="inline" set="null" line="619" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_red>
		<get_green get="inline" set="null" line="624" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_green>
		<get_blue get="inline" set="null" line="629" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_blue>
		<get_redFloat get="inline" set="null" line="634" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_redFloat>
		<get_greenFloat get="inline" set="null" line="639" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_greenFloat>
		<get_blueFloat get="inline" set="null" line="644" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_blueFloat>
		<set_red get="inline" set="null" line="649" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_red>
		<set_green get="inline" set="null" line="656" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_green>
		<set_blue get="inline" set="null" line="663" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_blue>
		<set_redFloat get="inline" set="null" line="670" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_redFloat>
		<set_greenFloat get="inline" set="null" line="676" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_greenFloat>
		<set_blueFloat get="inline" set="null" line="682" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_blueFloat>
		<get_cyan get="inline" set="null" line="688" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_cyan>
		<get_magenta get="inline" set="null" line="693" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_magenta>
		<get_yellow get="inline" set="null" line="698" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_yellow>
		<get_black get="inline" set="null" line="703" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_black>
		<set_cyan get="inline" set="null" line="708" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_cyan>
		<set_magenta get="inline" set="null" line="714" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_magenta>
		<set_yellow get="inline" set="null" line="720" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_yellow>
		<set_black get="inline" set="null" line="726" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_black>
		<get_hue set="method" line="732" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hue>
		<get_brightness get="inline" set="null" line="744" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_brightness>
		<get_saturation get="inline" set="null" line="749" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturation>
		<get_lightness get="inline" set="null" line="754" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightness>
		<set_hue get="inline" set="null" line="759" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hue>
		<set_saturation get="inline" set="null" line="765" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturation>
		<set_brightness get="inline" set="null" line="771" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_brightness>
		<set_lightness get="inline" set="null" line="777" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightness>
		<maxColor get="inline" set="null" line="783" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></maxColor>
		<minColor get="inline" set="null" line="788" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></minColor>
		<boundChannel get="inline" set="null" line="793" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></boundChannel>
		<roundDecimal set="method" line="800" static="1"><f a="value:precision">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></roundDecimal>
		<bound get="inline" set="null" line="810" static="1"><f a="value:?min:?max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></bound>
		<toString public="1" get="inline" set="null" line="817" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<_hsluvTuple expr="[0, 0, 0]" line="827" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
		</_hsluvTuple>
		<_hsluvResult expr="[0, 0, 0]" line="829" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
		</_hsluvResult>
		<_hsluvCacheMap expr="new IntIntMap()" line="831" static="1">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap()</e></m></meta>
		</_hsluvCacheMap>
		<_hsluvCacheValues expr="[]" line="833" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_hsluvCacheValues>
		<hueHSLuv public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The HSLuv hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hueHSLuv>
		<saturationHSLuv public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The HSLuv saturation of the color (from 0 to 1)</haxe_doc>
		</saturationHSLuv>
		<lightnessHSLuv public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The HSLuv lightness of the color (from 0 to 1)</haxe_doc>
		</lightnessHSLuv>
		<get_hueHSLuv set="method" line="849" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hueHSLuv>
		<set_hueHSLuv get="inline" set="null" line="854" static="1"><f a="this:hueHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hueHSLuv>
		<get_saturationHSLuv set="method" line="860" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturationHSLuv>
		<set_saturationHSLuv get="inline" set="null" line="865" static="1"><f a="this:saturationHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturationHSLuv>
		<get_lightnessHSLuv set="method" line="871" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightnessHSLuv>
		<set_lightnessHSLuv get="inline" set="null" line="876" static="1"><f a="this:lightnessHSLuv">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightnessHSLuv>
		<_getOrCreateCachedHSLuvComponent get="inline" set="null" line="882" static="1"><f a="this:index">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></_getOrCreateCachedHSLuvComponent>
		<fromHSLuv public="1" get="inline" set="null" line="905" static="1">
			<f a="hue:saturation:lightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a Color</haxe_doc>
		</fromHSLuv>
		<setHSLuv public="1" get="inline" set="null" line="919" static="1">
			<f a="this:hue:saturation:lightness">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Set HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    This color</haxe_doc>
		</setHSLuv>
		<getHSLuv public="1" get="inline" set="null" line="951" static="1">
			<f a="this:?result">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Get HSLuv components from the color instance.
     *
     * @param result A pre-allocated array to store the result into.
     * @return    The HSLuv components as a float array</haxe_doc>
		</getHSLuv>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.ComputeFps" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ComputeFps.hx">
		<frames><c path="Array"><x path="Float"/></c></frames>
		<index expr="0" line="9">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</index>
		<size><x path="Int"/></size>
		<fps public="1" set="null" expr="0" line="13">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</fps>
		<addFrame public="1" set="method" line="26"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></addFrame>
		<new public="1" set="method" line="15">
			<f a="?size" v="10">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ size : 10 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.ConvertField" params="T:U" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertField.hx" interface="1">
		<basicToField public="1" set="method">
			<f a="instance:field:assets:basic:done">
				<c path="ceramic.Entity"/>
				<c path="String"/>
				<c path="ceramic.Assets"/>
				<c path="ceramic.ConvertField.T"/>
				<f a="">
					<c path="ceramic.ConvertField.U"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Get field value from basic type. As this may require loading assets,
     * A usable `Assets` instance must be provided and the result will only be
     * provided asynchronously by calling `done` callback.</haxe_doc>
		</basicToField>
		<fieldToBasic public="1" set="method">
			<f a="instance:field:value">
				<c path="ceramic.Entity"/>
				<c path="String"/>
				<c path="ceramic.ConvertField.U"/>
				<c path="ceramic.ConvertField.T"/>
			</f>
			<haxe_doc>* Get a basic type from the field value.</haxe_doc>
		</fieldToBasic>
		<haxe_doc>* Interface to convert basic type `T` to field type `U` and vice versa.</haxe_doc>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.ConvertArray" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertArray.hx">
		<implements path="ceramic.ConvertField">
			<c path="Array"><c path="ceramic.ConvertArray.T"/></c>
			<c path="Array"><c path="ceramic.ConvertArray.T"/></c>
		</implements>
		<basicToField public="1" set="method" line="9"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<c path="Array"><c path="ceramic.ConvertArray.T"/></c>
	<f a="">
		<c path="Array"><c path="ceramic.ConvertArray.T"/></c>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="23"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="Array"><c path="ceramic.ConvertArray.T"/></c>
	<c path="Array"><c path="ceramic.ConvertArray.T"/></c>
</f></fieldToBasic>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.ConvertComponentMap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertComponentMap.hx">
		<implements path="ceramic.ConvertField">
			<x path="haxe.DynamicAccess"><c path="String"/></x>
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.Component"/>
			</t>
		</implements>
		<basicToField public="1" set="method" line="11"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<x path="haxe.DynamicAccess"><c path="String"/></x>
	<f a="">
		<t path="Map">
			<c path="String"/>
			<c path="ceramic.Component"/>
		</t>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="46"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</t>
	<x path="haxe.DynamicAccess"><c path="String"/></x>
</f></fieldToBasic>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.ConvertFont" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertFont.hx">
		<implements path="ceramic.ConvertField">
			<c path="String"/>
			<c path="ceramic.BitmapFont"/>
		</implements>
		<basicToField public="1" set="method" line="9"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<c path="String"/>
	<f a="">
		<c path="ceramic.BitmapFont"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="27"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.BitmapFont"/>
	<c path="String"/>
</f></fieldToBasic>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.ConvertFragmentData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertFragmentData.hx">
		<implements path="ceramic.ConvertField">
			<d/>
			<t path="ceramic.FragmentData"/>
		</implements>
		<basicToField public="1" set="method" line="7"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<d/>
	<f a="">
		<t path="ceramic.FragmentData"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="13"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<t path="ceramic.FragmentData"/>
	<d/>
</f></fieldToBasic>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.ConvertIntBoolMap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertIntBoolMap.hx">
		<implements path="ceramic.ConvertField">
			<d/>
			<x path="ceramic.IntBoolMap"/>
		</implements>
		<basicToField public="1" set="method" line="9"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<d/>
	<f a="">
		<x path="ceramic.IntBoolMap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="40"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<x path="ceramic.IntBoolMap"/>
	<d/>
</f></fieldToBasic>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.ConvertMap" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertMap.hx">
		<implements path="ceramic.ConvertField">
			<x path="haxe.DynamicAccess"><c path="ceramic.ConvertMap.T"/></x>
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.ConvertMap.T"/>
			</t>
		</implements>
		<basicToField public="1" set="method" line="9"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<x path="haxe.DynamicAccess"><c path="ceramic.ConvertMap.T"/></x>
	<f a="">
		<t path="Map">
			<c path="String"/>
			<c path="ceramic.ConvertMap.T"/>
		</t>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="26"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<c path="ceramic.ConvertMap.T"/>
	</t>
	<x path="haxe.DynamicAccess"><c path="ceramic.ConvertMap.T"/></x>
</f></fieldToBasic>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.ConvertTexture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ConvertTexture.hx">
		<implements path="ceramic.ConvertField">
			<c path="String"/>
			<c path="ceramic.Texture"/>
		</implements>
		<basicToField public="1" set="method" line="7"><f a="instance:field:assets:basic:done">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Assets"/>
	<c path="String"/>
	<f a="">
		<c path="ceramic.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></basicToField>
		<fieldToBasic public="1" set="method" line="20"><f a="instance:field:value">
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<c path="ceramic.Texture"/>
	<c path="String"/>
</f></fieldToBasic>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Csv" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Csv.hx">
		<parse public="1" set="method" line="16" static="1"><f a="csv">
	<c path="String"/>
	<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
</f></parse>
		<stringify public="1" set="method" line="171" static="1"><f a="items:?fields">
	<c path="Array"><d/></c>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
</f></stringify>
		<warning set="method" line="224" static="1"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></warning>
		<haxe_doc>* Utilities to parse CSV and related</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.CustomAssetKind" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/CustomAssetKind.hx">
		<kind public="1"><c path="String"/></kind>
		<add public="1"><f a="assets:name:variant:options">
	<c path="ceramic.Assets"/>
	<c path="String"/>
	<c path="String"/>
	<t path="ceramic.AssetOptions"/>
	<x path="Void"/>
</f></add>
		<extensions public="1"><c path="Array"><c path="String"/></c></extensions>
		<dir public="1"><x path="Bool"/></dir>
		<types public="1"><c path="Array"><c path="String"/></c></types>
		<new public="1" set="method" line="4">
			<f a="kind:add:extensions:dir:types">
				<c path="String"/>
				<f a="assets:name:variant:options">
					<c path="ceramic.Assets"/>
					<c path="String"/>
					<c path="String"/>
					<t path="ceramic.AssetOptions"/>
					<x path="Void"/>
				</f>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.DatabaseAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/DatabaseAsset.hx">
		<extends path="ceramic.Asset"/>
		<invalidateDatabase public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateDatabase>
		<database public="1" expr="null" line="8">
			<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</database>
		<unobservedDatabase>
			<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
			<haxe_doc></haxe_doc>
		</unobservedDatabase>
		<_dox_event_databaseChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
				<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when database field changes.</haxe_doc>
		</_dox_event_databaseChange>
		<emitDatabaseChange set="method" line="1095">
			<f a="current:previous">
				<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
				<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when database field changes.</haxe_doc>
		</emitDatabaseChange>
		<onDatabaseChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
					<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when database field changes.</haxe_doc>
		</onDatabaseChange>
		<onceDatabaseChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
					<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when database field changes.</haxe_doc>
		</onceDatabaseChange>
		<offDatabaseChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
					<c path="Array"><x path="haxe.DynamicAccess"><c path="String"/></x></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when database field changes.</haxe_doc>
		</offDatabaseChange>
		<listensDatabaseChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when database field changes.</haxe_doc>
		</listensDatabaseChange>
		<load public="1" set="method" line="16" override="1"><f a=""><x path="Void"/></f></load>
		<assetFilesDidChange set="method" line="67" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="88" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="10"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.DoubleClick" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/DoubleClick.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<_dox_event_doubleClick public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_doubleClick>
		<emitDoubleClick set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>doubleClick event</haxe_doc>
		</emitDoubleClick>
		<onDoubleClick public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>doubleClick event</haxe_doc>
		</onDoubleClick>
		<onceDoubleClick public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>doubleClick event</haxe_doc>
		</onceDoubleClick>
		<offDoubleClick public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>doubleClick event</haxe_doc>
		</offDoubleClick>
		<listensDoubleClick public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to doubleClick event</haxe_doc>
		</listensDoubleClick>
		<threshold public="1" expr="4.0" line="13">
			<x path="Float"/>
			<meta><m n=":value"><e>4.0</e></m></meta>
		</threshold>
		<maxDelay public="1" expr="0.4" line="15">
			<x path="Float"/>
			<meta><m n=":value"><e>0.4</e></m></meta>
		</maxDelay>
		<entity public="1">
			<c path="ceramic.Visual"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<pressed expr="false" line="21">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pressed>
		<firstClickTime expr="-1" line="23">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</firstClickTime>
		<pointerStartX expr="0.0" line="25">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</pointerStartX>
		<pointerStartY expr="0.0" line="26">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</pointerStartY>
		<bindAsComponent set="method" line="30"><f a=""><x path="Void"/></f></bindAsComponent>
		<cancel public="1" set="method" line="42"><f a=""><x path="Void"/></f></cancel>
		<handlePointerDown set="method" line="52"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerDown>
		<handlePointerUp set="method" line="72"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerUp>
		<handlePointerMove set="method" line="88"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerMove>
		<handleBlur set="method" line="98"><f a=""><x path="Void"/></f></handleBlur>
		<setEntity set="method" line="5">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="5">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<enum path="ceramic.Easing" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Easing.hx">
		<NONE/>
		<LINEAR/>
		<BACK_EASE_IN/>
		<BACK_EASE_IN_OUT/>
		<BACK_EASE_OUT/>
		<QUAD_EASE_IN/>
		<QUAD_EASE_IN_OUT/>
		<QUAD_EASE_OUT/>
		<CUBIC_EASE_IN/>
		<CUBIC_EASE_IN_OUT/>
		<CUBIC_EASE_OUT/>
		<QUART_EASE_IN/>
		<QUART_EASE_IN_OUT/>
		<QUART_EASE_OUT/>
		<QUINT_EASE_IN/>
		<QUINT_EASE_IN_OUT/>
		<QUINT_EASE_OUT/>
		<BOUNCE_EASE_IN/>
		<BOUNCE_EASE_IN_OUT/>
		<BOUNCE_EASE_OUT/>
		<ELASTIC_EASE_IN/>
		<ELASTIC_EASE_IN_OUT/>
		<ELASTIC_EASE_OUT/>
		<EXPO_EASE_IN/>
		<EXPO_EASE_IN_OUT/>
		<EXPO_EASE_OUT/>
		<SINE_EASE_IN/>
		<SINE_EASE_IN_OUT/>
		<SINE_EASE_OUT/>
		<BEZIER a="x1:y1:x2:y2">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</BEZIER>
		<CUSTOM a="easing"><f a="">
	<x path="Float"/>
	<x path="Float"/>
</f></CUSTOM>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<class path="ceramic.EasingUtils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/EasingUtils.hx">
		<_emptyArray expr="[]" line="5" static="1">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_emptyArray>
		<easingFromString public="1" set="method" line="7" static="1"><f a="str">
	<c path="String"/>
	<e path="ceramic.Easing"/>
</f></easingFromString>
		<easingToString public="1" set="method" line="15" static="1"><f a="easing">
	<e path="ceramic.Easing"/>
	<c path="String"/>
</f></easingToString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.TextInputDelegate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextInputDelegate.hx" interface="1">
		<textInputClosestPositionInLine public="1" set="method">
			<f a="fromPosition:fromLine:toLine">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the position in `toLine` which is closest
     * to the position in `fromLine`/`fromPosition` (in X coordinates).
     * Positions are relative to their line.</haxe_doc>
		</textInputClosestPositionInLine>
		<textInputNumberOfLines public="1" set="method"><f a=""><x path="Int"/></f></textInputNumberOfLines>
		<textInputIndexForPosInLine public="1" set="method"><f a="lineNumber:lineOffset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></textInputIndexForPosInLine>
		<textInputLineForIndex public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></textInputLineForIndex>
		<textInputPosInLineForIndex public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></textInputPosInLineForIndex>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.EditText" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/EditText.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.TextInputDelegate"/>
		<implements path="ceramic.Component"/>
		<_point expr="new Point()" line="13" static="1">
			<c path="ceramic.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
		</_point>
		<_activeEditTextInput expr="null" line="15" static="1">
			<c path="ceramic.EditText"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_activeEditTextInput>
		<_dox_event_update public="1" set="method" line="637">
			<f a="content">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_update>
		<emitUpdate set="method" line="1095">
			<f a="content">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>update event</haxe_doc>
		</emitUpdate>
		<onUpdate public="1" set="method" line="1199">
			<f a="owner:handleContent">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="content">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onUpdate>
		<onceUpdate public="1" set="method" line="1298">
			<f a="owner:handleContent">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="content">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onceUpdate>
		<offUpdate public="1" set="method" line="1368">
			<f a="?handleContent">
				<f a="content">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</offUpdate>
		<listensUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to update event</haxe_doc>
		</listensUpdate>
		<_dox_event_start public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_start>
		<emitStart set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>start event</haxe_doc>
		</emitStart>
		<onStart public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>start event</haxe_doc>
		</onStart>
		<onceStart public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>start event</haxe_doc>
		</onceStart>
		<offStart public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>start event</haxe_doc>
		</offStart>
		<listensStart public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to start event</haxe_doc>
		</listensStart>
		<_dox_event_submit public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_submit>
		<emitSubmit set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>submit event</haxe_doc>
		</emitSubmit>
		<onSubmit public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>submit event</haxe_doc>
		</onSubmit>
		<onceSubmit public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>submit event</haxe_doc>
		</onceSubmit>
		<offSubmit public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>submit event</haxe_doc>
		</offSubmit>
		<listensSubmit public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to submit event</haxe_doc>
		</listensSubmit>
		<_dox_event_stop public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_stop>
		<emitStop set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>stop event</haxe_doc>
		</emitStop>
		<onStop public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>stop event</haxe_doc>
		</onStop>
		<onceStop public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>stop event</haxe_doc>
		</onceStop>
		<offStop public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>stop event</haxe_doc>
		</offStop>
		<listensStop public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to stop event</haxe_doc>
		</listensStop>
		<entity public="1">
			<c path="ceramic.Text"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<multiline public="1" expr="false" line="31">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</multiline>
		<editing public="1" get="accessor" set="null"><x path="Bool"/></editing>
		<get_editing set="method" line="34"><f a=""><x path="Bool"/></f></get_editing>
		<selectionColor public="1" set="accessor"><x path="ceramic.Color"/></selectionColor>
		<set_selectionColor set="method" line="39"><f a="selectionColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_selectionColor>
		<textCursorColor public="1" set="accessor"><x path="ceramic.Color"/></textCursorColor>
		<set_textCursorColor set="method" line="47"><f a="textCursorColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_textCursorColor>
		<textCursorOffsetX public="1" set="accessor"><x path="Float"/></textCursorOffsetX>
		<set_textCursorOffsetX set="method" line="55"><f a="textCursorOffsetX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_textCursorOffsetX>
		<textCursorOffsetY public="1" set="accessor"><x path="Float"/></textCursorOffsetY>
		<set_textCursorOffsetY set="method" line="63"><f a="textCursorOffsetY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_textCursorOffsetY>
		<textCursorHeightFactor public="1" set="accessor"><x path="Float"/></textCursorHeightFactor>
		<set_textCursorHeightFactor set="method" line="71"><f a="textCursorHeightFactor">
	<x path="Float"/>
	<x path="Float"/>
</f></set_textCursorHeightFactor>
		<disabled public="1" set="accessor" expr="false" line="78">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</disabled>
		<set_disabled set="method" line="79"><f a="disabled">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_disabled>
		<container public="1" set="accessor" expr="null" line="91">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Optional container on which pointer events are bound</haxe_doc>
		</container>
		<set_container set="method" line="92"><f a="container">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
</f></set_container>
		<selectText public="1" set="null" expr="null" line="106">
			<c path="ceramic.SelectText"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* SelectText instance used internally to manage text selection.
     * Will be defined after component has been assigned to an entity.</haxe_doc>
		</selectText>
		<boundContainer expr="null" line="110">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</boundContainer>
		<selectionBackgrounds expr="[]" line="112">
			<c path="Array"><c path="ceramic.Quad"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</selectionBackgrounds>
		<inputActive expr="false" line="114">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</inputActive>
		<willUpdateSelection expr="false" line="116">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</willUpdateSelection>
		<textCursor expr="null" line="118">
			<c path="ceramic.Quad"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</textCursor>
		<textCursorToggleVisibilityTime expr="1.0" line="120">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</textCursorToggleVisibilityTime>
		<bindAsComponent set="method" line="137"><f a=""><x path="Void"/></f></bindAsComponent>
		<startInput public="1" set="method" line="160">
			<f a="?selectionStart:?selectionEnd" v="-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ selectionEnd : -1, selectionStart : -1 }</e></m></meta>
		</startInput>
		<stopInput public="1" set="method" line="229"><f a=""><x path="Void"/></f></stopInput>
		<updateText public="1" set="method" line="253"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></updateText>
		<focus public="1" set="method" line="261"><f a=""><x path="Void"/></f></focus>
		<handleStop set="method" line="281"><f a=""><x path="Void"/></f></handleStop>
		<handleEnter set="method" line="287"><f a=""><x path="Void"/></f></handleEnter>
		<handleEscape set="method" line="296"><f a=""><x path="Void"/></f></handleEscape>
		<updateFromTextInput set="method" line="302"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></updateFromTextInput>
		<updateFromSelection set="method" line="312"><f a="selectionStart:selectionEnd:inverted">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></updateFromSelection>
		<updateFromInputSelection set="method" line="318"><f a="selectionStart:selectionEnd">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateFromInputSelection>
		<textInputClosestPositionInLine public="1" set="method" line="327"><f a="fromPosition:fromLine:toLine">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></textInputClosestPositionInLine>
		<textInputNumberOfLines public="1" set="method" line="336"><f a=""><x path="Int"/></f></textInputNumberOfLines>
		<textInputIndexForPosInLine public="1" set="method" line="345"><f a="lineNumber:lineOffset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></textInputIndexForPosInLine>
		<textInputLineForIndex public="1" set="method" line="351"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></textInputLineForIndex>
		<textInputPosInLineForIndex public="1" set="method" line="357"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></textInputPosInLineForIndex>
		<bindPointerEvents set="method" line="365"><f a=""><x path="Void"/></f></bindPointerEvents>
		<handlePointerDown set="method" line="385"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerDown>
		<handleAppUpdate set="method" line="391"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></handleAppUpdate>
		<bindKeyBindings set="method" line="402"><f a=""><x path="Void"/></f></bindKeyBindings>
		<destroy public="1" set="method" line="447" override="1"><f a=""><x path="Void"/></f></destroy>
		<setEntity set="method" line="9">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="9">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="124">
			<f a="selectionColor:textCursorColor:?textCursorOffsetX:?textCursorOffsetY:?textCursorHeightFactor" v="::0:0:1">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ textCursorHeightFactor : 1, textCursorOffsetY : 0, textCursorOffsetX : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.Either" params="T1:T2" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Either.hx">
		<from>
			<icast><c path="ceramic.Either.T1"/></icast>
			<icast><c path="ceramic.Either.T2"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="ceramic.Either.T1"/></icast>
			<icast><c path="ceramic.Either.T2"/></icast>
		</to>
		<haxe_doc>* Useful to limit a Dynamic function argument's type to the specified
 * type parameters. This does NOT make the use of Dynamic type-safe in
 * any way (the underlying type is still Dynamic and Std.isOfType() checks +
 * casts are necessary).</haxe_doc>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="ceramic._Either.Either_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Either.hx" private="1" module="ceramic.Either" extern="1" final="1"><meta><m n=":hxGen"/></meta></class></impl>
	</abstract>
	<class path="ceramic._Either.Either_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Either.hx" private="1" module="ceramic.Either" extern="1" final="1"><meta><m n=":hxGen"/></meta></class>
	<class path="ceramic.Enums" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Enums.hx">
		<isEnumWithName public="1" params="T" set="method" static="1">
			<f a="valueExpr:nameExpr">
				<x path="Enum"><c path="isEnumWithName.T"/></x>
				<d/>
				<d/>
			</f>
			<haxe_doc>* Returns true if the given enum value has its name equal to the given name</haxe_doc>
		</isEnumWithName>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.Equal" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Equal.hx">
		<equal public="1" set="method" line="13" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Equality check (deep equality only working on arrays for now)
     * @param a
     * @param b
     * @return Bool</haxe_doc>
		</equal>
		<arrayEqual public="1" get="inline" set="null" line="30" static="1">
			<f a="a:b">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
			</f>
			<overloads><arrayEqual public="1" get="inline" set="null" line="37"><f a="a:b">
	<c path="Array"><x path="Any"/></c>
	<c path="Array"><x path="Any"/></c>
	<x path="Bool"/>
</f></arrayEqual></overloads>
		</arrayEqual>
		<_arrayEqual public="1" set="method" line="41" static="1"><f a="a:b">
	<c path="Array"><x path="Any"/></c>
	<c path="Array"><x path="Any"/></c>
	<x path="Bool"/>
</f></_arrayEqual>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.Errors" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Errors.hx">
		<handleUncaughtError set="method" line="13" static="1"><f a="e">
	<d/>
	<x path="Void"/>
</f></handleUncaughtError>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.Extensions" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Extensions.hx">
		<unsafeGet public="1" params="T" get="inline" set="null" line="12" static="1">
			<f a="array:index">
				<c path="Array"><c path="unsafeGet.T"/></c>
				<x path="Int"/>
				<c path="unsafeGet.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</unsafeGet>
		<unsafeSet public="1" params="T" get="inline" set="null" line="29" static="1">
			<f a="array:index:value">
				<c path="Array"><c path="unsafeSet.T"/></c>
				<x path="Int"/>
				<c path="unsafeSet.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</unsafeSet>
		<setArrayLength public="1" params="T" get="inline" set="null" line="46" static="1"><f a="array:length">
	<c path="Array"><c path="setArrayLength.T"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setArrayLength>
		<randomElement public="1" params="T" get="inline" set="null" line="66" static="1">
			<f a="array">
				<c path="Array"><c path="randomElement.T"/></c>
				<c path="randomElement.T"/>
			</f>
			<haxe_doc>* Return a random element contained in the given array</haxe_doc>
		</randomElement>
		<randomElementExcept public="1" params="T" set="method" line="79" static="1">
			<f a="array:except:?unsafe" v="::false">
				<c path="Array"><c path="randomElementExcept.T"/></c>
				<c path="randomElementExcept.T"/>
				<x path="Bool"/>
				<c path="randomElementExcept.T"/>
			</f>
			<meta><m n=":value"><e>{ unsafe : false }</e></m></meta>
			<haxe_doc>* Return a random element contained in the given array that is not equal to the `except` arg.
     * @param array  The array in which we extract the element from
     * @param except The element we don't want
     * @param unsafe If set to `true`, will prevent allocating a new array (and may be faster) but will loop forever if there is no element except the one we don't want
     * @return The random element or `null` if nothing was found</haxe_doc>
		</randomElementExcept>
		<randomElementMatchingValidator public="1" params="T" set="method" line="120" static="1">
			<f a="array:validator">
				<c path="Array"><c path="randomElementMatchingValidator.T"/></c>
				<f a="">
					<c path="randomElementMatchingValidator.T"/>
					<x path="Bool"/>
				</f>
				<c path="randomElementMatchingValidator.T"/>
			</f>
			<haxe_doc>* Return a random element contained in the given array that is validated by the provided validator.
     * If no item is valid, returns null.
     * @param array  The array in which we extract the element from
     * @param validator A function that returns true if the item is valid, false if not
     * @return The random element or `null` if nothing was found</haxe_doc>
		</randomElementMatchingValidator>
		<shuffle public="1" params="T" set="method" line="145" static="1">
			<f a="arr">
				<c path="Array"><c path="shuffle.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shuffle an Array. This operation affects the array in place.
     * The shuffle algorithm used is a variation of the [Fisher Yates Shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)</haxe_doc>
		</shuffle>
		<swapElements public="1" params="T" set="method" line="163" static="1"><f a="arr:index0:index1">
	<c path="Array"><c path="swapElements.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapElements>
		<removeNullElements public="1" params="T" set="method" line="171" static="1"><f a="arr">
	<c path="Array"><c path="removeNullElements.T"/></c>
	<x path="Void"/>
</f></removeNullElements>
		<setProperty public="1" params="T" get="inline" set="null" line="207" static="1">
			<f a="instance:field:value">
				<c path="setProperty.T"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setProperty>
		<getProperty public="1" params="T" get="inline" set="null" line="214" static="1">
			<f a="instance:field">
				<c path="getProperty.T"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</getProperty>
		<toBytes public="1" get="inline" set="null" line="224" static="1"><f a="buffer">
	<t path="ceramic.UInt8Array"/>
	<c path="haxe.io.Bytes"/>
</f></toBytes>
		<haxe_doc>* A bunch of static extensions to make life easier.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.FieldInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FieldInfo.hx">
		<fieldInfoMap expr="new Map()" line="13" static="1">
			<t path="Map">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<c path="String"/>
				</t>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</fieldInfoMap>
		<types public="1" set="method" line="15" static="1">
			<f a="targetClass:?recursive" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<c path="String"/>
				</x>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
		</types>
		<typeOf public="1" set="method" line="51" static="1"><f a="targetClass:field">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></typeOf>
		<haxe_doc>* Extract field information from a given class type.
 * This is expected to only work with Entity subclasses marked with @editable, @fieldInfo or @autoFieldInfo
 * or classes using FieldInfoMacro.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.FieldMeta" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FieldMeta.hx">
		<metaMap expr="new Map()" line="10" static="1">
			<t path="Map">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<t path="Map">
						<c path="String"/>
						<d/>
					</t>
				</t>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</metaMap>
		<metaMapRecursive expr="new Map()" line="12" static="1">
			<t path="Map">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<t path="Map">
						<c path="String"/>
						<d/>
					</t>
				</t>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</metaMapRecursive>
		<hasMeta public="1" get="inline" set="null" line="14" static="1">
			<f a="clazz:field:meta:?recursive" v=":::true">
				<x path="Class"><d/></x>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
			<overloads><hasMeta public="1" get="inline" set="null" line="21">
	<f a="targetClass:field:meta:?recursive" v=":::true">
		<c path="String"/>
		<c path="String"/>
		<c path="String"/>
		<x path="Bool"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
</hasMeta></overloads>
		</hasMeta>
		<_hasMeta set="method" line="28" static="1"><f a="clazz:targetClass:field:meta:recursive">
	<x path="Class"><d/></x>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></_hasMeta>
		<getMeta public="1" get="inline" set="null" line="35" static="1">
			<f a="clazz:field:?recursive" v="::true">
				<x path="Class"><d/></x>
				<c path="String"/>
				<x path="Bool"/>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<d/>
				</x>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
			<overloads><getMeta public="1" get="inline" set="null" line="42">
	<f a="targetClass:field:?recursive" v="::true">
		<c path="String"/>
		<c path="String"/>
		<x path="Bool"/>
		<x path="ceramic.ReadOnlyMap">
			<c path="String"/>
			<d/>
		</x>
	</f>
	<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
</getMeta></overloads>
		</getMeta>
		<_getMeta set="method" line="49" static="1"><f a="clazz:targetClass:field:recursive">
	<x path="Class"><d/></x>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<d/>
	</x>
</f></_getMeta>
		<haxe_doc>* Utility to get runtime metadata</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.FileWatcher" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FileWatcher.hx">
		<extends path="ceramic.Entity"/>
		<UPDATE_INTERVAL public="1" expr="1.0" line="13" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</UPDATE_INTERVAL>
		<checkContent expr="true" line="23">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If set to `true`, actual content of files will be compared</haxe_doc>
		</checkContent>
		<watched expr="new Map()" line="25">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic._FileWatcher.WatchedFile"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</watched>
		<timeSinceLastCheck expr="0.0" line="27">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</timeSinceLastCheck>
		<canWatch public="1" set="method" line="47"><f a=""><x path="Bool"/></f></canWatch>
		<watch public="1" set="method" line="68"><f a="path:onUpdate">
	<c path="String"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
</f></watch>
		<destroy public="1" set="method" line="97" override="1"><f a=""><x path="Void"/></f></destroy>
		<tick set="method" line="107"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></tick>
		<isFile set="method" line="159"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isFile>
		<lastModified set="method" line="177"><f a="path">
	<c path="String"/>
	<x path="Float"/>
</f></lastModified>
		<getContent set="method" line="199"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getContent>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A file watcher for ceramic compatible with `interpret.Watcher`.</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic._FileWatcher.WatchedFile" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FileWatcher.hx" private="1" module="ceramic.FileWatcher">
		<updateCallbacks public="1" expr="[]" line="222">
			<c path="Array"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</updateCallbacks>
		<mtime public="1" expr="-1" line="224">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</mtime>
		<content public="1" expr="null" line="226">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</content>
		<new public="1" set="method" line="228"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.FileWatcher</e></m>
		</meta>
	</class>
	<class path="ceramic.Files" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Files.hx">
		<haveSameContent public="1" set="method" line="24" static="1"><f a="filePath1:filePath2">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></haveSameContent>
		<haveSameLastModified public="1" set="method" line="48" static="1"><f a="filePath1:filePath2">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></haveSameLastModified>
		<setToSameLastModified public="1" set="method" line="88" static="1">
			<f a="srcFilePath:dstFilePath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Only works in nodejs for now.</haxe_doc>
		</setToSameLastModified>
		<getFlatDirectory public="1" set="method" line="110" static="1">
			<f a="dir:?excludeSystemFiles:?subCall:?recursive" v=":true:false:true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ recursive : true, subCall : false, excludeSystemFiles : true }</e></m></meta>
		</getFlatDirectory>
		<getLastModified public="1" set="method" line="193" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get file last modified time (in seconds) or `-1` if not available
     * @param path
     * @return Float</haxe_doc>
		</getLastModified>
		<removeEmptyDirectories public="1" set="method" line="215" static="1">
			<f a="dir:?excludeSystemFiles" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ excludeSystemFiles : true }</e></m></meta>
		</removeEmptyDirectories>
		<isEmptyDirectory public="1" set="method" line="240" static="1">
			<f a="dir:?excludeSystemFiles" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ excludeSystemFiles : true }</e></m></meta>
		</isEmptyDirectory>
		<deleteRecursive public="1" set="method" line="262" static="1"><f a="toDelete">
	<c path="String"/>
	<x path="Void"/>
</f></deleteRecursive>
		<getRelativePath public="1" set="method" line="305" static="1"><f a="absolutePath:relativeTo">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getRelativePath>
		<copyFileWithIntermediateDirs public="1" set="method" line="342" static="1"><f a="srcPath:dstPath">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></copyFileWithIntermediateDirs>
		<copyDirectory public="1" set="method" line="361" static="1">
			<f a="srcDir:dstDir:?removeExisting" v="::false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ removeExisting : false }</e></m></meta>
		</copyDirectory>
		<deleteFile public="1" set="method" line="395" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></deleteFile>
		<getContent public="1" set="method" line="421" static="1"><f a="path">
	<c path="String"/>
	<x path="Null"><c path="String"/></x>
</f></getContent>
		<getBytes public="1" set="method" line="448" static="1"><f a="path">
	<c path="String"/>
	<x path="Null"><c path="haxe.io.Bytes"/></x>
</f></getBytes>
		<saveContent public="1" set="method" line="476" static="1"><f a="path:content">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></saveContent>
		<saveBytes public="1" set="method" line="501" static="1"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></saveBytes>
		<createDirectory public="1" set="method" line="527" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></createDirectory>
		<exists public="1" set="method" line="572" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<isDirectory public="1" set="method" line="605" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isDirectory>
		<haxe_doc>* Filesystem-related utilities. Only work on sys targets and/or nodejs depending on the methods</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Quad" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Quad.hx">
		<extends path="ceramic.Visual"/>
		<FLAG_TRANSPARENT final="1" get="inline" set="null" expr="16" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</FLAG_TRANSPARENT>
		<FLAG_ROTATE_FRAME final="1" get="inline" set="null" expr="32" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</FLAG_ROTATE_FRAME>
		<_matrix expr="Visual._matrix" line="14" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>Visual._matrix</e></m></meta>
		</_matrix>
		<_degToRad expr="Visual._degToRad" line="16" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Visual._degToRad</e></m></meta>
		</_degToRad>
		<color public="1" expr="Color.WHITE" line="19">
			<x path="ceramic.Color"/>
			<meta>
				<m n=":value"><e>Color.WHITE</e></m>
				<m n="editable"/>
			</meta>
		</color>
		<transparent public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"/></meta>
			<haxe_doc>* If set to `true`, this quad will be considered
     * transparent thus won't be draw on screen.
     * Children still behave and get drawn as before:
     * they don't inherit this property.</haxe_doc>
		</transparent>
		<get_transparent get="inline" set="null" line="29"><f a=""><x path="Bool"/></f></get_transparent>
		<set_transparent get="inline" set="null" line="32"><f a="transparent">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_transparent>
		<tile public="1" set="accessor" expr="null" line="37">
			<c path="ceramic.TextureTile"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</tile>
		<set_tile set="method" line="38"><f a="tile">
	<c path="ceramic.TextureTile"/>
	<c path="ceramic.TextureTile"/>
</f></set_tile>
		<texture public="1" get="accessor" set="accessor">
			<c path="ceramic.Texture"/>
			<meta><m n="editable"/></meta>
			<haxe_doc>* The texture to use for this Quad object</haxe_doc>
		</texture>
		<get_texture get="inline" set="null" line="69"><f a=""><c path="ceramic.Texture"/></f></get_texture>
		<set_texture get="inline" set="null" line="72"><f a="texture">
	<c path="ceramic.Texture"/>
	<c path="ceramic.Texture"/>
</f></set_texture>
		<_texture expr="null" line="80">
			<c path="ceramic.Texture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_texture>
		<_set_texture set="method" line="81"><f a="texture">
	<c path="ceramic.Texture"/>
	<x path="Void"/>
</f></_set_texture>
		<frameX public="1" expr="-1" line="123">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</frameX>
		<frameY public="1" expr="-1" line="125">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</frameY>
		<frameWidth public="1" set="accessor" expr="-1" line="127">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</frameWidth>
		<set_frameWidth get="inline" set="null" line="128"><f a="frameWidth">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frameWidth>
		<frameHeight public="1" set="accessor" expr="-1" line="138">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</frameHeight>
		<set_frameHeight get="inline" set="null" line="139"><f a="frameHeight">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frameHeight>
		<rotateFrame public="1" get="accessor" set="accessor"><x path="Bool"/></rotateFrame>
		<get_rotateFrame get="inline" set="null" line="150"><f a=""><x path="Bool"/></f></get_rotateFrame>
		<set_rotateFrame get="inline" set="null" line="153"><f a="rotateFrame">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_rotateFrame>
		<destroy public="1" set="method" line="168" override="1"><f a=""><x path="Void"/></f></destroy>
		<frame public="1" get="inline" set="null" line="179"><f a="frameX:frameY:frameWidth:frameHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></frame>
		<isRegular public="1" set="method" line="191">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if this quad is a regular rectangle</haxe_doc>
		</isRegular>
		<computeMatrix set="method" line="205" override="1"><f a=""><x path="Void"/></f></computeMatrix>
		<textureDestroyed set="method" line="219"><f a="_">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></textureDestroyed>
		<new public="1" set="method" line="160"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n="editable"><e>{ implicitSizeUnlessNull : "texture" }</e></m>
		</meta>
	</class>
	<class path="ceramic.Layer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Layer.hx">
		<extends path="ceramic.Quad"/>
		<_dox_event_resize public="1" set="method" line="637">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_resize>
		<emitResize set="method" line="1095">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>resize event</haxe_doc>
		</emitResize>
		<onResize public="1" set="method" line="1199">
			<f a="owner:handleWidthHeight">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="width:height">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>resize event</haxe_doc>
		</onResize>
		<onceResize public="1" set="method" line="1298">
			<f a="owner:handleWidthHeight">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="width:height">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>resize event</haxe_doc>
		</onceResize>
		<offResize public="1" set="method" line="1368">
			<f a="?handleWidthHeight">
				<f a="width:height">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>resize event</haxe_doc>
		</offResize>
		<listensResize public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to resize event</haxe_doc>
		</listensResize>
		<sizeDirty expr="false" line="15">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</sizeDirty>
		<emitResizeIfNeeded set="method" line="25"><f a=""><x path="Void"/></f></emitResizeIfNeeded>
		<willEmitResize set="method" line="36"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitResize>
		<didEmitResize set="method" line="42"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></didEmitResize>
		<set_width set="method" line="48" override="1"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="58" override="1"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Just a regular quad (transparent by default) with a few addition to make it more convenient when used as a layer</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n="editable"><e>{ implicitSizeUnlessNull : "texture" }</e></m>
		</meta>
	</class>
	<class path="ceramic.Filter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Filter.hx">
		<extends path="ceramic.Layer"/>
		<implements path="tracker.Observable"/>
		<_matrix expr="Visual._matrix" line="17" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>Visual._matrix</e></m></meta>
		</_matrix>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Filter"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Filter"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Filter"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Filter"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.Filter"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false" line="131">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<textureId public="1" set="accessor" expr="null" line="24">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If provided, this id will be assigned to `renderTexture.id`.</haxe_doc>
		</textureId>
		<set_textureId set="method" line="25"><f a="textureId">
	<c path="String"/>
	<c path="String"/>
</f></set_textureId>
		<mesh public="1" set="accessor" expr="null" line="41">
			<c path="ceramic.Mesh"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* By default, the render texture managed by this filter is
     * rendered via itself, assigned to the `texture` field.
     * If you provide a `Mesh` instance, that mesh will be added as
     * a child of the filter and the texture will be rendered via
     * that mesh instead of itself. This opens the door to more advanced
     * post-processing in shaders.</haxe_doc>
		</mesh>
		<set_mesh set="method" line="42"><f a="mesh">
	<c path="ceramic.Mesh"/>
	<c path="ceramic.Mesh"/>
</f></set_mesh>
		<meshDirty expr="false" line="64">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</meshDirty>
		<destroyMeshOnRemove public="1" expr="true" line="71">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If set to `true`, when assigning `null` or
     * a new mesh intance to the `mesh` field will destroy
     * any existing mesh previously assigned.</haxe_doc>
		</destroyMeshOnRemove>
		<content public="1" set="null">
			<c path="ceramic.Quad"/>
			<haxe_doc>* The content in which you are expected to add visuals
     * so that they are rendered through the filter</haxe_doc>
		</content>
		<hitVisual public="1" set="accessor" expr="null" line="84">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If provided, visuals in content will react to hit tests
     * and touch events as if they were inside this hit visual.
     * By default, `hitVisual` is the `Filter` instance itself.</haxe_doc>
		</hitVisual>
		<set_hitVisual set="method" line="85"><f a="hitVisual">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
</f></set_hitVisual>
		<enabled public="1" set="accessor" expr="true" line="102">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If `enabled` is set to `false`, no render texture will be used.
     * The children will be displayed on screen directly.
     * Useful to toggle a filter without touching visuals hierarchy.</haxe_doc>
		</enabled>
		<set_enabled set="method" line="103"><f a="enabled">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<textureFilter public="1" set="accessor" expr="LINEAR" line="114">
			<e path="ceramic.TextureFilter"/>
			<meta><m n=":value"><e>LINEAR</e></m></meta>
			<haxe_doc>* Texture filter</haxe_doc>
		</textureFilter>
		<set_textureFilter set="method" line="115"><f a="textureFilter">
	<e path="ceramic.TextureFilter"/>
	<e path="ceramic.TextureFilter"/>
</f></set_textureFilter>
		<depthBuffer public="1" set="accessor" expr="true" line="125">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Texture depth</haxe_doc>
		</depthBuffer>
		<set_depthBuffer set="method" line="126"><f a="depthBuffer">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_depthBuffer>
		<stencil public="1" set="accessor" expr="true" line="136">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Texture stencil</haxe_doc>
		</stencil>
		<set_stencil set="method" line="137"><f a="stencil">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_stencil>
		<antialiasing public="1" set="accessor" expr="0" line="147">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Texture antialiasing</haxe_doc>
		</antialiasing>
		<set_antialiasing set="method" line="148"><f a="antialiasing">
	<x path="Int"/>
	<x path="Int"/>
</f></set_antialiasing>
		<autoRender public="1" set="accessor" expr="true" line="158">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Auto render?</haxe_doc>
		</autoRender>
		<set_autoRender set="method" line="159"><f a="autoRender">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoRender>
		<explicitRender public="1" set="accessor" expr="false" line="172">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If set to true, this filter will not render automatically its children.
     * It will instead set their `active` state to `false` unless explicitly rendered.
     * Note that when using explicit render, `active` property on children is managed
     * by this filter.</haxe_doc>
		</explicitRender>
		<set_explicitRender set="method" line="173"><f a="explicitRender">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_explicitRender>
		<textureTilePacker public="1" set="accessor" expr="null" line="180">
			<c path="ceramic.TextureTilePacker"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</textureTilePacker>
		<set_textureTilePacker set="method" line="181"><f a="textureTilePacker">
	<c path="ceramic.TextureTilePacker"/>
	<c path="ceramic.TextureTilePacker"/>
</f></set_textureTilePacker>
		<textureTile public="1" set="null" expr="null" line="197">
			<c path="ceramic.TextureTile"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</textureTile>
		<invalidateRenderTexture public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateRenderTexture>
		<renderTexture public="1" set="null" expr="null" line="199">
			<c path="ceramic.RenderTexture"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</renderTexture>
		<unobservedRenderTexture>
			<c path="ceramic.RenderTexture"/>
			<haxe_doc></haxe_doc>
		</unobservedRenderTexture>
		<_dox_event_renderTextureChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.RenderTexture"/>
				<c path="ceramic.RenderTexture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when renderTexture field changes.</haxe_doc>
		</_dox_event_renderTextureChange>
		<emitRenderTextureChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.RenderTexture"/>
				<c path="ceramic.RenderTexture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when renderTexture field changes.</haxe_doc>
		</emitRenderTextureChange>
		<onRenderTextureChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.RenderTexture"/>
					<c path="ceramic.RenderTexture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when renderTexture field changes.</haxe_doc>
		</onRenderTextureChange>
		<onceRenderTextureChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.RenderTexture"/>
					<c path="ceramic.RenderTexture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when renderTexture field changes.</haxe_doc>
		</onceRenderTextureChange>
		<offRenderTextureChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.RenderTexture"/>
					<c path="ceramic.RenderTexture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when renderTexture field changes.</haxe_doc>
		</offRenderTextureChange>
		<listensRenderTextureChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when renderTexture field changes.</haxe_doc>
		</listensRenderTextureChange>
		<density public="1" set="accessor" expr="-1" line="201">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</density>
		<set_density set="method" line="202"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<explicitRenderState expr="0" line="212">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal flag used to keep track of current explicit render state</haxe_doc>
		</explicitRenderState>
		<explicitRenderPendingResultCallbacks expr="null" line="217">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Used internally when concurrent renders are trigerred</haxe_doc>
		</explicitRenderPendingResultCallbacks>
		<handleTexturesDensityChange set="method" line="240"><f a="density:prevDensity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></handleTexturesDensityChange>
		<updateRenderTextureAndContent set="method" line="249"><f a="filterWidth:filterHeight:density:depthBuffer:stencil:antialiasing">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateRenderTextureAndContent>
		<render public="1" set="method" line="329"><f a="?done">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></render>
		<visualInContentHits public="1" set="method" line="453"><f a="visual:x:y">
	<c path="ceramic.Visual"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></visualInContentHits>
		<set_width set="method" line="532" override="1"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="538" override="1"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<computeContent public="1" set="method" line="544" override="1"><f a=""><x path="Void"/></f></computeContent>
		<destroy public="1" set="method" line="549" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="221"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A visuals that displays its children through a filter. A filter draws its children into a `RenderTexture`
 * allowing to process the result through a shader, apply blending or alpha on the final result...</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.Flags" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Flags.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="ceramic._Flags.Flags_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Flags.hx" private="1" module="ceramic.Flags" final="1">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a=""><x path="ceramic.Flags"/></f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<toInt public="1" get="inline" set="null" line="11" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></toInt>
	<fromInt public="1" get="inline" set="null" line="15" static="1"><f a="value">
	<x path="Int"/>
	<x path="ceramic.Flags"/>
</f></fromInt>
	<bool public="1" get="inline" set="null" line="19" static="1"><f a="this:bit">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></bool>
	<setBool public="1" get="inline" set="null" line="26" static="1"><f a="this:bit:bool">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setBool>
	<getBool public="1" get="inline" set="null" line="33" static="1"><f a="flags:bit">
	<x path="ceramic.Flags"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getBool>
	<setBoolAndGetFlags public="1" get="inline" set="null" line="39" static="1"><f a="flags:bit:bool">
	<x path="ceramic.Flags"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></setBoolAndGetFlags>
	<fromValues public="1" get="inline" set="null" line="46" static="1">
		<f a="flag0">
			<x path="Bool"/>
			<x path="ceramic.Flags"/>
		</f>
		<overloads>
			<fromValues public="1" get="inline" set="null" line="86"><f a="flag0:flag1:flag2:flag3:flag4:flag5:flag6:flag7">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			<fromValues public="1" get="inline" set="null" line="79"><f a="flag0:flag1:flag2:flag3:flag4:flag5:flag6">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			<fromValues public="1" get="inline" set="null" line="72"><f a="flag0:flag1:flag2:flag3:flag4:flag5">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			<fromValues public="1" get="inline" set="null" line="65"><f a="flag0:flag1:flag2:flag3:flag4">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			<fromValues public="1" get="inline" set="null" line="58"><f a="flag0:flag1:flag2:flag3">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			<fromValues public="1" get="inline" set="null" line="54"><f a="flag0:flag1:flag2">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			<fromValues public="1" get="inline" set="null" line="50"><f a="flag0:flag1">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
		</overloads>
	</fromValues>
	<_fromValues get="inline" set="null" line="93" static="1"><f a="flag0:flag1:flag2:flag3:flag4:flag5:flag6:flag7">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></_fromValues>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._Flags.Flags_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Flags.hx" private="1" module="ceramic.Flags" final="1">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a=""><x path="ceramic.Flags"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<toInt public="1" get="inline" set="null" line="11" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></toInt>
		<fromInt public="1" get="inline" set="null" line="15" static="1"><f a="value">
	<x path="Int"/>
	<x path="ceramic.Flags"/>
</f></fromInt>
		<bool public="1" get="inline" set="null" line="19" static="1"><f a="this:bit">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></bool>
		<setBool public="1" get="inline" set="null" line="26" static="1"><f a="this:bit:bool">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setBool>
		<getBool public="1" get="inline" set="null" line="33" static="1"><f a="flags:bit">
	<x path="ceramic.Flags"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getBool>
		<setBoolAndGetFlags public="1" get="inline" set="null" line="39" static="1"><f a="flags:bit:bool">
	<x path="ceramic.Flags"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></setBoolAndGetFlags>
		<fromValues public="1" get="inline" set="null" line="46" static="1">
			<f a="flag0">
				<x path="Bool"/>
				<x path="ceramic.Flags"/>
			</f>
			<overloads>
				<fromValues public="1" get="inline" set="null" line="86"><f a="flag0:flag1:flag2:flag3:flag4:flag5:flag6:flag7">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
				<fromValues public="1" get="inline" set="null" line="79"><f a="flag0:flag1:flag2:flag3:flag4:flag5:flag6">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
				<fromValues public="1" get="inline" set="null" line="72"><f a="flag0:flag1:flag2:flag3:flag4:flag5">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
				<fromValues public="1" get="inline" set="null" line="65"><f a="flag0:flag1:flag2:flag3:flag4">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
				<fromValues public="1" get="inline" set="null" line="58"><f a="flag0:flag1:flag2:flag3">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
				<fromValues public="1" get="inline" set="null" line="54"><f a="flag0:flag1:flag2">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
				<fromValues public="1" get="inline" set="null" line="50"><f a="flag0:flag1">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></fromValues>
			</overloads>
		</fromValues>
		<_fromValues get="inline" set="null" line="93" static="1"><f a="flag0:flag1:flag2:flag3:flag4:flag5:flag6:flag7">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="ceramic.Flags"/>
</f></_fromValues>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="ceramic.Float32Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Float32Array.hx">
		<t path="backend.Float32Array"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="ceramic.FontAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FontAsset.hx">
		<extends path="ceramic.Asset"/>
		<_dox_event_replaceFont public="1" set="method" line="637">
			<f a="newFont:prevFont">
				<c path="ceramic.BitmapFont"/>
				<c path="ceramic.BitmapFont"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_replaceFont>
		<emitReplaceFont set="method" line="1095">
			<f a="newFont:prevFont">
				<c path="ceramic.BitmapFont"/>
				<c path="ceramic.BitmapFont"/>
				<x path="Void"/>
			</f>
			<haxe_doc>replaceFont event</haxe_doc>
		</emitReplaceFont>
		<onReplaceFont public="1" set="method" line="1199">
			<f a="owner:handleNewFontPrevFont">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newFont:prevFont">
					<c path="ceramic.BitmapFont"/>
					<c path="ceramic.BitmapFont"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceFont event</haxe_doc>
		</onReplaceFont>
		<onceReplaceFont public="1" set="method" line="1298">
			<f a="owner:handleNewFontPrevFont">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newFont:prevFont">
					<c path="ceramic.BitmapFont"/>
					<c path="ceramic.BitmapFont"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceFont event</haxe_doc>
		</onceReplaceFont>
		<offReplaceFont public="1" set="method" line="1368">
			<f a="?handleNewFontPrevFont">
				<f a="newFont:prevFont">
					<c path="ceramic.BitmapFont"/>
					<c path="ceramic.BitmapFont"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceFont event</haxe_doc>
		</offReplaceFont>
		<listensReplaceFont public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to replaceFont event</haxe_doc>
		</listensReplaceFont>
		<fontData public="1" expr="null" line="14">
			<c path="ceramic.BitmapFontData"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</fontData>
		<pages public="1" expr="null" line="16">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.Texture"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</pages>
		<invalidateFont public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateFont>
		<font public="1" expr="null" line="18">
			<c path="ceramic.BitmapFont"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</font>
		<unobservedFont>
			<c path="ceramic.BitmapFont"/>
			<haxe_doc></haxe_doc>
		</unobservedFont>
		<_dox_event_fontChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.BitmapFont"/>
				<c path="ceramic.BitmapFont"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when font field changes.</haxe_doc>
		</_dox_event_fontChange>
		<emitFontChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.BitmapFont"/>
				<c path="ceramic.BitmapFont"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when font field changes.</haxe_doc>
		</emitFontChange>
		<onFontChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.BitmapFont"/>
					<c path="ceramic.BitmapFont"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when font field changes.</haxe_doc>
		</onFontChange>
		<onceFontChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.BitmapFont"/>
					<c path="ceramic.BitmapFont"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when font field changes.</haxe_doc>
		</onceFontChange>
		<offFontChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.BitmapFont"/>
					<c path="ceramic.BitmapFont"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when font field changes.</haxe_doc>
		</offFontChange>
		<listensFontChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when font field changes.</haxe_doc>
		</listensFontChange>
		<load public="1" set="method" line="31" override="1"><f a=""><x path="Void"/></f></load>
		<texturesDensityDidChange set="method" line="196" override="1"><f a="newDensity:prevDensity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texturesDensityDidChange>
		<checkTexturesDensity set="method" line="207"><f a=""><x path="Void"/></f></checkTexturesDensity>
		<assetFilesDidChange set="method" line="222" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="243" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="22"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Value" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Value.hx">
		<value public="1"><c path="ceramic.Value.T"/></value>
		<new public="1" set="method" line="10"><f a="?value">
	<c path="ceramic.Value.T"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* An object that can hold any value</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Fragment" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Fragment.hx">
		<extends path="ceramic.Layer"/>
		<basicTypes expr="[&quot;Bool&quot; =&gt; true, &quot;Int&quot; =&gt; true, &quot;Float&quot; =&gt; true, &quot;String&quot; =&gt; true, &quot;ceramic.Color&quot; =&gt; true, &quot;ceramic.ScriptContent&quot; =&gt; true]" line="136" static="1">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<meta><m n=":value"><e><![CDATA[["Bool" => true, "Int" => true, "Float" => true, "String" => true, "ceramic.Color" => true, "ceramic.ScriptContent" => true]]]></e></m></meta>
		</basicTypes>
		<cachedFragmentData expr="new Map()" line="147" static="1">
			<t path="Map">
				<c path="String"/>
				<t path="ceramic.FragmentData"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</cachedFragmentData>
		<cacheData public="1" set="method" line="149" static="1"><f a="fragmentData">
	<t path="ceramic.FragmentData"/>
	<x path="Void"/>
</f></cacheData>
		<getData public="1" set="method" line="162" static="1">
			<f a="fragmentId">
				<c path="String"/>
				<x path="Null"><t path="ceramic.FragmentData"/></x>
			</f>
			<haxe_doc><![CDATA[* A static helper to get a fragment data object from fragment id.
     * Fragments need to be cached first with `cacheFragmentData()`,
     * unless an editor instance is being active.
     * @param fragmentId
     * @return Null<FragmentData>]]></haxe_doc>
		</getData>
		<_trackResult expr="new Value&lt;TimelineTrack&lt;TimelineKeyframe&gt;&gt;()" line="948" static="1">
			<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
			<meta><m n=":value"><e><![CDATA[new Value<TimelineTrack<TimelineKeyframe>>()]]></e></m></meta>
			<haxe_doc>* Internal value used to hold timeline tracks created from `createTrack` events</haxe_doc>
		</_trackResult>
		<_keyframeResult expr="new Value&lt;TimelineKeyframe&gt;()" line="953" static="1">
			<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
			<meta><m n=":value"><e><![CDATA[new Value<TimelineKeyframe>()]]></e></m></meta>
			<haxe_doc>* Internal value used to hold timeline keyframes created from `createKeyframe` events</haxe_doc>
		</_keyframeResult>
		<_usedKeyframes expr="[]" line="959" static="1">
			<c path="Array"><c path="ceramic.TimelineKeyframe"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal list used to keep track of used keyframes when updating a track,
     * then be able to remove the keyframes that are not used anymore</haxe_doc>
		</_usedKeyframes>
		<_dox_event_floatAChange public="1" set="method" line="637">
			<f a="floatA:prevFloatA">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_floatAChange>
		<emitFloatAChange set="method" line="1095">
			<f a="floatA:prevFloatA">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>floatAChange event</haxe_doc>
		</emitFloatAChange>
		<onFloatAChange public="1" set="method" line="1199">
			<f a="owner:handleFloatAPrevFloatA">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatA:prevFloatA">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatAChange event</haxe_doc>
		</onFloatAChange>
		<onceFloatAChange public="1" set="method" line="1298">
			<f a="owner:handleFloatAPrevFloatA">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatA:prevFloatA">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatAChange event</haxe_doc>
		</onceFloatAChange>
		<offFloatAChange public="1" set="method" line="1368">
			<f a="?handleFloatAPrevFloatA">
				<f a="floatA:prevFloatA">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatAChange event</haxe_doc>
		</offFloatAChange>
		<listensFloatAChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to floatAChange event</haxe_doc>
		</listensFloatAChange>
		<_dox_event_floatBChange public="1" set="method" line="637">
			<f a="floatB:prevFloatB">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_floatBChange>
		<emitFloatBChange set="method" line="1095">
			<f a="floatB:prevFloatB">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>floatBChange event</haxe_doc>
		</emitFloatBChange>
		<onFloatBChange public="1" set="method" line="1199">
			<f a="owner:handleFloatBPrevFloatB">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatB:prevFloatB">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatBChange event</haxe_doc>
		</onFloatBChange>
		<onceFloatBChange public="1" set="method" line="1298">
			<f a="owner:handleFloatBPrevFloatB">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatB:prevFloatB">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatBChange event</haxe_doc>
		</onceFloatBChange>
		<offFloatBChange public="1" set="method" line="1368">
			<f a="?handleFloatBPrevFloatB">
				<f a="floatB:prevFloatB">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatBChange event</haxe_doc>
		</offFloatBChange>
		<listensFloatBChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to floatBChange event</haxe_doc>
		</listensFloatBChange>
		<_dox_event_floatCChange public="1" set="method" line="637">
			<f a="floatC:prevFloatC">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_floatCChange>
		<emitFloatCChange set="method" line="1095">
			<f a="floatC:prevFloatC">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>floatCChange event</haxe_doc>
		</emitFloatCChange>
		<onFloatCChange public="1" set="method" line="1199">
			<f a="owner:handleFloatCPrevFloatC">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatC:prevFloatC">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatCChange event</haxe_doc>
		</onFloatCChange>
		<onceFloatCChange public="1" set="method" line="1298">
			<f a="owner:handleFloatCPrevFloatC">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatC:prevFloatC">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatCChange event</haxe_doc>
		</onceFloatCChange>
		<offFloatCChange public="1" set="method" line="1368">
			<f a="?handleFloatCPrevFloatC">
				<f a="floatC:prevFloatC">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatCChange event</haxe_doc>
		</offFloatCChange>
		<listensFloatCChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to floatCChange event</haxe_doc>
		</listensFloatCChange>
		<_dox_event_floatDChange public="1" set="method" line="637">
			<f a="floatD:prevFloatD">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_floatDChange>
		<emitFloatDChange set="method" line="1095">
			<f a="floatD:prevFloatD">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>floatDChange event</haxe_doc>
		</emitFloatDChange>
		<onFloatDChange public="1" set="method" line="1199">
			<f a="owner:handleFloatDPrevFloatD">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatD:prevFloatD">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatDChange event</haxe_doc>
		</onFloatDChange>
		<onceFloatDChange public="1" set="method" line="1298">
			<f a="owner:handleFloatDPrevFloatD">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="floatD:prevFloatD">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatDChange event</haxe_doc>
		</onceFloatDChange>
		<offFloatDChange public="1" set="method" line="1368">
			<f a="?handleFloatDPrevFloatD">
				<f a="floatD:prevFloatD">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>floatDChange event</haxe_doc>
		</offFloatDChange>
		<listensFloatDChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to floatDChange event</haxe_doc>
		</listensFloatDChange>
		<_dox_event_location public="1" set="method" line="637">
			<f a="location">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Emit this event to change current location.
     * Behavior depends on how this event is handled and does nothing by default.</haxe_doc>
		</_dox_event_location>
		<emitLocation public="1" set="method" line="1095">
			<f a="location">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Emit this event to change current location.
     * Behavior depends on how this event is handled and does nothing by default.</haxe_doc>
		</emitLocation>
		<onLocation public="1" set="method" line="1199">
			<f a="owner:handleLocation">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="location">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Emit this event to change current location.
     * Behavior depends on how this event is handled and does nothing by default.</haxe_doc>
		</onLocation>
		<onceLocation public="1" set="method" line="1298">
			<f a="owner:handleLocation">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="location">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Emit this event to change current location.
     * Behavior depends on how this event is handled and does nothing by default.</haxe_doc>
		</onceLocation>
		<offLocation public="1" set="method" line="1368">
			<f a="?handleLocation">
				<f a="location">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Emit this event to change current location.
     * Behavior depends on how this event is handled and does nothing by default.</haxe_doc>
		</offLocation>
		<listensLocation public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Emit this event to change current location.
     * Behavior depends on how this event is handled and does nothing by default.</haxe_doc>
		</listensLocation>
		<editedItems public="1" set="null" expr="false" line="34">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</editedItems>
		<assets public="1" set="null" expr="null" line="36">
			<c path="ceramic.Assets"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</assets>
		<entities public="1" set="null"><c path="Array"><c path="ceramic.Entity"/></c></entities>
		<items public="1" set="null"><c path="Array"><t path="ceramic.FragmentItem"/></c></items>
		<tracks public="1" set="null"><c path="Array"><t path="ceramic.TimelineTrackData"/></c></tracks>
		<fps public="1" set="accessor" expr="30" line="44">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
		</fps>
		<fragmentData public="1" set="accessor" expr="null" line="47">
			<t path="ceramic.FragmentData"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="editable"/>
			</meta>
		</fragmentData>
		<resizable public="1" expr="false" line="50">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="editable"/>
			</meta>
		</resizable>
		<autoUpdateTimeline public="1" set="accessor" expr="true" line="53">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="editable"/>
			</meta>
		</autoUpdateTimeline>
		<set_autoUpdateTimeline set="method" line="54"><f a="autoUpdateTimeline">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoUpdateTimeline>
		<floatA public="1" set="accessor" expr="0.0" line="68">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.0</e></m>
				<m n="editable"><e>{ group : "floatsAB" }</e></m>
			</meta>
			<haxe_doc>* Custom float value that can be used in editor</haxe_doc>
		</floatA>
		<set_floatA set="method" line="69"><f a="floatA">
	<x path="Float"/>
	<x path="Float"/>
</f></set_floatA>
		<floatB public="1" set="accessor" expr="0.0" line="82">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.0</e></m>
				<m n="editable"><e>{ group : "floatsAB" }</e></m>
			</meta>
			<haxe_doc>* Custom float value that can be used in editor</haxe_doc>
		</floatB>
		<set_floatB set="method" line="83"><f a="floatB">
	<x path="Float"/>
	<x path="Float"/>
</f></set_floatB>
		<floatC public="1" set="accessor" expr="0.0" line="96">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.0</e></m>
				<m n="editable"><e>{ group : "floatsCD" }</e></m>
			</meta>
			<haxe_doc>* Custom float value that can be used in editor</haxe_doc>
		</floatC>
		<set_floatC set="method" line="97"><f a="floatC">
	<x path="Float"/>
	<x path="Float"/>
</f></set_floatC>
		<floatD public="1" set="accessor" expr="0.0" line="110">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.0</e></m>
				<m n="editable"><e>{ group : "floatsCD" }</e></m>
			</meta>
			<haxe_doc>* Custom float value that can be used in editor</haxe_doc>
		</floatD>
		<set_floatD set="method" line="111"><f a="floatD">
	<x path="Float"/>
	<x path="Float"/>
</f></set_floatD>
		<pendingLoads public="1" set="null" expr="0" line="120">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pendingLoads>
		<timeline public="1" expr="null" line="122">
			<c path="ceramic.Timeline"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</timeline>
		<_dox_event_ready public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_ready>
		<emitReady set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>ready event</haxe_doc>
		</emitReady>
		<onReady public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>ready event</haxe_doc>
		</onReady>
		<onceReady public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>ready event</haxe_doc>
		</onceReady>
		<offReady public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>ready event</haxe_doc>
		</offReady>
		<listensReady public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to ready event</haxe_doc>
		</listensReady>
		<set_fragmentData set="method" line="205"><f a="fragmentData">
	<t path="ceramic.FragmentData"/>
	<t path="ceramic.FragmentData"/>
</f></set_fragmentData>
		<set_fps set="method" line="348"><f a="fps">
	<x path="Int"/>
	<x path="Int"/>
</f></set_fps>
		<putItem public="1" set="method" line="366"><f a="item">
	<t path="ceramic.FragmentItem"/>
	<c path="ceramic.Entity"/>
</f></putItem>
		<putItemField set="method" line="525"><f a="isFragment:item:instance:field:value:converter">
	<x path="Bool"/>
	<t path="ceramic.FragmentItem"/>
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<d/>
	<c path="ceramic.ConvertField">
		<d/>
		<d/>
	</c>
	<x path="Void"/>
</f></putItemField>
		<get public="1" set="method" line="625"><f a="itemId">
	<c path="String"/>
	<c path="ceramic.Entity"/>
</f></get>
		<getItemInstanceByName public="1" set="method" line="639">
			<f a="name">
				<c path="String"/>
				<c path="ceramic.Entity"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":deprecated"/>
			</meta>
		</getItemInstanceByName>
		<getItem public="1" set="method" line="652"><f a="itemId">
	<c path="String"/>
	<t path="ceramic.FragmentItem"/>
</f></getItem>
		<getItemByName public="1" set="method" line="665"><f a="name">
	<c path="String"/>
	<t path="ceramic.FragmentItem"/>
</f></getItemByName>
		<typeOfItem public="1" set="method" line="678"><f a="itemId">
	<c path="String"/>
	<c path="String"/>
</f></typeOfItem>
		<removeItem public="1" set="method" line="691"><f a="itemId">
	<c path="String"/>
	<x path="Void"/>
</f></removeItem>
		<removeAllItems public="1" set="method" line="714"><f a=""><x path="Void"/></f></removeAllItems>
		<destroy public="1" set="method" line="731" override="1"><f a=""><x path="Void"/></f></destroy>
		<set_components set="method" line="856" override="1"><f a="components">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</x>
</f></set_components>
		<fragmentComponents public="1" set="accessor" expr="null" line="900">
			<x path="ceramic.ReadOnlyMap">
				<c path="String"/>
				<c path="ceramic.Component"/>
			</x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Fragment components mapping. Does not contain components
     * created separatelywith `component()` or macro-based components or components property.</haxe_doc>
		</fragmentComponents>
		<set_fragmentComponents set="method" line="901"><f a="fragmentComponents">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<c path="ceramic.Component"/>
	</x>
</f></set_fragmentComponents>
		<isManagedComponent set="method" line="939"><f a=""><x path="Void"/></f></isManagedComponent>
		<putTrack public="1" set="method" line="968">
			<f a="?entityType:track">
				<c path="String"/>
				<t path="ceramic.TimelineTrackData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create or update a timeline track from the provided track data
     * @param entityType
     *      (optional) entity type being targeted by the track.
     *      If not provided, will try to resolve it from track's target entity id
     * @param track Track data used to create or update timeline track</haxe_doc>
		</putTrack>
		<putTracksForItem set="method" line="1164"><f a="itemId">
	<c path="String"/>
	<x path="Void"/>
</f></putTracksForItem>
		<getTrack public="1" set="method" line="1177"><f a="entity:field">
	<c path="String"/>
	<c path="String"/>
	<t path="ceramic.TimelineTrackData"/>
</f></getTrack>
		<removeTrack public="1" set="method" line="1191"><f a="entity:field">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></removeTrack>
		<createTimelineIfNeeded public="1" set="method" line="1220"><f a=""><x path="Void"/></f></createTimelineIfNeeded>
		<putLabel public="1" set="method" line="1235">
			<f a="index:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create or update a timeline label from the provided label index and name
     * @param index Label index (position)
     * @param name Label name</haxe_doc>
		</putLabel>
		<indexOfLabel public="1" set="method" line="1250">
			<f a="name">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Return the index (position) of the given label name or -1 if no such label exists.
     * @param name
     * @return Int</haxe_doc>
		</indexOfLabel>
		<labelAtIndex public="1" set="method" line="1265">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return the label at the given index (position), if any exists.
     * @param index
     * @return Int</haxe_doc>
		</labelAtIndex>
		<removeLabel public="1" set="method" line="1279">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove label with the given name
     * @param name Label name</haxe_doc>
		</removeLabel>
		<removeLabelAtIndex public="1" set="method" line="1291">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove label at the given index (position)
     * @param index Label index</haxe_doc>
		</removeLabelAtIndex>
		<paused public="1" get="accessor" set="accessor"><x path="Bool"/></paused>
		<get_paused set="method" line="1300"><f a=""><x path="Bool"/></f></get_paused>
		<set_paused set="method" line="1303"><f a="paused">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_paused>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="187">
			<f a="?assets:?editedItems" v=":false">
				<c path="ceramic.Assets"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ editedItems : false }</e></m></meta>
		</new>
		<haxe_doc>* A fragment is a group of visuals rendered from data (.fragment file)</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n="editable"><e>{ implicitSizeUnlessTrue : "resizable" }</e></m>
		</meta>
	</class>
	<typedef path="ceramic.FragmentData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FragmentData.hx">
		<a>
			<width>
				<x path="Float"/>
				<haxe_doc>* Fragment width</haxe_doc>
			</width>
			<transparent>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Fragment being transparent or not (default `true`)</haxe_doc>
			</transparent>
			<tracks>
				<x path="Null"><c path="Array"><t path="ceramic.TimelineTrackData"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Timeline tracks</haxe_doc>
			</tracks>
			<overflow>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Whether fragment background overflows (no effect on fragment itself, depends on player implementation)</haxe_doc>
			</overflow>
			<labels>
				<x path="Null"><x path="haxe.DynamicAccess"><x path="Int"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Timeline labels</haxe_doc>
			</labels>
			<items>
				<x path="Null"><c path="Array"><t path="ceramic.FragmentItem"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Fragment items (visuals or other entities)</haxe_doc>
			</items>
			<id>
				<c path="String"/>
				<haxe_doc>* Identifier of the fragment.</haxe_doc>
			</id>
			<height>
				<x path="Float"/>
				<haxe_doc>* Fragment height</haxe_doc>
			</height>
			<fps>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Frames per second (used in timeline, default is 30).
     * Note that this is only affecting how long a frame in the timeline lasts.
     * Using 30FPS doesn't mean the screen will be rendered at 30FPS.
     * Frame values are interpolated to match screen frame rate.</haxe_doc>
			</fps>
			<data>
				<d><d/></d>
				<haxe_doc>* Arbitrary data hold by this fragment.</haxe_doc>
			</data>
			<components>
				<x path="haxe.DynamicAccess"><c path="String"/></x>
				<haxe_doc>* Fragment-level components</haxe_doc>
			</components>
			<color>
				<x path="Null"><x path="ceramic.Color"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Fragment color (if not transparent, default `BLACK`)</haxe_doc>
			</color>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="ceramic.FragmentItem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FragmentItem.hx">
		<a>
			<props>
				<d><d/></d>
				<haxe_doc>* Properties assigned after creating entity.</haxe_doc>
			</props>
			<name>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Entity name.</haxe_doc>
			</name>
			<id>
				<c path="String"/>
				<haxe_doc>* Entity identifier.</haxe_doc>
			</id>
			<entity>
				<c path="String"/>
				<haxe_doc>* Entity class (ex: ceramic.Visual, ceramic.Quad, ...).</haxe_doc>
			</entity>
			<data>
				<x path="Null"><d><d/></d></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Arbitrary data hold by this item.</haxe_doc>
			</data>
			<components>
				<d><c path="String"/></d>
				<haxe_doc>* Entity components.</haxe_doc>
			</components>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="ceramic.Fragments" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Fragments.hx"><meta>
	<m n=":hxGen"/>
	<m n=":build"><e>ceramic.macros.AssetsMacro.buildNames("fragments")</e></m>
</meta></class>
	<class path="ceramic.FragmentsAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/FragmentsAsset.hx">
		<extends path="ceramic.Asset"/>
		<invalidateFragments public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateFragments>
		<fragments public="1" expr="null" line="9">
			<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</fragments>
		<unobservedFragments>
			<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
			<haxe_doc></haxe_doc>
		</unobservedFragments>
		<_dox_event_fragmentsChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
				<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when fragments field changes.</haxe_doc>
		</_dox_event_fragmentsChange>
		<emitFragmentsChange set="method" line="1095">
			<f a="current:previous">
				<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
				<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when fragments field changes.</haxe_doc>
		</emitFragmentsChange>
		<onFragmentsChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
					<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fragments field changes.</haxe_doc>
		</onFragmentsChange>
		<onceFragmentsChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
					<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fragments field changes.</haxe_doc>
		</onceFragmentsChange>
		<offFragmentsChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
					<x path="haxe.DynamicAccess"><t path="ceramic.FragmentData"/></x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fragments field changes.</haxe_doc>
		</offFragmentsChange>
		<listensFragmentsChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fragments field changes.</haxe_doc>
		</listensFragmentsChange>
		<load public="1" set="method" line="17" override="1"><f a=""><x path="Void"/></f></load>
		<assetFilesDidChange set="method" line="68" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="89" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="11"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.GamepadAxis" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GamepadAxis.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._GamepadAxis.GamepadAxis_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GamepadAxis.hx" private="1" module="ceramic.GamepadAxis" final="1">
	<LEFT_X public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="ceramic.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT_X>
	<LEFT_Y public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="ceramic.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT_Y>
	<RIGHT_X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="ceramic.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT_X>
	<RIGHT_Y public="1" get="inline" set="null" expr="cast 3" line="11" static="1">
		<x path="ceramic.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT_Y>
	<LEFT_TRIGGER public="1" get="inline" set="null" expr="cast 4" line="13" static="1">
		<x path="ceramic.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT_TRIGGER>
	<RIGHT_TRIGGER public="1" get="inline" set="null" expr="cast 5" line="15" static="1">
		<x path="ceramic.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT_TRIGGER>
	<toString get="inline" set="null" line="17" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._GamepadAxis.GamepadAxis_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GamepadAxis.hx" private="1" module="ceramic.GamepadAxis" final="1">
		<LEFT_X public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="ceramic.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT_X>
		<LEFT_Y public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="ceramic.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT_Y>
		<RIGHT_X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="ceramic.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT_X>
		<RIGHT_Y public="1" get="inline" set="null" expr="cast 3" line="11" static="1">
			<x path="ceramic.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT_Y>
		<LEFT_TRIGGER public="1" get="inline" set="null" expr="cast 4" line="13" static="1">
			<x path="ceramic.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT_TRIGGER>
		<RIGHT_TRIGGER public="1" get="inline" set="null" expr="cast 5" line="15" static="1">
			<x path="ceramic.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT_TRIGGER>
		<toString get="inline" set="null" line="17" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="ceramic.GamepadButton" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GamepadButton.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._GamepadButton.GamepadButton_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GamepadButton.hx" private="1" module="ceramic.GamepadButton" final="1">
	<A public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</A>
	<B public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</B>
	<X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</X>
	<Y public="1" get="inline" set="null" expr="cast 3" line="11" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Y>
	<L1 public="1" get="inline" set="null" expr="cast 4" line="13" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</L1>
	<R1 public="1" get="inline" set="null" expr="cast 5" line="15" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</R1>
	<L2 public="1" get="inline" set="null" expr="cast 6" line="17" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</L2>
	<R2 public="1" get="inline" set="null" expr="cast 7" line="19" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</R2>
	<SELECT public="1" get="inline" set="null" expr="cast 8" line="21" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SELECT>
	<START public="1" get="inline" set="null" expr="cast 9" line="23" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</START>
	<L3 public="1" get="inline" set="null" expr="cast 10" line="25" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</L3>
	<R3 public="1" get="inline" set="null" expr="cast 11" line="27" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</R3>
	<DPAD_UP public="1" get="inline" set="null" expr="cast 12" line="29" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DPAD_UP>
	<DPAD_DOWN public="1" get="inline" set="null" expr="cast 13" line="31" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DPAD_DOWN>
	<DPAD_LEFT public="1" get="inline" set="null" expr="cast 14" line="33" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DPAD_LEFT>
	<DPAD_RIGHT public="1" get="inline" set="null" expr="cast 15" line="35" static="1">
		<x path="ceramic.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DPAD_RIGHT>
	<toString get="inline" set="null" line="37" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._GamepadButton.GamepadButton_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GamepadButton.hx" private="1" module="ceramic.GamepadButton" final="1">
		<A public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</A>
		<B public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</B>
		<X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</X>
		<Y public="1" get="inline" set="null" expr="cast 3" line="11" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Y>
		<L1 public="1" get="inline" set="null" expr="cast 4" line="13" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</L1>
		<R1 public="1" get="inline" set="null" expr="cast 5" line="15" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</R1>
		<L2 public="1" get="inline" set="null" expr="cast 6" line="17" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</L2>
		<R2 public="1" get="inline" set="null" expr="cast 7" line="19" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</R2>
		<SELECT public="1" get="inline" set="null" expr="cast 8" line="21" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SELECT>
		<START public="1" get="inline" set="null" expr="cast 9" line="23" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</START>
		<L3 public="1" get="inline" set="null" expr="cast 10" line="25" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</L3>
		<R3 public="1" get="inline" set="null" expr="cast 11" line="27" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</R3>
		<DPAD_UP public="1" get="inline" set="null" expr="cast 12" line="29" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" expr="cast 13" line="31" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" expr="cast 14" line="33" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="cast 15" line="35" static="1">
			<x path="ceramic.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DPAD_RIGHT>
		<toString get="inline" set="null" line="37" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="ceramic.GeometryUtils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GeometryUtils.hx">
		<pointInTriangle public="1" set="method" line="11" static="1">
			<f a="x:y:ax:ay:bx:by:cx:cy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns `true` if the point `(x,y)` is inside the given (a,b,c) triangle</haxe_doc>
		</pointInTriangle>
		<pointInRectangle public="1" set="method" line="31" static="1">
			<f a="x:y:rectX:rectY:rectWidth:rectHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns `true` if the point `(x,y)` is inside the given (rectX, rectY, rectWidth, rectHeight) rectangle</haxe_doc>
		</pointInRectangle>
		<pointInCircle public="1" get="inline" set="null" line="49" static="1">
			<f a="x:y:cx:cy:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns `true` if the point `(x,y)` is inside the given (cx, cy, radius) circle</haxe_doc>
		</pointInCircle>
		<distance public="1" get="inline" set="null" line="58" static="1">
			<f a="x1:y1:x2:y2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the distance between point (x1, y1) and point (x2, y2)</haxe_doc>
		</distance>
		<squareDistance public="1" get="inline" set="null" line="72" static="1">
			<f a="x1:y1:x2:y2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the square of the distance between point (x1, y1) and point (x2, y2)
     * It is expected to be used to simply compare two different distances when you
     * don't need the actual distance value (that needs sqrt call).</haxe_doc>
		</squareDistance>
		<angleTo public="1" set="method" line="84" static="1">
			<f a="x0:y0:x1:y1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the angle between (x0, y0) and (x1, y1) in degrees.</haxe_doc>
		</angleTo>
		<angleDelta public="1" set="method" line="98" static="1">
			<f a="angle0:angle1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the delta between `angle0` and `angle1`, all values being angles in degrees.</haxe_doc>
		</angleDelta>
		<clampDegrees public="1" set="method" line="119" static="1">
			<f a="deg">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Clamp an degrees (angle) value between 0 (included) and 360 (excluded)</haxe_doc>
		</clampDegrees>
		<angleDirection public="1" set="method" line="139" static="1">
			<f a="angle:result">
				<x path="Float"/>
				<c path="ceramic.Point"/>
				<c path="ceramic.Point"/>
			</f>
			<haxe_doc>* Set the given result's `x` and `y` values so that it's a vector representing
     * a direction matching the angle (in degrees)
     * @param angle The angle to compute the direction from
     * @param result The vector (a `Point` object) receiving the result</haxe_doc>
		</angleDirection>
		<haxe_doc>* Geometry-related utilities.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.GlyphQuad" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/GlyphQuad.hx">
		<extends path="ceramic.Quad"/>
		<_dox_event_clear public="1" set="method" line="637">
			<f a="quad">
				<c path="ceramic.GlyphQuad"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_clear>
		<emitClear set="method" line="1095">
			<f a="quad">
				<c path="ceramic.GlyphQuad"/>
				<x path="Void"/>
			</f>
			<haxe_doc>clear event</haxe_doc>
		</emitClear>
		<onClear public="1" set="method" line="1199">
			<f a="owner:handleQuad">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="quad">
					<c path="ceramic.GlyphQuad"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>clear event</haxe_doc>
		</onClear>
		<onceClear public="1" set="method" line="1298">
			<f a="owner:handleQuad">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="quad">
					<c path="ceramic.GlyphQuad"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>clear event</haxe_doc>
		</onceClear>
		<offClear public="1" set="method" line="1368">
			<f a="?handleQuad">
				<f a="quad">
					<c path="ceramic.GlyphQuad"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>clear event</haxe_doc>
		</offClear>
		<listensClear public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to clear event</haxe_doc>
		</listensClear>
		<char public="1" expr="null" line="7">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</char>
		<glyph public="1" expr="null" line="9">
			<c path="ceramic.BitmapFontCharacter"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</glyph>
		<index public="1" expr="-1" line="11">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</index>
		<posInLine public="1" expr="-1" line="13">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</posInLine>
		<line public="1" expr="-1" line="15">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</line>
		<code public="1" expr="-1" line="17">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</code>
		<glyphX public="1" expr="-1" line="19">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</glyphX>
		<glyphY public="1" expr="-1" line="21">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</glyphY>
		<glyphAdvance public="1" expr="-1" line="23">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</glyphAdvance>
		<toString set="method" line="27" override="1"><f a=""><c path="String"/></f></toString>
		<clear public="1" set="method" line="33" override="1"><f a=""><x path="Void"/></f></clear>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Group" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Group.hx">
		<extends path="ceramic.Entity"/>
		<items public="1" expr="[]" line="22">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.Group.T"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
		</items>
		<add public="1" set="method" line="36"><f a="item">
	<c path="ceramic.Group.T"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method" line="51"><f a="item">
	<c path="ceramic.Group.T"/>
	<x path="Void"/>
</f></remove>
		<contains public="1" get="inline" set="null" line="66"><f a="item">
	<c path="ceramic.Group.T"/>
	<x path="Bool"/>
</f></contains>
		<itemDestroyed set="method" line="72"><f a="item">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></itemDestroyed>
		<clear public="1" set="method" line="78"><f a=""><x path="Void"/></f></clear>
		<destroy public="1" set="method" line="100" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="24"><f a="?id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A group of entities, which is itself an entity.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.HashedString" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/HashedString.hx">
		<_lastDecodeIncomplete expr="false" line="16" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_lastDecodeIncomplete>
		<encode public="1" set="method" line="21" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Encode the given string `str` and return the result.</haxe_doc>
		</encode>
		<append public="1" set="method" line="34" static="1">
			<f a="encoded:str">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Encode and append `str` to the already encoded string `encoded` and return the results.
     * This is equivalent to `result = encoded + HashedString.encode(str)`</haxe_doc>
		</append>
		<decode public="1" set="method" line="43" static="1">
			<f a="encoded">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Decode the given `encoded` string and return the result.</haxe_doc>
		</decode>
		<isLastDecodeIncomplete public="1" get="inline" set="null" line="102"><f a=""><x path="Bool"/></f></isLastDecodeIncomplete>
		<haxe_doc>* An utility to encode strings with hashes, allowing to check their validity on decode.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.ImageAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ImageAsset.hx">
		<extends path="ceramic.Asset"/>
		<_dox_event_replaceTexture public="1" set="method" line="637">
			<f a="newTexture:prevTexture">
				<c path="ceramic.Texture"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_replaceTexture>
		<emitReplaceTexture set="method" line="1095">
			<f a="newTexture:prevTexture">
				<c path="ceramic.Texture"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>replaceTexture event</haxe_doc>
		</emitReplaceTexture>
		<onReplaceTexture public="1" set="method" line="1199">
			<f a="owner:handleNewTexturePrevTexture">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newTexture:prevTexture">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceTexture event</haxe_doc>
		</onReplaceTexture>
		<onceReplaceTexture public="1" set="method" line="1298">
			<f a="owner:handleNewTexturePrevTexture">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newTexture:prevTexture">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceTexture event</haxe_doc>
		</onceReplaceTexture>
		<offReplaceTexture public="1" set="method" line="1368">
			<f a="?handleNewTexturePrevTexture">
				<f a="newTexture:prevTexture">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceTexture event</haxe_doc>
		</offReplaceTexture>
		<listensReplaceTexture public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to replaceTexture event</haxe_doc>
		</listensReplaceTexture>
		<invalidateTexture public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTexture>
		<texture public="1" expr="null" line="19">
			<c path="ceramic.Texture"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</texture>
		<unobservedTexture>
			<c path="ceramic.Texture"/>
			<haxe_doc></haxe_doc>
		</unobservedTexture>
		<_dox_event_textureChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.Texture"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</_dox_event_textureChange>
		<emitTextureChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.Texture"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</emitTextureChange>
		<onTextureChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</onTextureChange>
		<onceTextureChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</onceTextureChange>
		<offTextureChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</offTextureChange>
		<listensTextureChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</listensTextureChange>
		<defaultImageOptions expr="null" line="24">
			<t path="ceramic.AssetOptions"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":allow"><e>ceramic.Assets</e></m>
			</meta>
		</defaultImageOptions>
		<reloadBecauseOfDensityChange expr="false" line="26">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</reloadBecauseOfDensityChange>
		<load public="1" set="method" line="49" override="1"><f a=""><x path="Void"/></f></load>
		<loadTexture set="method" line="164"><f a="path:loadOptions:callback">
	<c path="String"/>
	<t path="ceramic.AssetOptions"/>
	<f a="texture:backendPath">
		<c path="ceramic.Texture"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadTexture>
		<texturesDensityDidChange set="method" line="253" override="1"><f a="newDensity:prevDensity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texturesDensityDidChange>
		<checkTexturesDensity set="method" line="264"><f a=""><x path="Void"/></f></checkTexturesDensity>
		<assetFilesDidChange set="method" line="280" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="301" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="42"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.ImageType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ImageType.hx">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta>
			<m n=":nativeGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._ImageType.ImageType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ImageType.hx" private="1" module="ceramic.ImageType" extern="1" final="1">
	<PNG public="1" get="inline" set="null" expr="cast &quot;png&quot;" line="5" static="1">
		<x path="ceramic.ImageType"/>
		<meta>
			<m n=":value"><e>cast "png"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PNG>
	<JPEG public="1" get="inline" set="null" expr="cast &quot;jpeg&quot;" line="7" static="1">
		<x path="ceramic.ImageType"/>
		<meta>
			<m n=":value"><e>cast "jpeg"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</JPEG>
	<GIF public="1" get="inline" set="null" expr="cast &quot;gif&quot;" line="9" static="1">
		<x path="ceramic.ImageType"/>
		<meta>
			<m n=":value"><e>cast "gif"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</GIF>
	<meta>
		<m n=":nativeGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._ImageType.ImageType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ImageType.hx" private="1" module="ceramic.ImageType" extern="1" final="1">
		<PNG public="1" get="inline" set="null" expr="cast &quot;png&quot;" line="5" static="1">
			<x path="ceramic.ImageType"/>
			<meta>
				<m n=":value"><e>cast "png"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PNG>
		<JPEG public="1" get="inline" set="null" expr="cast &quot;jpeg&quot;" line="7" static="1">
			<x path="ceramic.ImageType"/>
			<meta>
				<m n=":value"><e>cast "jpeg"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</JPEG>
		<GIF public="1" get="inline" set="null" expr="cast &quot;gif&quot;" line="9" static="1">
			<x path="ceramic.ImageType"/>
			<meta>
				<m n=":value"><e>cast "gif"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</GIF>
		<meta>
			<m n=":nativeGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="ceramic.Immediate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Immediate.hx">
		<immediateCallbacks expr="[]" line="9">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</immediateCallbacks>
		<immediateCallbacksCapacity expr="0" line="11">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</immediateCallbacksCapacity>
		<immediateCallbacksLen expr="0" line="13">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</immediateCallbacksLen>
		<push public="1" set="method" line="20">
			<f a="handleImmediate">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Schedule a callback that will be run when flush() is called</haxe_doc>
		</push>
		<flush public="1" set="method" line="39">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Execute and flush every awaiting callback, including the ones that
        could have been added with `push()` after executing the existing callbacks.</haxe_doc>
		</flush>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.InitSettings" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/InitSettings.hx">
		<settings>
			<c path="ceramic.Settings"/>
			<haxe_doc>* App settings</haxe_doc>
		</settings>
		<targetWidth public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Target width. Affects window size at startup
     * and affects screen scaling at any time.
     * Ignored if set to 0 (default)</haxe_doc>
		</targetWidth>
		<get_targetWidth get="inline" set="null" line="28"><f a=""><x path="Int"/></f></get_targetWidth>
		<set_targetWidth get="inline" set="null" line="31"><f a="targetWidth">
	<x path="Int"/>
	<x path="Int"/>
</f></set_targetWidth>
		<targetHeight public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Target height. Affects window size at startup
     * and affects screen scaling at any time.
     * Ignored if set to 0 (default)</haxe_doc>
		</targetHeight>
		<get_targetHeight get="inline" set="null" line="41"><f a=""><x path="Int"/></f></get_targetHeight>
		<set_targetHeight get="inline" set="null" line="44"><f a="targetHeight">
	<x path="Int"/>
	<x path="Int"/>
</f></set_targetHeight>
		<targetSize public="1" get="inline" set="null" line="55">
			<f a="targetWidth:targetHeight">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Target width and height. Affects window size at startup
     * and affects screen scaling at any time.
     * Ignored if set to 0 (default)
     * @param targetWidth Target width
     * @param targetHeight Target height</haxe_doc>
		</targetSize>
		<windowWidth public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Target window width at startup
     * Uses `targetWidth` as fallback if set to 0 (default)</haxe_doc>
		</windowWidth>
		<get_windowWidth get="inline" set="null" line="65"><f a=""><x path="Int"/></f></get_windowWidth>
		<set_windowWidth get="inline" set="null" line="68"><f a="windowWidth">
	<x path="Int"/>
	<x path="Int"/>
</f></set_windowWidth>
		<windowHeight public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Target window height at startup
     * Uses `targetHeight` as fallback if set to 0 (default)</haxe_doc>
		</windowHeight>
		<get_windowHeight get="inline" set="null" line="77"><f a=""><x path="Int"/></f></get_windowHeight>
		<set_windowHeight get="inline" set="null" line="80"><f a="windowHeight">
	<x path="Int"/>
	<x path="Int"/>
</f></set_windowHeight>
		<windowSize public="1" get="inline" set="null" line="90">
			<f a="windowWidth:windowHeight">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Target window width and height at startup
     * Uses `targetWidth` and `targetHeight` as fallback if set to 0 (default)
     * @param windowWidth Window width
     * @param windowHeight Window height</haxe_doc>
		</windowSize>
		<targetDensity public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Target density. Affects the quality of textures
     * being loaded. Changing it at runtime will update
     * texture quality if needed.
     * Ignored if set to 0 (default)</haxe_doc>
		</targetDensity>
		<get_targetDensity get="inline" set="null" line="102"><f a=""><x path="Int"/></f></get_targetDensity>
		<set_targetDensity get="inline" set="null" line="105"><f a="targetDensity">
	<x path="Int"/>
	<x path="Int"/>
</f></set_targetDensity>
		<background public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<haxe_doc>* Background color.</haxe_doc>
		</background>
		<get_background get="inline" set="null" line="113"><f a=""><x path="ceramic.Color"/></f></get_background>
		<set_background get="inline" set="null" line="116"><f a="background">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_background>
		<scaling public="1" get="accessor" set="accessor">
			<e path="ceramic.ScreenScaling"/>
			<haxe_doc>* Screen scaling (FIT, FILL, RESIZE, FIT_RESIZE).</haxe_doc>
		</scaling>
		<get_scaling get="inline" set="null" line="124"><f a=""><e path="ceramic.ScreenScaling"/></f></get_scaling>
		<set_scaling get="inline" set="null" line="127"><f a="scaling">
	<e path="ceramic.ScreenScaling"/>
	<e path="ceramic.ScreenScaling"/>
</f></set_scaling>
		<title public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* App window title.</haxe_doc>
		</title>
		<get_title get="inline" set="null" line="135"><f a=""><c path="String"/></f></get_title>
		<set_title get="inline" set="null" line="138"><f a="title">
	<c path="String"/>
	<c path="String"/>
</f></set_title>
		<fullscreen public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Fullscreen enabled or not.</haxe_doc>
		</fullscreen>
		<get_fullscreen get="inline" set="null" line="146"><f a=""><x path="Bool"/></f></get_fullscreen>
		<set_fullscreen get="inline" set="null" line="149"><f a="fullscreen">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fullscreen>
		<targetFps public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Target FPS. Using default FPS if value < 1 or try to match the given value if >= 1.]]></haxe_doc>
		</targetFps>
		<get_targetFps get="inline" set="null" line="157"><f a=""><x path="Int"/></f></get_targetFps>
		<set_targetFps get="inline" set="null" line="160"><f a="targetFps">
	<x path="Int"/>
	<x path="Int"/>
</f></set_targetFps>
		<maxDelta public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Maximum app update delta time.
     * During app update (at each frame), `app.delta` will be capped to `maxDelta`
     * if its value is above `maxDelta`.
     * If needed, use `app.realDelta` to get real elapsed time since last frame.</haxe_doc>
		</maxDelta>
		<get_maxDelta get="inline" set="null" line="171"><f a=""><x path="Float"/></f></get_maxDelta>
		<set_maxDelta get="inline" set="null" line="174"><f a="maxDelta">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxDelta>
		<overrideDelta public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Override app update delta time.
     * This can be used to ignore completely the actual elapsed time between frames
     * and replace it with an explicit delta time of your choice.
     * This will affect timers, tween, systems update etc...
     * Use with caution.</haxe_doc>
		</overrideDelta>
		<get_overrideDelta get="inline" set="null" line="186"><f a=""><x path="Float"/></f></get_overrideDelta>
		<set_overrideDelta get="inline" set="null" line="189"><f a="overrideDelta">
	<x path="Float"/>
	<x path="Float"/>
</f></set_overrideDelta>
		<preventDefaultMouseWheel public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* If set to `true` (default). Default mouse wheel events
     * will be prevented. This is relevant when running the ceramic
     * app from an `iframe` inside a page that can scroll.</haxe_doc>
		</preventDefaultMouseWheel>
		<get_preventDefaultMouseWheel get="inline" set="null" line="200"><f a=""><x path="Bool"/></f></get_preventDefaultMouseWheel>
		<set_preventDefaultMouseWheel get="inline" set="null" line="203"><f a="preventDefaultMouseWheel">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_preventDefaultMouseWheel>
		<preventDefaultTouches public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* If set to `true` (default). Default touch events
     * will be prevented. This is relevant when running the ceramic
     * app from an `iframe` inside a page that can scroll,
     * on a touchscreen device.</haxe_doc>
		</preventDefaultTouches>
		<get_preventDefaultTouches get="inline" set="null" line="214"><f a=""><x path="Bool"/></f></get_preventDefaultTouches>
		<set_preventDefaultTouches get="inline" set="null" line="217"><f a="preventDefaultTouches">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_preventDefaultTouches>
		<orientation public="1" get="accessor" set="accessor">
			<x path="ceramic.ScreenOrientation"/>
			<haxe_doc>* Setup screen orientation. Default is `NONE`,
     * meaning nothing is enforced and project defaults will be used.</haxe_doc>
		</orientation>
		<get_orientation get="inline" set="null" line="226"><f a=""><x path="ceramic.ScreenOrientation"/></f></get_orientation>
		<set_orientation get="inline" set="null" line="229"><f a="orientation">
	<x path="ceramic.ScreenOrientation"/>
	<x path="ceramic.ScreenOrientation"/>
</f></set_orientation>
		<antialiasing public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Antialiasing value (0 means disabled).</haxe_doc>
		</antialiasing>
		<get_antialiasing get="inline" set="null" line="237"><f a=""><x path="Int"/></f></get_antialiasing>
		<set_antialiasing get="inline" set="null" line="240"><f a="antialiasing">
	<x path="Int"/>
	<x path="Int"/>
</f></set_antialiasing>
		<collections public="1" get="accessor" set="accessor">
			<f a=""><c path="ceramic.AutoCollections"/></f>
			<haxe_doc>* App collections.</haxe_doc>
		</collections>
		<get_collections get="inline" set="null" line="248"><f a=""><f a=""><c path="ceramic.AutoCollections"/></f></f></get_collections>
		<set_collections get="inline" set="null" line="251"><f a="collections">
	<f a=""><c path="ceramic.AutoCollections"/></f>
	<f a=""><c path="ceramic.AutoCollections"/></f>
</f></set_collections>
		<appInfo public="1" get="accessor" set="accessor">
			<d/>
			<haxe_doc>* App info (useful when dynamically loaded, not needed otherwise).</haxe_doc>
		</appInfo>
		<get_appInfo get="inline" set="null" line="259"><f a=""><d/></f></get_appInfo>
		<set_appInfo get="inline" set="null" line="262"><f a="appInfo">
	<d/>
	<d/>
</f></set_appInfo>
		<resizable public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the window can be resized or not.</haxe_doc>
		</resizable>
		<get_resizable get="inline" set="null" line="270"><f a=""><x path="Bool"/></f></get_resizable>
		<set_resizable get="inline" set="null" line="273"><f a="resizable">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_resizable>
		<assetsPath public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Assets path.</haxe_doc>
		</assetsPath>
		<get_assetsPath get="inline" set="null" line="281"><f a=""><c path="String"/></f></get_assetsPath>
		<set_assetsPath get="inline" set="null" line="284"><f a="assetsPath">
	<c path="String"/>
	<c path="String"/>
</f></set_assetsPath>
		<backend public="1" get="accessor" set="accessor">
			<d/>
			<haxe_doc>* Settings passed to backend.</haxe_doc>
		</backend>
		<get_backend get="inline" set="null" line="292"><f a=""><d/></f></get_backend>
		<set_backend get="inline" set="null" line="295"><f a="backend">
	<d/>
	<d/>
</f></set_backend>
		<defaultFont public="1" get="accessor" set="accessor">
			<x path="ceramic.AssetId"><c path="String"/></x>
			<haxe_doc>* Default font asset</haxe_doc>
		</defaultFont>
		<get_defaultFont get="inline" set="null" line="303"><f a=""><x path="ceramic.AssetId"><c path="String"/></x></f></get_defaultFont>
		<set_defaultFont get="inline" set="null" line="306"><f a="defaultFont">
	<x path="ceramic.AssetId"><c path="String"/></x>
	<x path="ceramic.AssetId"><c path="String"/></x>
</f></set_defaultFont>
		<defaultShader public="1" get="accessor" set="accessor">
			<x path="ceramic.AssetId"><c path="String"/></x>
			<haxe_doc>* Default shader asset</haxe_doc>
		</defaultShader>
		<get_defaultShader get="inline" set="null" line="314"><f a=""><x path="ceramic.AssetId"><c path="String"/></x></f></get_defaultShader>
		<set_defaultShader get="inline" set="null" line="317"><f a="defaultShader">
	<x path="ceramic.AssetId"><c path="String"/></x>
	<x path="ceramic.AssetId"><c path="String"/></x>
</f></set_defaultShader>
		<new set="method" line="16">
			<f a="settings">
				<c path="ceramic.Settings"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>ceramic.App</e></m></meta>
		</new>
		<haxe_doc>* Same as Settings, but for app startup (inside Project.new(settings)).
 * Read-only values can still
 * be edited at that stage.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Input" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Input.hx">
		<extends path="ceramic.Entity"/>
		<GAMEPAD_STORAGE_SIZE final="1" get="inline" set="null" expr="32" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
			<haxe_doc>* Internal value to store gamepad state</haxe_doc>
		</GAMEPAD_STORAGE_SIZE>
		<_dox_event_keyDown public="1" set="method" line="637">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* @event keyDown
     * Triggered when a key from the keyboard is being pressed.
     * @param key The key being pressed</haxe_doc>
		</_dox_event_keyDown>
		<emitKeyDown set="method" line="1095">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @event keyDown
     * Triggered when a key from the keyboard is being pressed.
     * @param key The key being pressed</haxe_doc>
		</emitKeyDown>
		<onKeyDown public="1" set="method" line="1199">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyDown
     * Triggered when a key from the keyboard is being pressed.
     * @param key The key being pressed</haxe_doc>
		</onKeyDown>
		<onceKeyDown public="1" set="method" line="1298">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyDown
     * Triggered when a key from the keyboard is being pressed.
     * @param key The key being pressed</haxe_doc>
		</onceKeyDown>
		<offKeyDown public="1" set="method" line="1368">
			<f a="?handleKey">
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyDown
     * Triggered when a key from the keyboard is being pressed.
     * @param key The key being pressed</haxe_doc>
		</offKeyDown>
		<listensKeyDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyDown
     * Triggered when a key from the keyboard is being pressed.
     * @param key The key being pressed</haxe_doc>
		</listensKeyDown>
		<_dox_event_keyUp public="1" set="method" line="637">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* @event keyUp
     * Triggered when a key from the keyboard is being released.
     * @param key The key being released</haxe_doc>
		</_dox_event_keyUp>
		<emitKeyUp set="method" line="1095">
			<f a="key">
				<c path="ceramic.Key"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @event keyUp
     * Triggered when a key from the keyboard is being released.
     * @param key The key being released</haxe_doc>
		</emitKeyUp>
		<onKeyUp public="1" set="method" line="1199">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyUp
     * Triggered when a key from the keyboard is being released.
     * @param key The key being released</haxe_doc>
		</onKeyUp>
		<onceKeyUp public="1" set="method" line="1298">
			<f a="owner:handleKey">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyUp
     * Triggered when a key from the keyboard is being released.
     * @param key The key being released</haxe_doc>
		</onceKeyUp>
		<offKeyUp public="1" set="method" line="1368">
			<f a="?handleKey">
				<f a="key">
					<c path="ceramic.Key"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyUp
     * Triggered when a key from the keyboard is being released.
     * @param key The key being released</haxe_doc>
		</offKeyUp>
		<listensKeyUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* @event keyUp
     * Triggered when a key from the keyboard is being released.
     * @param key The key being released</haxe_doc>
		</listensKeyUp>
		<_dox_event_gamepadAxis public="1" set="method" line="637">
			<f a="gamepadId:axis:value">
				<x path="Int"/>
				<x path="ceramic.GamepadAxis"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadAxis>
		<emitGamepadAxis set="method" line="1095">
			<f a="gamepadId:axis:value">
				<x path="Int"/>
				<x path="ceramic.GamepadAxis"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</emitGamepadAxis>
		<onGamepadAxis public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdAxisValue">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:axis:value">
					<x path="Int"/>
					<x path="ceramic.GamepadAxis"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</onGamepadAxis>
		<onceGamepadAxis public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdAxisValue">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:axis:value">
					<x path="Int"/>
					<x path="ceramic.GamepadAxis"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</onceGamepadAxis>
		<offGamepadAxis public="1" set="method" line="1368">
			<f a="?handleGamepadIdAxisValue">
				<f a="gamepadId:axis:value">
					<x path="Int"/>
					<x path="ceramic.GamepadAxis"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadAxis event</haxe_doc>
		</offGamepadAxis>
		<listensGamepadAxis public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadAxis event</haxe_doc>
		</listensGamepadAxis>
		<_dox_event_gamepadDown public="1" set="method" line="637">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadDown>
		<emitGamepadDown set="method" line="1095">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadDown event</haxe_doc>
		</emitGamepadDown>
		<onGamepadDown public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdButton">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:button">
					<x path="Int"/>
					<x path="ceramic.GamepadButton"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDown event</haxe_doc>
		</onGamepadDown>
		<onceGamepadDown public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdButton">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:button">
					<x path="Int"/>
					<x path="ceramic.GamepadButton"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDown event</haxe_doc>
		</onceGamepadDown>
		<offGamepadDown public="1" set="method" line="1368">
			<f a="?handleGamepadIdButton">
				<f a="gamepadId:button">
					<x path="Int"/>
					<x path="ceramic.GamepadButton"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDown event</haxe_doc>
		</offGamepadDown>
		<listensGamepadDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadDown event</haxe_doc>
		</listensGamepadDown>
		<_dox_event_gamepadUp public="1" set="method" line="637">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadUp>
		<emitGamepadUp set="method" line="1095">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadUp event</haxe_doc>
		</emitGamepadUp>
		<onGamepadUp public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdButton">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:button">
					<x path="Int"/>
					<x path="ceramic.GamepadButton"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadUp event</haxe_doc>
		</onGamepadUp>
		<onceGamepadUp public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdButton">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:button">
					<x path="Int"/>
					<x path="ceramic.GamepadButton"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadUp event</haxe_doc>
		</onceGamepadUp>
		<offGamepadUp public="1" set="method" line="1368">
			<f a="?handleGamepadIdButton">
				<f a="gamepadId:button">
					<x path="Int"/>
					<x path="ceramic.GamepadButton"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadUp event</haxe_doc>
		</offGamepadUp>
		<listensGamepadUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadUp event</haxe_doc>
		</listensGamepadUp>
		<_dox_event_gamepadGyro public="1" set="method" line="637">
			<f a="gamepadId:dx:dy:dz">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadGyro>
		<emitGamepadGyro set="method" line="1095">
			<f a="gamepadId:dx:dy:dz">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</emitGamepadGyro>
		<onGamepadGyro public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdDxDyDz">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:dx:dy:dz">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</onGamepadGyro>
		<onceGamepadGyro public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdDxDyDz">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:dx:dy:dz">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</onceGamepadGyro>
		<offGamepadGyro public="1" set="method" line="1368">
			<f a="?handleGamepadIdDxDyDz">
				<f a="gamepadId:dx:dy:dz">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadGyro event</haxe_doc>
		</offGamepadGyro>
		<listensGamepadGyro public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadGyro event</haxe_doc>
		</listensGamepadGyro>
		<_dox_event_gamepadEnable public="1" set="method" line="637">
			<f a="gamepadId:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadEnable>
		<emitGamepadEnable set="method" line="1095">
			<f a="gamepadId:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</emitGamepadEnable>
		<onGamepadEnable public="1" set="method" line="1199">
			<f a="owner:handleGamepadIdName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</onGamepadEnable>
		<onceGamepadEnable public="1" set="method" line="1298">
			<f a="owner:handleGamepadIdName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</onceGamepadEnable>
		<offGamepadEnable public="1" set="method" line="1368">
			<f a="?handleGamepadIdName">
				<f a="gamepadId:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadEnable event</haxe_doc>
		</offGamepadEnable>
		<listensGamepadEnable public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadEnable event</haxe_doc>
		</listensGamepadEnable>
		<_dox_event_gamepadDisable public="1" set="method" line="637">
			<f a="gamepadId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_gamepadDisable>
		<emitGamepadDisable set="method" line="1095">
			<f a="gamepadId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</emitGamepadDisable>
		<onGamepadDisable public="1" set="method" line="1199">
			<f a="owner:handleGamepadId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</onGamepadDisable>
		<onceGamepadDisable public="1" set="method" line="1298">
			<f a="owner:handleGamepadId">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="gamepadId">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</onceGamepadDisable>
		<offGamepadDisable public="1" set="method" line="1368">
			<f a="?handleGamepadId">
				<f a="gamepadId">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>gamepadDisable event</haxe_doc>
		</offGamepadDisable>
		<listensGamepadDisable public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to gamepadDisable event</haxe_doc>
		</listensGamepadDisable>
		<pressedScanCodes expr="new IntIntMap(16, 0.5, false)" line="31">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</pressedScanCodes>
		<pressedKeyCodes expr="new IntIntMap(16, 0.5, false)" line="33">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</pressedKeyCodes>
		<pressedGamepadButtons expr="new IntIntMap(16, 0.5, false)" line="35">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</pressedGamepadButtons>
		<gamepadAxisValues expr="new IntFloatMap(16, 0.5, false)" line="37">
			<c path="ceramic.IntFloatMap"/>
			<meta><m n=":value"><e>new IntFloatMap(16, 0.5, false)</e></m></meta>
		</gamepadAxisValues>
		<gamepadGyroDeltas expr="new IntMap()" line="39">
			<c path="ceramic.IntMap"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>new IntMap()</e></m></meta>
		</gamepadGyroDeltas>
		<gamepadGyroKeys expr="[]" line="41">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</gamepadGyroKeys>
		<gamepadNames expr="new IntMap()" line="43">
			<c path="ceramic.IntMap"><c path="String"/></c>
			<meta><m n=":value"><e>new IntMap()</e></m></meta>
		</gamepadNames>
		<activeGamepads public="1" expr="[]" line="45">
			<x path="ceramic.ReadOnlyArray"><x path="Int"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
		</activeGamepads>
		<resetDeltas set="method" line="53"><f a=""><x path="Void"/></f></resetDeltas>
		<willEmitKeyDown set="method" line="104"><f a="key">
	<c path="ceramic.Key"/>
	<x path="Void"/>
</f></willEmitKeyDown>
		<willEmitKeyUp set="method" line="131"><f a="key">
	<c path="ceramic.Key"/>
	<x path="Void"/>
</f></willEmitKeyUp>
		<keyPressed public="1" get="inline" set="null" line="151">
			<f a="keyCode">
				<x path="ceramic.KeyCode"/>
				<x path="Bool"/>
			</f>
			<overloads><keyPressed public="1" get="inline" set="null" line="187"><f a="keyCode:owner">
	<x path="ceramic.KeyCode"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></keyPressed></overloads>
		</keyPressed>
		<keyJustPressed public="1" get="inline" set="null" line="157">
			<f a="keyCode">
				<x path="ceramic.KeyCode"/>
				<x path="Bool"/>
			</f>
			<overloads><keyJustPressed public="1" get="inline" set="null" line="193"><f a="keyCode:owner">
	<x path="ceramic.KeyCode"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></keyJustPressed></overloads>
		</keyJustPressed>
		<keyJustReleased public="1" get="inline" set="null" line="163">
			<f a="keyCode">
				<x path="ceramic.KeyCode"/>
				<x path="Bool"/>
			</f>
			<overloads><keyJustReleased public="1" get="inline" set="null" line="199"><f a="keyCode:owner">
	<x path="ceramic.KeyCode"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></keyJustReleased></overloads>
		</keyJustReleased>
		<scanPressed public="1" get="inline" set="null" line="169">
			<f a="scanCode">
				<x path="ceramic.ScanCode"/>
				<x path="Bool"/>
			</f>
			<overloads><scanPressed public="1" get="inline" set="null" line="205"><f a="scanCode:owner">
	<x path="ceramic.ScanCode"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></scanPressed></overloads>
		</scanPressed>
		<scanJustPressed public="1" get="inline" set="null" line="175">
			<f a="scanCode">
				<x path="ceramic.ScanCode"/>
				<x path="Bool"/>
			</f>
			<overloads><scanJustPressed public="1" get="inline" set="null" line="211"><f a="scanCode:owner">
	<x path="ceramic.ScanCode"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></scanJustPressed></overloads>
		</scanJustPressed>
		<scanJustReleased public="1" get="inline" set="null" line="181">
			<f a="scanCode">
				<x path="ceramic.ScanCode"/>
				<x path="Bool"/>
			</f>
			<overloads><scanJustReleased public="1" get="inline" set="null" line="217"><f a="scanCode:owner">
	<x path="ceramic.ScanCode"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></scanJustReleased></overloads>
		</scanJustReleased>
		<_keyPressed set="method" line="223"><f a="keyCode">
	<x path="ceramic.KeyCode"/>
	<x path="Bool"/>
</f></_keyPressed>
		<_keyJustPressed set="method" line="229"><f a="keyCode">
	<x path="ceramic.KeyCode"/>
	<x path="Bool"/>
</f></_keyJustPressed>
		<_keyJustReleased set="method" line="235"><f a="keyCode">
	<x path="ceramic.KeyCode"/>
	<x path="Bool"/>
</f></_keyJustReleased>
		<_scanPressed set="method" line="241"><f a="scanCode">
	<x path="ceramic.ScanCode"/>
	<x path="Bool"/>
</f></_scanPressed>
		<_scanJustPressed set="method" line="247"><f a="scanCode">
	<x path="ceramic.ScanCode"/>
	<x path="Bool"/>
</f></_scanJustPressed>
		<_scanJustReleased set="method" line="253"><f a="scanCode">
	<x path="ceramic.ScanCode"/>
	<x path="Bool"/>
</f></_scanJustReleased>
		<willEmitGamepadEnable set="method" line="261"><f a="gamepadId:name">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></willEmitGamepadEnable>
		<willEmitGamepadDisable set="method" line="281"><f a="gamepadId">
	<x path="Int"/>
	<x path="Void"/>
</f></willEmitGamepadDisable>
		<willEmitGamepadDown set="method" line="308"><f a="gamepadId:button">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<x path="Void"/>
</f></willEmitGamepadDown>
		<willEmitGamepadUp set="method" line="330"><f a="gamepadId:button">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<x path="Void"/>
</f></willEmitGamepadUp>
		<willEmitGamepadGyro set="method" line="343"><f a="gamepadId:dx:dy:dz">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitGamepadGyro>
		<gamepadPressed public="1" get="inline" set="null" line="360">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Bool"/>
			</f>
			<overloads><gamepadPressed public="1" get="inline" set="null" line="378"><f a="gamepadId:button:owner">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></gamepadPressed></overloads>
		</gamepadPressed>
		<gamepadJustPressed public="1" get="inline" set="null" line="366">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Bool"/>
			</f>
			<overloads><gamepadJustPressed public="1" get="inline" set="null" line="384"><f a="gamepadId:button:owner">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></gamepadJustPressed></overloads>
		</gamepadJustPressed>
		<gamepadJustReleased public="1" get="inline" set="null" line="372">
			<f a="gamepadId:button">
				<x path="Int"/>
				<x path="ceramic.GamepadButton"/>
				<x path="Bool"/>
			</f>
			<overloads><gamepadJustReleased public="1" get="inline" set="null" line="390"><f a="gamepadId:button:owner">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></gamepadJustReleased></overloads>
		</gamepadJustReleased>
		<_gamepadPressed set="method" line="396"><f a="gamepadId:button">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<x path="Bool"/>
</f></_gamepadPressed>
		<_gamepadJustPressed set="method" line="403"><f a="gamepadId:button">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<x path="Bool"/>
</f></_gamepadJustPressed>
		<_gamepadJustReleased set="method" line="410"><f a="gamepadId:button">
	<x path="Int"/>
	<x path="ceramic.GamepadButton"/>
	<x path="Bool"/>
</f></_gamepadJustReleased>
		<willEmitGamepadAxis get="inline" set="null" line="417"><f a="gamepadId:axis:value">
	<x path="Int"/>
	<x path="ceramic.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitGamepadAxis>
		<gamepadAxisValue public="1" set="method" line="424"><f a="gamepadId:axis">
	<x path="Int"/>
	<x path="ceramic.GamepadAxis"/>
	<x path="Float"/>
</f></gamepadAxisValue>
		<gamepadGyroDeltaX public="1" set="method" line="431"><f a="gamepadId">
	<x path="Int"/>
	<x path="Float"/>
</f></gamepadGyroDeltaX>
		<gamepadGyroDeltaY public="1" set="method" line="442"><f a="gamepadId">
	<x path="Int"/>
	<x path="Float"/>
</f></gamepadGyroDeltaY>
		<gamepadGyroDeltaZ public="1" set="method" line="453"><f a="gamepadId">
	<x path="Int"/>
	<x path="Float"/>
</f></gamepadGyroDeltaZ>
		<startGamepadRumble public="1" set="method" line="471">
			<f a="gamepadId:duration:lowFrequency:highFrequency">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Starts a controller rumble.
     * @param gamepadId The id of the gamepad getting rumble
     * @param duration The duration, in seconds
     * @param lowFrequency Low frequency: value between 0 and 1
     * @param highFrequency High frequency: value between 0 and 1</haxe_doc>
		</startGamepadRumble>
		<stopGamepadRumble public="1" set="method" line="477"><f a="gamepadId">
	<x path="Int"/>
	<x path="Void"/>
</f></stopGamepadRumble>
		<gamepadName public="1" set="method" line="483"><f a="gamepadId">
	<x path="Int"/>
	<c path="String"/>
</f></gamepadName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new set="method" line="47"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<abstract path="ceramic.IntBoolMap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntBoolMap.hx">
		<this><c path="ceramic.IntIntMap"/></this>
		<haxe_doc>* A map that uses int as keys and booleans as values.</haxe_doc>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="ceramic._IntBoolMap.IntBoolMap_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntBoolMap.hx" private="1" module="ceramic.IntBoolMap" final="1">
	<size public="1" get="accessor" set="null" static="1"><x path="Int"/></size>
	<get_size public="1" get="inline" set="null" line="11" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
</f></get_size>
	<iterableKeys public="1" get="accessor" set="null" static="1"><c path="Array"><x path="Int"/></c></iterableKeys>
	<get_iterableKeys get="inline" set="null" line="14" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="Array"><x path="Int"/></c>
</f></get_iterableKeys>
	<_asIntBoolMap get="inline" set="null" line="16" static="1">
		<f a="this">
			<c path="ceramic.IntIntMap"/>
			<x path="ceramic.IntBoolMap"/>
		</f>
		<meta><m n=":has_untyped"/></meta>
	</_asIntBoolMap>
	<_new public="1" get="inline" set="null" line="20" static="1">
		<f a="?size:?fillFactor:?iterable" v="16:0.5:false">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="ceramic.IntBoolMap"/>
		</f>
		<meta>
			<m n=":value"><e>{ iterable : false, fillFactor : 0.5, size : 16 }</e></m>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<exists public="1" get="inline" set="null" line="24" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></exists>
	<existsInline public="1" get="inline" set="null" line="28" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></existsInline>
	<get public="1" get="inline" set="null" line="32" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></get>
	<getInline public="1" get="inline" set="null" line="36" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getInline>
	<set public="1" get="inline" set="null" line="40" static="1"><f a="this:key:value">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></set>
	<remove public="1" get="inline" set="null" line="44" static="1"><f a="this:key">
	<c path="ceramic.IntIntMap"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></remove>
	<clear public="1" get="inline" set="null" line="48" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<x path="Void"/>
</f></clear>
	<copy public="1" set="method" line="52" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<x path="ceramic.IntBoolMap"/>
</f></copy>
	<iterator public="1" get="inline" set="null" line="56" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="ceramic.IntBoolMapIterator"/>
</f></iterator>
	<keys public="1" get="inline" set="null" line="60" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="ceramic.IntBoolMapKeyIterator"/>
</f></keys>
	<keyValueIterator public="1" get="inline" set="null" line="64" static="1"><f a="this">
	<c path="ceramic.IntIntMap"/>
	<c path="ceramic.IntBoolMapKeyValueIterator"/>
</f></keyValueIterator>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic.IntBoolMapIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntBoolMap.hx" module="ceramic.IntBoolMap">
		<intBoolMap><x path="ceramic.IntBoolMap"/></intBoolMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="86"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="90"><f a=""><x path="Bool"/></f></next>
		<new get="inline" set="null" line="77"><f a="intBoolMap">
	<x path="ceramic.IntBoolMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.IntBoolMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntBoolMapKeyIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntBoolMap.hx" module="ceramic.IntBoolMap">
		<iterableKeys><c path="Array"><x path="Int"/></c></iterableKeys>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="115"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="119"><f a=""><x path="Int"/></f></next>
		<new get="inline" set="null" line="107"><f a="intBoolMap">
	<x path="ceramic.IntBoolMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.IntBoolMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntBoolMapKeyValueIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntBoolMap.hx" module="ceramic.IntBoolMap">
		<intBoolMap><x path="ceramic.IntBoolMap"/></intBoolMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="144"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="148"><f a=""><a>
	<value><x path="Bool"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new get="inline" set="null" line="135"><f a="intBoolMap">
	<x path="ceramic.IntBoolMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.IntBoolMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntFloatMap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntFloatMap.hx">
		<intMap>
			<t path="Map">
				<x path="Int"/>
				<x path="Float"/>
			</t>
			<haxe_doc>* Backing map</haxe_doc>
		</intMap>
		<iterableKeys public="1" set="null" expr="null" line="201">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* When this map is marked as iterable, this array will contain every key.</haxe_doc>
		</iterableKeys>
		<iterableKeysUsed expr="null" line="202">
			<x path="ceramic.IntBoolMap"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</iterableKeysUsed>
		<size public="1" set="null" expr="0" line="204">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</size>
		<clear public="1" set="method" line="215"><f a=""><x path="Void"/></f></clear>
		<exists public="1" get="inline" set="null" line="224"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></exists>
		<set public="1" set="method" line="228"><f a="key:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set>
		<get public="1" get="inline" set="null" line="241"><f a="key">
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<remove public="1" set="method" line="245"><f a="key">
	<x path="Int"/>
	<x path="Float"/>
</f></remove>
		<getInline public="1" get="inline" set="null" line="260"><f a="key">
	<x path="Int"/>
	<x path="Float"/>
</f></getInline>
		<existsInline public="1" get="inline" set="null" line="265"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></existsInline>
		<copy public="1" get="inline" set="null" line="269"><f a=""><c path="ceramic.IntFloatMap"/></f></copy>
		<iterator public="1" get="inline" set="null" line="282"><f a=""><c path="ceramic.IntFloatMapIterator"/></f></iterator>
		<keys public="1" get="inline" set="null" line="286"><f a=""><c path="ceramic.IntFloatMapKeyIterator"/></f></keys>
		<keyValueIterator public="1" get="inline" set="null" line="290"><f a=""><c path="ceramic.IntFloatMapKeyValueIterator"/></f></keyValueIterator>
		<new public="1" set="method" line="206">
			<f a="?size:?fillFactor:?iterable" v="16:0.5:false">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ iterable : false, fillFactor : 0.5, size : 16 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.IntFloatMapIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntFloatMap.hx" module="ceramic.IntFloatMap">
		<intFloatMap><c path="ceramic.IntFloatMap"/></intFloatMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="314"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="318"><f a=""><x path="Float"/></f></next>
		<new get="inline" set="null" line="305"><f a="intFloatMap">
	<c path="ceramic.IntFloatMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.IntFloatMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntFloatMapKeyIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntFloatMap.hx" module="ceramic.IntFloatMap">
		<iterableKeys><c path="Array"><x path="Int"/></c></iterableKeys>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="343"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="347"><f a=""><x path="Float"/></f></next>
		<new get="inline" set="null" line="335"><f a="intFloatMap">
	<c path="ceramic.IntFloatMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.IntFloatMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntFloatMapKeyValueIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntFloatMap.hx" module="ceramic.IntFloatMap">
		<intFloatMap><c path="ceramic.IntFloatMap"/></intFloatMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="372"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="376"><f a=""><a>
	<value><x path="Float"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new get="inline" set="null" line="363"><f a="intFloatMap">
	<c path="ceramic.IntFloatMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.IntFloatMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntIntMapIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntIntMap.hx" module="ceramic.IntIntMap">
		<intIntMap><c path="ceramic.IntIntMap"/></intIntMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="582"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="586"><f a=""><x path="Int"/></f></next>
		<new get="inline" set="null" line="573"><f a="intIntMap">
	<c path="ceramic.IntIntMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.IntIntMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntIntMapKeyIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntIntMap.hx" module="ceramic.IntIntMap">
		<iterableKeys><c path="Array"><x path="Int"/></c></iterableKeys>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="611"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="615"><f a=""><x path="Int"/></f></next>
		<new get="inline" set="null" line="603"><f a="intIntMap">
	<c path="ceramic.IntIntMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.IntIntMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntIntMapKeyValueIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntIntMap.hx" module="ceramic.IntIntMap">
		<intIntMap><c path="ceramic.IntIntMap"/></intIntMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="640"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="644"><f a=""><a>
	<value><x path="Int"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new get="inline" set="null" line="631"><f a="intIntMap">
	<c path="ceramic.IntIntMap"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.IntIntMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntMap" params="V" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntMap.hx">
		<NO_VALUE get="inline" set="null" expr="0" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_VALUE>
		<NULL_VALUE get="inline" set="null" expr="1" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</NULL_VALUE>
		<RESERVED_GAP get="inline" set="null" expr="2" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</RESERVED_GAP>
		<RET_NULL final="1" set="null" expr="null" line="18" static="1">
			<c path="ceramic.IntMap.V"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</RET_NULL>
		<_keys><c path="ceramic.IntIntMap"/></_keys>
		<nextFreeIndex expr="0" line="22">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextFreeIndex>
		<initialSize><x path="Int"/></initialSize>
		<initialFillFactor><x path="Float"/></initialFillFactor>
		<iterableKeys public="1" set="null" expr="null" line="31">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* When this map is marked as iterable, this array will contain every key.</haxe_doc>
		</iterableKeys>
		<values public="1" set="null">
			<x path="haxe.ds.Vector"><x path="Any"/></x>
			<haxe_doc>* Values as they are stored.
     * Can be used to iterate on values directly,
     * but can contain null values.</haxe_doc>
		</values>
		<get public="1" set="method" line="58"><f a="key">
	<x path="Int"/>
	<c path="ceramic.IntMap.V"/>
</f></get>
		<getInline public="1" get="inline" set="null" line="64"><f a="key">
	<x path="Int"/>
	<c path="ceramic.IntMap.V"/>
</f></getInline>
		<exists public="1" set="method" line="71"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></exists>
		<existsInline public="1" get="inline" set="null" line="77"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></existsInline>
		<set public="1" set="method" line="83"><f a="key:value">
	<x path="Int"/>
	<c path="ceramic.IntMap.V"/>
	<x path="Void"/>
</f></set>
		<remove public="1" set="method" line="136"><f a="key">
	<x path="Int"/>
	<x path="Void"/>
</f></remove>
		<copy public="1" set="method" line="163"><f a=""><c path="ceramic.IntMap"><c path="ceramic.IntMap.V"/></c></f></copy>
		<clear public="1" set="method" line="178"><f a=""><x path="Void"/></f></clear>
		<iterator public="1" get="inline" set="null" line="190"><f a=""><c path="ceramic.IntMapIterator"><c path="ceramic.IntMap.V"/></c></f></iterator>
		<keys public="1" get="inline" set="null" line="194"><f a=""><c path="ceramic.IntMapKeyIterator"><c path="ceramic.IntMap.V"/></c></f></keys>
		<keyValueIterator public="1" get="inline" set="null" line="198"><f a=""><c path="ceramic.IntMapKeyValueIterator"><c path="ceramic.IntMap.V"/></c></f></keyValueIterator>
		<resizeValues set="method" line="204"><f a="targetSize">
	<x path="Int"/>
	<x path="Void"/>
</f></resizeValues>
		<new public="1" set="method" line="44">
			<f a="?size:?fillFactor:?iterable" v="16:0.5:false">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ iterable : false, fillFactor : 0.5, size : 16 }</e></m></meta>
		</new>
		<haxe_doc>* An object map that uses integers as key.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.IntMapIterator" params="V" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntMap.hx" module="ceramic.IntMap">
		<intMap><c path="ceramic.IntMap"><c path="ceramic.IntMapIterator.V"/></c></intMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="239"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="243"><f a=""><c path="ceramic.IntMapIterator.V"/></f></next>
		<new get="inline" set="null" line="230"><f a="intMap">
	<c path="ceramic.IntMap"><c path="ceramic.IntMapIterator.V"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.IntMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntMapKeyIterator" params="V" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntMap.hx" module="ceramic.IntMap">
		<iterableKeys><c path="Array"><x path="Int"/></c></iterableKeys>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="270"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="274"><f a=""><x path="Int"/></f></next>
		<new get="inline" set="null" line="262"><f a="intMap">
	<c path="ceramic.IntMap"><c path="ceramic.IntMapKeyIterator.V"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.IntMap</e></m>
		</meta>
	</class>
	<class path="ceramic.IntMapKeyValueIterator" params="V" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/IntMap.hx" module="ceramic.IntMap">
		<intMap><c path="ceramic.IntMap"><c path="ceramic.IntMapKeyValueIterator.V"/></c></intMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="302"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="306"><f a=""><a>
	<value><c path="ceramic.IntMapKeyValueIterator.V"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new get="inline" set="null" line="293"><f a="intMap">
	<c path="ceramic.IntMap"><c path="ceramic.IntMapKeyValueIterator.V"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.IntMap</e></m>
		</meta>
	</class>
	<class path="ceramic.Json" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Json.hx">
		<stringify public="1" get="inline" set="null" line="5" static="1"><f a="value:?replacer:?space">
	<d/>
	<f a="key:value">
		<d/>
		<d/>
		<d/>
	</f>
	<c path="String"/>
	<c path="String"/>
</f></stringify>
		<parse public="1" get="inline" set="null" line="11" static="1"><f a="text">
	<c path="String"/>
	<d/>
</f></parse>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.Key" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Key.hx">
		<keyCode public="1" set="null">
			<x path="ceramic.KeyCode"/>
			<haxe_doc>* Key code (localized key) depends on keyboard mapping (QWERTY, AZERTY, ...)</haxe_doc>
		</keyCode>
		<keyCodeName public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>* Name associated to the key code (localized key)</haxe_doc>
		</keyCodeName>
		<get_keyCodeName get="inline" set="null" line="21"><f a=""><c path="String"/></f></get_keyCodeName>
		<scanCode public="1" set="null">
			<x path="ceramic.ScanCode"/>
			<haxe_doc>* Scan code (US international key) doesn't depend on keyboard mapping (QWERTY, AZERTY, ...)</haxe_doc>
		</scanCode>
		<scanCodeName public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>* Name associated to the scan code (US international key)</haxe_doc>
		</scanCodeName>
		<get_scanCodeName get="inline" set="null" line="34"><f a=""><c path="String"/></f></get_scanCodeName>
		<toString set="method" line="38"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="5"><f a="keyCode:scanCode">
	<x path="ceramic.KeyCode"/>
	<x path="ceramic.ScanCode"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<enum path="ceramic.KeyAcceleratorItem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/KeyAcceleratorItem.hx">
		<SHIFT/>
		<CMD_OR_CTRL/>
		<SCAN a="scanCode"><x path="ceramic.ScanCode"/></SCAN>
		<KEY a="keyCode"><x path="ceramic.KeyCode"/></KEY>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<class path="ceramic.KeyBinding" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/KeyBinding.hx">
		<extends path="ceramic.Entity"/>
		<_dox_event_trigger public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_trigger>
		<emitTrigger set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>trigger event</haxe_doc>
		</emitTrigger>
		<onTrigger public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>trigger event</haxe_doc>
		</onTrigger>
		<onceTrigger public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>trigger event</haxe_doc>
		</onceTrigger>
		<offTrigger public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>trigger event</haxe_doc>
		</offTrigger>
		<listensTrigger public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to trigger event</haxe_doc>
		</listensTrigger>
		<accelerator public="1" set="null"><x path="ceramic.ReadOnlyArray"><e path="ceramic.KeyAcceleratorItem"/></x></accelerator>
		<bindings public="1" set="null" expr="null" line="16">
			<c path="ceramic.KeyBindings"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</bindings>
		<pressedItems expr="[]" line="18">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pressedItems>
		<matches expr="false" line="20">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</matches>
		<leftShiftPressed expr="false" line="22">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</leftShiftPressed>
		<rightShiftPressed expr="false" line="24">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rightShiftPressed>
		<disableIfShiftPressed expr="false" line="26">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</disableIfShiftPressed>
		<forceKeysUp public="1" set="method" line="48">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</forceKeysUp>
		<bindKeyboardEvents set="method" line="62"><f a=""><x path="Void"/></f></bindKeyboardEvents>
		<bindScanCode set="method" line="101"><f a="scanCode:itemIndex">
	<x path="ceramic.ScanCode"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bindScanCode>
		<bindKeyCode set="method" line="175"><f a="keyCode:itemIndex">
	<x path="ceramic.KeyCode"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bindKeyCode>
		<bindShift set="method" line="213"><f a=""><x path="Void"/></f></bindShift>
		<checkStatus set="method" line="239"><f a=""><x path="Void"/></f></checkStatus>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new set="method" line="35"><f a="accelerator:?bindings">
	<c path="Array"><e path="ceramic.KeyAcceleratorItem"/></c>
	<c path="ceramic.KeyBindings"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.KeyBindings</e></m>
		</meta>
	</class>
	<class path="ceramic.KeyBindings" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/KeyBindings.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<instances expr="[]" line="9" static="1">
			<c path="Array"><c path="ceramic.KeyBindings"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</instances>
		<forceKeysUp public="1" set="method" line="64" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</forceKeysUp>
		<bindings expr="[]" line="13">
			<c path="Array"><c path="ceramic.KeyBinding"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</bindings>
		<bindAsComponent set="method" line="17"><f a=""><x path="Void"/></f></bindAsComponent>
		<destroy public="1" set="method" line="31" override="1"><f a=""><x path="Void"/></f></destroy>
		<bind public="1" set="method" line="48"><f a="accelerator:?callback">
	<c path="Array"><e path="ceramic.KeyAcceleratorItem"/></c>
	<f a=""><x path="Void"/></f>
	<c path="ceramic.KeyBinding"/>
</f></bind>
		<entity public="1">
			<c path="ceramic.Entity"/>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</entity>
		<setEntity set="method" line="7">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="7">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.KeyCode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/KeyCode.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._KeyCode.KeyCode_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/KeyCode.hx" private="1" module="ceramic.KeyCode" final="1">
	<UNKNOWN public="1" get="inline" set="null" expr="cast 0" line="13" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNKNOWN>
	<ENTER public="1" get="inline" set="null" expr="cast 13" line="15" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ENTER>
	<ESCAPE public="1" get="inline" set="null" expr="cast 27" line="16" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 27</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ESCAPE>
	<BACKSPACE public="1" get="inline" set="null" expr="cast 8" line="17" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BACKSPACE>
	<TAB public="1" get="inline" set="null" expr="cast 9" line="18" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TAB>
	<SPACE public="1" get="inline" set="null" expr="cast 32" line="19" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 32</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SPACE>
	<EXCLAIM public="1" get="inline" set="null" expr="cast 33" line="20" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 33</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EXCLAIM>
	<QUOTEDBL public="1" get="inline" set="null" expr="cast 34" line="21" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 34</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUOTEDBL>
	<HASH public="1" get="inline" set="null" expr="cast 35" line="22" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 35</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HASH>
	<PERCENT public="1" get="inline" set="null" expr="cast 37" line="23" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 37</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PERCENT>
	<DOLLAR public="1" get="inline" set="null" expr="cast 36" line="24" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 36</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DOLLAR>
	<AMPERSAND public="1" get="inline" set="null" expr="cast 38" line="25" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 38</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AMPERSAND>
	<QUOTE public="1" get="inline" set="null" expr="cast 39" line="26" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 39</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUOTE>
	<LEFTPAREN public="1" get="inline" set="null" expr="cast 40" line="27" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 40</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFTPAREN>
	<RIGHTPAREN public="1" get="inline" set="null" expr="cast 41" line="28" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 41</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHTPAREN>
	<ASTERISK public="1" get="inline" set="null" expr="cast 42" line="29" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 42</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ASTERISK>
	<PLUS public="1" get="inline" set="null" expr="cast 43" line="30" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 43</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PLUS>
	<COMMA public="1" get="inline" set="null" expr="cast 44" line="31" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 44</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COMMA>
	<MINUS public="1" get="inline" set="null" expr="cast 45" line="32" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 45</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MINUS>
	<PERIOD public="1" get="inline" set="null" expr="cast 46" line="33" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 46</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PERIOD>
	<SLASH public="1" get="inline" set="null" expr="cast 47" line="34" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 47</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SLASH>
	<KEY_0 public="1" get="inline" set="null" expr="cast 48" line="35" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 48</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_0>
	<KEY_1 public="1" get="inline" set="null" expr="cast 49" line="36" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 49</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_1>
	<KEY_2 public="1" get="inline" set="null" expr="cast 50" line="37" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 50</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_2>
	<KEY_3 public="1" get="inline" set="null" expr="cast 51" line="38" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 51</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_3>
	<KEY_4 public="1" get="inline" set="null" expr="cast 52" line="39" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 52</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_4>
	<KEY_5 public="1" get="inline" set="null" expr="cast 53" line="40" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 53</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_5>
	<KEY_6 public="1" get="inline" set="null" expr="cast 54" line="41" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 54</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_6>
	<KEY_7 public="1" get="inline" set="null" expr="cast 55" line="42" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 55</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_7>
	<KEY_8 public="1" get="inline" set="null" expr="cast 56" line="43" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 56</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_8>
	<KEY_9 public="1" get="inline" set="null" expr="cast 57" line="44" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 57</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_9>
	<COLON public="1" get="inline" set="null" expr="cast 58" line="45" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 58</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COLON>
	<SEMICOLON public="1" get="inline" set="null" expr="cast 59" line="46" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 59</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SEMICOLON>
	<LESS public="1" get="inline" set="null" expr="cast 60" line="47" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 60</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LESS>
	<EQUALS public="1" get="inline" set="null" expr="cast 61" line="48" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 61</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EQUALS>
	<GREATER public="1" get="inline" set="null" expr="cast 62" line="49" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 62</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</GREATER>
	<QUESTION public="1" get="inline" set="null" expr="cast 63" line="50" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 63</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUESTION>
	<AT public="1" get="inline" set="null" expr="cast 64" line="51" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 64</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AT>
	<LEFTBRACKET public="1" get="inline" set="null" expr="cast 91" line="55" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 91</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFTBRACKET>
	<BACKSLASH public="1" get="inline" set="null" expr="cast 92" line="56" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 92</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BACKSLASH>
	<RIGHTBRACKET public="1" get="inline" set="null" expr="cast 93" line="57" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 93</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHTBRACKET>
	<CARET public="1" get="inline" set="null" expr="cast 94" line="58" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 94</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CARET>
	<UNDERSCORE public="1" get="inline" set="null" expr="cast 95" line="59" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 95</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNDERSCORE>
	<BACKQUOTE public="1" get="inline" set="null" expr="cast 96" line="60" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 96</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BACKQUOTE>
	<KEY_A public="1" get="inline" set="null" expr="cast 97" line="61" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 97</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_A>
	<KEY_B public="1" get="inline" set="null" expr="cast 98" line="62" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 98</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_B>
	<KEY_C public="1" get="inline" set="null" expr="cast 99" line="63" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 99</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_C>
	<KEY_D public="1" get="inline" set="null" expr="cast 100" line="64" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 100</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_D>
	<KEY_E public="1" get="inline" set="null" expr="cast 101" line="65" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 101</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_E>
	<KEY_F public="1" get="inline" set="null" expr="cast 102" line="66" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 102</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_F>
	<KEY_G public="1" get="inline" set="null" expr="cast 103" line="67" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 103</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_G>
	<KEY_H public="1" get="inline" set="null" expr="cast 104" line="68" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 104</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_H>
	<KEY_I public="1" get="inline" set="null" expr="cast 105" line="69" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 105</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_I>
	<KEY_J public="1" get="inline" set="null" expr="cast 106" line="70" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 106</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_J>
	<KEY_K public="1" get="inline" set="null" expr="cast 107" line="71" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 107</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_K>
	<KEY_L public="1" get="inline" set="null" expr="cast 108" line="72" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 108</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_L>
	<KEY_M public="1" get="inline" set="null" expr="cast 109" line="73" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 109</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_M>
	<KEY_N public="1" get="inline" set="null" expr="cast 110" line="74" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 110</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_N>
	<KEY_O public="1" get="inline" set="null" expr="cast 111" line="75" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 111</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_O>
	<KEY_P public="1" get="inline" set="null" expr="cast 112" line="76" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 112</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_P>
	<KEY_Q public="1" get="inline" set="null" expr="cast 113" line="77" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 113</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_Q>
	<KEY_R public="1" get="inline" set="null" expr="cast 114" line="78" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 114</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_R>
	<KEY_S public="1" get="inline" set="null" expr="cast 115" line="79" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 115</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_S>
	<KEY_T public="1" get="inline" set="null" expr="cast 116" line="80" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 116</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_T>
	<KEY_U public="1" get="inline" set="null" expr="cast 117" line="81" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 117</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_U>
	<KEY_V public="1" get="inline" set="null" expr="cast 118" line="82" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 118</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_V>
	<KEY_W public="1" get="inline" set="null" expr="cast 119" line="83" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 119</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_W>
	<KEY_X public="1" get="inline" set="null" expr="cast 120" line="84" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 120</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_X>
	<KEY_Y public="1" get="inline" set="null" expr="cast 121" line="85" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 121</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_Y>
	<KEY_Z public="1" get="inline" set="null" expr="cast 122" line="86" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 122</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_Z>
	<CAPSLOCK public="1" get="inline" set="null" expr="cast 57 | (1 &lt;&lt; 30)" line="88" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 57 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CAPSLOCK>
	<F1 public="1" get="inline" set="null" expr="cast 58 | (1 &lt;&lt; 30)" line="90" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 58 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F1>
	<F2 public="1" get="inline" set="null" expr="cast 59 | (1 &lt;&lt; 30)" line="91" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 59 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F2>
	<F3 public="1" get="inline" set="null" expr="cast 60 | (1 &lt;&lt; 30)" line="92" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 60 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F3>
	<F4 public="1" get="inline" set="null" expr="cast 61 | (1 &lt;&lt; 30)" line="93" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 61 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F4>
	<F5 public="1" get="inline" set="null" expr="cast 62 | (1 &lt;&lt; 30)" line="94" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 62 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F5>
	<F6 public="1" get="inline" set="null" expr="cast 63 | (1 &lt;&lt; 30)" line="95" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 63 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F6>
	<F7 public="1" get="inline" set="null" expr="cast 64 | (1 &lt;&lt; 30)" line="96" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 64 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F7>
	<F8 public="1" get="inline" set="null" expr="cast 65 | (1 &lt;&lt; 30)" line="97" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 65 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F8>
	<F9 public="1" get="inline" set="null" expr="cast 66 | (1 &lt;&lt; 30)" line="98" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 66 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F9>
	<F10 public="1" get="inline" set="null" expr="cast 67 | (1 &lt;&lt; 30)" line="99" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 67 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F10>
	<F11 public="1" get="inline" set="null" expr="cast 68 | (1 &lt;&lt; 30)" line="100" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 68 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F11>
	<F12 public="1" get="inline" set="null" expr="cast 69 | (1 &lt;&lt; 30)" line="101" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 69 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F12>
	<PRINTSCREEN public="1" get="inline" set="null" expr="cast 70 | (1 &lt;&lt; 30)" line="103" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 70 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PRINTSCREEN>
	<SCROLLLOCK public="1" get="inline" set="null" expr="cast 71 | (1 &lt;&lt; 30)" line="104" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 71 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCROLLLOCK>
	<PAUSE public="1" get="inline" set="null" expr="cast 72 | (1 &lt;&lt; 30)" line="105" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 72 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAUSE>
	<INSERT public="1" get="inline" set="null" expr="cast 73 | (1 &lt;&lt; 30)" line="107" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 73 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INSERT>
	<HOME public="1" get="inline" set="null" expr="cast 74 | (1 &lt;&lt; 30)" line="108" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 74 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HOME>
	<PAGEUP public="1" get="inline" set="null" expr="cast 75 | (1 &lt;&lt; 30)" line="109" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 75 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAGEUP>
	<DELETE public="1" get="inline" set="null" expr="cast 127" line="110" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 127</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DELETE>
	<END public="1" get="inline" set="null" expr="cast 77 | (1 &lt;&lt; 30)" line="111" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 77 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</END>
	<PAGEDOWN public="1" get="inline" set="null" expr="cast 78 | (1 &lt;&lt; 30)" line="112" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 78 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAGEDOWN>
	<RIGHT public="1" get="inline" set="null" expr="cast 79 | (1 &lt;&lt; 30)" line="113" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 79 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT>
	<LEFT public="1" get="inline" set="null" expr="cast 80 | (1 &lt;&lt; 30)" line="114" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 80 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT>
	<DOWN public="1" get="inline" set="null" expr="cast 81 | (1 &lt;&lt; 30)" line="115" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 81 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DOWN>
	<UP public="1" get="inline" set="null" expr="cast 82 | (1 &lt;&lt; 30)" line="116" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 82 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UP>
	<NUMLOCKCLEAR public="1" get="inline" set="null" expr="cast 83 | (1 &lt;&lt; 30)" line="118" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 83 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NUMLOCKCLEAR>
	<KP_DIVIDE public="1" get="inline" set="null" expr="cast 84 | (1 &lt;&lt; 30)" line="119" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 84 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DIVIDE>
	<KP_MULTIPLY public="1" get="inline" set="null" expr="cast 85 | (1 &lt;&lt; 30)" line="120" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 85 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MULTIPLY>
	<KP_MINUS public="1" get="inline" set="null" expr="cast 86 | (1 &lt;&lt; 30)" line="121" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 86 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MINUS>
	<KP_PLUS public="1" get="inline" set="null" expr="cast 87 | (1 &lt;&lt; 30)" line="122" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 87 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PLUS>
	<KP_ENTER public="1" get="inline" set="null" expr="cast 88 | (1 &lt;&lt; 30)" line="123" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 88 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_ENTER>
	<KP_1 public="1" get="inline" set="null" expr="cast 89 | (1 &lt;&lt; 30)" line="124" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 89 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_1>
	<KP_2 public="1" get="inline" set="null" expr="cast 90 | (1 &lt;&lt; 30)" line="125" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 90 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_2>
	<KP_3 public="1" get="inline" set="null" expr="cast 91 | (1 &lt;&lt; 30)" line="126" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 91 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_3>
	<KP_4 public="1" get="inline" set="null" expr="cast 92 | (1 &lt;&lt; 30)" line="127" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 92 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_4>
	<KP_5 public="1" get="inline" set="null" expr="cast 93 | (1 &lt;&lt; 30)" line="128" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 93 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_5>
	<KP_6 public="1" get="inline" set="null" expr="cast 94 | (1 &lt;&lt; 30)" line="129" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 94 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_6>
	<KP_7 public="1" get="inline" set="null" expr="cast 95 | (1 &lt;&lt; 30)" line="130" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 95 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_7>
	<KP_8 public="1" get="inline" set="null" expr="cast 96 | (1 &lt;&lt; 30)" line="131" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 96 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_8>
	<KP_9 public="1" get="inline" set="null" expr="cast 97 | (1 &lt;&lt; 30)" line="132" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 97 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_9>
	<KP_0 public="1" get="inline" set="null" expr="cast 98 | (1 &lt;&lt; 30)" line="133" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 98 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_0>
	<KP_PERIOD public="1" get="inline" set="null" expr="cast 99 | (1 &lt;&lt; 30)" line="134" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 99 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PERIOD>
	<APPLICATION public="1" get="inline" set="null" expr="cast 101 | (1 &lt;&lt; 30)" line="136" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 101 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</APPLICATION>
	<POWER public="1" get="inline" set="null" expr="cast 102 | (1 &lt;&lt; 30)" line="138" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 102 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</POWER>
	<KP_EQUALS public="1" get="inline" set="null" expr="cast 103 | (1 &lt;&lt; 30)" line="139" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 103 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_EQUALS>
	<F13 public="1" get="inline" set="null" expr="cast 104 | (1 &lt;&lt; 30)" line="140" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 104 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F13>
	<F14 public="1" get="inline" set="null" expr="cast 105 | (1 &lt;&lt; 30)" line="141" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 105 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F14>
	<F15 public="1" get="inline" set="null" expr="cast 106 | (1 &lt;&lt; 30)" line="142" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 106 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F15>
	<F16 public="1" get="inline" set="null" expr="cast 107 | (1 &lt;&lt; 30)" line="143" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 107 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F16>
	<F17 public="1" get="inline" set="null" expr="cast 108 | (1 &lt;&lt; 30)" line="144" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 108 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F17>
	<F18 public="1" get="inline" set="null" expr="cast 109 | (1 &lt;&lt; 30)" line="145" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 109 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F18>
	<F19 public="1" get="inline" set="null" expr="cast 110 | (1 &lt;&lt; 30)" line="146" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 110 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F19>
	<F20 public="1" get="inline" set="null" expr="cast 111 | (1 &lt;&lt; 30)" line="147" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 111 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F20>
	<F21 public="1" get="inline" set="null" expr="cast 112 | (1 &lt;&lt; 30)" line="148" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 112 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F21>
	<F22 public="1" get="inline" set="null" expr="cast 113 | (1 &lt;&lt; 30)" line="149" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 113 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F22>
	<F23 public="1" get="inline" set="null" expr="cast 114 | (1 &lt;&lt; 30)" line="150" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 114 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F23>
	<F24 public="1" get="inline" set="null" expr="cast 115 | (1 &lt;&lt; 30)" line="151" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 115 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F24>
	<EXECUTE public="1" get="inline" set="null" expr="cast 116 | (1 &lt;&lt; 30)" line="152" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 116 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EXECUTE>
	<HELP public="1" get="inline" set="null" expr="cast 117 | (1 &lt;&lt; 30)" line="153" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 117 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HELP>
	<MENU public="1" get="inline" set="null" expr="cast 118 | (1 &lt;&lt; 30)" line="154" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 118 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MENU>
	<SELECT public="1" get="inline" set="null" expr="cast 119 | (1 &lt;&lt; 30)" line="155" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 119 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SELECT>
	<STOP public="1" get="inline" set="null" expr="cast 120 | (1 &lt;&lt; 30)" line="156" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 120 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</STOP>
	<AGAIN public="1" get="inline" set="null" expr="cast 121 | (1 &lt;&lt; 30)" line="158" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 121 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AGAIN>
	<UNDO public="1" get="inline" set="null" expr="cast 122 | (1 &lt;&lt; 30)" line="159" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 122 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNDO>
	<CUT public="1" get="inline" set="null" expr="cast 123 | (1 &lt;&lt; 30)" line="160" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 123 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CUT>
	<COPY public="1" get="inline" set="null" expr="cast 124 | (1 &lt;&lt; 30)" line="161" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 124 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COPY>
	<PASTE public="1" get="inline" set="null" expr="cast 125 | (1 &lt;&lt; 30)" line="162" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 125 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PASTE>
	<FIND public="1" get="inline" set="null" expr="cast 126 | (1 &lt;&lt; 30)" line="163" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 126 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</FIND>
	<MUTE public="1" get="inline" set="null" expr="cast 127 | (1 &lt;&lt; 30)" line="164" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 127 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MUTE>
	<VOLUMEUP public="1" get="inline" set="null" expr="cast 128 | (1 &lt;&lt; 30)" line="165" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 128 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VOLUMEUP>
	<VOLUMEDOWN public="1" get="inline" set="null" expr="cast 129 | (1 &lt;&lt; 30)" line="166" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 129 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VOLUMEDOWN>
	<KP_COMMA public="1" get="inline" set="null" expr="cast 133 | (1 &lt;&lt; 30)" line="168" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 133 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_COMMA>
	<KP_EQUALSAS400 public="1" get="inline" set="null" expr="cast 134 | (1 &lt;&lt; 30)" line="169" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 134 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_EQUALSAS400>
	<ALTERASE public="1" get="inline" set="null" expr="cast 153 | (1 &lt;&lt; 30)" line="171" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 153 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ALTERASE>
	<SYSREQ public="1" get="inline" set="null" expr="cast 154 | (1 &lt;&lt; 30)" line="172" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 154 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SYSREQ>
	<CANCEL public="1" get="inline" set="null" expr="cast 155 | (1 &lt;&lt; 30)" line="173" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 155 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CANCEL>
	<CLEAR public="1" get="inline" set="null" expr="cast 156 | (1 &lt;&lt; 30)" line="174" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 156 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CLEAR>
	<PRIOR public="1" get="inline" set="null" expr="cast 157 | (1 &lt;&lt; 30)" line="175" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 157 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PRIOR>
	<RETURN2 public="1" get="inline" set="null" expr="cast 158 | (1 &lt;&lt; 30)" line="176" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 158 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RETURN2>
	<SEPARATOR public="1" get="inline" set="null" expr="cast 159 | (1 &lt;&lt; 30)" line="177" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 159 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SEPARATOR>
	<OUT public="1" get="inline" set="null" expr="cast 160 | (1 &lt;&lt; 30)" line="178" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 160 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OUT>
	<OPER public="1" get="inline" set="null" expr="cast 161 | (1 &lt;&lt; 30)" line="179" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 161 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OPER>
	<CLEARAGAIN public="1" get="inline" set="null" expr="cast 162 | (1 &lt;&lt; 30)" line="180" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 162 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CLEARAGAIN>
	<CRSEL public="1" get="inline" set="null" expr="cast 163 | (1 &lt;&lt; 30)" line="181" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 163 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CRSEL>
	<EXSEL public="1" get="inline" set="null" expr="cast 164 | (1 &lt;&lt; 30)" line="182" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 164 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EXSEL>
	<KP_00 public="1" get="inline" set="null" expr="cast 176 | (1 &lt;&lt; 30)" line="184" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 176 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_00>
	<KP_000 public="1" get="inline" set="null" expr="cast 177 | (1 &lt;&lt; 30)" line="185" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 177 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_000>
	<THOUSANDSSEPARATOR public="1" get="inline" set="null" expr="cast 178 | (1 &lt;&lt; 30)" line="186" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 178 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</THOUSANDSSEPARATOR>
	<DECIMALSEPARATOR public="1" get="inline" set="null" expr="cast 179 | (1 &lt;&lt; 30)" line="187" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 179 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DECIMALSEPARATOR>
	<CURRENCYUNIT public="1" get="inline" set="null" expr="cast 180 | (1 &lt;&lt; 30)" line="188" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 180 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CURRENCYUNIT>
	<CURRENCYSUBUNIT public="1" get="inline" set="null" expr="cast 181 | (1 &lt;&lt; 30)" line="189" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 181 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CURRENCYSUBUNIT>
	<KP_LEFTPAREN public="1" get="inline" set="null" expr="cast 182 | (1 &lt;&lt; 30)" line="190" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 182 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_LEFTPAREN>
	<KP_RIGHTPAREN public="1" get="inline" set="null" expr="cast 183 | (1 &lt;&lt; 30)" line="191" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 183 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_RIGHTPAREN>
	<KP_LEFTBRACE public="1" get="inline" set="null" expr="cast 184 | (1 &lt;&lt; 30)" line="192" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 184 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_LEFTBRACE>
	<KP_RIGHTBRACE public="1" get="inline" set="null" expr="cast 185 | (1 &lt;&lt; 30)" line="193" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 185 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_RIGHTBRACE>
	<KP_TAB public="1" get="inline" set="null" expr="cast 186 | (1 &lt;&lt; 30)" line="194" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 186 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_TAB>
	<KP_BACKSPACE public="1" get="inline" set="null" expr="cast 187 | (1 &lt;&lt; 30)" line="195" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 187 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_BACKSPACE>
	<KP_A public="1" get="inline" set="null" expr="cast 188 | (1 &lt;&lt; 30)" line="196" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 188 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_A>
	<KP_B public="1" get="inline" set="null" expr="cast 189 | (1 &lt;&lt; 30)" line="197" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 189 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_B>
	<KP_C public="1" get="inline" set="null" expr="cast 190 | (1 &lt;&lt; 30)" line="198" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 190 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_C>
	<KP_D public="1" get="inline" set="null" expr="cast 191 | (1 &lt;&lt; 30)" line="199" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 191 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_D>
	<KP_E public="1" get="inline" set="null" expr="cast 192 | (1 &lt;&lt; 30)" line="200" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 192 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_E>
	<KP_F public="1" get="inline" set="null" expr="cast 193 | (1 &lt;&lt; 30)" line="201" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 193 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_F>
	<KP_XOR public="1" get="inline" set="null" expr="cast 194 | (1 &lt;&lt; 30)" line="202" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 194 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_XOR>
	<KP_POWER public="1" get="inline" set="null" expr="cast 195 | (1 &lt;&lt; 30)" line="203" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 195 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_POWER>
	<KP_PERCENT public="1" get="inline" set="null" expr="cast 196 | (1 &lt;&lt; 30)" line="204" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 196 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PERCENT>
	<KP_LESS public="1" get="inline" set="null" expr="cast 197 | (1 &lt;&lt; 30)" line="205" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 197 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_LESS>
	<KP_GREATER public="1" get="inline" set="null" expr="cast 198 | (1 &lt;&lt; 30)" line="206" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 198 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_GREATER>
	<KP_AMPERSAND public="1" get="inline" set="null" expr="cast 199 | (1 &lt;&lt; 30)" line="207" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 199 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_AMPERSAND>
	<KP_DBLAMPERSAND public="1" get="inline" set="null" expr="cast 200 | (1 &lt;&lt; 30)" line="208" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 200 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DBLAMPERSAND>
	<KP_VERTICALBAR public="1" get="inline" set="null" expr="cast 201 | (1 &lt;&lt; 30)" line="209" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 201 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_VERTICALBAR>
	<KP_DBLVERTICALBAR public="1" get="inline" set="null" expr="cast 202 | (1 &lt;&lt; 30)" line="210" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 202 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DBLVERTICALBAR>
	<KP_COLON public="1" get="inline" set="null" expr="cast 203 | (1 &lt;&lt; 30)" line="211" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 203 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_COLON>
	<KP_HASH public="1" get="inline" set="null" expr="cast 204 | (1 &lt;&lt; 30)" line="212" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 204 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_HASH>
	<KP_SPACE public="1" get="inline" set="null" expr="cast 205 | (1 &lt;&lt; 30)" line="213" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 205 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_SPACE>
	<KP_AT public="1" get="inline" set="null" expr="cast 206 | (1 &lt;&lt; 30)" line="214" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 206 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_AT>
	<KP_EXCLAM public="1" get="inline" set="null" expr="cast 207 | (1 &lt;&lt; 30)" line="215" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 207 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_EXCLAM>
	<KP_MEMSTORE public="1" get="inline" set="null" expr="cast 208 | (1 &lt;&lt; 30)" line="216" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 208 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMSTORE>
	<KP_MEMRECALL public="1" get="inline" set="null" expr="cast 209 | (1 &lt;&lt; 30)" line="217" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 209 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMRECALL>
	<KP_MEMCLEAR public="1" get="inline" set="null" expr="cast 210 | (1 &lt;&lt; 30)" line="218" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 210 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMCLEAR>
	<KP_MEMADD public="1" get="inline" set="null" expr="cast 211 | (1 &lt;&lt; 30)" line="219" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 211 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMADD>
	<KP_MEMSUBTRACT public="1" get="inline" set="null" expr="cast 212 | (1 &lt;&lt; 30)" line="220" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 212 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMSUBTRACT>
	<KP_MEMMULTIPLY public="1" get="inline" set="null" expr="cast 213 | (1 &lt;&lt; 30)" line="221" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 213 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMMULTIPLY>
	<KP_MEMDIVIDE public="1" get="inline" set="null" expr="cast 214 | (1 &lt;&lt; 30)" line="222" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 214 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMDIVIDE>
	<KP_PLUSMINUS public="1" get="inline" set="null" expr="cast 215 | (1 &lt;&lt; 30)" line="223" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 215 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PLUSMINUS>
	<KP_CLEAR public="1" get="inline" set="null" expr="cast 216 | (1 &lt;&lt; 30)" line="224" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 216 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_CLEAR>
	<KP_CLEARENTRY public="1" get="inline" set="null" expr="cast 217 | (1 &lt;&lt; 30)" line="225" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 217 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_CLEARENTRY>
	<KP_BINARY public="1" get="inline" set="null" expr="cast 218 | (1 &lt;&lt; 30)" line="226" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 218 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_BINARY>
	<KP_OCTAL public="1" get="inline" set="null" expr="cast 219 | (1 &lt;&lt; 30)" line="227" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 219 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_OCTAL>
	<KP_DECIMAL public="1" get="inline" set="null" expr="cast 220 | (1 &lt;&lt; 30)" line="228" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 220 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DECIMAL>
	<KP_HEXADECIMAL public="1" get="inline" set="null" expr="cast 221 | (1 &lt;&lt; 30)" line="229" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 221 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_HEXADECIMAL>
	<LCTRL public="1" get="inline" set="null" expr="cast 224 | (1 &lt;&lt; 30)" line="231" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 224 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LCTRL>
	<LSHIFT public="1" get="inline" set="null" expr="cast 225 | (1 &lt;&lt; 30)" line="232" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 225 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LSHIFT>
	<LALT public="1" get="inline" set="null" expr="cast 226 | (1 &lt;&lt; 30)" line="233" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 226 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LALT>
	<LMETA public="1" get="inline" set="null" expr="cast 227 | (1 &lt;&lt; 30)" line="234" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 227 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LMETA>
	<RCTRL public="1" get="inline" set="null" expr="cast 228 | (1 &lt;&lt; 30)" line="235" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 228 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RCTRL>
	<RSHIFT public="1" get="inline" set="null" expr="cast 229 | (1 &lt;&lt; 30)" line="236" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 229 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RSHIFT>
	<RALT public="1" get="inline" set="null" expr="cast 230 | (1 &lt;&lt; 30)" line="237" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 230 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RALT>
	<RMETA public="1" get="inline" set="null" expr="cast 231 | (1 &lt;&lt; 30)" line="238" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 231 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RMETA>
	<MODE public="1" get="inline" set="null" expr="cast 257 | (1 &lt;&lt; 30)" line="240" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 257 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MODE>
	<AUDIONEXT public="1" get="inline" set="null" expr="cast 258 | (1 &lt;&lt; 30)" line="242" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 258 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIONEXT>
	<AUDIOPREV public="1" get="inline" set="null" expr="cast 259 | (1 &lt;&lt; 30)" line="243" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 259 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOPREV>
	<AUDIOSTOP public="1" get="inline" set="null" expr="cast 260 | (1 &lt;&lt; 30)" line="244" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 260 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOSTOP>
	<AUDIOPLAY public="1" get="inline" set="null" expr="cast 261 | (1 &lt;&lt; 30)" line="245" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 261 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOPLAY>
	<AUDIOMUTE public="1" get="inline" set="null" expr="cast 262 | (1 &lt;&lt; 30)" line="246" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 262 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOMUTE>
	<MEDIASELECT public="1" get="inline" set="null" expr="cast 263 | (1 &lt;&lt; 30)" line="247" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 263 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MEDIASELECT>
	<WWW public="1" get="inline" set="null" expr="cast 264 | (1 &lt;&lt; 30)" line="248" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 264 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WWW>
	<MAIL public="1" get="inline" set="null" expr="cast 265 | (1 &lt;&lt; 30)" line="249" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 265 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MAIL>
	<CALCULATOR public="1" get="inline" set="null" expr="cast 266 | (1 &lt;&lt; 30)" line="250" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 266 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CALCULATOR>
	<COMPUTER public="1" get="inline" set="null" expr="cast 267 | (1 &lt;&lt; 30)" line="251" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 267 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COMPUTER>
	<AC_SEARCH public="1" get="inline" set="null" expr="cast 268 | (1 &lt;&lt; 30)" line="252" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 268 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_SEARCH>
	<AC_HOME public="1" get="inline" set="null" expr="cast 269 | (1 &lt;&lt; 30)" line="253" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 269 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_HOME>
	<AC_BACK public="1" get="inline" set="null" expr="cast 270 | (1 &lt;&lt; 30)" line="254" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 270 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_BACK>
	<AC_FORWARD public="1" get="inline" set="null" expr="cast 271 | (1 &lt;&lt; 30)" line="255" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 271 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_FORWARD>
	<AC_STOP public="1" get="inline" set="null" expr="cast 272 | (1 &lt;&lt; 30)" line="256" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 272 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_STOP>
	<AC_REFRESH public="1" get="inline" set="null" expr="cast 273 | (1 &lt;&lt; 30)" line="257" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 273 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_REFRESH>
	<AC_BOOKMARKS public="1" get="inline" set="null" expr="cast 274 | (1 &lt;&lt; 30)" line="258" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 274 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_BOOKMARKS>
	<BRIGHTNESSDOWN public="1" get="inline" set="null" expr="cast 275 | (1 &lt;&lt; 30)" line="260" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 275 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BRIGHTNESSDOWN>
	<BRIGHTNESSUP public="1" get="inline" set="null" expr="cast 276 | (1 &lt;&lt; 30)" line="261" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 276 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BRIGHTNESSUP>
	<DISPLAYSWITCH public="1" get="inline" set="null" expr="cast 277 | (1 &lt;&lt; 30)" line="262" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 277 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DISPLAYSWITCH>
	<KBDILLUMTOGGLE public="1" get="inline" set="null" expr="cast 278 | (1 &lt;&lt; 30)" line="263" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 278 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KBDILLUMTOGGLE>
	<KBDILLUMDOWN public="1" get="inline" set="null" expr="cast 279 | (1 &lt;&lt; 30)" line="264" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 279 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KBDILLUMDOWN>
	<KBDILLUMUP public="1" get="inline" set="null" expr="cast 280 | (1 &lt;&lt; 30)" line="265" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 280 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KBDILLUMUP>
	<EJECT public="1" get="inline" set="null" expr="cast 281 | (1 &lt;&lt; 30)" line="266" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 281 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EJECT>
	<SLEEP public="1" get="inline" set="null" expr="cast 282 | (1 &lt;&lt; 30)" line="267" static="1">
		<x path="ceramic.KeyCode"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 282 | (1 << 30)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SLEEP>
	<name public="1" set="method" line="272" static="1">
		<f a="keyCode">
			<x path="ceramic.KeyCode"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Convert a keyCode to string</haxe_doc>
	</name>
	<toString set="method" line="327" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._KeyCode.KeyCode_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/KeyCode.hx" private="1" module="ceramic.KeyCode" final="1">
		<UNKNOWN public="1" get="inline" set="null" expr="cast 0" line="13" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNKNOWN>
		<ENTER public="1" get="inline" set="null" expr="cast 13" line="15" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ENTER>
		<ESCAPE public="1" get="inline" set="null" expr="cast 27" line="16" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 27</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ESCAPE>
		<BACKSPACE public="1" get="inline" set="null" expr="cast 8" line="17" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BACKSPACE>
		<TAB public="1" get="inline" set="null" expr="cast 9" line="18" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TAB>
		<SPACE public="1" get="inline" set="null" expr="cast 32" line="19" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 32</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SPACE>
		<EXCLAIM public="1" get="inline" set="null" expr="cast 33" line="20" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 33</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EXCLAIM>
		<QUOTEDBL public="1" get="inline" set="null" expr="cast 34" line="21" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 34</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUOTEDBL>
		<HASH public="1" get="inline" set="null" expr="cast 35" line="22" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 35</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HASH>
		<PERCENT public="1" get="inline" set="null" expr="cast 37" line="23" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 37</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PERCENT>
		<DOLLAR public="1" get="inline" set="null" expr="cast 36" line="24" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 36</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DOLLAR>
		<AMPERSAND public="1" get="inline" set="null" expr="cast 38" line="25" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 38</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AMPERSAND>
		<QUOTE public="1" get="inline" set="null" expr="cast 39" line="26" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 39</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUOTE>
		<LEFTPAREN public="1" get="inline" set="null" expr="cast 40" line="27" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 40</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFTPAREN>
		<RIGHTPAREN public="1" get="inline" set="null" expr="cast 41" line="28" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 41</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHTPAREN>
		<ASTERISK public="1" get="inline" set="null" expr="cast 42" line="29" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 42</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ASTERISK>
		<PLUS public="1" get="inline" set="null" expr="cast 43" line="30" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 43</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PLUS>
		<COMMA public="1" get="inline" set="null" expr="cast 44" line="31" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 44</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COMMA>
		<MINUS public="1" get="inline" set="null" expr="cast 45" line="32" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 45</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MINUS>
		<PERIOD public="1" get="inline" set="null" expr="cast 46" line="33" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 46</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" expr="cast 47" line="34" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 47</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SLASH>
		<KEY_0 public="1" get="inline" set="null" expr="cast 48" line="35" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 48</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_0>
		<KEY_1 public="1" get="inline" set="null" expr="cast 49" line="36" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 49</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_1>
		<KEY_2 public="1" get="inline" set="null" expr="cast 50" line="37" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 50</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_2>
		<KEY_3 public="1" get="inline" set="null" expr="cast 51" line="38" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 51</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_3>
		<KEY_4 public="1" get="inline" set="null" expr="cast 52" line="39" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 52</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_4>
		<KEY_5 public="1" get="inline" set="null" expr="cast 53" line="40" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 53</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_5>
		<KEY_6 public="1" get="inline" set="null" expr="cast 54" line="41" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 54</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_6>
		<KEY_7 public="1" get="inline" set="null" expr="cast 55" line="42" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 55</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_7>
		<KEY_8 public="1" get="inline" set="null" expr="cast 56" line="43" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 56</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_8>
		<KEY_9 public="1" get="inline" set="null" expr="cast 57" line="44" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 57</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_9>
		<COLON public="1" get="inline" set="null" expr="cast 58" line="45" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 58</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COLON>
		<SEMICOLON public="1" get="inline" set="null" expr="cast 59" line="46" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 59</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SEMICOLON>
		<LESS public="1" get="inline" set="null" expr="cast 60" line="47" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 60</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LESS>
		<EQUALS public="1" get="inline" set="null" expr="cast 61" line="48" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 61</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EQUALS>
		<GREATER public="1" get="inline" set="null" expr="cast 62" line="49" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 62</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</GREATER>
		<QUESTION public="1" get="inline" set="null" expr="cast 63" line="50" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 63</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUESTION>
		<AT public="1" get="inline" set="null" expr="cast 64" line="51" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 64</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AT>
		<LEFTBRACKET public="1" get="inline" set="null" expr="cast 91" line="55" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 91</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFTBRACKET>
		<BACKSLASH public="1" get="inline" set="null" expr="cast 92" line="56" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 92</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BACKSLASH>
		<RIGHTBRACKET public="1" get="inline" set="null" expr="cast 93" line="57" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 93</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHTBRACKET>
		<CARET public="1" get="inline" set="null" expr="cast 94" line="58" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 94</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CARET>
		<UNDERSCORE public="1" get="inline" set="null" expr="cast 95" line="59" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 95</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNDERSCORE>
		<BACKQUOTE public="1" get="inline" set="null" expr="cast 96" line="60" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 96</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BACKQUOTE>
		<KEY_A public="1" get="inline" set="null" expr="cast 97" line="61" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 97</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_A>
		<KEY_B public="1" get="inline" set="null" expr="cast 98" line="62" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 98</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_B>
		<KEY_C public="1" get="inline" set="null" expr="cast 99" line="63" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 99</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_C>
		<KEY_D public="1" get="inline" set="null" expr="cast 100" line="64" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 100</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_D>
		<KEY_E public="1" get="inline" set="null" expr="cast 101" line="65" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 101</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_E>
		<KEY_F public="1" get="inline" set="null" expr="cast 102" line="66" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 102</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_F>
		<KEY_G public="1" get="inline" set="null" expr="cast 103" line="67" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 103</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_G>
		<KEY_H public="1" get="inline" set="null" expr="cast 104" line="68" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 104</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_H>
		<KEY_I public="1" get="inline" set="null" expr="cast 105" line="69" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 105</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_I>
		<KEY_J public="1" get="inline" set="null" expr="cast 106" line="70" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 106</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_J>
		<KEY_K public="1" get="inline" set="null" expr="cast 107" line="71" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 107</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_K>
		<KEY_L public="1" get="inline" set="null" expr="cast 108" line="72" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 108</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_L>
		<KEY_M public="1" get="inline" set="null" expr="cast 109" line="73" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 109</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_M>
		<KEY_N public="1" get="inline" set="null" expr="cast 110" line="74" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 110</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_N>
		<KEY_O public="1" get="inline" set="null" expr="cast 111" line="75" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 111</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_O>
		<KEY_P public="1" get="inline" set="null" expr="cast 112" line="76" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 112</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_P>
		<KEY_Q public="1" get="inline" set="null" expr="cast 113" line="77" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 113</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_Q>
		<KEY_R public="1" get="inline" set="null" expr="cast 114" line="78" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 114</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_R>
		<KEY_S public="1" get="inline" set="null" expr="cast 115" line="79" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 115</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_S>
		<KEY_T public="1" get="inline" set="null" expr="cast 116" line="80" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 116</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_T>
		<KEY_U public="1" get="inline" set="null" expr="cast 117" line="81" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 117</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_U>
		<KEY_V public="1" get="inline" set="null" expr="cast 118" line="82" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 118</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_V>
		<KEY_W public="1" get="inline" set="null" expr="cast 119" line="83" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 119</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_W>
		<KEY_X public="1" get="inline" set="null" expr="cast 120" line="84" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 120</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_X>
		<KEY_Y public="1" get="inline" set="null" expr="cast 121" line="85" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 121</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_Y>
		<KEY_Z public="1" get="inline" set="null" expr="cast 122" line="86" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 122</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_Z>
		<CAPSLOCK public="1" get="inline" set="null" expr="cast 57 | (1 &lt;&lt; 30)" line="88" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 57 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CAPSLOCK>
		<F1 public="1" get="inline" set="null" expr="cast 58 | (1 &lt;&lt; 30)" line="90" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 58 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="cast 59 | (1 &lt;&lt; 30)" line="91" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 59 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="cast 60 | (1 &lt;&lt; 30)" line="92" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 60 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="cast 61 | (1 &lt;&lt; 30)" line="93" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 61 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="cast 62 | (1 &lt;&lt; 30)" line="94" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 62 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="cast 63 | (1 &lt;&lt; 30)" line="95" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 63 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="cast 64 | (1 &lt;&lt; 30)" line="96" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 64 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="cast 65 | (1 &lt;&lt; 30)" line="97" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 65 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="cast 66 | (1 &lt;&lt; 30)" line="98" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 66 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="cast 67 | (1 &lt;&lt; 30)" line="99" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 67 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="cast 68 | (1 &lt;&lt; 30)" line="100" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 68 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="cast 69 | (1 &lt;&lt; 30)" line="101" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 69 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F12>
		<PRINTSCREEN public="1" get="inline" set="null" expr="cast 70 | (1 &lt;&lt; 30)" line="103" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 70 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PRINTSCREEN>
		<SCROLLLOCK public="1" get="inline" set="null" expr="cast 71 | (1 &lt;&lt; 30)" line="104" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 71 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCROLLLOCK>
		<PAUSE public="1" get="inline" set="null" expr="cast 72 | (1 &lt;&lt; 30)" line="105" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 72 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAUSE>
		<INSERT public="1" get="inline" set="null" expr="cast 73 | (1 &lt;&lt; 30)" line="107" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 73 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INSERT>
		<HOME public="1" get="inline" set="null" expr="cast 74 | (1 &lt;&lt; 30)" line="108" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 74 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HOME>
		<PAGEUP public="1" get="inline" set="null" expr="cast 75 | (1 &lt;&lt; 30)" line="109" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 75 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAGEUP>
		<DELETE public="1" get="inline" set="null" expr="cast 127" line="110" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 127</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DELETE>
		<END public="1" get="inline" set="null" expr="cast 77 | (1 &lt;&lt; 30)" line="111" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 77 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</END>
		<PAGEDOWN public="1" get="inline" set="null" expr="cast 78 | (1 &lt;&lt; 30)" line="112" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 78 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAGEDOWN>
		<RIGHT public="1" get="inline" set="null" expr="cast 79 | (1 &lt;&lt; 30)" line="113" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 79 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT>
		<LEFT public="1" get="inline" set="null" expr="cast 80 | (1 &lt;&lt; 30)" line="114" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 80 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT>
		<DOWN public="1" get="inline" set="null" expr="cast 81 | (1 &lt;&lt; 30)" line="115" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 81 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DOWN>
		<UP public="1" get="inline" set="null" expr="cast 82 | (1 &lt;&lt; 30)" line="116" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 82 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UP>
		<NUMLOCKCLEAR public="1" get="inline" set="null" expr="cast 83 | (1 &lt;&lt; 30)" line="118" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 83 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NUMLOCKCLEAR>
		<KP_DIVIDE public="1" get="inline" set="null" expr="cast 84 | (1 &lt;&lt; 30)" line="119" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 84 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DIVIDE>
		<KP_MULTIPLY public="1" get="inline" set="null" expr="cast 85 | (1 &lt;&lt; 30)" line="120" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 85 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MULTIPLY>
		<KP_MINUS public="1" get="inline" set="null" expr="cast 86 | (1 &lt;&lt; 30)" line="121" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 86 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MINUS>
		<KP_PLUS public="1" get="inline" set="null" expr="cast 87 | (1 &lt;&lt; 30)" line="122" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 87 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PLUS>
		<KP_ENTER public="1" get="inline" set="null" expr="cast 88 | (1 &lt;&lt; 30)" line="123" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 88 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_ENTER>
		<KP_1 public="1" get="inline" set="null" expr="cast 89 | (1 &lt;&lt; 30)" line="124" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 89 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_1>
		<KP_2 public="1" get="inline" set="null" expr="cast 90 | (1 &lt;&lt; 30)" line="125" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 90 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_2>
		<KP_3 public="1" get="inline" set="null" expr="cast 91 | (1 &lt;&lt; 30)" line="126" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 91 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_3>
		<KP_4 public="1" get="inline" set="null" expr="cast 92 | (1 &lt;&lt; 30)" line="127" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 92 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_4>
		<KP_5 public="1" get="inline" set="null" expr="cast 93 | (1 &lt;&lt; 30)" line="128" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 93 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_5>
		<KP_6 public="1" get="inline" set="null" expr="cast 94 | (1 &lt;&lt; 30)" line="129" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 94 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_6>
		<KP_7 public="1" get="inline" set="null" expr="cast 95 | (1 &lt;&lt; 30)" line="130" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 95 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_7>
		<KP_8 public="1" get="inline" set="null" expr="cast 96 | (1 &lt;&lt; 30)" line="131" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 96 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_8>
		<KP_9 public="1" get="inline" set="null" expr="cast 97 | (1 &lt;&lt; 30)" line="132" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 97 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_9>
		<KP_0 public="1" get="inline" set="null" expr="cast 98 | (1 &lt;&lt; 30)" line="133" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 98 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_0>
		<KP_PERIOD public="1" get="inline" set="null" expr="cast 99 | (1 &lt;&lt; 30)" line="134" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 99 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PERIOD>
		<APPLICATION public="1" get="inline" set="null" expr="cast 101 | (1 &lt;&lt; 30)" line="136" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 101 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</APPLICATION>
		<POWER public="1" get="inline" set="null" expr="cast 102 | (1 &lt;&lt; 30)" line="138" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 102 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</POWER>
		<KP_EQUALS public="1" get="inline" set="null" expr="cast 103 | (1 &lt;&lt; 30)" line="139" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 103 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_EQUALS>
		<F13 public="1" get="inline" set="null" expr="cast 104 | (1 &lt;&lt; 30)" line="140" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 104 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F13>
		<F14 public="1" get="inline" set="null" expr="cast 105 | (1 &lt;&lt; 30)" line="141" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 105 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F14>
		<F15 public="1" get="inline" set="null" expr="cast 106 | (1 &lt;&lt; 30)" line="142" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 106 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F15>
		<F16 public="1" get="inline" set="null" expr="cast 107 | (1 &lt;&lt; 30)" line="143" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 107 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F16>
		<F17 public="1" get="inline" set="null" expr="cast 108 | (1 &lt;&lt; 30)" line="144" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 108 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F17>
		<F18 public="1" get="inline" set="null" expr="cast 109 | (1 &lt;&lt; 30)" line="145" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 109 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F18>
		<F19 public="1" get="inline" set="null" expr="cast 110 | (1 &lt;&lt; 30)" line="146" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 110 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F19>
		<F20 public="1" get="inline" set="null" expr="cast 111 | (1 &lt;&lt; 30)" line="147" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 111 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F20>
		<F21 public="1" get="inline" set="null" expr="cast 112 | (1 &lt;&lt; 30)" line="148" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 112 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F21>
		<F22 public="1" get="inline" set="null" expr="cast 113 | (1 &lt;&lt; 30)" line="149" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 113 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F22>
		<F23 public="1" get="inline" set="null" expr="cast 114 | (1 &lt;&lt; 30)" line="150" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 114 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F23>
		<F24 public="1" get="inline" set="null" expr="cast 115 | (1 &lt;&lt; 30)" line="151" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 115 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F24>
		<EXECUTE public="1" get="inline" set="null" expr="cast 116 | (1 &lt;&lt; 30)" line="152" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 116 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EXECUTE>
		<HELP public="1" get="inline" set="null" expr="cast 117 | (1 &lt;&lt; 30)" line="153" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 117 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HELP>
		<MENU public="1" get="inline" set="null" expr="cast 118 | (1 &lt;&lt; 30)" line="154" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 118 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MENU>
		<SELECT public="1" get="inline" set="null" expr="cast 119 | (1 &lt;&lt; 30)" line="155" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 119 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SELECT>
		<STOP public="1" get="inline" set="null" expr="cast 120 | (1 &lt;&lt; 30)" line="156" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 120 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</STOP>
		<AGAIN public="1" get="inline" set="null" expr="cast 121 | (1 &lt;&lt; 30)" line="158" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 121 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AGAIN>
		<UNDO public="1" get="inline" set="null" expr="cast 122 | (1 &lt;&lt; 30)" line="159" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 122 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNDO>
		<CUT public="1" get="inline" set="null" expr="cast 123 | (1 &lt;&lt; 30)" line="160" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 123 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CUT>
		<COPY public="1" get="inline" set="null" expr="cast 124 | (1 &lt;&lt; 30)" line="161" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 124 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COPY>
		<PASTE public="1" get="inline" set="null" expr="cast 125 | (1 &lt;&lt; 30)" line="162" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 125 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PASTE>
		<FIND public="1" get="inline" set="null" expr="cast 126 | (1 &lt;&lt; 30)" line="163" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 126 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</FIND>
		<MUTE public="1" get="inline" set="null" expr="cast 127 | (1 &lt;&lt; 30)" line="164" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 127 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MUTE>
		<VOLUMEUP public="1" get="inline" set="null" expr="cast 128 | (1 &lt;&lt; 30)" line="165" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 128 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VOLUMEUP>
		<VOLUMEDOWN public="1" get="inline" set="null" expr="cast 129 | (1 &lt;&lt; 30)" line="166" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 129 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VOLUMEDOWN>
		<KP_COMMA public="1" get="inline" set="null" expr="cast 133 | (1 &lt;&lt; 30)" line="168" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 133 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_COMMA>
		<KP_EQUALSAS400 public="1" get="inline" set="null" expr="cast 134 | (1 &lt;&lt; 30)" line="169" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 134 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_EQUALSAS400>
		<ALTERASE public="1" get="inline" set="null" expr="cast 153 | (1 &lt;&lt; 30)" line="171" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 153 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ALTERASE>
		<SYSREQ public="1" get="inline" set="null" expr="cast 154 | (1 &lt;&lt; 30)" line="172" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 154 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SYSREQ>
		<CANCEL public="1" get="inline" set="null" expr="cast 155 | (1 &lt;&lt; 30)" line="173" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 155 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CANCEL>
		<CLEAR public="1" get="inline" set="null" expr="cast 156 | (1 &lt;&lt; 30)" line="174" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 156 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CLEAR>
		<PRIOR public="1" get="inline" set="null" expr="cast 157 | (1 &lt;&lt; 30)" line="175" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 157 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PRIOR>
		<RETURN2 public="1" get="inline" set="null" expr="cast 158 | (1 &lt;&lt; 30)" line="176" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 158 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RETURN2>
		<SEPARATOR public="1" get="inline" set="null" expr="cast 159 | (1 &lt;&lt; 30)" line="177" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 159 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SEPARATOR>
		<OUT public="1" get="inline" set="null" expr="cast 160 | (1 &lt;&lt; 30)" line="178" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 160 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OUT>
		<OPER public="1" get="inline" set="null" expr="cast 161 | (1 &lt;&lt; 30)" line="179" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 161 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OPER>
		<CLEARAGAIN public="1" get="inline" set="null" expr="cast 162 | (1 &lt;&lt; 30)" line="180" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 162 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CLEARAGAIN>
		<CRSEL public="1" get="inline" set="null" expr="cast 163 | (1 &lt;&lt; 30)" line="181" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 163 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CRSEL>
		<EXSEL public="1" get="inline" set="null" expr="cast 164 | (1 &lt;&lt; 30)" line="182" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 164 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EXSEL>
		<KP_00 public="1" get="inline" set="null" expr="cast 176 | (1 &lt;&lt; 30)" line="184" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 176 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_00>
		<KP_000 public="1" get="inline" set="null" expr="cast 177 | (1 &lt;&lt; 30)" line="185" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 177 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_000>
		<THOUSANDSSEPARATOR public="1" get="inline" set="null" expr="cast 178 | (1 &lt;&lt; 30)" line="186" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 178 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</THOUSANDSSEPARATOR>
		<DECIMALSEPARATOR public="1" get="inline" set="null" expr="cast 179 | (1 &lt;&lt; 30)" line="187" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 179 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DECIMALSEPARATOR>
		<CURRENCYUNIT public="1" get="inline" set="null" expr="cast 180 | (1 &lt;&lt; 30)" line="188" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 180 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CURRENCYUNIT>
		<CURRENCYSUBUNIT public="1" get="inline" set="null" expr="cast 181 | (1 &lt;&lt; 30)" line="189" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 181 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CURRENCYSUBUNIT>
		<KP_LEFTPAREN public="1" get="inline" set="null" expr="cast 182 | (1 &lt;&lt; 30)" line="190" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 182 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_LEFTPAREN>
		<KP_RIGHTPAREN public="1" get="inline" set="null" expr="cast 183 | (1 &lt;&lt; 30)" line="191" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 183 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_RIGHTPAREN>
		<KP_LEFTBRACE public="1" get="inline" set="null" expr="cast 184 | (1 &lt;&lt; 30)" line="192" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 184 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_LEFTBRACE>
		<KP_RIGHTBRACE public="1" get="inline" set="null" expr="cast 185 | (1 &lt;&lt; 30)" line="193" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 185 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_RIGHTBRACE>
		<KP_TAB public="1" get="inline" set="null" expr="cast 186 | (1 &lt;&lt; 30)" line="194" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 186 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_TAB>
		<KP_BACKSPACE public="1" get="inline" set="null" expr="cast 187 | (1 &lt;&lt; 30)" line="195" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 187 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_BACKSPACE>
		<KP_A public="1" get="inline" set="null" expr="cast 188 | (1 &lt;&lt; 30)" line="196" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 188 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_A>
		<KP_B public="1" get="inline" set="null" expr="cast 189 | (1 &lt;&lt; 30)" line="197" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 189 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_B>
		<KP_C public="1" get="inline" set="null" expr="cast 190 | (1 &lt;&lt; 30)" line="198" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 190 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_C>
		<KP_D public="1" get="inline" set="null" expr="cast 191 | (1 &lt;&lt; 30)" line="199" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 191 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_D>
		<KP_E public="1" get="inline" set="null" expr="cast 192 | (1 &lt;&lt; 30)" line="200" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 192 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_E>
		<KP_F public="1" get="inline" set="null" expr="cast 193 | (1 &lt;&lt; 30)" line="201" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 193 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_F>
		<KP_XOR public="1" get="inline" set="null" expr="cast 194 | (1 &lt;&lt; 30)" line="202" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 194 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_XOR>
		<KP_POWER public="1" get="inline" set="null" expr="cast 195 | (1 &lt;&lt; 30)" line="203" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 195 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_POWER>
		<KP_PERCENT public="1" get="inline" set="null" expr="cast 196 | (1 &lt;&lt; 30)" line="204" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 196 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PERCENT>
		<KP_LESS public="1" get="inline" set="null" expr="cast 197 | (1 &lt;&lt; 30)" line="205" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 197 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_LESS>
		<KP_GREATER public="1" get="inline" set="null" expr="cast 198 | (1 &lt;&lt; 30)" line="206" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 198 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_GREATER>
		<KP_AMPERSAND public="1" get="inline" set="null" expr="cast 199 | (1 &lt;&lt; 30)" line="207" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 199 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_AMPERSAND>
		<KP_DBLAMPERSAND public="1" get="inline" set="null" expr="cast 200 | (1 &lt;&lt; 30)" line="208" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 200 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DBLAMPERSAND>
		<KP_VERTICALBAR public="1" get="inline" set="null" expr="cast 201 | (1 &lt;&lt; 30)" line="209" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 201 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_VERTICALBAR>
		<KP_DBLVERTICALBAR public="1" get="inline" set="null" expr="cast 202 | (1 &lt;&lt; 30)" line="210" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 202 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DBLVERTICALBAR>
		<KP_COLON public="1" get="inline" set="null" expr="cast 203 | (1 &lt;&lt; 30)" line="211" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 203 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_COLON>
		<KP_HASH public="1" get="inline" set="null" expr="cast 204 | (1 &lt;&lt; 30)" line="212" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 204 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_HASH>
		<KP_SPACE public="1" get="inline" set="null" expr="cast 205 | (1 &lt;&lt; 30)" line="213" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 205 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_SPACE>
		<KP_AT public="1" get="inline" set="null" expr="cast 206 | (1 &lt;&lt; 30)" line="214" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 206 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_AT>
		<KP_EXCLAM public="1" get="inline" set="null" expr="cast 207 | (1 &lt;&lt; 30)" line="215" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 207 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_EXCLAM>
		<KP_MEMSTORE public="1" get="inline" set="null" expr="cast 208 | (1 &lt;&lt; 30)" line="216" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 208 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMSTORE>
		<KP_MEMRECALL public="1" get="inline" set="null" expr="cast 209 | (1 &lt;&lt; 30)" line="217" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 209 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMRECALL>
		<KP_MEMCLEAR public="1" get="inline" set="null" expr="cast 210 | (1 &lt;&lt; 30)" line="218" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 210 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMCLEAR>
		<KP_MEMADD public="1" get="inline" set="null" expr="cast 211 | (1 &lt;&lt; 30)" line="219" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 211 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMADD>
		<KP_MEMSUBTRACT public="1" get="inline" set="null" expr="cast 212 | (1 &lt;&lt; 30)" line="220" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 212 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMSUBTRACT>
		<KP_MEMMULTIPLY public="1" get="inline" set="null" expr="cast 213 | (1 &lt;&lt; 30)" line="221" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 213 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMMULTIPLY>
		<KP_MEMDIVIDE public="1" get="inline" set="null" expr="cast 214 | (1 &lt;&lt; 30)" line="222" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 214 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMDIVIDE>
		<KP_PLUSMINUS public="1" get="inline" set="null" expr="cast 215 | (1 &lt;&lt; 30)" line="223" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 215 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PLUSMINUS>
		<KP_CLEAR public="1" get="inline" set="null" expr="cast 216 | (1 &lt;&lt; 30)" line="224" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 216 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_CLEAR>
		<KP_CLEARENTRY public="1" get="inline" set="null" expr="cast 217 | (1 &lt;&lt; 30)" line="225" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 217 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_CLEARENTRY>
		<KP_BINARY public="1" get="inline" set="null" expr="cast 218 | (1 &lt;&lt; 30)" line="226" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 218 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_BINARY>
		<KP_OCTAL public="1" get="inline" set="null" expr="cast 219 | (1 &lt;&lt; 30)" line="227" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 219 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_OCTAL>
		<KP_DECIMAL public="1" get="inline" set="null" expr="cast 220 | (1 &lt;&lt; 30)" line="228" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 220 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DECIMAL>
		<KP_HEXADECIMAL public="1" get="inline" set="null" expr="cast 221 | (1 &lt;&lt; 30)" line="229" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 221 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_HEXADECIMAL>
		<LCTRL public="1" get="inline" set="null" expr="cast 224 | (1 &lt;&lt; 30)" line="231" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 224 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LCTRL>
		<LSHIFT public="1" get="inline" set="null" expr="cast 225 | (1 &lt;&lt; 30)" line="232" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 225 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LSHIFT>
		<LALT public="1" get="inline" set="null" expr="cast 226 | (1 &lt;&lt; 30)" line="233" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 226 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LALT>
		<LMETA public="1" get="inline" set="null" expr="cast 227 | (1 &lt;&lt; 30)" line="234" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 227 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LMETA>
		<RCTRL public="1" get="inline" set="null" expr="cast 228 | (1 &lt;&lt; 30)" line="235" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 228 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RCTRL>
		<RSHIFT public="1" get="inline" set="null" expr="cast 229 | (1 &lt;&lt; 30)" line="236" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 229 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RSHIFT>
		<RALT public="1" get="inline" set="null" expr="cast 230 | (1 &lt;&lt; 30)" line="237" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 230 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RALT>
		<RMETA public="1" get="inline" set="null" expr="cast 231 | (1 &lt;&lt; 30)" line="238" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 231 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RMETA>
		<MODE public="1" get="inline" set="null" expr="cast 257 | (1 &lt;&lt; 30)" line="240" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 257 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MODE>
		<AUDIONEXT public="1" get="inline" set="null" expr="cast 258 | (1 &lt;&lt; 30)" line="242" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 258 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIONEXT>
		<AUDIOPREV public="1" get="inline" set="null" expr="cast 259 | (1 &lt;&lt; 30)" line="243" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 259 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOPREV>
		<AUDIOSTOP public="1" get="inline" set="null" expr="cast 260 | (1 &lt;&lt; 30)" line="244" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 260 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOSTOP>
		<AUDIOPLAY public="1" get="inline" set="null" expr="cast 261 | (1 &lt;&lt; 30)" line="245" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 261 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOPLAY>
		<AUDIOMUTE public="1" get="inline" set="null" expr="cast 262 | (1 &lt;&lt; 30)" line="246" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 262 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOMUTE>
		<MEDIASELECT public="1" get="inline" set="null" expr="cast 263 | (1 &lt;&lt; 30)" line="247" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 263 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MEDIASELECT>
		<WWW public="1" get="inline" set="null" expr="cast 264 | (1 &lt;&lt; 30)" line="248" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 264 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WWW>
		<MAIL public="1" get="inline" set="null" expr="cast 265 | (1 &lt;&lt; 30)" line="249" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 265 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MAIL>
		<CALCULATOR public="1" get="inline" set="null" expr="cast 266 | (1 &lt;&lt; 30)" line="250" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 266 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CALCULATOR>
		<COMPUTER public="1" get="inline" set="null" expr="cast 267 | (1 &lt;&lt; 30)" line="251" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 267 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COMPUTER>
		<AC_SEARCH public="1" get="inline" set="null" expr="cast 268 | (1 &lt;&lt; 30)" line="252" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 268 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_SEARCH>
		<AC_HOME public="1" get="inline" set="null" expr="cast 269 | (1 &lt;&lt; 30)" line="253" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 269 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_HOME>
		<AC_BACK public="1" get="inline" set="null" expr="cast 270 | (1 &lt;&lt; 30)" line="254" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 270 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_BACK>
		<AC_FORWARD public="1" get="inline" set="null" expr="cast 271 | (1 &lt;&lt; 30)" line="255" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 271 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_FORWARD>
		<AC_STOP public="1" get="inline" set="null" expr="cast 272 | (1 &lt;&lt; 30)" line="256" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 272 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_STOP>
		<AC_REFRESH public="1" get="inline" set="null" expr="cast 273 | (1 &lt;&lt; 30)" line="257" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 273 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_REFRESH>
		<AC_BOOKMARKS public="1" get="inline" set="null" expr="cast 274 | (1 &lt;&lt; 30)" line="258" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 274 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_BOOKMARKS>
		<BRIGHTNESSDOWN public="1" get="inline" set="null" expr="cast 275 | (1 &lt;&lt; 30)" line="260" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 275 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BRIGHTNESSDOWN>
		<BRIGHTNESSUP public="1" get="inline" set="null" expr="cast 276 | (1 &lt;&lt; 30)" line="261" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 276 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BRIGHTNESSUP>
		<DISPLAYSWITCH public="1" get="inline" set="null" expr="cast 277 | (1 &lt;&lt; 30)" line="262" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 277 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DISPLAYSWITCH>
		<KBDILLUMTOGGLE public="1" get="inline" set="null" expr="cast 278 | (1 &lt;&lt; 30)" line="263" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 278 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KBDILLUMTOGGLE>
		<KBDILLUMDOWN public="1" get="inline" set="null" expr="cast 279 | (1 &lt;&lt; 30)" line="264" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 279 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KBDILLUMDOWN>
		<KBDILLUMUP public="1" get="inline" set="null" expr="cast 280 | (1 &lt;&lt; 30)" line="265" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 280 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KBDILLUMUP>
		<EJECT public="1" get="inline" set="null" expr="cast 281 | (1 &lt;&lt; 30)" line="266" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 281 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EJECT>
		<SLEEP public="1" get="inline" set="null" expr="cast 282 | (1 &lt;&lt; 30)" line="267" static="1">
			<x path="ceramic.KeyCode"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 282 | (1 << 30)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SLEEP>
		<name public="1" set="method" line="272" static="1">
			<f a="keyCode">
				<x path="ceramic.KeyCode"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Convert a keyCode to string</haxe_doc>
		</name>
		<toString set="method" line="327" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="polyline.MiterUtils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/polyline/polyline/MiterUtils.hx">
		<tangentX public="1" expr="0" line="5">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tangentX>
		<tangentY public="1" expr="0" line="7">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tangentY>
		<miterX public="1" expr="0" line="9">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</miterX>
		<miterY public="1" expr="0" line="11">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</miterY>
		<aX public="1" expr="0" line="13">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</aX>
		<aY public="1" expr="0" line="15">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</aY>
		<bX public="1" expr="0" line="17">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bX>
		<bY public="1" expr="0" line="19">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bY>
		<outX public="1" expr="0" line="21">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</outX>
		<outY public="1" expr="0" line="23">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</outY>
		<tmpX expr="0" line="25">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tmpX>
		<tmpY expr="0" line="27">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tmpY>
		<computeMiter public="1" get="inline" set="null" line="31"><f a="halfThick">
	<x path="Float"/>
	<x path="Float"/>
</f></computeMiter>
		<normal public="1" get="inline" set="null" line="48"><f a="dirX:dirY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></normal>
		<direction public="1" get="inline" set="null" line="56"><f a=""><x path="Void"/></f></direction>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="polyline.Stroke" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/polyline/polyline/Stroke.hx">
		<NUMBER_NONE get="inline" set="null" expr="-9999999999.0" line="7" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>-9999999999.0</e></m></meta>
		</NUMBER_NONE>
		<MATH_TWO_PI get="inline" set="null" expr="6.28318530718" line="9" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>6.28318530718</e></m></meta>
		</MATH_TWO_PI>
		<MATH_HALF_PI get="inline" set="null" expr="1.57079632679" line="11" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.57079632679</e></m></meta>
		</MATH_HALF_PI>
		<MATH_PI_AND_HALF get="inline" set="null" expr="4.71238898038" line="13" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>4.71238898038</e></m></meta>
		</MATH_PI_AND_HALF>
		<miterUtils expr="new MiterUtils()" line="15" static="1">
			<c path="polyline.MiterUtils"/>
			<meta><m n=":value"><e>new MiterUtils()</e></m></meta>
		</miterUtils>
		<miterLimit public="1" expr="10" line="18">
			<x path="Float"/>
			<meta><m n=":value"><e>10</e></m></meta>
			<haxe_doc>The limit before miters turn into bevels. Default 10</haxe_doc>
		</miterLimit>
		<thickness public="1" expr="1" line="21">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>The line thickness</haxe_doc>
		</thickness>
		<join public="1" expr="MITER" line="24">
			<e path="polyline.StrokeJoin"/>
			<meta><m n=":value"><e>MITER</e></m></meta>
			<haxe_doc>The join type, can be `MITER` or `BEVEL`. Default `MITER`</haxe_doc>
		</join>
		<cap public="1" expr="BUTT" line="27">
			<e path="polyline.StrokeCap"/>
			<meta><m n=":value"><e>BUTT</e></m></meta>
			<haxe_doc>The cap type. Can be `BUTT` or `SQUARE`. Default `BUTT`</haxe_doc>
		</cap>
		<canLoop public="1" expr="false" line="30">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Will try to join the first and last points together if they are identical</haxe_doc>
		</canLoop>
		<tmpX expr="0" line="32">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tmpX>
		<tmpY expr="0" line="34">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tmpY>
		<lineAX expr="0" line="36">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lineAX>
		<lineAY expr="0" line="38">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lineAY>
		<lineBX expr="0" line="40">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lineBX>
		<lineBY expr="0" line="42">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lineBY>
		<tangentX expr="0" line="44">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tangentX>
		<tangentY expr="0" line="46">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tangentY>
		<miterX expr="0" line="48">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</miterX>
		<miterY expr="0" line="50">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</miterY>
		<capEndX expr="0" line="52">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</capEndX>
		<capEndY expr="0" line="54">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</capEndY>
		<_hasNormal expr="false" line="56">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_hasNormal>
		<_normalX expr="0" line="58">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_normalX>
		<_normalY expr="0" line="60">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_normalY>
		<_lastFlip expr="-1" line="62">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</_lastFlip>
		<_started expr="false" line="64">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_started>
		<_points expr="null" line="66">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</_points>
		<build public="1" set="method" line="74"><f a="points:vertices:indices">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></build>
		<mapThickness set="method" line="188"><f a="pointX:pointY:i:points">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
</f></mapThickness>
		<_seg get="inline" set="null" line="194"><f a="vertices:indices:index:lastX:lastY:curX:curY:nextX:nextY:halfThick">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></_seg>
		<extrusions get="inline" set="null" line="386"><f a="vertices:pointX:pointY:normalX:normalY:scale">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></extrusions>
		<pointsAngle get="inline" set="null" line="401"><f a="x:y:x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pointsAngle>
		<distanceToLine get="inline" set="null" line="410"><f a="x:y:x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></distanceToLine>
		<new public="1" set="method" line="68"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Line" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Line.hx">
		<extends path="ceramic.Mesh"/>
		<_stroke expr="new Stroke()" line="21" static="1">
			<c path="polyline.Stroke"/>
			<meta><m n=":value"><e>new Stroke()</e></m></meta>
		</_stroke>
		<points public="1" set="accessor" expr="null" line="29">
			<c path="Array"><x path="Float"/></c>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* Line points.
     * Note: when editing array content without reassigning it,
     * `contentDirty` must be set to `true` to let the line being updated accordingly.</haxe_doc>
		</points>
		<set_points get="inline" set="null" line="30"><f a="points">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
</f></set_points>
		<miterLimit public="1" set="accessor" expr="10" line="40">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>10</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* The limit before miters turn into bevels. Default 10</haxe_doc>
		</miterLimit>
		<set_miterLimit get="inline" set="null" line="41"><f a="miterLimit">
	<x path="Float"/>
	<x path="Float"/>
</f></set_miterLimit>
		<thickness public="1" set="accessor" expr="1" line="52">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n="editable"><e>{ slider : [1, 64] }</e></m>
			</meta>
			<haxe_doc>* The line thickness</haxe_doc>
		</thickness>
		<set_thickness get="inline" set="null" line="53"><f a="thickness">
	<x path="Float"/>
	<x path="Float"/>
</f></set_thickness>
		<join public="1" set="accessor" expr="BEVEL" line="64">
			<t path="ceramic.LineJoin"/>
			<meta>
				<m n=":value"><e>BEVEL</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* The join type, can be `MITER` or `BEVEL`. Default `BEVEL`</haxe_doc>
		</join>
		<set_join get="inline" set="null" line="65"><f a="join">
	<t path="ceramic.LineJoin"/>
	<t path="ceramic.LineJoin"/>
</f></set_join>
		<cap public="1" set="accessor" expr="BUTT" line="76">
			<t path="ceramic.LineCap"/>
			<meta>
				<m n=":value"><e>BUTT</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* The cap type. Can be `BUTT` or `SQUARE`. Default `BUTT`</haxe_doc>
		</cap>
		<set_cap get="inline" set="null" line="77"><f a="cap">
	<t path="ceramic.LineCap"/>
	<t path="ceramic.LineCap"/>
</f></set_cap>
		<loop public="1" set="accessor" expr="false" line="89">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* If `loop` is `true`, will try to join the first and last
     * points together if they are identical. Default `false`</haxe_doc>
		</loop>
		<set_loop get="inline" set="null" line="90"><f a="loop">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_loop>
		<autoComputeSize public="1" set="accessor" expr="true" line="101">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="editable"><e>{ label : "Auto Size" }</e></m>
			</meta>
			<haxe_doc>* If set to `true`, width and heigh will be computed from line points.</haxe_doc>
		</autoComputeSize>
		<set_autoComputeSize get="inline" set="null" line="102"><f a="autoComputeSize">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoComputeSize>
		<computeContent public="1" set="method" line="110" override="1"><f a=""><x path="Void"/></f></computeContent>
		<computeSize public="1" set="method" line="136" override="1"><f a=""><x path="Void"/></f></computeSize>
		<haxe_doc>* Display lines composed of multiple segments, curves...</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n="editable"><e>{ implicitSize : true, highlight : { points : "points", minPoints : 2, maxPoints : 999999999 }, disable : ["texture", "vertices", "indices", "uvs"] }</e></m>
		</meta>
	</class>
	<typedef path="ceramic.LineCap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/LineCap.hx">
		<e path="polyline.StrokeCap"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="ceramic.LineJoin" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/LineJoin.hx">
		<e path="polyline.StrokeJoin"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="ceramic.Logger" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Logger.hx">
		<extends path="ceramic.Entity"/>
		<didInitOnce expr="false" line="26" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</didInitOnce>
		<_dox_event__info public="1" set="method" line="637">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__info>
		<emitInfo set="method" line="1095">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>info event</haxe_doc>
		</emitInfo>
		<onInfo public="1" set="method" line="1199">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>info event</haxe_doc>
		</onInfo>
		<onceInfo public="1" set="method" line="1298">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>info event</haxe_doc>
		</onceInfo>
		<offInfo public="1" set="method" line="1368">
			<f a="?handleValuePos">
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>info event</haxe_doc>
		</offInfo>
		<listensInfo public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to info event</haxe_doc>
		</listensInfo>
		<_dox_event__debug public="1" set="method" line="637">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__debug>
		<emitDebug set="method" line="1095">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>debug event</haxe_doc>
		</emitDebug>
		<onDebug public="1" set="method" line="1199">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>debug event</haxe_doc>
		</onDebug>
		<onceDebug public="1" set="method" line="1298">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>debug event</haxe_doc>
		</onceDebug>
		<offDebug public="1" set="method" line="1368">
			<f a="?handleValuePos">
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>debug event</haxe_doc>
		</offDebug>
		<listensDebug public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to debug event</haxe_doc>
		</listensDebug>
		<_dox_event__success public="1" set="method" line="637">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__success>
		<emitSuccess set="method" line="1095">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>success event</haxe_doc>
		</emitSuccess>
		<onSuccess public="1" set="method" line="1199">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>success event</haxe_doc>
		</onSuccess>
		<onceSuccess public="1" set="method" line="1298">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>success event</haxe_doc>
		</onceSuccess>
		<offSuccess public="1" set="method" line="1368">
			<f a="?handleValuePos">
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>success event</haxe_doc>
		</offSuccess>
		<listensSuccess public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to success event</haxe_doc>
		</listensSuccess>
		<_dox_event__warning public="1" set="method" line="637">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__warning>
		<emitWarning set="method" line="1095">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>warning event</haxe_doc>
		</emitWarning>
		<onWarning public="1" set="method" line="1199">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>warning event</haxe_doc>
		</onWarning>
		<onceWarning public="1" set="method" line="1298">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>warning event</haxe_doc>
		</onceWarning>
		<offWarning public="1" set="method" line="1368">
			<f a="?handleValuePos">
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>warning event</haxe_doc>
		</offWarning>
		<listensWarning public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to warning event</haxe_doc>
		</listensWarning>
		<_dox_event__error public="1" set="method" line="637">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__error>
		<emitError set="method" line="1095">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>error event</haxe_doc>
		</emitError>
		<onError public="1" set="method" line="1199">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>error event</haxe_doc>
		</onError>
		<onceError public="1" set="method" line="1298">
			<f a="owner:handleValuePos">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>error event</haxe_doc>
		</onceError>
		<offError public="1" set="method" line="1368">
			<f a="?handleValuePos">
				<f a="value:pos">
					<d/>
					<t path="haxe.PosInfos"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>error event</haxe_doc>
		</offError>
		<listensError public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to error event</haxe_doc>
		</listensError>
		<indentPrefix expr="&quot;&quot;" line="24">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</indentPrefix>
		<debug public="1" set="method" line="46">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</debug>
		<info public="1" set="method" line="69">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</info>
		<success public="1" set="method" line="92">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</success>
		<warning public="1" set="method" line="115">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</warning>
		<error public="1" set="method" line="144">
			<f a="value:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</error>
		<pushIndent public="1" get="inline" set="null" line="173"><f a=""><x path="Void"/></f></pushIndent>
		<popIndent public="1" get="inline" set="null" line="179"><f a=""><x path="Void"/></f></popIndent>
		<prefixLines set="method" line="187"><f a="prefix:input">
	<c path="String"/>
	<d/>
	<c path="String"/>
</f></prefixLines>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<class path="ceramic.LongPress" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/LongPress.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<_dox_event_longPress public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_longPress>
		<emitLongPress set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>longPress event</haxe_doc>
		</emitLongPress>
		<onLongPress public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>longPress event</haxe_doc>
		</onLongPress>
		<onceLongPress public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>longPress event</haxe_doc>
		</onceLongPress>
		<offLongPress public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>longPress event</haxe_doc>
		</offLongPress>
		<listensLongPress public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to longPress event</haxe_doc>
		</listensLongPress>
		<threshold public="1" expr="4.0" line="13">
			<x path="Float"/>
			<meta><m n=":value"><e>4.0</e></m></meta>
		</threshold>
		<requiredDuration public="1" expr="1.0" line="15">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</requiredDuration>
		<entity public="1">
			<c path="ceramic.Visual"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<click public="1"><c path="ceramic.Click"/></click>
		<bindAsComponent set="method" line="35"><f a=""><x path="Void"/></f></bindAsComponent>
		<pointerStartX expr="0.0" line="44">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</pointerStartX>
		<pointerStartY expr="0.0" line="46">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</pointerStartY>
		<didLongPress expr="false" line="48">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</didLongPress>
		<cancelLongPress expr="null" line="50">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</cancelLongPress>
		<bindPointerEvents set="method" line="52"><f a=""><x path="Void"/></f></bindPointerEvents>
		<handlePointerDown set="method" line="59"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerDown>
		<handlePointerMove set="method" line="81"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerMove>
		<handlePointerUp set="method" line="93"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerUp>
		<setEntity set="method" line="5">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="5">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="23"><f a="?handleLongPress:?click">
	<f a="">
		<c path="ceramic.TouchInfo"/>
		<x path="Void"/>
	</f>
	<c path="ceramic.Click"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.LowRes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/LowRes.hx">
		<extends path="ceramic.Layer"/>
		<pixelArt>
			<c path="ceramic.PixelArt"/>
			<haxe_doc>* Pixel art container to display nice and sharp pixels at any size</haxe_doc>
		</pixelArt>
		<filter>
			<c path="ceramic.Filter"/>
			<haxe_doc>* Filter used to create supersampled content</haxe_doc>
		</filter>
		<sharpness public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Sharpness of the pixels (from 1.0 to above)</haxe_doc>
		</sharpness>
		<get_sharpness get="inline" set="null" line="23"><f a=""><x path="Float"/></f></get_sharpness>
		<set_sharpness get="inline" set="null" line="26"><f a="sharpness">
	<x path="Float"/>
	<x path="Float"/>
</f></set_sharpness>
		<explicitRender public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Explicit render?</haxe_doc>
		</explicitRender>
		<get_explicitRender get="inline" set="null" line="34"><f a=""><x path="Bool"/></f></get_explicitRender>
		<set_explicitRender get="inline" set="null" line="37"><f a="explicitRender">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_explicitRender>
		<autoRender public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Auto render?</haxe_doc>
		</autoRender>
		<get_autoRender get="inline" set="null" line="45"><f a=""><x path="Bool"/></f></get_autoRender>
		<set_autoRender get="inline" set="null" line="48"><f a="autoRender">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoRender>
		<density public="1" set="accessor" expr="1" line="58">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Density value used for supersampled content.
     * A density of 1 means no supersampling (thus no antialiasing).
     * Any value above (2 or more) will increase the supersampled content size and generate antialiasing.
     * Use a power of two and not a too high value (2 is recommended if result is nice enough).</haxe_doc>
		</density>
		<set_density set="method" line="59"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<content public="1" set="null">
			<c path="ceramic.Quad"/>
			<haxe_doc>* The visual containing what should be displayed</haxe_doc>
		</content>
		<handleResize set="method" line="90"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></handleResize>
		<new public="1" set="method" line="72"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A container to display visuals at low resolution,
 * with the possibility to use antialiasing (supersampling).</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.MeshColorMapping" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MeshColorMapping.hx">
		<this><x path="Int"/></this>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._MeshColorMapping.MeshColorMapping_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MeshColorMapping.hx" private="1" module="ceramic.MeshColorMapping" extern="1" final="1">
	<MESH public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
		<x path="ceramic.MeshColorMapping"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Map a single color to the whole mesh.</haxe_doc>
	</MESH>
	<INDICES public="1" get="inline" set="null" expr="cast 1" line="11" static="1">
		<x path="ceramic.MeshColorMapping"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Map a color to each indice.</haxe_doc>
	</INDICES>
	<VERTICES public="1" get="inline" set="null" expr="cast 2" line="15" static="1">
		<x path="ceramic.MeshColorMapping"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Map a color to each vertex.</haxe_doc>
	</VERTICES>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._MeshColorMapping.MeshColorMapping_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MeshColorMapping.hx" private="1" module="ceramic.MeshColorMapping" extern="1" final="1">
		<MESH public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
			<x path="ceramic.MeshColorMapping"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Map a single color to the whole mesh.</haxe_doc>
		</MESH>
		<INDICES public="1" get="inline" set="null" expr="cast 1" line="11" static="1">
			<x path="ceramic.MeshColorMapping"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Map a color to each indice.</haxe_doc>
		</INDICES>
		<VERTICES public="1" get="inline" set="null" expr="cast 2" line="15" static="1">
			<x path="ceramic.MeshColorMapping"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Map a color to each vertex.</haxe_doc>
		</VERTICES>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="ceramic.MeshExtensions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MeshExtensions.hx">
		<createQuad public="1" set="method" line="20" static="1">
			<f a="mesh:width:height:?floatsPerVertex" v=":::-1">
				<c path="ceramic.Mesh"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ floatsPerVertex : -1 }</e></m></meta>
			<haxe_doc>* Generate vertices, indices and uvs on the given mesh to make it form a quad
     * @param mesh The mesh to work with
     * @param width With of the quad to form
     * @param height Height of the quad to form
     * @param floatsPerVertex
     *          (optional) Number of floats per vertex
     *          Set to 2 for regular quad, 6 for quads with dark color, must be 2 or higher.
     *          If not provided, will resolve the value from `mesh.customFloatAttributesSize`</haxe_doc>
		</createQuad>
		<setDarkColor public="1" set="method" line="101" static="1">
			<f a="mesh:darkColor">
				<c path="ceramic.Mesh"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assign a dark color to the given mesh.
     * The mesh is expected to have 6 floats per vertex
     * and 4 last vertices will be used for color values.
     * @param mesh The mesh to work with
     * @param darkColor The dark color to assign</haxe_doc>
		</setDarkColor>
		<setDarkAlphaColor public="1" set="method" line="130" static="1">
			<f a="mesh:darkAlphaColor">
				<c path="ceramic.Mesh"/>
				<x path="ceramic.AlphaColor"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assign a dark color (with alpha included) to the given mesh.
     * The mesh is expected to have 6 floats per vertex
     * and 4 last vertices will be used for color values.
     * @param mesh The mesh to work with
     * @param darkColor The dark color to assign</haxe_doc>
		</setDarkAlphaColor>
		<createArc public="1" set="method" line="162" static="1">
			<f a="mesh:radius:angle:thickness:sides:borderPosition">
				<c path="ceramic.Mesh"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<e path="ceramic.BorderPosition"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Generate vertices and indices to draw arc, pie, ring or disc geometry
     * @param mesh The mesh to work with
     * @param radius Radius of the arc
     * @param angle Angle (from 0 to 360). 360 will make it draw a full circle/ring
     * @param thickness Thickness of the arc. If same value as radius and borderPosition is `INSIDE`, will draw a pie.
     * @param sides Number of sides. Higher is smoother but needs more vertices
     * @param borderPosition Position of the drawn border</haxe_doc>
		</createArc>
		<createVerticesGrid public="1" set="method" line="235" static="1">
			<f a="mesh:columns:rows:width:height:?staggerX:?staggerY:?attrLength:?attrValues" v=":::::0:0:0:">
				<c path="ceramic.Mesh"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ attrLength : 0, staggerY : 0, staggerX : 0 }</e></m></meta>
			<haxe_doc>* Create vertices to form a grid with the given options
     * @param mesh The mesh to work with
     * @param columns The number of columns in the grid
     * @param rows The number of rows in the grid
     * @param width The total width of the grid
     * @param height The total height of the grid
     * @param staggerX (optional, default 0) A stagger value to offset rows by this value
     * @param staggerY (optional, default 0) A stagger value to offset columns by this value
     * @param attrLength (optional, default 0) The number of attribute values per vertex
     * @param attrValues (optional) The attributes buffer that will be added to vertex data</haxe_doc>
		</createVerticesGrid>
		<createIndicesGrid public="1" set="method" line="248" static="1">
			<f a="mesh:columns:rows:?mirrorX:?mirrorY:?mirrorFlip" v=":::false:false:false">
				<c path="ceramic.Mesh"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mirrorFlip : false, mirrorY : false, mirrorX : false }</e></m></meta>
			<haxe_doc>* Create indices to form a grid with the given options
     * @param mesh The mesh to work with
     * @param columns The number of columns in the grid
     * @param rows The number of rows in the grid
     * @param mirrorX (optional, default false) Mirror triangles horizontally in odd columns
     * @param mirrorY (optional, default false) Mirror triangles vertically in odd rows
     * @param mirrorFlip (optional, default false) Invert the mirroring described by `mirrorX` and `mirrorY`</haxe_doc>
		</createIndicesGrid>
		<createUVsGrid public="1" set="method" line="260" static="1">
			<f a="mesh:columns:rows">
				<c path="ceramic.Mesh"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create uvs to match a grid with the given options.
     * The uvs will be distributed linearly across the mesh so that
     * when displaying a texture it would be stretched to the grid.
     * @param mesh The mesh to work with
     * @param columns The number of columns in the grid
     * @param rows The number of rows in the grid</haxe_doc>
		</createUVsGrid>
		<haxe_doc>* Static extension with additional helpers for `ceramic.Mesh`</haxe_doc>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.MeshPool" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MeshPool.hx">
		<availableMeshes expr="[]" line="10" static="1">
			<c path="Array"><c path="ceramic.Mesh"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</availableMeshes>
		<availableFloatArrays expr="[]" line="12" static="1">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</availableFloatArrays>
		<availableIntArrays expr="[]" line="13" static="1">
			<c path="Array"><c path="Array"><x path="Int"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</availableIntArrays>
		<getIntArray public="1" get="inline" set="null" line="15" static="1">
			<f a=""><c path="Array"><x path="Int"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</getIntArray>
		<getFloatArray public="1" get="inline" set="null" line="21" static="1">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</getFloatArray>
		<recycleIntArray public="1" get="inline" set="null" line="27" static="1">
			<f a="array">
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</recycleIntArray>
		<recycleFloatArray public="1" get="inline" set="null" line="42" static="1">
			<f a="array">
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</recycleFloatArray>
		<get public="1" set="method" line="60" static="1">
			<f a=""><c path="ceramic.Mesh"/></f>
			<haxe_doc>* Get or create a mesh. The mesh is active an ready to be displayed.</haxe_doc>
		</get>
		<recycle public="1" set="method" line="90" static="1">
			<f a="mesh">
				<c path="ceramic.Mesh"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Recycle an existing mesh. The mesh will be cleaned up and marked as inactive (e.g. not displayed)</haxe_doc>
		</recycle>
		<clear public="1" set="method" line="167" static="1"><f a=""><x path="Void"/></f></clear>
		<haxe_doc>* An utility to reuse meshes at application level.</haxe_doc>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.MeshUtils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MeshUtils.hx">
		<createVerticesGrid public="1" set="method" line="20" static="1">
			<f a="?vertices:columns:rows:width:height:?staggerX:?staggerY:?attrLength:?attrValues" v=":::::0:0:0:">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ attrLength : 0, staggerY : 0, staggerX : 0 }</e></m></meta>
			<haxe_doc>* Create vertices to form a grid with the given options
     * @param vertices (optional) The existing vertices. If provided, will be used as result instead of creating a new array
     * @param columns The number of columns in the grid
     * @param rows The number of rows in the grid
     * @param width The total width of the grid
     * @param height The total height of the grid
     * @param staggerX (optional, default 0) A stagger value to offset rows by this value
     * @param staggerY (optional, default 0) A stagger value to offset columns by this value
     * @param attrLength (optional, default 0) The number of attribute values per vertex
     * @param attrValues (optional) The attributes buffer that will be added to vertex data
     * @return The generated vertices</haxe_doc>
		</createVerticesGrid>
		<createIndicesGrid public="1" set="method" line="124" static="1">
			<f a="?indices:columns:rows:?mirrorX:?mirrorY:?mirrorFlip" v=":::false:false:false">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ mirrorFlip : false, mirrorY : false, mirrorX : false }</e></m></meta>
			<haxe_doc>* Create indices to form a grid with the given options
     * @param indices (optional) The existing indices. If provided, will be used as result instead of creating a new array
     * @param columns The number of columns in the grid
     * @param rows The number of rows in the grid
     * @param mirrorX (optional, default false) Mirror triangles horizontally in odd columns
     * @param mirrorY (optional, default false) Mirror triangles vertically in odd rows
     * @param mirrorFlip (optional, default false) Invert the mirroring described by `mirrorX` and `mirrorY`
     * @return The generated indices</haxe_doc>
		</createIndicesGrid>
		<createUVsGrid public="1" set="method" line="187" static="1">
			<f a="?uvs:columns:rows">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Create uvs to match a grid with the given options.
     * The uvs will be distributed linearly across the mesh so that
     * when displaying a texture it would be stretched to the grid.
     * @param uvs (optional) The existing uvs. If provided, will be used as result instead of creating a new array
     * @param columns The number of columns in the grid
     * @param rows The number of rows in the grid
     * @return The generated uvs</haxe_doc>
		</createUVsGrid>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="ceramic.MouseButton" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MouseButton.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>* A typed (mouse) button id</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._MouseButton.MouseButton_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MouseButton.hx" private="1" module="ceramic.MouseButton" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast -1" line="11" static="1">
		<x path="ceramic.MouseButton"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* No mouse buttons</haxe_doc>
	</NONE>
	<LEFT public="1" get="inline" set="null" expr="cast 0" line="15" static="1">
		<x path="ceramic.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Left mouse button</haxe_doc>
	</LEFT>
	<MIDDLE public="1" get="inline" set="null" expr="cast 1" line="19" static="1">
		<x path="ceramic.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Middle mouse button</haxe_doc>
	</MIDDLE>
	<RIGHT public="1" get="inline" set="null" expr="cast 2" line="23" static="1">
		<x path="ceramic.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Right mouse button</haxe_doc>
	</RIGHT>
	<EXTRA1 public="1" get="inline" set="null" expr="cast 3" line="27" static="1">
		<x path="ceramic.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Extra button pressed</haxe_doc>
	</EXTRA1>
	<EXTRA2 public="1" get="inline" set="null" expr="cast 4" line="31" static="1">
		<x path="ceramic.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Extra button pressed</haxe_doc>
	</EXTRA2>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._MouseButton.MouseButton_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/MouseButton.hx" private="1" module="ceramic.MouseButton" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast -1" line="11" static="1">
			<x path="ceramic.MouseButton"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* No mouse buttons</haxe_doc>
		</NONE>
		<LEFT public="1" get="inline" set="null" expr="cast 0" line="15" static="1">
			<x path="ceramic.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Left mouse button</haxe_doc>
		</LEFT>
		<MIDDLE public="1" get="inline" set="null" expr="cast 1" line="19" static="1">
			<x path="ceramic.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Middle mouse button</haxe_doc>
		</MIDDLE>
		<RIGHT public="1" get="inline" set="null" expr="cast 2" line="23" static="1">
			<x path="ceramic.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Right mouse button</haxe_doc>
		</RIGHT>
		<EXTRA1 public="1" get="inline" set="null" expr="cast 3" line="27" static="1">
			<x path="ceramic.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Extra button pressed</haxe_doc>
		</EXTRA1>
		<EXTRA2 public="1" get="inline" set="null" expr="cast 4" line="31" static="1">
			<x path="ceramic.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Extra button pressed</haxe_doc>
		</EXTRA2>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="ceramic.Ngon" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Ngon.hx">
		<extends path="ceramic.Mesh"/>
		<sides public="1" set="accessor" expr="32" line="9">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>32</e></m>
				<m n="editable"><e>{ slider : [3, 100] }</e></m>
			</meta>
		</sides>
		<set_sides get="inline" set="null" line="10"><f a="sides">
	<x path="Int"/>
	<x path="Int"/>
</f></set_sides>
		<radius public="1" set="accessor" expr="50" line="18">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>50</e></m>
				<m n="editable"><e>{ slider : [0, 999] }</e></m>
			</meta>
		</radius>
		<set_radius set="method" line="19"><f a="radius">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius>
		<computeContent public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></computeContent>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n="editable"><e>{ implicitSize : true }</e></m>
		</meta>
	</class>
	<class path="ceramic.ParticleEmitter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ParticleEmitter.hx">
		<extends path="ceramic.Entity"/>
		<implements path="tracker.Observable"/>
		<implements path="ceramic.Component"/>
		<_point expr="new Point(0, 0)" line="797" static="1">
			<c path="ceramic.Point"/>
			<meta><m n=":value"><e>new Point(0, 0)</e></m></meta>
			<haxe_doc>* Internal point object, handy for reusing for memory management purposes.</haxe_doc>
		</_point>
		<degToRad get="inline" set="null" line="1317" static="1"><f a="deg">
	<x path="Float"/>
	<x path="Float"/>
</f></degToRad>
		<interpolateColor get="inline" set="null" line="1340" static="1"><f a="a:b:percent">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
	<x path="Float"/>
	<x path="ceramic.Color"/>
</f></interpolateColor>
		<velocityFromAngle get="inline" set="null" line="1350" static="1"><f a="angle:speed:result">
	<x path="Float"/>
	<x path="Float"/>
	<c path="ceramic.Point"/>
	<x path="Void"/>
</f></velocityFromAngle>
		<computeVelocity get="inline" set="null" line="1369" static="1">
			<f a="velocity:acceleration:drag:max:elapsed">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* A tween-like function that takes a starting velocity and some other factors and returns an altered velocity.
     *
     * @param	velocity		Any component of velocity (e.g. 20).
     * @param	acceleration	Rate at which the velocity is changing.
     * @param	drag	This is how much the velocity changes if acceleration is not set.
     * @param	max				An absolute value cap for the velocity (0 for no cap).
     * @param	elapsed			The amount of time passed in to the latest update cycle
     * @return	The altered velocity value.</haxe_doc>
		</computeVelocity>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.ParticleEmitter"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.ParticleEmitter"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.ParticleEmitter"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.ParticleEmitter"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.ParticleEmitter"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false" line="131">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<entity public="1">
			<c path="ceramic.Visual"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<visual public="1" get="accessor" set="accessor"><c path="ceramic.Visual"/></visual>
		<get_visual get="inline" set="null" line="21"><f a=""><c path="ceramic.Visual"/></f></get_visual>
		<set_visual get="inline" set="null" line="22"><f a="visual">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
</f></set_visual>
		<_dox_event__emitParticle public="1" set="method" line="637">
			<f a="particle">
				<c path="ceramic.ParticleItem"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__emitParticle>
		<emitEmitParticle set="method" line="1095">
			<f a="particle">
				<c path="ceramic.ParticleItem"/>
				<x path="Void"/>
			</f>
			<haxe_doc>emitParticle event</haxe_doc>
		</emitEmitParticle>
		<onEmitParticle public="1" set="method" line="1199">
			<f a="owner:handleParticle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="particle">
					<c path="ceramic.ParticleItem"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>emitParticle event</haxe_doc>
		</onEmitParticle>
		<onceEmitParticle public="1" set="method" line="1298">
			<f a="owner:handleParticle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="particle">
					<c path="ceramic.ParticleItem"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>emitParticle event</haxe_doc>
		</onceEmitParticle>
		<offEmitParticle public="1" set="method" line="1368">
			<f a="?handleParticle">
				<f a="particle">
					<c path="ceramic.ParticleItem"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>emitParticle event</haxe_doc>
		</offEmitParticle>
		<listensEmitParticle public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to emitParticle event</haxe_doc>
		</listensEmitParticle>
		<size public="1" get="inline" set="null" line="34">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The width and height of the emission area.
     * If not defined (`-1`), will use visual's width and height bound to this `ParticleEmitter` object, if any</haxe_doc>
		</size>
		<pos public="1" get="inline" set="null" line="42">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The x and y position of the emission, relative to particles parent (if any)</haxe_doc>
		</pos>
		<maxVelocity public="1" get="inline" set="null" line="51">
			<f a="maxVelocityX:maxVelocityY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
     * to cap the speed automatically (very useful!).</haxe_doc>
		</maxVelocity>
		<velocityStart public="1" get="inline" set="null" line="59">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the velocity starting range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityStart>
		<velocityEnd public="1" get="inline" set="null" line="79">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the velocity ending range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityEnd>
		<speedStart public="1" get="inline" set="null" line="99">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the speed starting range of particles launched from this emitter. Only used with `CIRCLE`.</haxe_doc>
		</speedStart>
		<speedEnd public="1" get="inline" set="null" line="107">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the speed ending range of particles launched from this emitter. Only used with `CIRCLE`.</haxe_doc>
		</speedEnd>
		<angularAcceleration public="1" get="inline" set="null" line="115">
			<f a="startMin:startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the angular acceleration range of particles launched from this emitter.</haxe_doc>
		</angularAcceleration>
		<angularDrag public="1" get="inline" set="null" line="123">
			<f a="startMin:startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the angular drag range of particles launched from this emitter.</haxe_doc>
		</angularDrag>
		<angularVelocityStart public="1" get="inline" set="null" line="131">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angular velocity starting range of particles launched from this emitter.</haxe_doc>
		</angularVelocityStart>
		<angularVelocityEnd public="1" get="inline" set="null" line="139">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angular velocity ending range of particles launched from this emitter.</haxe_doc>
		</angularVelocityEnd>
		<angleStart public="1" get="inline" set="null" line="148">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angle starting range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleStart>
		<angleEnd public="1" get="inline" set="null" line="157">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angle ending range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleEnd>
		<launchAngle public="1" get="inline" set="null" line="166">
			<f a="min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angle range at which particles will be launched from this emitter.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</launchAngle>
		<lifespan public="1" get="inline" set="null" line="174">
			<f a="min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The life, or duration, range of particles launched from this emitter.</haxe_doc>
		</lifespan>
		<scaleStart public="1" get="inline" set="null" line="182">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `scale` starting range of particles launched from this emitter.</haxe_doc>
		</scaleStart>
		<scaleEnd public="1" get="inline" set="null" line="202">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `scale` ending range of particles launched from this emitter.</haxe_doc>
		</scaleEnd>
		<accelerationStart public="1" get="inline" set="null" line="222">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `acceleration` starting range of particles launched from this emitter.</haxe_doc>
		</accelerationStart>
		<accelerationEnd public="1" get="inline" set="null" line="242">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `acceleration` ending range of particles launched from this emitter.</haxe_doc>
		</accelerationEnd>
		<dragStart public="1" get="inline" set="null" line="262">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `drag` starting range of particles launched from this emitter.</haxe_doc>
		</dragStart>
		<dragEnd public="1" get="inline" set="null" line="282">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `drag` ending range of particles launched from this emitter.</haxe_doc>
		</dragEnd>
		<colorStart public="1" get="inline" set="null" line="302">
			<f a="startMin:?startMax">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `color` starting range of particles launched from this emitter.</haxe_doc>
		</colorStart>
		<colorEnd public="1" get="inline" set="null" line="310">
			<f a="endMin:?endMax">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `color` ending range of particles launched from this emitter.</haxe_doc>
		</colorEnd>
		<alphaStart public="1" get="inline" set="null" line="318">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `alpha` starting range of particles launched from this emitter.</haxe_doc>
		</alphaStart>
		<alphaEnd public="1" get="inline" set="null" line="326">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `alpha` ending range of particles launched from this emitter.</haxe_doc>
		</alphaEnd>
		<invalidateStatus public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateStatus>
		<status public="1" set="null" expr="IDLE" line="336">
			<e path="ceramic.ParticlesStatus"/>
			<meta>
				<m n=":value"><e>IDLE</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Determines whether the emitter is currently emitting particles or not</haxe_doc>
		</status>
		<unobservedStatus>
			<e path="ceramic.ParticlesStatus"/>
			<haxe_doc></haxe_doc>
		</unobservedStatus>
		<_dox_event_statusChange public="1" set="method" line="637">
			<f a="current:previous">
				<e path="ceramic.ParticlesStatus"/>
				<e path="ceramic.ParticlesStatus"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</_dox_event_statusChange>
		<emitStatusChange set="method" line="1095">
			<f a="current:previous">
				<e path="ceramic.ParticlesStatus"/>
				<e path="ceramic.ParticlesStatus"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</emitStatusChange>
		<onStatusChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.ParticlesStatus"/>
					<e path="ceramic.ParticlesStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</onStatusChange>
		<onceStatusChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.ParticlesStatus"/>
					<e path="ceramic.ParticlesStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</onceStatusChange>
		<offStatusChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<e path="ceramic.ParticlesStatus"/>
					<e path="ceramic.ParticlesStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</offStatusChange>
		<listensStatusChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</listensStatusChange>
		<paused public="1" expr="false" line="341">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Determines whether the emitter is currently paused. It is totally safe to directly toggle this.</haxe_doc>
		</paused>
		<interval public="1" expr="0.1" line="347">
			<x path="Float"/>
			<meta><m n=":value"><e>0.1</e></m></meta>
			<haxe_doc>* How often a particle is emitted, if currently emitting.
     * Can be modified at the middle of an emission safely;</haxe_doc>
		</interval>
		<launchMode public="1" expr="CIRCLE" line="353">
			<e path="ceramic.ParticlesLaunchMode"/>
			<meta><m n=":value"><e>CIRCLE</e></m></meta>
			<haxe_doc>* How particles should be launched. If `CIRCLE` (default), particles will use `launchAngle` and `speed`.
     * Otherwise, particles will just use `velocityX` and `velocityY`.</haxe_doc>
		</launchMode>
		<keepScaleRatio public="1" expr="false" line="358">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Keep the scale ratio of the particle. Uses the `scaleX` value for reference.</haxe_doc>
		</keepScaleRatio>
		<visualScaleActive public="1" expr="true" line="363">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Apply particle scale to underlying visual or not.</haxe_doc>
		</visualScaleActive>
		<visualColorActive public="1" expr="true" line="368">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Apply particle color to underlying visual or not.</haxe_doc>
		</visualColorActive>
		<visualPositionActive public="1" expr="true" line="373">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc><![CDATA[* Apply particle position (x & y) to underlying visual or not.]]></haxe_doc>
		</visualPositionActive>
		<visualRotationActive public="1" expr="true" line="378">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Apply particle angle to underlying visual rotation or not.</haxe_doc>
		</visualRotationActive>
		<visualAlphaActive public="1" expr="true" line="383">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Apply particle alpha to underlying visual or not.</haxe_doc>
		</visualAlphaActive>
		<width public="1" expr="-1" line="389">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The width of the emission area.
     * If not defined (`-1`), will use visual's width bound to this `ParticleEmitter` object, if any</haxe_doc>
		</width>
		<height public="1" expr="-1" line="394">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The height of the emission area.
     * If not defined (`-1`), will use visual's height bound to this `ParticleEmitter` object, if any</haxe_doc>
		</height>
		<x public="1" expr="0" line="399">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The x position of the emission, relative to particles parent (if any)</haxe_doc>
		</x>
		<y public="1" expr="0" line="403">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The y position of the emission, relative to particles parent (if any)</haxe_doc>
		</y>
		<maxVelocityX public="1" expr="10000" line="409">
			<x path="Float"/>
			<meta><m n=":value"><e>10000</e></m></meta>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
     * to cap the speed automatically (very useful!).</haxe_doc>
		</maxVelocityX>
		<maxVelocityY public="1" expr="10000" line="414">
			<x path="Float"/>
			<meta><m n=":value"><e>10000</e></m></meta>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
     * to cap the speed automatically (very useful!).</haxe_doc>
		</maxVelocityY>
		<velocityActive public="1" expr="true" line="419">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityActive>
		<velocityStartMinX public="1" expr="-100" line="423">
			<x path="Float"/>
			<meta><m n=":value"><e>-100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityStartMinX>
		<velocityStartMinY public="1" expr="-100" line="427">
			<x path="Float"/>
			<meta><m n=":value"><e>-100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityStartMinY>
		<velocityStartMaxX public="1" expr="100" line="431">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityStartMaxX>
		<velocityStartMaxY public="1" expr="100" line="435">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityStartMaxY>
		<velocityEndMinX public="1" expr="-100" line="439">
			<x path="Float"/>
			<meta><m n=":value"><e>-100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityEndMinX>
		<velocityEndMinY public="1" expr="-100" line="443">
			<x path="Float"/>
			<meta><m n=":value"><e>-100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityEndMinY>
		<velocityEndMaxX public="1" expr="100" line="447">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityEndMaxX>
		<velocityEndMaxY public="1" expr="100" line="451">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `SQUARE`.</haxe_doc>
		</velocityEndMaxY>
		<speedStartMin public="1" expr="0" line="456">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this emitter. Only used with `CIRCLE`.</haxe_doc>
		</speedStartMin>
		<speedStartMax public="1" expr="100" line="460">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this emitter. Only used with `CIRCLE`.</haxe_doc>
		</speedStartMax>
		<speedEndMin public="1" expr="0" line="464">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this emitter. Only used with `CIRCLE`.</haxe_doc>
		</speedEndMin>
		<speedEndMax public="1" expr="100" line="468">
			<x path="Float"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this emitter. Only used with `CIRCLE`.</haxe_doc>
		</speedEndMax>
		<maxAngularVelocity public="1" expr="10000" line="473">
			<x path="Float"/>
			<meta><m n=":value"><e>10000</e></m></meta>
			<haxe_doc>* Use in conjunction with angularAcceleration for fluid spin speed control.</haxe_doc>
		</maxAngularVelocity>
		<angularAccelerationActive public="1" expr="true" line="478">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the angular acceleration range of particles launched from this emitter.</haxe_doc>
		</angularAccelerationActive>
		<angularAccelerationStartMin public="1" expr="0" line="482">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the angular acceleration range of particles launched from this emitter.</haxe_doc>
		</angularAccelerationStartMin>
		<angularAccelerationStartMax public="1" expr="0" line="486">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the angular acceleration range of particles launched from this emitter.</haxe_doc>
		</angularAccelerationStartMax>
		<angularDragActive public="1" expr="true" line="491">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the angular drag range of particles launched from this emitter.</haxe_doc>
		</angularDragActive>
		<angularDragStartMin public="1" expr="0" line="495">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the angular drag range of particles launched from this emitter.</haxe_doc>
		</angularDragStartMin>
		<angularDragStartMax public="1" expr="0" line="499">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the angular drag range of particles launched from this emitter.</haxe_doc>
		</angularDragStartMax>
		<angularVelocityActive public="1" expr="true" line="504">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the angular velocity range of particles launched from this emitter.</haxe_doc>
		</angularVelocityActive>
		<angularVelocityStartMin public="1" expr="0" line="508">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this emitter.</haxe_doc>
		</angularVelocityStartMin>
		<angularVelocityStartMax public="1" expr="0" line="512">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this emitter.</haxe_doc>
		</angularVelocityStartMax>
		<angularVelocityEndMin public="1" expr="0" line="516">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this emitter.</haxe_doc>
		</angularVelocityEndMin>
		<angularVelocityEndMax public="1" expr="0" line="520">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this emitter.</haxe_doc>
		</angularVelocityEndMax>
		<angleActive public="1" expr="true" line="526">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the angle range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleActive>
		<angleStartMin public="1" expr="0" line="531">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleStartMin>
		<angleStartMax public="1" expr="0" line="536">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleStartMax>
		<angleEndMin public="1" expr="0" line="541">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleEndMin>
		<angleEndMax public="1" expr="0" line="546">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this emitter.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angleEndMax>
		<ignoreAngularVelocity public="1" expr="false" line="552">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Set this if you want to specify the beginning and ending value of angle,
     * instead of using `angularVelocity` (or `angularAcceleration`).</haxe_doc>
		</ignoreAngularVelocity>
		<launchAngleActive public="1" expr="true" line="558">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the angle range at which particles will be launched from this emitter.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</launchAngleActive>
		<launchAngleMin public="1" expr="-180" line="563">
			<x path="Float"/>
			<meta><m n=":value"><e>-180</e></m></meta>
			<haxe_doc>* The angle range at which particles will be launched from this emitter.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</launchAngleMin>
		<launchAngleMax public="1" expr="180" line="568">
			<x path="Float"/>
			<meta><m n=":value"><e>180</e></m></meta>
			<haxe_doc>* The angle range at which particles will be launched from this emitter.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</launchAngleMax>
		<lifespanActive public="1" expr="true" line="573">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the life, or duration, range of particles launched from this emitter.</haxe_doc>
		</lifespanActive>
		<lifespanMin public="1" expr="3" line="577">
			<x path="Float"/>
			<meta><m n=":value"><e>3</e></m></meta>
			<haxe_doc>* The life, or duration, range of particles launched from this emitter.</haxe_doc>
		</lifespanMin>
		<lifespanMax public="1" expr="3" line="581">
			<x path="Float"/>
			<meta><m n=":value"><e>3</e></m></meta>
			<haxe_doc>* The life, or duration, range of particles launched from this emitter.</haxe_doc>
		</lifespanMax>
		<scaleActive public="1" expr="true" line="586">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleActive>
		<scaleStartMinX public="1" expr="1" line="590">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleStartMinX>
		<scaleStartMinY public="1" expr="1" line="594">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleStartMinY>
		<scaleStartMaxX public="1" expr="1" line="598">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleStartMaxX>
		<scaleStartMaxY public="1" expr="1" line="602">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleStartMaxY>
		<scaleEndMinX public="1" expr="1" line="606">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleEndMinX>
		<scaleEndMinY public="1" expr="1" line="610">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleEndMinY>
		<scaleEndMaxX public="1" expr="1" line="614">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleEndMaxX>
		<scaleEndMaxY public="1" expr="1" line="618">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scaleEndMaxY>
		<alphaActive public="1" expr="true" line="623">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable `alpha` range of particles launched from this emitter.</haxe_doc>
		</alphaActive>
		<alphaStartMin public="1" expr="1" line="627">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this emitter.</haxe_doc>
		</alphaStartMin>
		<alphaStartMax public="1" expr="1" line="631">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this emitter.</haxe_doc>
		</alphaStartMax>
		<alphaEndMin public="1" expr="1" line="635">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this emitter.</haxe_doc>
		</alphaEndMin>
		<alphaEndMax public="1" expr="1" line="639">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this emitter.</haxe_doc>
		</alphaEndMax>
		<colorActive public="1" expr="true" line="644">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable `color` range of particles launched from this emitter.</haxe_doc>
		</colorActive>
		<colorStartMin public="1" expr="Color.WHITE" line="648">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this emitter.</haxe_doc>
		</colorStartMin>
		<colorStartMax public="1" expr="Color.WHITE" line="652">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this emitter.</haxe_doc>
		</colorStartMax>
		<colorEndMin public="1" expr="Color.WHITE" line="656">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this emitter.</haxe_doc>
		</colorEndMin>
		<colorEndMax public="1" expr="Color.WHITE" line="660">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this emitter.</haxe_doc>
		</colorEndMax>
		<dragActive public="1" expr="true" line="665">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragActive>
		<dragStartMinX public="1" expr="0" line="669">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragStartMinX>
		<dragStartMinY public="1" expr="0" line="673">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragStartMinY>
		<dragStartMaxX public="1" expr="0" line="677">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragStartMaxX>
		<dragStartMaxY public="1" expr="0" line="681">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragStartMaxY>
		<dragEndMinX public="1" expr="0" line="685">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragEndMinX>
		<dragEndMinY public="1" expr="0" line="689">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragEndMinY>
		<dragEndMaxX public="1" expr="0" line="693">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragEndMaxX>
		<dragEndMaxY public="1" expr="0" line="697">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</dragEndMaxY>
		<accelerationActive public="1" expr="true" line="703">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enable or disable the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationActive>
		<accelerationStartMinX public="1" expr="0" line="708">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationStartMinX>
		<accelerationStartMinY public="1" expr="0" line="713">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationStartMinY>
		<accelerationStartMaxX public="1" expr="0" line="718">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationStartMaxX>
		<accelerationStartMaxY public="1" expr="0" line="723">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationStartMaxY>
		<accelerationEndMinX public="1" expr="0" line="728">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationEndMinX>
		<accelerationEndMinY public="1" expr="0" line="733">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationEndMinY>
		<accelerationEndMaxX public="1" expr="0" line="738">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationEndMaxX>
		<accelerationEndMaxY public="1" expr="0" line="743">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</accelerationEndMaxY>
		<seed public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* A random seed used to generated particles.
     * Provide a custom seed to reproduce same chain of particles.</haxe_doc>
		</seed>
		<get_seed get="inline" set="null" line="750"><f a=""><x path="Float"/></f></get_seed>
		<set_seed set="method" line="753"><f a="seed">
	<x path="Float"/>
	<x path="Float"/>
</f></set_seed>
		<getCustomParticleVisual public="1">
			<f a="existingVisual">
				<c path="ceramic.Visual"/>
				<c path="ceramic.Visual"/>
			</f>
			<haxe_doc>* Custom particle visual creation. Use this to emit custom visuals as particle. Another option
     * is to create a subclass of `ParticleEmitter` and override `getParticleVisual()` method.</haxe_doc>
		</getCustomParticleVisual>
		<_quantityToEmit expr="0" line="767">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The internal quantity we want to emit (when emitting continuously)</haxe_doc>
		</_quantityToEmit>
		<_continuousTimer expr="0" line="772">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Timer used when emitting continuously</haxe_doc>
		</_continuousTimer>
		<_activeParticles expr="[]" line="777">
			<c path="Array"><c path="ceramic.ParticleItem"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal list of active particle items</haxe_doc>
		</_activeParticles>
		<_recycledParticles expr="[]" line="782">
			<c path="Array"><c path="ceramic.ParticleItem"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal list of recycled particle items</haxe_doc>
		</_recycledParticles>
		<_updatingParticles expr="[]" line="787">
			<c path="Array"><c path="ceramic.ParticleItem"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal list of particle items when they are being iterated on to be updated</haxe_doc>
		</_updatingParticles>
		<_seedRandom expr="new SeedRandom(Math.random() * 999999999)" line="792">
			<c path="ceramic.SeedRandom"/>
			<meta><m n=":value"><e>new SeedRandom(Math.random() * 999999999)</e></m></meta>
			<haxe_doc>* The seeded random used internally</haxe_doc>
		</_seedRandom>
		<destroy public="1" set="method" line="811" override="1"><f a=""><x path="Void"/></f></destroy>
		<bindAsComponent set="method" line="830"><f a=""><x path="Void"/></f></bindAsComponent>
		<update set="method" line="838">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called automatically by the game loop</haxe_doc>
		</update>
		<emitContinuousParticlesIfNeeded get="inline" set="null" line="879">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Emit one or more particles if continuous emission is active and enough time has passed</haxe_doc>
		</emitContinuousParticlesIfNeeded>
		<updateParticle set="method" line="914">
			<f a="particle:delta">
				<c path="ceramic.ParticleItem"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Update a particle (and its visual) from its parameter and elapsed time</haxe_doc>
		</updateParticle>
		<createParticleItem set="method" line="1002">
			<f a=""><c path="ceramic.ParticleItem"/></f>
			<haxe_doc>* Instanciate and return a new ParticleItem object.
     * Override this method if you want to instanciate a custom ParticleItem subclass
     * @return ParticleItem</haxe_doc>
		</createParticleItem>
		<getParticle set="method" line="1008"><f a=""><c path="ceramic.ParticleItem"/></f></getParticle>
		<getParticleVisual set="method" line="1036">
			<f a="existingVisual">
				<c path="ceramic.Visual"/>
				<c path="ceramic.Visual"/>
			</f>
			<haxe_doc>* Get a visual for a particle that will be emitted right after.
     * If a visual is being recycled, provide it as argument.</haxe_doc>
		</getParticleVisual>
		<recycleParticle set="method" line="1061"><f a="particle">
	<c path="ceramic.ParticleItem"/>
	<x path="Void"/>
</f></recycleParticle>
		<recycleParticleVisual set="method" line="1079">
			<f a="visualToRecycle">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Recycle a particle's visual to reuse it later.</haxe_doc>
		</recycleParticleVisual>
		<emitContinuously public="1" set="method" line="1097">
			<f a="?interval:?quantity" v="0.1:-1">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ quantity : -1, interval : 0.1 }</e></m></meta>
			<haxe_doc>* Start emitting particles continuously.
     *
     * @param   interval   How often to emit a particle.
     *                      `0` = never emit, `0.1` = 1 particle every 0.1 seconds, `5` = 1 particle every 5 seconds.
     * @param   quantity    How many particles to launch before stopping. `-1` (default) = never stop</haxe_doc>
		</emitContinuously>
		<explode public="1" set="method" line="1116">
			<f a="quantity">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Burst a given quantity number of particles at once
     *
     * @param   quantity    How many particles to launch. Does nothing if lower than `1`</haxe_doc>
		</explode>
		<stop public="1" set="method" line="1132">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stop emitting (if it was emitting)</haxe_doc>
		</stop>
		<emitParticle public="1" set="method" line="1144">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function can be used both internally and externally to emit the next particle.</haxe_doc>
		</emitParticle>
		<randomBetweenFloats get="inline" set="null" line="1323"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></randomBetweenFloats>
		<randomBetweenColors get="inline" set="null" line="1329"><f a="a:b">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></randomBetweenColors>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<setEntity set="method" line="14">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="14">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="805">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a new `ParticleEmitter` object.</haxe_doc>
		</new>
		<haxe_doc>* A particle emitter.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.ParticleItem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ParticleItem.hx">
		<visual public="1" expr="null" line="11">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</visual>
		<visualScaleActive public="1" expr="true" line="13">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</visualScaleActive>
		<visualColorActive public="1" expr="true" line="14">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</visualColorActive>
		<visualPositionActive public="1" expr="true" line="15">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</visualPositionActive>
		<visualRotationActive public="1" expr="true" line="16">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</visualRotationActive>
		<visualAlphaActive public="1" expr="true" line="17">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</visualAlphaActive>
		<active public="1" expr="false" line="19">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</active>
		<lifespan public="1" expr="0" line="21">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lifespan>
		<age public="1" expr="0" line="22">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</age>
		<time public="1" expr="0" line="27">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The time relative to app when this particule was emitted</haxe_doc>
		</time>
		<random public="1" expr="0" line="32">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Convenience: hold a random value between 0 and 1 for each particle</haxe_doc>
		</random>
		<status public="1" expr="0" line="37">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* In case implementation needs to keep a status for each particle, this property can be used for that</haxe_doc>
		</status>
		<colorRangeActive public="1" expr="true" line="39">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</colorRangeActive>
		<colorRangeStart public="1" expr="Color.WHITE" line="40">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
		</colorRangeStart>
		<colorRangeEnd public="1" expr="Color.WHITE" line="41">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
		</colorRangeEnd>
		<color public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<meta><m n=":isVar"/></meta>
		</color>
		<get_color get="inline" set="null" line="43"><f a=""><x path="ceramic.Color"/></f></get_color>
		<set_color get="inline" set="null" line="58"><f a="color">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
		<accelerationRangeActive public="1" expr="true" line="70">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</accelerationRangeActive>
		<accelerationRangeStartX public="1" expr="0" line="71">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accelerationRangeStartX>
		<accelerationRangeStartY public="1" expr="0" line="72">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accelerationRangeStartY>
		<accelerationRangeEndX public="1" expr="0" line="73">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accelerationRangeEndX>
		<accelerationRangeEndY public="1" expr="0" line="74">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accelerationRangeEndY>
		<accelerationX public="1" expr="0" line="75">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accelerationX>
		<accelerationY public="1" expr="0" line="76">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accelerationY>
		<dragRangeActive public="1" expr="true" line="78">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</dragRangeActive>
		<dragRangeStartX public="1" expr="0" line="79">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dragRangeStartX>
		<dragRangeStartY public="1" expr="0" line="80">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dragRangeStartY>
		<dragRangeEndX public="1" expr="0" line="81">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dragRangeEndX>
		<dragRangeEndY public="1" expr="0" line="82">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dragRangeEndY>
		<dragX public="1" expr="0" line="83">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dragX>
		<dragY public="1" expr="0" line="84">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dragY>
		<velocityRangeActive public="1" expr="true" line="86">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</velocityRangeActive>
		<velocityRangeStartX public="1" expr="0" line="87">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</velocityRangeStartX>
		<velocityRangeStartY public="1" expr="0" line="88">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</velocityRangeStartY>
		<velocityRangeEndX public="1" expr="0" line="89">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</velocityRangeEndX>
		<velocityRangeEndY public="1" expr="0" line="90">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</velocityRangeEndY>
		<velocityX public="1" expr="0" line="91">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</velocityX>
		<velocityY public="1" expr="0" line="92">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</velocityY>
		<angularVelocityRangeActive public="1" expr="true" line="94">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</angularVelocityRangeActive>
		<angularVelocityRangeStart public="1" expr="0" line="95">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularVelocityRangeStart>
		<angularVelocityRangeEnd public="1" expr="0" line="96">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularVelocityRangeEnd>
		<angularVelocity public="1" expr="0" line="97">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularVelocity>
		<angularAccelerationRangeActive public="1" expr="true" line="99">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</angularAccelerationRangeActive>
		<angularAccelerationRangeStart public="1" expr="0" line="100">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularAccelerationRangeStart>
		<angularAccelerationRangeEnd public="1" expr="0" line="101">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularAccelerationRangeEnd>
		<angularAcceleration public="1" expr="0" line="102">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularAcceleration>
		<angularDrag public="1" expr="0" line="104">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angularDrag>
		<scaleRangeActive public="1" expr="true" line="106">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</scaleRangeActive>
		<scaleRangeStartX public="1" expr="1" line="107">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</scaleRangeStartX>
		<scaleRangeStartY public="1" expr="1" line="108">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</scaleRangeStartY>
		<scaleRangeEndX public="1" expr="1" line="109">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</scaleRangeEndX>
		<scaleRangeEndY public="1" expr="1" line="110">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</scaleRangeEndY>
		<scaleX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</scaleX>
		<get_scaleX get="inline" set="null" line="112"><f a=""><x path="Float"/></f></get_scaleX>
		<set_scaleX get="inline" set="null" line="115"><f a="scaleX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<scaleY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</scaleY>
		<get_scaleY get="inline" set="null" line="122"><f a=""><x path="Float"/></f></get_scaleY>
		<set_scaleY get="inline" set="null" line="125"><f a="scaleY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<scale public="1" get="inline" set="null" line="131"><f a="scaleX:scaleY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</x>
		<get_x get="inline" set="null" line="137"><f a=""><x path="Float"/></f></get_x>
		<set_x get="inline" set="null" line="140"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</y>
		<get_y get="inline" set="null" line="147"><f a=""><x path="Float"/></f></get_y>
		<set_y get="inline" set="null" line="150"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<pos public="1" get="inline" set="null" line="156"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pos>
		<angle public="1" get="accessor" set="accessor" expr="0" line="161">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":isVar"/>
			</meta>
		</angle>
		<get_angle get="inline" set="null" line="162"><f a=""><x path="Float"/></f></get_angle>
		<set_angle get="inline" set="null" line="165"><f a="angle">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<alphaRangeActive public="1" expr="true" line="172">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</alphaRangeActive>
		<alphaRangeStart public="1" expr="1" line="173">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</alphaRangeStart>
		<alphaRangeEnd public="1" expr="1" line="174">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</alphaRangeEnd>
		<alpha public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</alpha>
		<get_alpha get="inline" set="null" line="176"><f a=""><x path="Float"/></f></get_alpha>
		<set_alpha get="inline" set="null" line="179"><f a="alpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<reset public="1" get="inline" set="null" line="188"><f a=""><x path="Void"/></f></reset>
		<new set="method" line="186"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A particle item.
 * You should not instanciate this yourself as
 * it is managed by a `Particles` emitter object.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.ParticleEmitter</e></m>
		</meta>
	</class>
	<class path="ceramic.Particles" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Particles.hx">
		<extends path="ceramic.Visual"/>
		<emitter public="1">
			<c path="ceramic.Particles.T"/>
			<meta><m n="component"/></meta>
		</emitter>
		<init set="method" line="30"><f a=""><x path="Void"/></f></init>
		<autoEmit public="1" set="accessor" expr="false" line="60">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="editable"><e>{ group : "emitterInterval" }</e></m>
			</meta>
		</autoEmit>
		<set_autoEmit set="method" line="61"><f a="autoEmit">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoEmit>
		<clearExplodeInterval expr="null" line="74">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</clearExplodeInterval>
		<autoExplodeInterval public="1" set="accessor" expr="-1" line="77">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="editable"><e>{ label : "Explode Interval", group : "autoExplode" }</e></m>
			</meta>
		</autoExplodeInterval>
		<set_autoExplodeInterval set="method" line="78"><f a="autoExplodeInterval">
	<x path="Float"/>
	<x path="Float"/>
</f></set_autoExplodeInterval>
		<autoExplodeQuantity public="1" set="accessor" expr="64" line="87">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>64</e></m>
				<m n="editable"><e>{ label : "Explode Quantity", group : "autoExplode" }</e></m>
			</meta>
		</autoExplodeQuantity>
		<set_autoExplodeQuantity set="method" line="88"><f a="autoExplodeQuantity">
	<x path="Int"/>
	<x path="Int"/>
</f></set_autoExplodeQuantity>
		<computeAutoExplode set="method" line="96"><f a=""><x path="Void"/></f></computeAutoExplode>
		<doAutoExplode set="method" line="109"><f a=""><x path="Void"/></f></doAutoExplode>
		<emitterPaused public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Paused" }</e></m></meta>
			<haxe_doc>* Determines whether the emitter is currently paused. It is totally safe to directly toggle this.</haxe_doc>
		</emitterPaused>
		<get_emitterPaused get="inline" set="null" line="129"><f a=""><x path="Bool"/></f></get_emitterPaused>
		<set_emitterPaused get="inline" set="null" line="130"><f a="paused">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterPaused>
		<emitterInterval public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Interval", group : "emitterInterval" }</e></m></meta>
			<haxe_doc>* How often a particle is emitted, if currently emitting.
     * Can be modified at the middle of an emission safely;</haxe_doc>
		</emitterInterval>
		<get_emitterInterval get="inline" set="null" line="139"><f a=""><x path="Float"/></f></get_emitterInterval>
		<set_emitterInterval get="inline" set="null" line="140"><f a="interval">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterInterval>
		<emitterLaunchMode public="1" get="accessor" set="accessor">
			<e path="ceramic.ParticlesLaunchMode"/>
			<meta><m n="editable"><e>{ label : "Launch Mode" }</e></m></meta>
			<haxe_doc>* How particles should be launched. If `CIRCLE` (default), particles will use `launchAngle` and `speed`.
     * Otherwise, particles will just use `velocityX` and `velocityY`.</haxe_doc>
		</emitterLaunchMode>
		<get_emitterLaunchMode get="inline" set="null" line="148"><f a=""><e path="ceramic.ParticlesLaunchMode"/></f></get_emitterLaunchMode>
		<set_emitterLaunchMode get="inline" set="null" line="149"><f a="launchMode">
	<e path="ceramic.ParticlesLaunchMode"/>
	<e path="ceramic.ParticlesLaunchMode"/>
</f></set_emitterLaunchMode>
		<emitterVisualScaleActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Scale Active", group : "emitterScale" }</e></m></meta>
			<haxe_doc>* Apply particle scale to underlying visual or not.</haxe_doc>
		</emitterVisualScaleActive>
		<get_emitterVisualScaleActive get="inline" set="null" line="156"><f a=""><x path="Bool"/></f></get_emitterVisualScaleActive>
		<set_emitterVisualScaleActive get="inline" set="null" line="157"><f a="visualScaleActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterVisualScaleActive>
		<emitterKeepScaleRatio public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Keep Scale Ratio", group : "emitterScale" }</e></m></meta>
			<haxe_doc>* Keep the scale ratio of the particle. Uses the `scaleX` value for reference.</haxe_doc>
		</emitterKeepScaleRatio>
		<get_emitterKeepScaleRatio get="inline" set="null" line="164"><f a=""><x path="Bool"/></f></get_emitterKeepScaleRatio>
		<set_emitterKeepScaleRatio get="inline" set="null" line="165"><f a="keepScaleRatio">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterKeepScaleRatio>
		<emitterVisualColorActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Color Active", group : "emitterColorAlphaActive" }</e></m></meta>
			<haxe_doc>* Apply particle color to underlying visual or not.</haxe_doc>
		</emitterVisualColorActive>
		<get_emitterVisualColorActive get="inline" set="null" line="172"><f a=""><x path="Bool"/></f></get_emitterVisualColorActive>
		<set_emitterVisualColorActive get="inline" set="null" line="173"><f a="visualColorActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterVisualColorActive>
		<emitterVisualAlphaActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Alpha Active", group : "emitterColorAlphaActive" }</e></m></meta>
			<haxe_doc>* Apply particle alpha to underlying visual or not.</haxe_doc>
		</emitterVisualAlphaActive>
		<get_emitterVisualAlphaActive get="inline" set="null" line="180"><f a=""><x path="Bool"/></f></get_emitterVisualAlphaActive>
		<set_emitterVisualAlphaActive get="inline" set="null" line="181"><f a="visualAlphaActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterVisualAlphaActive>
		<emitterVisualPositionActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Position Active", group : "emitterPosRotationActive" }</e></m></meta>
			<haxe_doc><![CDATA[* Apply particle position (x & y) to underlying visual or not.]]></haxe_doc>
		</emitterVisualPositionActive>
		<get_emitterVisualPositionActive get="inline" set="null" line="188"><f a=""><x path="Bool"/></f></get_emitterVisualPositionActive>
		<set_emitterVisualPositionActive get="inline" set="null" line="189"><f a="visualPositionActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterVisualPositionActive>
		<emitterVisualRotationActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Rotation Active", group : "emitterPosRotationActive" }</e></m></meta>
			<haxe_doc>* Apply particle angle to underlying visual rotation or not.</haxe_doc>
		</emitterVisualRotationActive>
		<get_emitterVisualRotationActive get="inline" set="null" line="196"><f a=""><x path="Bool"/></f></get_emitterVisualRotationActive>
		<set_emitterVisualRotationActive get="inline" set="null" line="197"><f a="visualRotationActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterVisualRotationActive>
		<emitterWidth public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Emitter Width", group : "emitterSize" }</e></m></meta>
			<haxe_doc>* The width of the emission area.
     * If not defined (`-1`), will use visual's width bound to this `ParticleEmitter` object, if any</haxe_doc>
		</emitterWidth>
		<get_emitterWidth get="inline" set="null" line="205"><f a=""><x path="Float"/></f></get_emitterWidth>
		<set_emitterWidth get="inline" set="null" line="206"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterWidth>
		<emitterHeight public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Emitter Height", group : "emitterSize" }</e></m></meta>
			<haxe_doc>* The height of the emission area.
     * If not defined (`-1`), will use visual's height bound to this `ParticleEmitter` object, if any</haxe_doc>
		</emitterHeight>
		<get_emitterHeight get="inline" set="null" line="213"><f a=""><x path="Float"/></f></get_emitterHeight>
		<set_emitterHeight get="inline" set="null" line="214"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterHeight>
		<emitterX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Emitter X", group : "emitterPos" }</e></m></meta>
			<haxe_doc>* The x position of the emission, relative to particles parent (if any)</haxe_doc>
		</emitterX>
		<get_emitterX get="inline" set="null" line="221"><f a=""><x path="Float"/></f></get_emitterX>
		<set_emitterX get="inline" set="null" line="222"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterX>
		<emitterY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Emitter Y", group : "emitterPos" }</e></m></meta>
			<haxe_doc>* The y position of the emission, relative to particles parent (if any)</haxe_doc>
		</emitterY>
		<get_emitterY get="inline" set="null" line="228"><f a=""><x path="Float"/></f></get_emitterY>
		<set_emitterY get="inline" set="null" line="229"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterY>
		<emitterVelocityActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Vel. Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityActive>
		<get_emitterVelocityActive get="inline" set="null" line="236"><f a=""><x path="Bool"/></f></get_emitterVelocityActive>
		<set_emitterVelocityActive get="inline" set="null" line="237"><f a="velocityActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterVelocityActive>
		<emitterMaxVelocityX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Max Vel. X", group : "emitterMaxVelocity" }</e></m></meta>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
     * to cap the speed automatically (very useful!).</haxe_doc>
		</emitterMaxVelocityX>
		<get_emitterMaxVelocityX get="inline" set="null" line="245"><f a=""><x path="Float"/></f></get_emitterMaxVelocityX>
		<set_emitterMaxVelocityX get="inline" set="null" line="246"><f a="maxVelocityX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterMaxVelocityX>
		<emitterMaxVelocityY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Max Vel. Y", group : "emitterMaxVelocity" }</e></m></meta>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
     * to cap the speed automatically (very useful!).</haxe_doc>
		</emitterMaxVelocityY>
		<get_emitterMaxVelocityY get="inline" set="null" line="253"><f a=""><x path="Float"/></f></get_emitterMaxVelocityY>
		<set_emitterMaxVelocityY get="inline" set="null" line="254"><f a="maxVelocityY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterMaxVelocityY>
		<emitterVelocityStartMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. Start Min X", group : "emitterVelocityStartMin" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityStartMinX>
		<get_emitterVelocityStartMinX get="inline" set="null" line="260"><f a=""><x path="Float"/></f></get_emitterVelocityStartMinX>
		<set_emitterVelocityStartMinX get="inline" set="null" line="261"><f a="velocityStartMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityStartMinX>
		<emitterVelocityStartMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. Start Min Y", group : "emitterVelocityStartMin" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityStartMinY>
		<get_emitterVelocityStartMinY get="inline" set="null" line="267"><f a=""><x path="Float"/></f></get_emitterVelocityStartMinY>
		<set_emitterVelocityStartMinY get="inline" set="null" line="268"><f a="velocityStartMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityStartMinY>
		<emitterVelocityStartMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. Start Max X", group : "emitterVelocityStartMax" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityStartMaxX>
		<get_emitterVelocityStartMaxX get="inline" set="null" line="274"><f a=""><x path="Float"/></f></get_emitterVelocityStartMaxX>
		<set_emitterVelocityStartMaxX get="inline" set="null" line="275"><f a="velocityStartMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityStartMaxX>
		<emitterVelocityStartMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. Start Max Y", group : "emitterVelocityStartMax" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityStartMaxY>
		<get_emitterVelocityStartMaxY get="inline" set="null" line="281"><f a=""><x path="Float"/></f></get_emitterVelocityStartMaxY>
		<set_emitterVelocityStartMaxY get="inline" set="null" line="282"><f a="velocityStartMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityStartMaxY>
		<emitterVelocityEndMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. End Min X", group : "emitterVelocityEndMin" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityEndMinX>
		<get_emitterVelocityEndMinX get="inline" set="null" line="288"><f a=""><x path="Float"/></f></get_emitterVelocityEndMinX>
		<set_emitterVelocityEndMinX get="inline" set="null" line="289"><f a="velocityEndMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityEndMinX>
		<emitterVelocityEndMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. End Min Y", group : "emitterVelocityEndMin" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityEndMinY>
		<get_emitterVelocityEndMinY get="inline" set="null" line="295"><f a=""><x path="Float"/></f></get_emitterVelocityEndMinY>
		<set_emitterVelocityEndMinY get="inline" set="null" line="296"><f a="velocityEndMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityEndMinY>
		<emitterVelocityEndMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. End Max X", group : "emitterVelocityEndMax" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityEndMaxX>
		<get_emitterVelocityEndMaxX get="inline" set="null" line="302"><f a=""><x path="Float"/></f></get_emitterVelocityEndMaxX>
		<set_emitterVelocityEndMaxX get="inline" set="null" line="303"><f a="velocityEndMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityEndMaxX>
		<emitterVelocityEndMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Vel. End Max Y", group : "emitterVelocityEndMax" }</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityEndMaxY>
		<get_emitterVelocityEndMaxY get="inline" set="null" line="309"><f a=""><x path="Float"/></f></get_emitterVelocityEndMaxY>
		<set_emitterVelocityEndMaxY get="inline" set="null" line="310"><f a="velocityEndMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterVelocityEndMaxY>
		<emitterSpeedStartMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Speed Start Min", group : "emitterSpeedStart" }</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `CIRCLE`.</haxe_doc>
		</emitterSpeedStartMin>
		<get_emitterSpeedStartMin get="inline" set="null" line="317"><f a=""><x path="Float"/></f></get_emitterSpeedStartMin>
		<set_emitterSpeedStartMin get="inline" set="null" line="318"><f a="speedStartMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterSpeedStartMin>
		<emitterSpeedStartMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Speed Start Max", group : "emitterSpeedStart" }</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `CIRCLE`.</haxe_doc>
		</emitterSpeedStartMax>
		<get_emitterSpeedStartMax get="inline" set="null" line="324"><f a=""><x path="Float"/></f></get_emitterSpeedStartMax>
		<set_emitterSpeedStartMax get="inline" set="null" line="325"><f a="speedStartMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterSpeedStartMax>
		<emitterSpeedEndMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Speed End Min", group : "emitterSpeedEnd" }</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `CIRCLE`.</haxe_doc>
		</emitterSpeedEndMin>
		<get_emitterSpeedEndMin get="inline" set="null" line="332"><f a=""><x path="Float"/></f></get_emitterSpeedEndMin>
		<set_emitterSpeedEndMin get="inline" set="null" line="333"><f a="speedEndMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterSpeedEndMin>
		<emitterSpeedEndMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Speed End Max", group : "emitterSpeedEnd" }</e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `CIRCLE`.</haxe_doc>
		</emitterSpeedEndMax>
		<get_emitterSpeedEndMax get="inline" set="null" line="339"><f a=""><x path="Float"/></f></get_emitterSpeedEndMax>
		<set_emitterSpeedEndMax get="inline" set="null" line="340"><f a="speedEndMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterSpeedEndMax>
		<emitterMaxAngularVelocity public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Max Angular Vel.", group : "emitterAngularVelocityAcceleration" }</e></m></meta>
			<haxe_doc>* Use in conjunction with angularAcceleration for fluid spin speed control.</haxe_doc>
		</emitterMaxAngularVelocity>
		<get_emitterMaxAngularVelocity get="inline" set="null" line="347"><f a=""><x path="Float"/></f></get_emitterMaxAngularVelocity>
		<set_emitterMaxAngularVelocity get="inline" set="null" line="348"><f a="maxAngularVelocity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterMaxAngularVelocity>
		<emitterAngularAccelerationActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Angular Accel. Active", group : "emitterAngularVelocityAcceleration" }</e></m></meta>
			<haxe_doc>* Enable or disable the angular acceleration range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularAccelerationActive>
		<get_emitterAngularAccelerationActive get="inline" set="null" line="354"><f a=""><x path="Bool"/></f></get_emitterAngularAccelerationActive>
		<set_emitterAngularAccelerationActive get="inline" set="null" line="355"><f a="angularAccelerationActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterAngularAccelerationActive>
		<emitterAngularAccelerationStartMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Accel. Start Min", group : "emitterAngularAccelerationStart" }</e></m></meta>
			<haxe_doc>* Set the angular acceleration range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularAccelerationStartMin>
		<get_emitterAngularAccelerationStartMin get="inline" set="null" line="362"><f a=""><x path="Float"/></f></get_emitterAngularAccelerationStartMin>
		<set_emitterAngularAccelerationStartMin get="inline" set="null" line="363"><f a="angularAccelerationStartMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularAccelerationStartMin>
		<emitterAngularAccelerationStartMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Accel. Start Max", group : "emitterAngularAccelerationStart" }</e></m></meta>
			<haxe_doc>* Set the angular acceleration range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularAccelerationStartMax>
		<get_emitterAngularAccelerationStartMax get="inline" set="null" line="369"><f a=""><x path="Float"/></f></get_emitterAngularAccelerationStartMax>
		<set_emitterAngularAccelerationStartMax get="inline" set="null" line="370"><f a="angularAccelerationStartMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularAccelerationStartMax>
		<emitterAngularDragActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Angular Drag Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the angular drag range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularDragActive>
		<get_emitterAngularDragActive get="inline" set="null" line="377"><f a=""><x path="Bool"/></f></get_emitterAngularDragActive>
		<set_emitterAngularDragActive get="inline" set="null" line="378"><f a="angularDragActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterAngularDragActive>
		<emitterAngularDragStartMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Drag Start Min", group : "emitterAngularDragStart" }</e></m></meta>
			<haxe_doc>* Set the angular drag range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularDragStartMin>
		<get_emitterAngularDragStartMin get="inline" set="null" line="385"><f a=""><x path="Float"/></f></get_emitterAngularDragStartMin>
		<set_emitterAngularDragStartMin get="inline" set="null" line="386"><f a="angularDragStartMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularDragStartMin>
		<emitterAngularDragStartMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Drag Start Max", group : "emitterAngularDragStart" }</e></m></meta>
			<haxe_doc>* Set the angular drag range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularDragStartMax>
		<get_emitterAngularDragStartMax get="inline" set="null" line="392"><f a=""><x path="Float"/></f></get_emitterAngularDragStartMax>
		<set_emitterAngularDragStartMax get="inline" set="null" line="393"><f a="angularDragStartMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularDragStartMax>
		<emitterAngularVelocityActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Angular Vel. Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the angular velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityActive>
		<get_emitterAngularVelocityActive get="inline" set="null" line="400"><f a=""><x path="Bool"/></f></get_emitterAngularVelocityActive>
		<set_emitterAngularVelocityActive get="inline" set="null" line="401"><f a="angularVelocityActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterAngularVelocityActive>
		<emitterAngularVelocityStartMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Vel. Start Min", group : "emitterAngularVelocityStart" }</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityStartMin>
		<get_emitterAngularVelocityStartMin get="inline" set="null" line="408"><f a=""><x path="Float"/></f></get_emitterAngularVelocityStartMin>
		<set_emitterAngularVelocityStartMin get="inline" set="null" line="409"><f a="angularVelocityStartMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularVelocityStartMin>
		<emitterAngularVelocityStartMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Vel. Start Max", group : "emitterAngularVelocityStart" }</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityStartMax>
		<get_emitterAngularVelocityStartMax get="inline" set="null" line="415"><f a=""><x path="Float"/></f></get_emitterAngularVelocityStartMax>
		<set_emitterAngularVelocityStartMax get="inline" set="null" line="416"><f a="angularVelocityStartMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularVelocityStartMax>
		<emitterAngularVelocityEndMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Vel. End Min", group : "emitterAngularVelocityEnd" }</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityEndMin>
		<get_emitterAngularVelocityEndMin get="inline" set="null" line="423"><f a=""><x path="Float"/></f></get_emitterAngularVelocityEndMin>
		<set_emitterAngularVelocityEndMin get="inline" set="null" line="424"><f a="angularVelocityEndMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularVelocityEndMin>
		<emitterAngularVelocityEndMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angular Vel. End Max", group : "emitterAngularVelocityEnd" }</e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityEndMax>
		<get_emitterAngularVelocityEndMax get="inline" set="null" line="430"><f a=""><x path="Float"/></f></get_emitterAngularVelocityEndMax>
		<set_emitterAngularVelocityEndMax get="inline" set="null" line="431"><f a="angularVelocityEndMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngularVelocityEndMax>
		<emitterAngleActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Angle Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the angle range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleActive>
		<get_emitterAngleActive get="inline" set="null" line="439"><f a=""><x path="Bool"/></f></get_emitterAngleActive>
		<set_emitterAngleActive get="inline" set="null" line="440"><f a="angleActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterAngleActive>
		<emitterAngleStartMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angle Start Min", group : "emitterAngleStart" }</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleStartMin>
		<get_emitterAngleStartMin get="inline" set="null" line="448"><f a=""><x path="Float"/></f></get_emitterAngleStartMin>
		<set_emitterAngleStartMin get="inline" set="null" line="449"><f a="angleStartMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngleStartMin>
		<emitterAngleStartMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angle Start Max", group : "emitterAngleStart" }</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleStartMax>
		<get_emitterAngleStartMax get="inline" set="null" line="456"><f a=""><x path="Float"/></f></get_emitterAngleStartMax>
		<set_emitterAngleStartMax get="inline" set="null" line="457"><f a="angleStartMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngleStartMax>
		<emitterAngleEndMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angle End Min", group : "emitterAngleEnd" }</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleEndMin>
		<get_emitterAngleEndMin get="inline" set="null" line="465"><f a=""><x path="Float"/></f></get_emitterAngleEndMin>
		<set_emitterAngleEndMin get="inline" set="null" line="466"><f a="angleEndMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngleEndMin>
		<emitterAngleEndMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Angle End Max", group : "emitterAngleEnd" }</e></m></meta>
			<haxe_doc>* The angle range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleEndMax>
		<get_emitterAngleEndMax get="inline" set="null" line="473"><f a=""><x path="Float"/></f></get_emitterAngleEndMax>
		<set_emitterAngleEndMax get="inline" set="null" line="474"><f a="angleEndMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAngleEndMax>
		<emitterIgnoreAngularVelocity public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Ignore Angular Vel." }</e></m></meta>
			<haxe_doc>* Set this if you want to specify the beginning and ending value of angle,
     * instead of using `angularVelocity` (or `angularAcceleration`).</haxe_doc>
		</emitterIgnoreAngularVelocity>
		<get_emitterIgnoreAngularVelocity get="inline" set="null" line="482"><f a=""><x path="Bool"/></f></get_emitterIgnoreAngularVelocity>
		<set_emitterIgnoreAngularVelocity get="inline" set="null" line="483"><f a="ignoreAngularVelocity">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterIgnoreAngularVelocity>
		<emitterLaunchAngleActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Launch Angle Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the angle range at which particles will be launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</emitterLaunchAngleActive>
		<get_emitterLaunchAngleActive get="inline" set="null" line="491"><f a=""><x path="Bool"/></f></get_emitterLaunchAngleActive>
		<set_emitterLaunchAngleActive get="inline" set="null" line="492"><f a="launchAngleActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterLaunchAngleActive>
		<emitterLaunchAngleMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Launch Angle Min", group : "emitterLaunchAngle" }</e></m></meta>
			<haxe_doc>* The angle range at which particles will be launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</emitterLaunchAngleMin>
		<get_emitterLaunchAngleMin get="inline" set="null" line="500"><f a=""><x path="Float"/></f></get_emitterLaunchAngleMin>
		<set_emitterLaunchAngleMin get="inline" set="null" line="501"><f a="launchAngleMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterLaunchAngleMin>
		<emitterLaunchAngleMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Launch Angle Max", group : "emitterLaunchAngle" }</e></m></meta>
			<haxe_doc>* The angle range at which particles will be launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</emitterLaunchAngleMax>
		<get_emitterLaunchAngleMax get="inline" set="null" line="508"><f a=""><x path="Float"/></f></get_emitterLaunchAngleMax>
		<set_emitterLaunchAngleMax get="inline" set="null" line="509"><f a="launchAngleMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterLaunchAngleMax>
		<emitterLifespanActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Lifespan Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the life, or duration, range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterLifespanActive>
		<get_emitterLifespanActive get="inline" set="null" line="516"><f a=""><x path="Bool"/></f></get_emitterLifespanActive>
		<set_emitterLifespanActive get="inline" set="null" line="517"><f a="lifespanActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterLifespanActive>
		<emitterLifespanMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Lifespan Min", group : "emitterLifespan" }</e></m></meta>
			<haxe_doc>* The life, or duration, range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterLifespanMin>
		<get_emitterLifespanMin get="inline" set="null" line="524"><f a=""><x path="Float"/></f></get_emitterLifespanMin>
		<set_emitterLifespanMin get="inline" set="null" line="525"><f a="lifespanMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterLifespanMin>
		<emitterLifespanMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Lifespan Max", group : "emitterLifespan" }</e></m></meta>
			<haxe_doc>* The life, or duration, range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterLifespanMax>
		<get_emitterLifespanMax get="inline" set="null" line="531"><f a=""><x path="Float"/></f></get_emitterLifespanMax>
		<set_emitterLifespanMax get="inline" set="null" line="532"><f a="lifespanMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterLifespanMax>
		<emitterScaleActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Scale Active" }</e></m></meta>
			<haxe_doc>* Enable or disable `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleActive>
		<get_emitterScaleActive get="inline" set="null" line="539"><f a=""><x path="Bool"/></f></get_emitterScaleActive>
		<set_emitterScaleActive get="inline" set="null" line="540"><f a="scaleActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterScaleActive>
		<emitterScaleStartMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale Start Min X", group : "emitterScaleStartMin" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleStartMinX>
		<get_emitterScaleStartMinX get="inline" set="null" line="547"><f a=""><x path="Float"/></f></get_emitterScaleStartMinX>
		<set_emitterScaleStartMinX get="inline" set="null" line="548"><f a="scaleStartMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleStartMinX>
		<emitterScaleStartMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale Start Min Y", group : "emitterScaleStartMin" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleStartMinY>
		<get_emitterScaleStartMinY get="inline" set="null" line="554"><f a=""><x path="Float"/></f></get_emitterScaleStartMinY>
		<set_emitterScaleStartMinY get="inline" set="null" line="555"><f a="scaleStartMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleStartMinY>
		<emitterScaleStartMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale Start Max X", group : "emitterScaleStartMax" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleStartMaxX>
		<get_emitterScaleStartMaxX get="inline" set="null" line="561"><f a=""><x path="Float"/></f></get_emitterScaleStartMaxX>
		<set_emitterScaleStartMaxX get="inline" set="null" line="562"><f a="scaleStartMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleStartMaxX>
		<emitterScaleStartMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale Start Max Y", group : "emitterScaleStartMax" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleStartMaxY>
		<get_emitterScaleStartMaxY get="inline" set="null" line="568"><f a=""><x path="Float"/></f></get_emitterScaleStartMaxY>
		<set_emitterScaleStartMaxY get="inline" set="null" line="569"><f a="scaleStartMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleStartMaxY>
		<emitterScaleEndMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale End Min X", group : "emitterScaleEndMin" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleEndMinX>
		<get_emitterScaleEndMinX get="inline" set="null" line="575"><f a=""><x path="Float"/></f></get_emitterScaleEndMinX>
		<set_emitterScaleEndMinX get="inline" set="null" line="576"><f a="scaleEndMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleEndMinX>
		<emitterScaleEndMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale End Min Y", group : "emitterScaleEndMin" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleEndMinY>
		<get_emitterScaleEndMinY get="inline" set="null" line="582"><f a=""><x path="Float"/></f></get_emitterScaleEndMinY>
		<set_emitterScaleEndMinY get="inline" set="null" line="583"><f a="scaleEndMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleEndMinY>
		<emitterScaleEndMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale End Max X", group : "emitterScaleEndMax" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleEndMaxX>
		<get_emitterScaleEndMaxX get="inline" set="null" line="589"><f a=""><x path="Float"/></f></get_emitterScaleEndMaxX>
		<set_emitterScaleEndMaxX get="inline" set="null" line="590"><f a="scaleEndMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleEndMaxX>
		<emitterScaleEndMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Scale End Max Y", group : "emitterScaleEndMax" }</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleEndMaxY>
		<get_emitterScaleEndMaxY get="inline" set="null" line="596"><f a=""><x path="Float"/></f></get_emitterScaleEndMaxY>
		<set_emitterScaleEndMaxY get="inline" set="null" line="597"><f a="scaleEndMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterScaleEndMaxY>
		<emitterAlphaActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Alpha Active" }</e></m></meta>
			<haxe_doc>* Enable or disable `alpha` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaActive>
		<get_emitterAlphaActive get="inline" set="null" line="604"><f a=""><x path="Bool"/></f></get_emitterAlphaActive>
		<set_emitterAlphaActive get="inline" set="null" line="605"><f a="alphaActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterAlphaActive>
		<emitterAlphaStartMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Alpha Start Min", group : "emitterAlphaStart" }</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaStartMin>
		<get_emitterAlphaStartMin get="inline" set="null" line="612"><f a=""><x path="Float"/></f></get_emitterAlphaStartMin>
		<set_emitterAlphaStartMin get="inline" set="null" line="613"><f a="alphaStartMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAlphaStartMin>
		<emitterAlphaStartMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Alpha Start Max", group : "emitterAlphaStart" }</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaStartMax>
		<get_emitterAlphaStartMax get="inline" set="null" line="619"><f a=""><x path="Float"/></f></get_emitterAlphaStartMax>
		<set_emitterAlphaStartMax get="inline" set="null" line="620"><f a="alphaStartMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAlphaStartMax>
		<emitterAlphaEndMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Alpha End Min", group : "emitterAlphaEnd" }</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaEndMin>
		<get_emitterAlphaEndMin get="inline" set="null" line="627"><f a=""><x path="Float"/></f></get_emitterAlphaEndMin>
		<set_emitterAlphaEndMin get="inline" set="null" line="628"><f a="alphaEndMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAlphaEndMin>
		<emitterAlphaEndMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Alpha End Max", group : "emitterAlphaEnd" }</e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaEndMax>
		<get_emitterAlphaEndMax get="inline" set="null" line="634"><f a=""><x path="Float"/></f></get_emitterAlphaEndMax>
		<set_emitterAlphaEndMax get="inline" set="null" line="635"><f a="alphaEndMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAlphaEndMax>
		<emitterColorActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Color Active" }</e></m></meta>
			<haxe_doc>* Enable or disable `color` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorActive>
		<get_emitterColorActive get="inline" set="null" line="642"><f a=""><x path="Bool"/></f></get_emitterColorActive>
		<set_emitterColorActive get="inline" set="null" line="643"><f a="colorActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterColorActive>
		<emitterColorStartMin public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<meta><m n="editable"><e>{ label : "Color Start Min", group : "emitterColorStart" }</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorStartMin>
		<get_emitterColorStartMin get="inline" set="null" line="650"><f a=""><x path="ceramic.Color"/></f></get_emitterColorStartMin>
		<set_emitterColorStartMin get="inline" set="null" line="651"><f a="colorStartMin">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_emitterColorStartMin>
		<emitterColorStartMax public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<meta><m n="editable"><e>{ label : "Color Start Max", group : "emitterColorStart" }</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorStartMax>
		<get_emitterColorStartMax get="inline" set="null" line="657"><f a=""><x path="ceramic.Color"/></f></get_emitterColorStartMax>
		<set_emitterColorStartMax get="inline" set="null" line="658"><f a="colorStartMax">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_emitterColorStartMax>
		<emitterColorEndMin public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<meta><m n="editable"><e>{ label : "Color End Min", group : "emitterColorEnd" }</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorEndMin>
		<get_emitterColorEndMin get="inline" set="null" line="665"><f a=""><x path="ceramic.Color"/></f></get_emitterColorEndMin>
		<set_emitterColorEndMin get="inline" set="null" line="666"><f a="colorEndMin">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_emitterColorEndMin>
		<emitterColorEndMax public="1" get="accessor" set="accessor">
			<x path="ceramic.Color"/>
			<meta><m n="editable"><e>{ label : "Color End Max", group : "emitterColorEnd" }</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorEndMax>
		<get_emitterColorEndMax get="inline" set="null" line="672"><f a=""><x path="ceramic.Color"/></f></get_emitterColorEndMax>
		<set_emitterColorEndMax get="inline" set="null" line="673"><f a="colorEndMax">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_emitterColorEndMax>
		<emitterDragActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Drag Active" }</e></m></meta>
			<haxe_doc>* Enable or disable X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragActive>
		<get_emitterDragActive get="inline" set="null" line="680"><f a=""><x path="Bool"/></f></get_emitterDragActive>
		<set_emitterDragActive get="inline" set="null" line="681"><f a="dragActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterDragActive>
		<emitterDragStartMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag Start Min X", group : "emitterDragStartMin" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragStartMinX>
		<get_emitterDragStartMinX get="inline" set="null" line="688"><f a=""><x path="Float"/></f></get_emitterDragStartMinX>
		<set_emitterDragStartMinX get="inline" set="null" line="689"><f a="dragStartMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragStartMinX>
		<emitterDragStartMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag Start Min Y", group : "emitterDragStartMin" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragStartMinY>
		<get_emitterDragStartMinY get="inline" set="null" line="695"><f a=""><x path="Float"/></f></get_emitterDragStartMinY>
		<set_emitterDragStartMinY get="inline" set="null" line="696"><f a="dragStartMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragStartMinY>
		<emitterDragStartMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag Start Max X", group : "emitterDragStartMax" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragStartMaxX>
		<get_emitterDragStartMaxX get="inline" set="null" line="702"><f a=""><x path="Float"/></f></get_emitterDragStartMaxX>
		<set_emitterDragStartMaxX get="inline" set="null" line="703"><f a="dragStartMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragStartMaxX>
		<emitterDragStartMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag Start Max Y", group : "emitterDragStartMax" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragStartMaxY>
		<get_emitterDragStartMaxY get="inline" set="null" line="709"><f a=""><x path="Float"/></f></get_emitterDragStartMaxY>
		<set_emitterDragStartMaxY get="inline" set="null" line="710"><f a="dragStartMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragStartMaxY>
		<emitterDragEndMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag End Min X", group : "emitterDragEndMin" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragEndMinX>
		<get_emitterDragEndMinX get="inline" set="null" line="716"><f a=""><x path="Float"/></f></get_emitterDragEndMinX>
		<set_emitterDragEndMinX get="inline" set="null" line="717"><f a="dragEndMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragEndMinX>
		<emitterDragEndMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag End Min Y", group : "emitterDragEndMin" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragEndMinY>
		<get_emitterDragEndMinY get="inline" set="null" line="723"><f a=""><x path="Float"/></f></get_emitterDragEndMinY>
		<set_emitterDragEndMinY get="inline" set="null" line="724"><f a="dragEndMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragEndMinY>
		<emitterDragEndMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag End Max X", group : "emitterDragEndMax" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragEndMaxX>
		<get_emitterDragEndMaxX get="inline" set="null" line="730"><f a=""><x path="Float"/></f></get_emitterDragEndMaxX>
		<set_emitterDragEndMaxX get="inline" set="null" line="731"><f a="dragEndMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragEndMaxX>
		<emitterDragEndMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Drag End Max Y", group : "emitterDragEndMax" }</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragEndMaxY>
		<get_emitterDragEndMaxY get="inline" set="null" line="737"><f a=""><x path="Float"/></f></get_emitterDragEndMaxY>
		<set_emitterDragEndMaxY get="inline" set="null" line="738"><f a="dragEndMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterDragEndMaxY>
		<emitterAccelerationActive public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n="editable"><e>{ label : "Accel. Active" }</e></m></meta>
			<haxe_doc>* Enable or disable the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationActive>
		<get_emitterAccelerationActive get="inline" set="null" line="746"><f a=""><x path="Bool"/></f></get_emitterAccelerationActive>
		<set_emitterAccelerationActive get="inline" set="null" line="747"><f a="accelerationActive">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_emitterAccelerationActive>
		<emitterAccelerationStartMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. Start Min X", group : "emitterAccelerationStartMin" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationStartMinX>
		<get_emitterAccelerationStartMinX get="inline" set="null" line="755"><f a=""><x path="Float"/></f></get_emitterAccelerationStartMinX>
		<set_emitterAccelerationStartMinX get="inline" set="null" line="756"><f a="accelerationStartMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationStartMinX>
		<emitterAccelerationStartMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. Start Min Y", group : "emitterAccelerationStartMin" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationStartMinY>
		<get_emitterAccelerationStartMinY get="inline" set="null" line="763"><f a=""><x path="Float"/></f></get_emitterAccelerationStartMinY>
		<set_emitterAccelerationStartMinY get="inline" set="null" line="764"><f a="accelerationStartMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationStartMinY>
		<emitterAccelerationStartMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. Start Max X", group : "emitterAccelerationStartMax" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationStartMaxX>
		<get_emitterAccelerationStartMaxX get="inline" set="null" line="771"><f a=""><x path="Float"/></f></get_emitterAccelerationStartMaxX>
		<set_emitterAccelerationStartMaxX get="inline" set="null" line="772"><f a="accelerationStartMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationStartMaxX>
		<emitterAccelerationStartMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. Start Max Y", group : "emitterAccelerationStartMax" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationStartMaxY>
		<get_emitterAccelerationStartMaxY get="inline" set="null" line="779"><f a=""><x path="Float"/></f></get_emitterAccelerationStartMaxY>
		<set_emitterAccelerationStartMaxY get="inline" set="null" line="780"><f a="accelerationStartMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationStartMaxY>
		<emitterAccelerationEndMinX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. End Min X", group : "emitterAccelerationEndMin" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationEndMinX>
		<get_emitterAccelerationEndMinX get="inline" set="null" line="787"><f a=""><x path="Float"/></f></get_emitterAccelerationEndMinX>
		<set_emitterAccelerationEndMinX get="inline" set="null" line="788"><f a="accelerationEndMinX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationEndMinX>
		<emitterAccelerationEndMinY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. End Min Y", group : "emitterAccelerationEndMin" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationEndMinY>
		<get_emitterAccelerationEndMinY get="inline" set="null" line="795"><f a=""><x path="Float"/></f></get_emitterAccelerationEndMinY>
		<set_emitterAccelerationEndMinY get="inline" set="null" line="796"><f a="accelerationEndMinY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationEndMinY>
		<emitterAccelerationEndMaxX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. End Max X", group : "emitterAccelerationEndMax" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationEndMaxX>
		<get_emitterAccelerationEndMaxX get="inline" set="null" line="803"><f a=""><x path="Float"/></f></get_emitterAccelerationEndMaxX>
		<set_emitterAccelerationEndMaxX get="inline" set="null" line="804"><f a="accelerationEndMaxX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationEndMaxX>
		<emitterAccelerationEndMaxY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="editable"><e>{ label : "Accel. End Max Y", group : "emitterAccelerationEndMax" }</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Set acceleration y-values to give particles gravity.</haxe_doc>
		</emitterAccelerationEndMaxY>
		<get_emitterAccelerationEndMaxY get="inline" set="null" line="811"><f a=""><x path="Float"/></f></get_emitterAccelerationEndMaxY>
		<set_emitterAccelerationEndMaxY get="inline" set="null" line="812"><f a="accelerationEndMaxY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_emitterAccelerationEndMaxY>
		<emitterSize public="1" get="inline" set="null" line="820">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The width and height of the emission area.
     * If not defined (`-1`), will use visual's width and height bound to this `ParticleEmitter` object, if any</haxe_doc>
		</emitterSize>
		<emitterPos public="1" get="inline" set="null" line="827">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The x and y position of the emission, relative to particles parent (if any)</haxe_doc>
		</emitterPos>
		<emitterMaxVelocity public="1" get="inline" set="null" line="835">
			<f a="maxVelocityX:maxVelocityY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
     * to cap the speed automatically (very useful!).</haxe_doc>
		</emitterMaxVelocity>
		<emitterVelocityStart public="1" get="inline" set="null" line="842">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the velocity starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityStart>
		<emitterVelocityEnd public="1" get="inline" set="null" line="849">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the velocity ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `SQUARE`.</haxe_doc>
		</emitterVelocityEnd>
		<emitterSpeedStart public="1" get="inline" set="null" line="856">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the speed starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `CIRCLE`.</haxe_doc>
		</emitterSpeedStart>
		<emitterSpeedEnd public="1" get="inline" set="null" line="863">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the speed ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end. Only used with `CIRCLE`.</haxe_doc>
		</emitterSpeedEnd>
		<emitterAngularAcceleration public="1" get="inline" set="null" line="870">
			<f a="startMin:startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the angular acceleration range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularAcceleration>
		<emitterAngularDrag public="1" get="inline" set="null" line="877">
			<f a="startMin:startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the angular drag range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularDrag>
		<emitterAngularVelocityStart public="1" get="inline" set="null" line="884">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angular velocity starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityStart>
		<emitterAngularVelocityEnd public="1" get="inline" set="null" line="891">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angular velocity ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAngularVelocityEnd>
		<emitterAngleStart public="1" get="inline" set="null" line="899">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angle starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleStart>
		<emitterAngleEnd public="1" get="inline" set="null" line="907">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angle ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * `angleEndMin` and `angleEndMax` are ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</emitterAngleEnd>
		<emitterLaunchAngle public="1" get="inline" set="null" line="915">
			<f a="min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The angle range at which particles will be launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.
     * Ignored unless `launchMode` is set to `CIRCLE`.</haxe_doc>
		</emitterLaunchAngle>
		<emitterLifespan public="1" get="inline" set="null" line="922">
			<f a="min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The life, or duration, range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterLifespan>
		<emitterScaleStart public="1" get="inline" set="null" line="929">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `scale` starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleStart>
		<emitterScaleEnd public="1" get="inline" set="null" line="936">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `scale` ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterScaleEnd>
		<emitterAccelerationStart public="1" get="inline" set="null" line="943">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `acceleration` starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAccelerationStart>
		<emitterAccelerationEnd public="1" get="inline" set="null" line="950">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `acceleration` ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAccelerationEnd>
		<emitterDragStart public="1" get="inline" set="null" line="957">
			<f a="startMinX:startMinY:?startMaxX:?startMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `drag` starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterDragStart>
		<emitterdragEnd public="1" get="inline" set="null" line="964">
			<f a="endMinX:endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `drag` ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterdragEnd>
		<emitterColorStart public="1" get="inline" set="null" line="971">
			<f a="startMin:?startMax">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `color` starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorStart>
		<emitterColorEnd public="1" get="inline" set="null" line="978">
			<f a="endMin:?endMax">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `color` ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterColorEnd>
		<emitterAlphaStart public="1" get="inline" set="null" line="985">
			<f a="startMin:?startMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `alpha` starting range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaStart>
		<emitterAlphaEnd public="1" get="inline" set="null" line="992">
			<f a="endMin:?endMax">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `alpha` ending range of particles launched from this #if cs (cast emitter:ParticleEmitter) #else emitter #end.</haxe_doc>
		</emitterAlphaEnd>
		<new public="1" set="method" line="15"><f a="?emitter">
	<c path="ceramic.Particles.T"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n="editable"/>
		</meta>
	</class>
	<enum path="ceramic.ParticlesLaunchMode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ParticlesLaunchMode.hx">
		<CIRCLE><haxe_doc>* Particles will use `launchAngle` and `speed` to be launched</haxe_doc></CIRCLE>
		<SQUARE><haxe_doc>* Particles will use `velocityX` and `velocityY` to be launched</haxe_doc></SQUARE>
		<haxe_doc>* How particles should be launched. If `CIRCLE`, particles will use `launchAngle` and `speed`.
 * Otherwise, particles will just use `velocityX` and `velocityY`.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="ceramic.ParticlesStatus" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ParticlesStatus.hx">
		<IDLE><haxe_doc>* Not emitting particles, and no particle is visible.</haxe_doc></IDLE>
		<EMITTING><haxe_doc>* Emitting particles.</haxe_doc></EMITTING>
		<SPREADING><haxe_doc>* Not emitting particles, but previously emitted particles are still spreading</haxe_doc></SPREADING>
		<haxe_doc>* Which status a `Particles` emitter object has.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.Path" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Path.hx">
		<withoutExtension public="1" set="method" line="126" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the file extension.

        If `path` is null, the result is unspecified.</haxe_doc>
		</withoutExtension>
		<withoutDirectory public="1" set="method" line="137" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the directory.

        If `path` is null, the result is unspecified.</haxe_doc>
		</withoutDirectory>
		<directory public="1" set="method" line="150" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

        If the directory is null, the empty String `""` is returned.

        If `path` is null, the result is unspecified.</haxe_doc>
		</directory>
		<extension public="1" set="method" line="164" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the extension of `path`.

        If the extension is null, the empty String `""` is returned.

        If `path` is null, the result is unspecified.</haxe_doc>
		</extension>
		<withExtension public="1" set="method" line="178" static="1">
			<f a="path:ext">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String representation of `path` where the extension is `ext`.

        If `path` has no extension, `ext` is added as extension.

        If `path` or `ext` are null, the result is unspecified.</haxe_doc>
		</withExtension>
		<join public="1" set="method" line="192" static="1">
			<f a="paths">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all paths in `paths` together.

        If `paths` is empty, the empty String `""` is returned. Otherwise the
        paths are joined with a slash between them.

        If `paths` is null, the result is unspecified.</haxe_doc>
		</join>
		<normalize public="1" set="method" line="213" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Normalize a given `path` (e.g. make '/usr/local/../lib' to '/usr/lib').

        Also replaces backslashes \ with slashes / and afterwards turns
        multiple slashes into a single one.

        If `path` is null, the result is unspecified.</haxe_doc>
		</normalize>
		<addTrailingSlash public="1" set="method" line="270" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

        If the last slash in `path` is a backslash, a backslash is appended to
        `path`.

        If the last slash in `path` is a slash, or if no slash is found, a slash
        is appended to `path`. In particular, this applies to the empty String
        `""`.

        If `path` is null, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<removeTrailingSlashes public="1" set="method" line="295" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":require"><e><![CDATA[haxe_ver >= 3.1]]></e></m></meta>
			<haxe_doc>Removes trailing slashes from `path`.

        If `path` does not end with a `/` or `\`, `path` is returned unchanged.

        Otherwise the substring of `path` excluding the trailing slashes or
        backslashes is returned.

        If `path` is null, the result is unspecified.</haxe_doc>
		</removeTrailingSlashes>
		<isAbsolute public="1" set="method" line="308" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the path is an absolute path, and false otherwise.</haxe_doc>
		</isAbsolute>
		<dir public="1">
			<c path="String"/>
			<haxe_doc>The directory.

        This is the leading part of the path that is not part of the file name
        and the extension.

        Does not end with a `/` or `\` separator.

        If the path has no directory, the value is null.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

        This is the part of the part between the directory and the extension.

        If there is no file name, e.g. for ".htaccess" or "/dir/", the value
        is the empty String "".</haxe_doc>
		</file>
		<ext public="1">
			<c path="String"/>
			<haxe_doc>The file extension.

        It is separated from the file name by a dot. This dot is not part of
        the extension.

        If the path has no extension, the value is null.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>True if the last directory separator is a backslash, false otherwise.</haxe_doc>
		</backslash>
		<toString public="1" set="method" line="117">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of `this` path.

        If `this.backslash` is true, backslash is used as directory separator,
        otherwise slash is used. This only affects the separator between
        `this.dir` and `this.file`.

        If `this.directory` or `this.extension` is null, their representation
        is the empty String "".</haxe_doc>
		</toString>
		<new public="1" set="method" line="79">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Path instance by parsing `path`.

        Path information can be retrieved by accessing the dir, file and ext
        properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
    common path formats:

    - directory1/directory2/filename.extension
    - directory1\directory2\filename.extension</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.PersistentData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/PersistentData.hx">
		<internalData><x path="haxe.DynamicAccess"><d/></x></internalData>
		<id public="1" set="null"><c path="String"/></id>
		<get public="1" get="inline" set="null" line="30"><f a="key">
	<c path="String"/>
	<d/>
</f></get>
		<set public="1" get="inline" set="null" line="36"><f a="key:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></set>
		<remove public="1" get="inline" set="null" line="42"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></remove>
		<clear public="1" get="inline" set="null" line="48"><f a=""><x path="Void"/></f></clear>
		<exists public="1" get="inline" set="null" line="56"><f a="key">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<keys public="1" get="inline" set="null" line="62"><f a=""><c path="Array"><c path="String"/></c></f></keys>
		<save public="1" set="method" line="68"><f a=""><x path="Void"/></f></save>
		<new public="1" set="method" line="12"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.PixelArt" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/PixelArt.hx">
		<extends path="ceramic.Filter"/>
		<sharpness public="1" set="accessor" expr="8.0" line="14">
			<x path="Float"/>
			<meta><m n=":value"><e>8.0</e></m></meta>
			<haxe_doc>* Sharpness of the pixels (from 1.0 to above)</haxe_doc>
		</sharpness>
		<set_sharpness set="method" line="15"><f a="sharpness">
	<x path="Float"/>
	<x path="Float"/>
</f></set_sharpness>
		<gridThickness public="1" set="accessor" expr="0.0" line="27">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
			<haxe_doc>* If set above 0.0, a grid will be displayed.
     * Can be used to simulate GBA-style LCD displays.</haxe_doc>
		</gridThickness>
		<set_gridThickness set="method" line="28"><f a="gridThickness">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gridThickness>
		<gridColor public="1" set="accessor" expr="Color.BLACK" line="39">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.BLACK</e></m></meta>
			<haxe_doc>* When using a grid, this is the color of the grid</haxe_doc>
		</gridColor>
		<set_gridColor set="method" line="40"><f a="gridColor">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_gridColor>
		<gridAlpha public="1" set="accessor" expr="0.0" line="51">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
			<haxe_doc>* When using a grid, this is the alpha of the grid</haxe_doc>
		</gridAlpha>
		<set_gridAlpha set="method" line="52"><f a="gridAlpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gridAlpha>
		<set_density set="method" line="60" override="1"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<handleResize set="method" line="83"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></handleResize>
		<updateResolution set="method" line="89"><f a=""><x path="Void"/></f></updateResolution>
		<destroy public="1" set="method" line="100" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="67"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A filter configured to display pixel art content.
 * Uses a shader to get a nicer rendering of upscaled pixel art.
 * Better than NEAREST or LINEAR texture filtering.
 * (see https://colececil.io/blog/2017/scaling-pixel-art-without-destroying-it/)</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Pixels" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Pixels.hx">
		<copy public="1" set="method" line="36" static="1">
			<f a="srcBuffer:srcBufferWidth:dstBuffer:dstBufferWidth:srcX:srcY:srcWidth:srcHeight:dstX:dstY:?copyRed:?copyGreen:?copyBlue:?copyAlpha" v="::::::::::true:true:true:true">
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ copyAlpha : true, copyBlue : true, copyGreen : true, copyRed : true }</e></m></meta>
			<haxe_doc>* Copy pixels from `srcBuffer` to `dstBuffer`
     * @param srcBuffer Source buffer to copy pixels from
     * @param srcBufferWidth Source buffer image width (needed to know index from x,y coordinates)
     * @param dstBuffer Destination buffer to past pixels into
     * @param dstBufferWidth Destination buffer image width (needed to know index from x,y coordinates)
     * @param srcX Source x position to copy from
     * @param srcY Source y position to copy from
     * @param srcWidth Source width to copy from
     * @param srcHeight Source height to copy from
     * @param dstX Destination x to paste into
     * @param dstY Destination y to paste into
     * @param copyRed Set to `true` default to copy red channel
     * @param copyGreen Set to `true` default to copy green channel
     * @param copyBlue Set to `true` default to copy blue channel
     * @param copyAlpha Set to `true` default to copy alpha channel</haxe_doc>
		</copy>
		<create public="1" set="method" line="99" static="1">
			<f a="width:height:fillColor">
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
				<t path="ceramic.UInt8Array"/>
			</f>
			<haxe_doc>* Create a pixels buffer
     * @param width Image width
     * @param height Image height
     * @param fillColor Default color
     * @return UInt8Array</haxe_doc>
		</create>
		<fromBytes public="1" set="method" line="119" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<t path="ceramic.UInt8Array"/>
			</f>
			<haxe_doc>* Create a pixels buffer from bytes with RGBA representation</haxe_doc>
		</fromBytes>
		<get public="1" get="inline" set="null" line="140" static="1">
			<f a="buffer:bufferWidth:x:y">
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
			</f>
			<haxe_doc>* Get a pixel as `AlphaColor` at `x`,`y` coordinates on the given buffer
     * @param buffer The pixel buffer to read from
     * @param bufferWidth Image width
     * @param x Pixel x position
     * @param y Pixel y position
     * @return AlphaColor</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="160" static="1">
			<f a="buffer:bufferWidth:x:y:color">
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set a pixel as `AlphaColor` at `x`,`y` coordinates on the given buffer
     * @param buffer The pixel buffer to write into
     * @param bufferWidth Image width
     * @param x Pixel x position
     * @param y Pixel y position
     * @param color AlphaColor of the pixel</haxe_doc>
		</set>
		<setRectangle public="1" get="inline" set="null" line="183" static="1">
			<f a="buffer:bufferWidth:x:y:width:height:color">
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.AlphaColor"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set a rectangle of pixels as `AlphaColor` at `x`,`y` coordinates and with the specified `width` and `height` on the given buffer
     * @param buffer The pixel buffer to write into
     * @param bufferWidth Image width
     * @param x Rectangle x position
     * @param y Rectangle y position
     * @param width Rectangle width
     * @param height Rectangle height
     * @param color AlphaColor of the rectangle's pixels</haxe_doc>
		</setRectangle>
		<pixelsToPng public="1" get="inline" set="null" line="199" static="1">
			<f a="width:height:pixels:path:done">
				<x path="Int"/>
				<x path="Int"/>
				<t path="ceramic.UInt8Array"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Export the given pixels pixels as PNG data and save it to the given file path
     * @param width Image width
     * @param height Image height
     * @param pixels The pixels buffer
     * @param path The png file path where to save the image (`'/path/to/image.png'`)
     * @param done Called when the png has been exported</haxe_doc>
			<overloads><pixelsToPng public="1" get="inline" set="null" line="213">
	<f a="width:height:pixels:done">
		<x path="Int"/>
		<x path="Int"/>
		<t path="ceramic.UInt8Array"/>
		<f a="data">
			<c path="haxe.io.Bytes"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<haxe_doc><![CDATA[* Export the given pixels to PNG data/bytes
     * @param width Image width
     * @param height Image height
     * @param pixels The pixels buffer
     * @param done Called when the png has been exported, with `data` containing PNG bytes
     * @return ->Void):Void]]></haxe_doc>
</pixelsToPng></overloads>
		</pixelsToPng>
		<_pixelsToPng set="method" line="219" static="1"><f a="width:height:pixels:?path:done">
	<x path="Int"/>
	<x path="Int"/>
	<t path="ceramic.UInt8Array"/>
	<c path="String"/>
	<f a="?data">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></_pixelsToPng>
		<rgbaPixelsToRgbPixels public="1" set="method" line="233" static="1">
			<f a="width:height:inPixels:?outPixels">
				<x path="Int"/>
				<x path="Int"/>
				<t path="ceramic.UInt8Array"/>
				<x path="Null"><t path="ceramic.UInt8Array"/></x>
				<t path="ceramic.UInt8Array"/>
			</f>
			<haxe_doc>* Converts a RGBA pixels buffer into RGB pixels buffer
     * @param width Image width
     * @param height Image height
     * @param inPixels The source RGBA pixels buffer
     * @param outPixels (optional) The destination RGB pixels buffer
     * @return The final RGB pixels buffer</haxe_doc>
		</rgbaPixelsToRgbPixels>
		<rgbPixelsToRgbaPixels public="1" set="method" line="268" static="1">
			<f a="width:height:?alpha:inPixels:?outPixels" v="::255::">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="ceramic.UInt8Array"/>
				<x path="Null"><t path="ceramic.UInt8Array"/></x>
				<t path="ceramic.UInt8Array"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 255 }</e></m></meta>
			<haxe_doc>* Converts a RGB pixels buffer into RGBA pixels buffer
     * @param width Image width
     * @param height Image height
     * @param alpha Alpha value (0-255) to use (default to 255)
     * @param inPixels The source RGBA pixels buffer
     * @param outPixels (optional) The destination RGB pixels buffer
     * @return The final RGBA pixels buffer</haxe_doc>
		</rgbPixelsToRgbaPixels>
		<mixPixelsBuffers public="1" set="method" line="303" static="1">
			<f a="inPixelsList:?middleFactor:?outPixels" v=":1:">
				<c path="Array"><t path="ceramic.UInt8Array"/></c>
				<x path="Float"/>
				<x path="Null"><t path="ceramic.UInt8Array"/></x>
				<t path="ceramic.UInt8Array"/>
			</f>
			<meta><m n=":value"><e>{ middleFactor : 1 }</e></m></meta>
			<haxe_doc>* Mix the given list of pixels buffers into a single one.
     * @param inPixelsList An array of pixels buffers
     * @param middleFactor A multiplicator that makes the middle buffers more important than the rest if above 1
     * @param outPixels (optional) The destination pixels buffer
     * @return The final mixed pixels buffer</haxe_doc>
		</mixPixelsBuffers>
		<flipY public="1" set="method" line="351" static="1">
			<f a="buffer:bufferWidth">
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Flip the given pixels buffer on the Y axis
     * @param buffer The pixel buffer to read from and write to
     * @param bufferWidth Image width</haxe_doc>
		</flipY>
		<flipX public="1" set="method" line="388" static="1">
			<f a="buffer:bufferWidth">
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Flip the given pixels buffer on the X axis
     * @param buffer The pixel buffer to read from and write to
     * @param bufferWidth Image width</haxe_doc>
		</flipX>
		<haxe_doc>* Utilities to manipulate RGBA pixels.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.PlatformSpecific" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/PlatformSpecific.hx">
		<postAppInit public="1" set="method" line="25" static="1"><f a=""><x path="Void"/></f></postAppInit>
		<readStringFromAsset public="1" set="method" line="41" static="1">
			<f a="assetPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Read a string from an asset file, synchronously.
     * Warning: not available on every targets
     * @return String</haxe_doc>
		</readStringFromAsset>
		<readBytesFromAsset public="1" set="method" line="90" static="1">
			<f a="assetPath">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Read bytes from an asset file, synchronously.
     * Warning: not available on every targets
     * @return String</haxe_doc>
		</readBytesFromAsset>
		<getAssetsPath public="1" set="method" line="139" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns assets paths on disk (if any)
     * Warning: not available on every targets
     * @return String</haxe_doc>
		</getAssetsPath>
		<getRtti public="1" params="T" set="method" line="177" static="1"><f a="c">
	<x path="Class"><c path="getRtti.T"/></x>
	<t path="haxe.rtti.Classdef"/>
</f></getRtti>
		<quit public="1" set="method" line="264" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</quit>
		<haxe_doc>* An internal class that encapsulate platform-specific code.
 * We usually want platform-specific code to be located in a backend,
 * but it may happen that sometimes creating a backend interface is overkill.
 * That's where this comes handy.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.PremultiplyAlpha" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/PremultiplyAlpha.hx">
		<premultiplyAlpha public="1" set="method" line="5" static="1"><f a="pixels">
	<t path="ceramic.UInt8Array"/>
	<x path="Void"/>
</f></premultiplyAlpha>
		<reversePremultiplyAlpha public="1" set="method" line="27" static="1"><f a="pixels">
	<t path="ceramic.UInt8Array"/>
	<x path="Void"/>
</f></reversePremultiplyAlpha>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="ceramic.ReadOnlyArray" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="ceramic.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
 APIs that don't modify the instance, hence "read-only".
 
 Note that this doesn't necessarily mean that the instance is *immutable*.
 Other code holding a reference to the underlying `Array` can still modify it,
 and the reference can be obtained with a `cast`.</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":forward">
				<e>get</e>
				<e>concat</e>
				<e>copy</e>
				<e>filter</e>
				<e>indexOf</e>
				<e>iterator</e>
				<e>keyValueIterator</e>
				<e>join</e>
				<e>lastIndexOf</e>
				<e>map</e>
				<e>slice</e>
				<e>contains</e>
				<e>toString</e>
			</m>
		</meta>
		<impl><class path="ceramic._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyArray.hx" private="1" module="ceramic.ReadOnlyArray" final="1">
	<arrayAccess public="1" get="inline" set="null" line="38" static="1">
		<f a="this:key">
			<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
			<x path="Int"/>
			<c path="ceramic.ReadOnlyArray.T"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</arrayAccess>
	<original public="1" get="accessor" set="null" static="1">
		<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
		<haxe_doc>* Returns the underlying (and mutable) data. Use at your own risk!</haxe_doc>
	</original>
	<get_original get="inline" set="null" line="44" static="1"><f a="this">
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
</f></get_original>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>The length of `this` Array.</haxe_doc>
	</length>
	<get_length get="inline" set="null" line="51" static="1"><f a="this">
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
	<x path="Int"/>
</f></get_length>
	<unsafeGet public="1" get="inline" set="null" line="55" static="1"><f a="this:index">
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
	<x path="Int"/>
	<c path="ceramic.ReadOnlyArray.T"/>
</f></unsafeGet>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyArray.hx" private="1" module="ceramic.ReadOnlyArray" final="1">
		<arrayAccess public="1" get="inline" set="null" line="38" static="1">
			<f a="this:key">
				<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
				<x path="Int"/>
				<c path="ceramic.ReadOnlyArray.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</arrayAccess>
		<original public="1" get="accessor" set="null" static="1">
			<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
			<haxe_doc>* Returns the underlying (and mutable) data. Use at your own risk!</haxe_doc>
		</original>
		<get_original get="inline" set="null" line="44" static="1"><f a="this">
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
</f></get_original>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="51" static="1"><f a="this">
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
	<x path="Int"/>
</f></get_length>
		<unsafeGet public="1" get="inline" set="null" line="55" static="1"><f a="this:index">
	<c path="Array"><c path="ceramic.ReadOnlyArray.T"/></c>
	<x path="Int"/>
	<c path="ceramic.ReadOnlyArray.T"/>
</f></unsafeGet>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="ceramic.ReadOnlyMap" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyMap.hx">
		<from><icast><t path="Map">
	<c path="ceramic.ReadOnlyMap.K"/>
	<c path="ceramic.ReadOnlyMap.V"/>
</t></icast></from>
		<this><t path="Map">
	<c path="ceramic.ReadOnlyMap.K"/>
	<c path="ceramic.ReadOnlyMap.V"/>
</t></this>
		<to><icast><t path="Map">
	<c path="ceramic.ReadOnlyMap.K"/>
	<c path="ceramic.ReadOnlyMap.V"/>
</t></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":forward">
				<e>get</e>
				<e>exists</e>
				<e>keys</e>
				<e>toString</e>
			</m>
		</meta>
		<impl><class path="ceramic._ReadOnlyMap.ReadOnlyMap_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyMap.hx" private="1" module="ceramic.ReadOnlyMap" final="1">
	<arrayAccess public="1" get="inline" set="null" line="6" static="1">
		<f a="this:key">
			<t path="Map">
				<c path="ceramic.ReadOnlyMap.K"/>
				<c path="ceramic.ReadOnlyMap.V"/>
			</t>
			<c path="ceramic.ReadOnlyMap.K"/>
			<c path="ceramic.ReadOnlyMap.V"/>
		</f>
		<meta>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</arrayAccess>
	<original public="1" get="accessor" set="null" static="1">
		<t path="Map">
			<c path="ceramic.ReadOnlyMap.K"/>
			<c path="ceramic.ReadOnlyMap.V"/>
		</t>
		<haxe_doc>* Returns the underlying (and mutable) data. Use at your own risk!</haxe_doc>
	</original>
	<get_original get="inline" set="null" line="12" static="1"><f a="this">
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
</f></get_original>
	<iterator public="1" get="inline" set="null" line="15" static="1"><f a="this">
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
	<t path="Iterator"><c path="ceramic.ReadOnlyMap.V"/></t>
</f></iterator>
	<keyValueIterator public="1" get="inline" set="null" line="18" static="1"><f a="this">
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
	<t path="KeyValueIterator">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
</f></keyValueIterator>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._ReadOnlyMap.ReadOnlyMap_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyMap.hx" private="1" module="ceramic.ReadOnlyMap" final="1">
		<arrayAccess public="1" get="inline" set="null" line="6" static="1">
			<f a="this:key">
				<t path="Map">
					<c path="ceramic.ReadOnlyMap.K"/>
					<c path="ceramic.ReadOnlyMap.V"/>
				</t>
				<c path="ceramic.ReadOnlyMap.K"/>
				<c path="ceramic.ReadOnlyMap.V"/>
			</f>
			<meta>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</arrayAccess>
		<original public="1" get="accessor" set="null" static="1">
			<t path="Map">
				<c path="ceramic.ReadOnlyMap.K"/>
				<c path="ceramic.ReadOnlyMap.V"/>
			</t>
			<haxe_doc>* Returns the underlying (and mutable) data. Use at your own risk!</haxe_doc>
		</original>
		<get_original get="inline" set="null" line="12" static="1"><f a="this">
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
</f></get_original>
		<iterator public="1" get="inline" set="null" line="15" static="1"><f a="this">
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
	<t path="Iterator"><c path="ceramic.ReadOnlyMap.V"/></t>
</f></iterator>
		<keyValueIterator public="1" get="inline" set="null" line="18" static="1"><f a="this">
	<t path="Map">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
	<t path="KeyValueIterator">
		<c path="ceramic.ReadOnlyMap.K"/>
		<c path="ceramic.ReadOnlyMap.V"/>
	</t>
</f></keyValueIterator>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="ceramic.ReadOnlyPoint" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyPoint.hx">
		<from><icast><c path="ceramic.Point"/></icast></from>
		<this><c path="ceramic.Point"/></this>
		<meta>
			<m n=":hxGen"/>
			<m n=":structInit"/>
			<m n=":allow"><e>ceramic.Screen</e></m>
		</meta>
		<impl><class path="ceramic._ReadOnlyPoint.ReadOnlyPoint_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyPoint.hx" private="1" module="ceramic.ReadOnlyPoint" final="1">
	<x public="1" get="accessor" set="null" static="1"><x path="Float"/></x>
	<get_x get="inline" set="null" line="8" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<x path="Float"/>
</f></get_x>
	<y public="1" get="accessor" set="null" static="1"><x path="Float"/></y>
	<get_y get="inline" set="null" line="11" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<x path="Float"/>
</f></get_y>
	<z public="1" get="accessor" set="null" static="1"><x path="Float"/></z>
	<get_z get="inline" set="null" line="14" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<x path="Float"/>
</f></get_z>
	<toPoint public="1" get="inline" set="null" line="16" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<c path="ceramic.Point"/>
</f></toPoint>
	<toString set="method" line="20" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<c path="String"/>
</f></toString>
	<meta>
		<m n=":hxGen"/>
		<m n=":allow"><e>ceramic.Screen</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._ReadOnlyPoint.ReadOnlyPoint_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReadOnlyPoint.hx" private="1" module="ceramic.ReadOnlyPoint" final="1">
		<x public="1" get="accessor" set="null" static="1"><x path="Float"/></x>
		<get_x get="inline" set="null" line="8" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<x path="Float"/>
</f></get_x>
		<y public="1" get="accessor" set="null" static="1"><x path="Float"/></y>
		<get_y get="inline" set="null" line="11" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<x path="Float"/>
</f></get_y>
		<z public="1" get="accessor" set="null" static="1"><x path="Float"/></z>
		<get_z get="inline" set="null" line="14" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<x path="Float"/>
</f></get_z>
		<toPoint public="1" get="inline" set="null" line="16" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<c path="ceramic.Point"/>
</f></toPoint>
		<toString set="method" line="20" static="1"><f a="this">
	<c path="ceramic.Point"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.Screen</e></m>
		</meta>
	</class>
	<class path="ceramic.Rect" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Rect.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<toString set="method" line="14"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="20">
			<f a="?x:?y:?width:?height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="ceramic.RenderPrimitiveType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/RenderPrimitiveType.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._RenderPrimitiveType.RenderPrimitiveType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/RenderPrimitiveType.hx" private="1" module="ceramic.RenderPrimitiveType" extern="1" final="1">
	<TRIANGLE public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="ceramic.RenderPrimitiveType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TRIANGLE>
	<LINE public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
		<x path="ceramic.RenderPrimitiveType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LINE>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._RenderPrimitiveType.RenderPrimitiveType_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/RenderPrimitiveType.hx" private="1" module="ceramic.RenderPrimitiveType" extern="1" final="1">
		<TRIANGLE public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="ceramic.RenderPrimitiveType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TRIANGLE>
		<LINE public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
			<x path="ceramic.RenderPrimitiveType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LINE>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="ceramic.Texture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Texture.hx">
		<extends path="ceramic.Entity"/>
		<_nextIndex expr="1" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</_nextIndex>
		<fromPixels public="1" set="method" line="140" static="1">
			<f a="width:height:pixels:?density" v=":::1">
				<x path="Float"/>
				<x path="Float"/>
				<t path="ceramic.UInt8Array"/>
				<x path="Float"/>
				<c path="ceramic.Texture"/>
			</f>
			<meta><m n=":value"><e>{ density : 1 }</e></m></meta>
			<haxe_doc>* Create a new texture from the given pixels buffer
     * @param width Width of the texture
     * @param height Height of the texture
     * @param pixels A pixel buffer in integer RGBA format
     * @param density (optional) density of the texture
     * @return Texture</haxe_doc>
		</fromPixels>
		<fromBytes public="1" set="method" line="155" static="1">
			<f a="bytes:?density:?options:done" v=":1::">
				<c path="haxe.io.Bytes"/>
				<x path="Float"/>
				<x path="Null"><t path="backend.LoadTextureOptions"/></x>
				<f a="texture">
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ density : 1 }</e></m></meta>
			<haxe_doc>* Create a new texture from the given bytes.
     * The bytes must be PNG or JPEG data
     * @param bytes The PNG or JPEG data as bytes
     * @param density (optional) Density of the texture
     * @param options (optional) Additional options when loading texture (could depend on backend)
     * @param done A callback receiving the loaded texture, or `null` if it failed</haxe_doc>
		</fromBytes>
		<index public="1" expr="_nextIndex++" line="21">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>_nextIndex++</e></m>
				<m n=":noCompletion"/>
			</meta>
		</index>
		<isRenderTexture public="1" set="null" expr="false" line="23">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isRenderTexture>
		<asRenderTexture public="1" set="null" expr="null" line="25">
			<c path="ceramic.RenderTexture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</asRenderTexture>
		<textureId public="1" get="accessor" set="null">
			<t path="backend.TextureId"/>
			<haxe_doc>* The texture ID used by the underlying backend (OpenGL etc...)</haxe_doc>
		</textureId>
		<get_textureId get="inline" set="null" line="33"><f a=""><t path="backend.TextureId"/></f></get_textureId>
		<nativeWidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The native width of the texture, not depending on texture density</haxe_doc>
		</nativeWidth>
		<get_nativeWidth get="inline" set="null" line="41"><f a=""><x path="Int"/></f></get_nativeWidth>
		<nativeHeight public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The native height of the texture, not depending on texture density</haxe_doc>
		</nativeHeight>
		<get_nativeHeight get="inline" set="null" line="49"><f a=""><x path="Int"/></f></get_nativeHeight>
		<nativeWidthActual public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The native actual width of the texture.
     * Same as native width unless underlying backend needs pot (power of two) sizes.</haxe_doc>
		</nativeWidthActual>
		<get_nativeWidthActual get="inline" set="null" line="58"><f a=""><x path="Int"/></f></get_nativeWidthActual>
		<nativeHeightActual public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The native actual height of the texture.
     * Same as native height unless underlying backend needs pot (power of two) sizes.</haxe_doc>
		</nativeHeightActual>
		<get_nativeHeightActual get="inline" set="null" line="67"><f a=""><x path="Int"/></f></get_nativeHeightActual>
		<width public="1" set="null"><x path="Float"/></width>
		<height public="1" set="null"><x path="Float"/></height>
		<density public="1" set="accessor"><x path="Float"/></density>
		<set_density set="method" line="76"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<filter public="1" set="accessor" expr="LINEAR" line="84">
			<e path="ceramic.TextureFilter"/>
			<meta><m n=":value"><e>LINEAR</e></m></meta>
		</filter>
		<set_filter set="method" line="85"><f a="filter">
	<e path="ceramic.TextureFilter"/>
	<e path="ceramic.TextureFilter"/>
</f></set_filter>
		<wrapS public="1" set="accessor" expr="CLAMP" line="95">
			<x path="ceramic.TextureWrap"/>
			<meta><m n=":value"><e>CLAMP</e></m></meta>
			<haxe_doc>* Horizontal texture wrap mode</haxe_doc>
		</wrapS>
		<set_wrapS set="method" line="96"><f a="wrapS">
	<x path="ceramic.TextureWrap"/>
	<x path="ceramic.TextureWrap"/>
</f></set_wrapS>
		<wrapT public="1" set="accessor" expr="CLAMP" line="106">
			<x path="ceramic.TextureWrap"/>
			<meta><m n=":value"><e>CLAMP</e></m></meta>
			<haxe_doc>* Vertical texture wrapping mode</haxe_doc>
		</wrapT>
		<set_wrapT set="method" line="107"><f a="wrapT">
	<x path="ceramic.TextureWrap"/>
	<x path="ceramic.TextureWrap"/>
</f></set_wrapT>
		<setWrap public="1" set="method" line="120">
			<f a="wrapS:?wrapT">
				<x path="ceramic.TextureWrap"/>
				<x path="ceramic.TextureWrap"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shorthand for setting both wrapS and wrapT at the same time.
     * Possible values: `CLAMP`, `REPEAT`, `MIRROR`
     * @param wrapS horizontal wrap mode
     * @param wrapT vertical wrap mode</haxe_doc>
		</setWrap>
		<backendItem public="1"><t path="backend.Texture"/></backendItem>
		<asset public="1" expr="null" line="128">
			<c path="ceramic.ImageAsset"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</asset>
		<destroy public="1" set="method" line="174" override="1"><f a=""><x path="Void"/></f></destroy>
		<fetchPixels public="1" set="method" line="187"><f a="?result">
	<x path="Null"><t path="ceramic.UInt8Array"/></x>
	<t path="ceramic.UInt8Array"/>
</f></fetchPixels>
		<submitPixels public="1" set="method" line="193"><f a="pixels">
	<t path="ceramic.UInt8Array"/>
	<x path="Void"/>
</f></submitPixels>
		<toPng public="1" get="inline" set="null" line="206">
			<f a="path:?reversePremultiplyAlpha:done" v=":true:">
				<c path="String"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ reversePremultiplyAlpha : true }</e></m></meta>
			<haxe_doc>* Export texture as PNG data and save it to the given file path
     * @param path The png file path where to save the image (`'/path/to/image.png'`)
     * @param done Called when the png has been exported</haxe_doc>
			<overloads><toPng public="1" get="inline" set="null" line="216">
	<f a="?reversePremultiplyAlpha:done" v="true:">
		<x path="Bool"/>
		<f a="data">
			<c path="haxe.io.Bytes"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{ reversePremultiplyAlpha : true }</e></m></meta>
	<haxe_doc>* Export texture to PNG data/bytes
     * @param done Called when the png has been exported, with `data` containing PNG bytes</haxe_doc>
</toPng></overloads>
		</toPng>
		<_toPng set="method" line="222">
			<f a="?path:?reversePremultiplyAlpha:done" v=":true:">
				<c path="String"/>
				<x path="Bool"/>
				<f a="?data">
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ reversePremultiplyAlpha : true }</e></m></meta>
		</_toPng>
		<toString set="method" line="230" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="163">
			<f a="backendItem:?density" v=":-1">
				<t path="backend.Texture"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ density : -1 }</e></m></meta>
		</new>
		<haxe_doc>* A texture is an image ready to be drawn.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.RenderTexture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/RenderTexture.hx">
		<extends path="ceramic.Texture"/>
		<_clearQuad expr="null" line="15" static="1">
			<c path="ceramic.Quad"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_clearQuad>
		<autoRender public="1" expr="true" line="17">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoRender>
		<clearOnRender public="1" expr="true" line="19">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</clearOnRender>
		<renderDirty public="1" expr="false" line="21">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</renderDirty>
		<depth public="1" set="null" expr="true" line="23">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</depth>
		<stencil public="1" set="null" expr="true" line="25">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</stencil>
		<antialiasing public="1" set="null" expr="0" line="27">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</antialiasing>
		<dependingTextures public="1" expr="null" line="32">
			<c path="ceramic.IntIntMap"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dependingTextures>
		<priority public="1" set="null" expr="0" line="35">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</priority>
		<_usedInRendering expr="false" line="42">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":allow"><e>ceramic.Renderer</e></m>
			</meta>
		</_usedInRendering>
		<_renderedOnce set="accessor" expr="false" line="45">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":allow"><e>ceramic.Renderer</e></m>
			</meta>
		</_renderedOnce>
		<set__renderedOnce set="method" line="46"><f a="_renderedOnce">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set__renderedOnce>
		<_initialClearQuad expr="null" line="58">
			<c path="ceramic.Quad"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_initialClearQuad>
		<destroy public="1" set="method" line="98" override="1"><f a=""><x path="Void"/></f></destroy>
		<stamp public="1" set="method" line="120">
			<f a="visual:done">
				<c path="ceramic.Visual"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws the given visual onto the render texture.
     * The drawing operation is not done synchronously.
     * It waits for the next draw stage of the app to perform it,
     * then calls done() when finished.
     * This is expected to be used with a texture `autoRender` set to `false`.</haxe_doc>
		</stamp>
		<_stamp set="method" line="144"><f a="visual:done">
	<c path="ceramic.Visual"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></_stamp>
		<clear public="1" set="method" line="199">
			<f a="?color:?alpha:?clipX:?clipY:?clipWidth:?clipHeight:done" v="0xFFFFFF:0:-1:-1:-1:-1:">
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ clipHeight : -1, clipWidth : -1, clipY : -1, clipX : -1, alpha : 0, color : 0xFFFFFF }</e></m></meta>
			<haxe_doc>* Clears the texture, or a specific area of it with a fill color and alpha.
     * The drawing operation is not done synchronously.
     * It waits for the next draw stage of the app to perform it,
     * then calls done() when finished.
     * This is expected to be used with a texture `autoRender` set to `false`.</haxe_doc>
		</clear>
		<dependsOnTexture public="1" get="inline" set="null" line="225">
			<f a="texture">
				<c path="ceramic.Texture"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</dependsOnTexture>
		<dependsOnTextureCount public="1" get="inline" set="null" line="235">
			<f a="texture">
				<c path="ceramic.Texture"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</dependsOnTextureCount>
		<incrementDependingTextureCount public="1" get="inline" set="null" line="245">
			<f a="texture">
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</incrementDependingTextureCount>
		<resetDependingTextureCounts public="1" get="inline" set="null" line="265">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</resetDependingTextureCounts>
		<toString set="method" line="275" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="63">
			<f a="width:height:?density:?depth:?stencil:?antialiasing" v="::-1:true:true:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ antialiasing : 0, stencil : true, depth : true, density : -1 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<class path="ceramic.Renderer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Renderer.hx">
		<extends path="ceramic.Entity"/>
		<drawCalls expr="0" line="13">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</drawCalls>
		<activeShader expr="null" line="15">
			<x path="backend.Shader"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</activeShader>
		<customFloatAttributesSize expr="0" line="16">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</customFloatAttributesSize>
		<stencilClip expr="false" line="18">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</stencilClip>
		<lastTexture expr="null" line="20">
			<c path="ceramic.Texture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastTexture>
		<lastTextureId expr="backend.TextureId.DEFAULT" line="21">
			<t path="backend.TextureId"/>
			<meta><m n=":value"><e>backend.TextureId.DEFAULT</e></m></meta>
		</lastTextureId>
		<lastShader expr="null" line="22">
			<c path="ceramic.Shader"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastShader>
		<lastRenderTarget expr="null" line="23">
			<c path="ceramic.RenderTexture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastRenderTarget>
		<lastComputedBlending expr="ceramic.Blending.PREMULTIPLIED_ALPHA" line="24">
			<x path="ceramic.Blending"/>
			<meta><m n=":value"><e>ceramic.Blending.PREMULTIPLIED_ALPHA</e></m></meta>
		</lastComputedBlending>
		<lastClip expr="null" line="25">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastClip>
		<lastClipIsRegular expr="false" line="26">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lastClipIsRegular>
		<activeTextureSlot expr="0" line="27">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</activeTextureSlot>
		<backendTextures><c path="backend.Textures"/></backendTextures>
		<backendShaders><c path="backend.Shaders"/></backendShaders>
		<texWidth expr="0" line="32">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texWidth>
		<texHeight expr="0" line="33">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texHeight>
		<texWidthActual expr="0" line="34">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texWidthActual>
		<texHeightActual expr="0" line="35">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texHeightActual>
		<defaultTexturedShader expr="null" line="38">
			<x path="backend.Shader"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</defaultTexturedShader>
		<defaultWhiteTexture expr="null" line="39">
			<c path="ceramic.Texture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</defaultWhiteTexture>
		<quad expr="null" line="41">
			<c path="ceramic.Quad"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</quad>
		<mesh expr="null" line="42">
			<c path="ceramic.Mesh"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</mesh>
		<stateDirty expr="true" line="44">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</stateDirty>
		<z expr="0" line="46">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</z>
		<usedTextureIndexes expr="[]" line="48">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</usedTextureIndexes>
		<usedTextures expr="0" line="49">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</usedTextures>
		<maxUsableTexturesInBatch expr="-1" line="50">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</maxUsableTexturesInBatch>
		<activeShaderCanBatchMultipleTextures expr="false" line="51">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</activeShaderCanBatchMultipleTextures>
		<usedRenderTarget expr="null" line="53">
			<c path="ceramic.RenderTexture"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</usedRenderTarget>
		<render public="1" set="method" line="74"><f a="isMainRender:ceramicVisuals">
	<x path="Bool"/>
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Void"/>
</f></render>
		<drawQuad get="inline" set="null" line="334"><f a="draw:quad">
	<c path="backend.Draw"/>
	<c path="ceramic.Quad"/>
	<x path="Void"/>
</f></drawQuad>
		<drawMesh get="inline" set="null" line="892">
			<f a="draw:mesh">
				<c path="backend.Draw"/>
				<c path="ceramic.Mesh"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Using an inline internal function because we want to use similar code multiple times,
            and let haxe compiler evaluate `hasCustomAttributes` and `hasTextureSlot`
            at compile time.</haxe_doc>
		</drawMesh>
		<flush get="inline" set="null" line="1340"><f a="draw">
	<c path="backend.Draw"/>
	<x path="Bool"/>
</f></flush>
		<computeQuadBlending get="inline" set="null" line="1363"><f a="quad">
	<c path="ceramic.Quad"/>
	<x path="ceramic.Blending"/>
</f></computeQuadBlending>
		<computeMeshBlending get="inline" set="null" line="1391"><f a="mesh">
	<c path="ceramic.Mesh"/>
	<x path="ceramic.Blending"/>
</f></computeMeshBlending>
		<isSameShader get="inline" set="null" line="1427"><f a="shaderA:shaderB">
	<c path="ceramic.Shader"/>
	<c path="ceramic.Shader"/>
	<x path="Bool"/>
</f></isSameShader>
		<useShader get="inline" set="null" line="1436"><f a="draw:shader">
	<c path="backend.Draw"/>
	<x path="backend.Shader"/>
	<x path="Void"/>
</f></useShader>
		<useBlending get="inline" set="null" line="1457"><f a="draw:blending">
	<c path="backend.Draw"/>
	<x path="ceramic.Blending"/>
	<x path="Void"/>
</f></useBlending>
		<scissorWithQuad get="inline" set="null" line="1514"><f a="draw:quad">
	<c path="backend.Draw"/>
	<c path="ceramic.Quad"/>
	<x path="Void"/>
</f></scissorWithQuad>
		<isNotRenderedRenderTexture get="inline" set="null" line="1525"><f a="texture">
	<c path="ceramic.Texture"/>
	<x path="Bool"/>
</f></isNotRenderedRenderTexture>
		<useRenderTarget get="inline" set="null" line="1532"><f a="draw:renderTarget">
	<c path="backend.Draw"/>
	<c path="ceramic.RenderTexture"/>
	<x path="Void"/>
</f></useRenderTarget>
		<useFirstTextureInBatch get="inline" set="null" line="1546"><f a="draw:texture">
	<c path="backend.Draw"/>
	<c path="ceramic.Texture"/>
	<x path="Void"/>
</f></useFirstTextureInBatch>
		<useTexture get="inline" set="null" line="1568"><f a="draw:texture:reusing">
	<c path="backend.Draw"/>
	<c path="ceramic.Texture"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></useTexture>
		<canUseTextureInSameBatch get="inline" set="null" line="1599"><f a="draw:texture">
	<c path="backend.Draw"/>
	<c path="ceramic.Texture"/>
	<x path="Bool"/>
</f></canUseTextureInSameBatch>
		<useTextureInSameBatch get="inline" set="null" line="1636"><f a="draw:texture">
	<c path="backend.Draw"/>
	<c path="ceramic.Texture"/>
	<x path="Void"/>
</f></useTextureInSameBatch>
		<unbindUsedTextures get="inline" set="null" line="1670"><f a="draw">
	<c path="backend.Draw"/>
	<x path="Void"/>
</f></unbindUsedTextures>
		<new public="1" set="method" line="68"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* An implementation-independant GPU 2D renderer.
 * To be used in pair with a draw backend implementation.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.ReusableArray" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ReusableArray.hx">
		<_poolIndex expr="-1" line="12">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_poolIndex>
		<vector><x path="haxe.ds.Vector"><c path="ceramic.ReusableArray.T"/></x></vector>
		<length public="1" set="accessor"><x path="Int"/></length>
		<set_length set="method" line="24"><f a="length">
	<x path="Int"/>
	<x path="Int"/>
</f></set_length>
		<get public="1" get="inline" set="null" line="54"><f a="index">
	<x path="Int"/>
	<c path="ceramic.ReusableArray.T"/>
</f></get>
		<set public="1" get="inline" set="null" line="60"><f a="index:value">
	<x path="Int"/>
	<c path="ceramic.ReusableArray.T"/>
	<x path="Void"/>
</f></set>
		<new public="1" get="inline" set="null" line="18"><f a="length">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A reusable array to use in places that need a temporary array many times.
 * Changing array size only increases the backing array size but never decreases it.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Runner" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Runner.hx">
		<mainThread static="1"><x path="sys.thread.Thread"/></mainThread>
		<queue static="1"><c path="sys.thread.Deque"><f a=""><x path="Void"/></f></c></queue>
		<currentIsMainThread public="1" get="inline" set="null" line="43" static="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if current running thread is main thread
     * @return Bool</haxe_doc>
		</currentIsMainThread>
		<init public="1" set="method" line="57" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Call this on your thread to make primary,
     * the calling thread will be used for callbacks.</haxe_doc>
		</init>
		<tick public="1" set="method" line="68" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Call this on the primary manually,
     * Returns the number of callbacks called.</haxe_doc>
		</tick>
		<isEmulatingBackgroundWithMain public="1" get="inline" set="null" line="90" static="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns `true` if _running in background_ is emulated on this platform by
     * running _background_ code in main thread instead of using background thread.</haxe_doc>
		</isEmulatingBackgroundWithMain>
		<runInMain public="1" set="method" line="104" static="1">
			<f a="_fn">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Call a function on the primary thread without waiting or blocking.
     * If you want return values see runInMainBlocking</haxe_doc>
		</runInMain>
		<runInBackground public="1" set="method" line="117" static="1">
			<f a="fn">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a background thread using the given function, or just run (deferred) the function if threads are not supported</haxe_doc>
		</runInBackground>
		<haxe_doc>A simple Haxe class for easily running threads and calling functions on the primary thread.
from https://github.com/underscorediscovery/

Usage:
- call Runner.init() from your primary thread 
- call Runner.tick() periodically to service callbacks (i.e inside your main loop)
- use Runner.thread(function() { ... }) to make a thread
- use Runner.runInMainThread(function() { ... }) to run code on the main thread
- use runInMainThreadBlocking to run code on the main thread and wait for the return value</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.RuntimeAssets" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/RuntimeAssets.hx">
		<fromPath public="1" set="method" line="65" static="1"><f a="path">
	<c path="String"/>
	<c path="ceramic.RuntimeAssets"/>
</f></fromPath>
		<toAssetConstName set="method" line="253" static="1"><f a="input">
	<c path="String"/>
	<c path="String"/>
</f></toAssetConstName>
		<isAsciiChar set="method" line="365" static="1"><f a="c">
	<c path="String"/>
	<x path="Bool"/>
</f></isAsciiChar>
		<allAssets expr="null" line="18">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</allAssets>
		<allAssetDirs expr="null" line="20">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</allAssetDirs>
		<assetsByBaseName expr="null" line="22">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</assetsByBaseName>
		<assetDirsByBaseName expr="null" line="24">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</assetDirsByBaseName>
		<cachedNames expr="new Map()" line="30">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><a>
	<paths><c path="Array"><c path="String"/></c></paths>
	<name><c path="String"/></name>
	<constName><c path="String"/></constName>
</a></c>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</cachedNames>
		<cachedLists expr="null" line="37">
			<a>
				<allDirsByName><t path="Map">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</t></allDirsByName>
				<allDirs><c path="Array"><c path="String"/></c></allDirs>
				<allByName><t path="Map">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</t></allByName>
				<all><c path="Array"><c path="String"/></c></all>
			</a>
			<meta><m n=":value"><e>null</e></m></meta>
		</cachedLists>
		<path public="1" set="null" expr="null" line="39">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</path>
		<reset public="1" set="method" line="50"><f a="allAssets:?path">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></reset>
		<getNames public="1" set="method" line="81">
			<f a="kind:?extensions:?dir" v="::false">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<c path="Array"><a>
	<paths><c path="Array"><c path="String"/></c></paths>
	<name><c path="String"/></name>
	<constName><c path="String"/></constName>
</a></c>
			</f>
			<meta><m n=":value"><e>{ dir : false }</e></m></meta>
		</getNames>
		<getLists public="1" set="method" line="177"><f a=""><a>
	<allDirsByName><t path="Map">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</t></allDirsByName>
	<allDirs><c path="Array"><c path="String"/></c></allDirs>
	<allByName><t path="Map">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</t></allByName>
	<all><c path="Array"><c path="String"/></c></all>
</a></f></getLists>
		<getEncodableLists public="1" set="method" line="228">
			<f a=""><a>
	<allDirsByName><d><c path="Array"><c path="String"/></c></d></allDirsByName>
	<allDirs><c path="Array"><c path="String"/></c></allDirs>
	<allByName><d><c path="Array"><c path="String"/></c></d></allByName>
	<all><c path="Array"><c path="String"/></c></all>
</a></f>
			<haxe_doc>* Same as getLists(), but will transform Maps into JSON-encodable raw objects.</haxe_doc>
		</getEncodableLists>
		<initData set="method" line="299"><f a=""><x path="Void"/></f></initData>
		<new public="1" set="method" line="41"><f a="allAssets:?path">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Runtime utilities to compute asset lists/names from raw (relative) file list.
 * Code is very similar to AssetsMacro, but for runtime execution, with any list of asset.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="ceramic.ScanCode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScanCode.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._ScanCode.ScanCode_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScanCode.hx" private="1" module="ceramic.ScanCode" final="1">
	<name public="1" set="method" line="16" static="1">
		<f a="scanCode">
			<x path="ceramic.ScanCode"/>
			<c path="String"/>
		</f>
		<haxe_doc>* Convert a scanCode to a readable name</haxe_doc>
	</name>
	<toString set="method" line="28" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<MASK public="1" expr="(1 &lt;&lt; 30)" line="35" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e><![CDATA[(1 << 30)]]></e></m></meta>
	</MASK>
	<UNKNOWN public="1" get="inline" set="null" expr="cast 0" line="37" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNKNOWN>
	<KEY_A public="1" get="inline" set="null" expr="cast 4" line="42" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_A>
	<KEY_B public="1" get="inline" set="null" expr="cast 5" line="43" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_B>
	<KEY_C public="1" get="inline" set="null" expr="cast 6" line="44" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_C>
	<KEY_D public="1" get="inline" set="null" expr="cast 7" line="45" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_D>
	<KEY_E public="1" get="inline" set="null" expr="cast 8" line="46" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_E>
	<KEY_F public="1" get="inline" set="null" expr="cast 9" line="47" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_F>
	<KEY_G public="1" get="inline" set="null" expr="cast 10" line="48" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_G>
	<KEY_H public="1" get="inline" set="null" expr="cast 11" line="49" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_H>
	<KEY_I public="1" get="inline" set="null" expr="cast 12" line="50" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_I>
	<KEY_J public="1" get="inline" set="null" expr="cast 13" line="51" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_J>
	<KEY_K public="1" get="inline" set="null" expr="cast 14" line="52" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_K>
	<KEY_L public="1" get="inline" set="null" expr="cast 15" line="53" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_L>
	<KEY_M public="1" get="inline" set="null" expr="cast 16" line="54" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_M>
	<KEY_N public="1" get="inline" set="null" expr="cast 17" line="55" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 17</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_N>
	<KEY_O public="1" get="inline" set="null" expr="cast 18" line="56" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 18</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_O>
	<KEY_P public="1" get="inline" set="null" expr="cast 19" line="57" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 19</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_P>
	<KEY_Q public="1" get="inline" set="null" expr="cast 20" line="58" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_Q>
	<KEY_R public="1" get="inline" set="null" expr="cast 21" line="59" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 21</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_R>
	<KEY_S public="1" get="inline" set="null" expr="cast 22" line="60" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 22</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_S>
	<KEY_T public="1" get="inline" set="null" expr="cast 23" line="61" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 23</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_T>
	<KEY_U public="1" get="inline" set="null" expr="cast 24" line="62" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 24</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_U>
	<KEY_V public="1" get="inline" set="null" expr="cast 25" line="63" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 25</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_V>
	<KEY_W public="1" get="inline" set="null" expr="cast 26" line="64" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 26</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_W>
	<KEY_X public="1" get="inline" set="null" expr="cast 27" line="65" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 27</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_X>
	<KEY_Y public="1" get="inline" set="null" expr="cast 28" line="66" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 28</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_Y>
	<KEY_Z public="1" get="inline" set="null" expr="cast 29" line="67" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 29</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_Z>
	<KEY_1 public="1" get="inline" set="null" expr="cast 30" line="69" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 30</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_1>
	<KEY_2 public="1" get="inline" set="null" expr="cast 31" line="70" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 31</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_2>
	<KEY_3 public="1" get="inline" set="null" expr="cast 32" line="71" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 32</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_3>
	<KEY_4 public="1" get="inline" set="null" expr="cast 33" line="72" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 33</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_4>
	<KEY_5 public="1" get="inline" set="null" expr="cast 34" line="73" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 34</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_5>
	<KEY_6 public="1" get="inline" set="null" expr="cast 35" line="74" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 35</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_6>
	<KEY_7 public="1" get="inline" set="null" expr="cast 36" line="75" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 36</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_7>
	<KEY_8 public="1" get="inline" set="null" expr="cast 37" line="76" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 37</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_8>
	<KEY_9 public="1" get="inline" set="null" expr="cast 38" line="77" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 38</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_9>
	<KEY_0 public="1" get="inline" set="null" expr="cast 39" line="78" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 39</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KEY_0>
	<ENTER public="1" get="inline" set="null" expr="cast 40" line="80" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 40</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ENTER>
	<ESCAPE public="1" get="inline" set="null" expr="cast 41" line="81" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 41</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ESCAPE>
	<BACKSPACE public="1" get="inline" set="null" expr="cast 42" line="82" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 42</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BACKSPACE>
	<TAB public="1" get="inline" set="null" expr="cast 43" line="83" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 43</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TAB>
	<SPACE public="1" get="inline" set="null" expr="cast 44" line="84" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 44</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SPACE>
	<MINUS public="1" get="inline" set="null" expr="cast 45" line="86" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 45</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MINUS>
	<EQUALS public="1" get="inline" set="null" expr="cast 46" line="87" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 46</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EQUALS>
	<LEFTBRACKET public="1" get="inline" set="null" expr="cast 47" line="88" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 47</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFTBRACKET>
	<RIGHTBRACKET public="1" get="inline" set="null" expr="cast 48" line="89" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 48</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHTBRACKET>
	<BACKSLASH public="1" get="inline" set="null" expr="cast 49" line="105" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 49</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BACKSLASH>
	<NONUSHASH public="1" get="inline" set="null" expr="cast 50" line="119" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 50</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONUSHASH>
	<SEMICOLON public="1" get="inline" set="null" expr="cast 51" line="120" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 51</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SEMICOLON>
	<APOSTROPHE public="1" get="inline" set="null" expr="cast 52" line="121" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 52</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</APOSTROPHE>
	<GRAVE public="1" get="inline" set="null" expr="cast 53" line="140" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 53</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</GRAVE>
	<COMMA public="1" get="inline" set="null" expr="cast 54" line="141" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 54</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COMMA>
	<PERIOD public="1" get="inline" set="null" expr="cast 55" line="142" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 55</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PERIOD>
	<SLASH public="1" get="inline" set="null" expr="cast 56" line="143" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 56</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SLASH>
	<CAPSLOCK public="1" get="inline" set="null" expr="cast 57" line="145" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 57</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CAPSLOCK>
	<F1 public="1" get="inline" set="null" expr="cast 58" line="147" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 58</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F1>
	<F2 public="1" get="inline" set="null" expr="cast 59" line="148" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 59</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F2>
	<F3 public="1" get="inline" set="null" expr="cast 60" line="149" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 60</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F3>
	<F4 public="1" get="inline" set="null" expr="cast 61" line="150" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 61</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F4>
	<F5 public="1" get="inline" set="null" expr="cast 62" line="151" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 62</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F5>
	<F6 public="1" get="inline" set="null" expr="cast 63" line="152" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 63</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F6>
	<F7 public="1" get="inline" set="null" expr="cast 64" line="153" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 64</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F7>
	<F8 public="1" get="inline" set="null" expr="cast 65" line="154" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 65</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F8>
	<F9 public="1" get="inline" set="null" expr="cast 66" line="155" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 66</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F9>
	<F10 public="1" get="inline" set="null" expr="cast 67" line="156" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 67</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F10>
	<F11 public="1" get="inline" set="null" expr="cast 68" line="157" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 68</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F11>
	<F12 public="1" get="inline" set="null" expr="cast 69" line="158" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 69</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F12>
	<PRINTSCREEN public="1" get="inline" set="null" expr="cast 70" line="160" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 70</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PRINTSCREEN>
	<SCROLLLOCK public="1" get="inline" set="null" expr="cast 71" line="161" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 71</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCROLLLOCK>
	<PAUSE public="1" get="inline" set="null" expr="cast 72" line="162" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 72</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAUSE>
	<INSERT public="1" get="inline" set="null" expr="cast 73" line="165" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 73</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INSERT>
	<HOME public="1" get="inline" set="null" expr="cast 74" line="166" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 74</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HOME>
	<PAGEUP public="1" get="inline" set="null" expr="cast 75" line="167" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 75</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAGEUP>
	<DELETE public="1" get="inline" set="null" expr="cast 76" line="168" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 76</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DELETE>
	<END public="1" get="inline" set="null" expr="cast 77" line="169" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 77</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</END>
	<PAGEDOWN public="1" get="inline" set="null" expr="cast 78" line="170" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 78</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PAGEDOWN>
	<RIGHT public="1" get="inline" set="null" expr="cast 79" line="171" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 79</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT>
	<LEFT public="1" get="inline" set="null" expr="cast 80" line="172" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 80</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT>
	<DOWN public="1" get="inline" set="null" expr="cast 81" line="173" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 81</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DOWN>
	<UP public="1" get="inline" set="null" expr="cast 82" line="174" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 82</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UP>
	<NUMLOCKCLEAR public="1" get="inline" set="null" expr="cast 83" line="177" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 83</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NUMLOCKCLEAR>
	<KP_DIVIDE public="1" get="inline" set="null" expr="cast 84" line="178" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 84</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DIVIDE>
	<KP_MULTIPLY public="1" get="inline" set="null" expr="cast 85" line="179" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 85</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MULTIPLY>
	<KP_MINUS public="1" get="inline" set="null" expr="cast 86" line="180" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 86</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MINUS>
	<KP_PLUS public="1" get="inline" set="null" expr="cast 87" line="181" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 87</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PLUS>
	<KP_ENTER public="1" get="inline" set="null" expr="cast 88" line="182" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 88</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_ENTER>
	<KP_1 public="1" get="inline" set="null" expr="cast 89" line="183" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 89</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_1>
	<KP_2 public="1" get="inline" set="null" expr="cast 90" line="184" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 90</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_2>
	<KP_3 public="1" get="inline" set="null" expr="cast 91" line="185" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 91</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_3>
	<KP_4 public="1" get="inline" set="null" expr="cast 92" line="186" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 92</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_4>
	<KP_5 public="1" get="inline" set="null" expr="cast 93" line="187" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 93</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_5>
	<KP_6 public="1" get="inline" set="null" expr="cast 94" line="188" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 94</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_6>
	<KP_7 public="1" get="inline" set="null" expr="cast 95" line="189" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 95</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_7>
	<KP_8 public="1" get="inline" set="null" expr="cast 96" line="190" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 96</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_8>
	<KP_9 public="1" get="inline" set="null" expr="cast 97" line="191" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 97</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_9>
	<KP_0 public="1" get="inline" set="null" expr="cast 98" line="192" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 98</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_0>
	<KP_PERIOD public="1" get="inline" set="null" expr="cast 99" line="193" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 99</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PERIOD>
	<NONUSBACKSLASH public="1" get="inline" set="null" expr="cast 100" line="206" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 100</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONUSBACKSLASH>
	<APPLICATION public="1" get="inline" set="null" expr="cast 101" line="209" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 101</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</APPLICATION>
	<POWER public="1" get="inline" set="null" expr="cast 102" line="214" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 102</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</POWER>
	<KP_EQUALS public="1" get="inline" set="null" expr="cast 103" line="215" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 103</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_EQUALS>
	<F13 public="1" get="inline" set="null" expr="cast 104" line="216" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 104</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F13>
	<F14 public="1" get="inline" set="null" expr="cast 105" line="217" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 105</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F14>
	<F15 public="1" get="inline" set="null" expr="cast 106" line="218" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 106</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F15>
	<F16 public="1" get="inline" set="null" expr="cast 107" line="219" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 107</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F16>
	<F17 public="1" get="inline" set="null" expr="cast 108" line="220" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 108</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F17>
	<F18 public="1" get="inline" set="null" expr="cast 109" line="221" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 109</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F18>
	<F19 public="1" get="inline" set="null" expr="cast 110" line="222" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 110</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F19>
	<F20 public="1" get="inline" set="null" expr="cast 111" line="223" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 111</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F20>
	<F21 public="1" get="inline" set="null" expr="cast 112" line="224" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 112</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F21>
	<F22 public="1" get="inline" set="null" expr="cast 113" line="225" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 113</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F22>
	<F23 public="1" get="inline" set="null" expr="cast 114" line="226" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 114</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F23>
	<F24 public="1" get="inline" set="null" expr="cast 115" line="227" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 115</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</F24>
	<EXECUTE public="1" get="inline" set="null" expr="cast 116" line="228" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 116</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EXECUTE>
	<HELP public="1" get="inline" set="null" expr="cast 117" line="229" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 117</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HELP>
	<MENU public="1" get="inline" set="null" expr="cast 118" line="230" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 118</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MENU>
	<SELECT public="1" get="inline" set="null" expr="cast 119" line="231" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 119</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SELECT>
	<STOP public="1" get="inline" set="null" expr="cast 120" line="232" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 120</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</STOP>
	<AGAIN public="1" get="inline" set="null" expr="cast 121" line="235" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 121</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AGAIN>
	<UNDO public="1" get="inline" set="null" expr="cast 122" line="236" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 122</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNDO>
	<CUT public="1" get="inline" set="null" expr="cast 123" line="237" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 123</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CUT>
	<COPY public="1" get="inline" set="null" expr="cast 124" line="238" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 124</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COPY>
	<PASTE public="1" get="inline" set="null" expr="cast 125" line="239" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 125</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PASTE>
	<FIND public="1" get="inline" set="null" expr="cast 126" line="240" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 126</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</FIND>
	<MUTE public="1" get="inline" set="null" expr="cast 127" line="241" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 127</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MUTE>
	<VOLUMEUP public="1" get="inline" set="null" expr="cast 128" line="242" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 128</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VOLUMEUP>
	<VOLUMEDOWN public="1" get="inline" set="null" expr="cast 129" line="243" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 129</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VOLUMEDOWN>
	<KP_COMMA public="1" get="inline" set="null" expr="cast 133" line="250" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 133</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_COMMA>
	<KP_EQUALSAS400 public="1" get="inline" set="null" expr="cast 134" line="251" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 134</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_EQUALSAS400>
	<INTERNATIONAL1 public="1" get="inline" set="null" expr="cast 135" line="254" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 135</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL1>
	<INTERNATIONAL2 public="1" get="inline" set="null" expr="cast 136" line="255" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 136</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL2>
	<INTERNATIONAL3 public="1" get="inline" set="null" expr="cast 137" line="258" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 137</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL3>
	<INTERNATIONAL4 public="1" get="inline" set="null" expr="cast 138" line="259" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 138</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL4>
	<INTERNATIONAL5 public="1" get="inline" set="null" expr="cast 139" line="260" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 139</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL5>
	<INTERNATIONAL6 public="1" get="inline" set="null" expr="cast 140" line="261" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 140</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL6>
	<INTERNATIONAL7 public="1" get="inline" set="null" expr="cast 141" line="262" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 141</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL7>
	<INTERNATIONAL8 public="1" get="inline" set="null" expr="cast 142" line="263" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 142</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL8>
	<INTERNATIONAL9 public="1" get="inline" set="null" expr="cast 143" line="264" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 143</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INTERNATIONAL9>
	<LANG1 public="1" get="inline" set="null" expr="cast 144" line="266" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 144</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG1>
	<LANG2 public="1" get="inline" set="null" expr="cast 145" line="268" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 145</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG2>
	<LANG3 public="1" get="inline" set="null" expr="cast 146" line="270" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 146</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG3>
	<LANG4 public="1" get="inline" set="null" expr="cast 147" line="272" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 147</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG4>
	<LANG5 public="1" get="inline" set="null" expr="cast 148" line="274" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 148</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG5>
	<LANG6 public="1" get="inline" set="null" expr="cast 149" line="276" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 149</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG6>
	<LANG7 public="1" get="inline" set="null" expr="cast 150" line="278" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 150</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG7>
	<LANG8 public="1" get="inline" set="null" expr="cast 151" line="280" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 151</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG8>
	<LANG9 public="1" get="inline" set="null" expr="cast 152" line="282" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 152</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANG9>
	<ALTERASE public="1" get="inline" set="null" expr="cast 153" line="284" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 153</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ALTERASE>
	<SYSREQ public="1" get="inline" set="null" expr="cast 154" line="285" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 154</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SYSREQ>
	<CANCEL public="1" get="inline" set="null" expr="cast 155" line="286" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 155</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CANCEL>
	<CLEAR public="1" get="inline" set="null" expr="cast 156" line="287" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 156</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CLEAR>
	<PRIOR public="1" get="inline" set="null" expr="cast 157" line="288" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 157</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PRIOR>
	<RETURN2 public="1" get="inline" set="null" expr="cast 158" line="289" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 158</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RETURN2>
	<SEPARATOR public="1" get="inline" set="null" expr="cast 159" line="290" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 159</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SEPARATOR>
	<OUT public="1" get="inline" set="null" expr="cast 160" line="291" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 160</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OUT>
	<OPER public="1" get="inline" set="null" expr="cast 161" line="292" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 161</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OPER>
	<CLEARAGAIN public="1" get="inline" set="null" expr="cast 162" line="293" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 162</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CLEARAGAIN>
	<CRSEL public="1" get="inline" set="null" expr="cast 163" line="294" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 163</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CRSEL>
	<EXSEL public="1" get="inline" set="null" expr="cast 164" line="295" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 164</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EXSEL>
	<KP_00 public="1" get="inline" set="null" expr="cast 176" line="297" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 176</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_00>
	<KP_000 public="1" get="inline" set="null" expr="cast 177" line="298" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 177</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_000>
	<THOUSANDSSEPARATOR public="1" get="inline" set="null" expr="cast 178" line="299" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 178</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</THOUSANDSSEPARATOR>
	<DECIMALSEPARATOR public="1" get="inline" set="null" expr="cast 179" line="300" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 179</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DECIMALSEPARATOR>
	<CURRENCYUNIT public="1" get="inline" set="null" expr="cast 180" line="301" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 180</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CURRENCYUNIT>
	<CURRENCYSUBUNIT public="1" get="inline" set="null" expr="cast 181" line="302" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 181</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CURRENCYSUBUNIT>
	<KP_LEFTPAREN public="1" get="inline" set="null" expr="cast 182" line="303" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 182</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_LEFTPAREN>
	<KP_RIGHTPAREN public="1" get="inline" set="null" expr="cast 183" line="304" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 183</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_RIGHTPAREN>
	<KP_LEFTBRACE public="1" get="inline" set="null" expr="cast 184" line="305" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 184</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_LEFTBRACE>
	<KP_RIGHTBRACE public="1" get="inline" set="null" expr="cast 185" line="306" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 185</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_RIGHTBRACE>
	<KP_TAB public="1" get="inline" set="null" expr="cast 186" line="307" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 186</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_TAB>
	<KP_BACKSPACE public="1" get="inline" set="null" expr="cast 187" line="308" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 187</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_BACKSPACE>
	<KP_A public="1" get="inline" set="null" expr="cast 188" line="309" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 188</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_A>
	<KP_B public="1" get="inline" set="null" expr="cast 189" line="310" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 189</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_B>
	<KP_C public="1" get="inline" set="null" expr="cast 190" line="311" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 190</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_C>
	<KP_D public="1" get="inline" set="null" expr="cast 191" line="312" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 191</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_D>
	<KP_E public="1" get="inline" set="null" expr="cast 192" line="313" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 192</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_E>
	<KP_F public="1" get="inline" set="null" expr="cast 193" line="314" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 193</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_F>
	<KP_XOR public="1" get="inline" set="null" expr="cast 194" line="315" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 194</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_XOR>
	<KP_POWER public="1" get="inline" set="null" expr="cast 195" line="316" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 195</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_POWER>
	<KP_PERCENT public="1" get="inline" set="null" expr="cast 196" line="317" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 196</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PERCENT>
	<KP_LESS public="1" get="inline" set="null" expr="cast 197" line="318" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 197</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_LESS>
	<KP_GREATER public="1" get="inline" set="null" expr="cast 198" line="319" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 198</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_GREATER>
	<KP_AMPERSAND public="1" get="inline" set="null" expr="cast 199" line="320" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 199</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_AMPERSAND>
	<KP_DBLAMPERSAND public="1" get="inline" set="null" expr="cast 200" line="321" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 200</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DBLAMPERSAND>
	<KP_VERTICALBAR public="1" get="inline" set="null" expr="cast 201" line="322" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 201</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_VERTICALBAR>
	<KP_DBLVERTICALBAR public="1" get="inline" set="null" expr="cast 202" line="323" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 202</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DBLVERTICALBAR>
	<KP_COLON public="1" get="inline" set="null" expr="cast 203" line="324" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 203</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_COLON>
	<KP_HASH public="1" get="inline" set="null" expr="cast 204" line="325" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 204</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_HASH>
	<KP_SPACE public="1" get="inline" set="null" expr="cast 205" line="326" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 205</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_SPACE>
	<KP_AT public="1" get="inline" set="null" expr="cast 206" line="327" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 206</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_AT>
	<KP_EXCLAM public="1" get="inline" set="null" expr="cast 207" line="328" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 207</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_EXCLAM>
	<KP_MEMSTORE public="1" get="inline" set="null" expr="cast 208" line="329" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 208</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMSTORE>
	<KP_MEMRECALL public="1" get="inline" set="null" expr="cast 209" line="330" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 209</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMRECALL>
	<KP_MEMCLEAR public="1" get="inline" set="null" expr="cast 210" line="331" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 210</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMCLEAR>
	<KP_MEMADD public="1" get="inline" set="null" expr="cast 211" line="332" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 211</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMADD>
	<KP_MEMSUBTRACT public="1" get="inline" set="null" expr="cast 212" line="333" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 212</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMSUBTRACT>
	<KP_MEMMULTIPLY public="1" get="inline" set="null" expr="cast 213" line="334" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 213</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMMULTIPLY>
	<KP_MEMDIVIDE public="1" get="inline" set="null" expr="cast 214" line="335" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 214</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_MEMDIVIDE>
	<KP_PLUSMINUS public="1" get="inline" set="null" expr="cast 215" line="336" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 215</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_PLUSMINUS>
	<KP_CLEAR public="1" get="inline" set="null" expr="cast 216" line="337" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 216</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_CLEAR>
	<KP_CLEARENTRY public="1" get="inline" set="null" expr="cast 217" line="338" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 217</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_CLEARENTRY>
	<KP_BINARY public="1" get="inline" set="null" expr="cast 218" line="339" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 218</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_BINARY>
	<KP_OCTAL public="1" get="inline" set="null" expr="cast 219" line="340" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 219</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_OCTAL>
	<KP_DECIMAL public="1" get="inline" set="null" expr="cast 220" line="341" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 220</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_DECIMAL>
	<KP_HEXADECIMAL public="1" get="inline" set="null" expr="cast 221" line="342" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 221</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KP_HEXADECIMAL>
	<LCTRL public="1" get="inline" set="null" expr="cast 224" line="344" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 224</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LCTRL>
	<LSHIFT public="1" get="inline" set="null" expr="cast 225" line="345" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 225</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LSHIFT>
	<LALT public="1" get="inline" set="null" expr="cast 226" line="347" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 226</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LALT>
	<LMETA public="1" get="inline" set="null" expr="cast 227" line="349" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 227</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LMETA>
	<RCTRL public="1" get="inline" set="null" expr="cast 228" line="350" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 228</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RCTRL>
	<RSHIFT public="1" get="inline" set="null" expr="cast 229" line="351" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 229</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RSHIFT>
	<RALT public="1" get="inline" set="null" expr="cast 230" line="353" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 230</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RALT>
	<RMETA public="1" get="inline" set="null" expr="cast 231" line="355" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 231</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RMETA>
	<MODE public="1" get="inline" set="null" expr="cast 257" line="360" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 257</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MODE>
	<AUDIONEXT public="1" get="inline" set="null" expr="cast 258" line="366" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 258</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIONEXT>
	<AUDIOPREV public="1" get="inline" set="null" expr="cast 259" line="367" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 259</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOPREV>
	<AUDIOSTOP public="1" get="inline" set="null" expr="cast 260" line="368" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 260</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOSTOP>
	<AUDIOPLAY public="1" get="inline" set="null" expr="cast 261" line="369" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 261</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOPLAY>
	<AUDIOMUTE public="1" get="inline" set="null" expr="cast 262" line="370" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 262</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUDIOMUTE>
	<MEDIASELECT public="1" get="inline" set="null" expr="cast 263" line="371" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 263</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MEDIASELECT>
	<WWW public="1" get="inline" set="null" expr="cast 264" line="372" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 264</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WWW>
	<MAIL public="1" get="inline" set="null" expr="cast 265" line="373" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 265</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MAIL>
	<CALCULATOR public="1" get="inline" set="null" expr="cast 266" line="374" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 266</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CALCULATOR>
	<COMPUTER public="1" get="inline" set="null" expr="cast 267" line="375" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 267</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COMPUTER>
	<AC_SEARCH public="1" get="inline" set="null" expr="cast 268" line="376" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 268</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_SEARCH>
	<AC_HOME public="1" get="inline" set="null" expr="cast 269" line="377" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 269</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_HOME>
	<AC_BACK public="1" get="inline" set="null" expr="cast 270" line="378" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 270</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_BACK>
	<AC_FORWARD public="1" get="inline" set="null" expr="cast 271" line="379" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 271</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_FORWARD>
	<AC_STOP public="1" get="inline" set="null" expr="cast 272" line="380" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 272</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_STOP>
	<AC_REFRESH public="1" get="inline" set="null" expr="cast 273" line="381" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 273</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_REFRESH>
	<AC_BOOKMARKS public="1" get="inline" set="null" expr="cast 274" line="382" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 274</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AC_BOOKMARKS>
	<BRIGHTNESSDOWN public="1" get="inline" set="null" expr="cast 275" line="387" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 275</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BRIGHTNESSDOWN>
	<BRIGHTNESSUP public="1" get="inline" set="null" expr="cast 276" line="388" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 276</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BRIGHTNESSUP>
	<DISPLAYSWITCH public="1" get="inline" set="null" expr="cast 277" line="391" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 277</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DISPLAYSWITCH>
	<KBDILLUMTOGGLE public="1" get="inline" set="null" expr="cast 278" line="393" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 278</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KBDILLUMTOGGLE>
	<KBDILLUMDOWN public="1" get="inline" set="null" expr="cast 279" line="394" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 279</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KBDILLUMDOWN>
	<KBDILLUMUP public="1" get="inline" set="null" expr="cast 280" line="395" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 280</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</KBDILLUMUP>
	<EJECT public="1" get="inline" set="null" expr="cast 281" line="396" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 281</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EJECT>
	<SLEEP public="1" get="inline" set="null" expr="cast 282" line="397" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 282</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SLEEP>
	<APP1 public="1" get="inline" set="null" expr="cast 283" line="399" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 283</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</APP1>
	<APP2 public="1" get="inline" set="null" expr="cast 284" line="400" static="1">
		<x path="ceramic.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 284</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</APP2>
	<scanCodeNames expr="[null, null, null, null, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;0&quot;, &quot;Enter&quot;, &quot;Escape&quot;, &quot;Backspace&quot;, &quot;Tab&quot;, &quot;Space&quot;, &quot;-&quot;, &quot;=&quot;, &quot;[&quot;, &quot;]&quot;, &quot;\\&quot;, &quot;#&quot;, &quot;;&quot;, &quot;&apos;&quot;, &quot;`&quot;, &quot;,&quot;, &quot;.&quot;, &quot;/&quot;, &quot;CapsLock&quot;, &quot;F1&quot;, &quot;F2&quot;, &quot;F3&quot;, &quot;F4&quot;, &quot;F5&quot;, &quot;F6&quot;, &quot;F7&quot;, &quot;F8&quot;, &quot;F9&quot;, &quot;F10&quot;, &quot;F11&quot;, &quot;F12&quot;, &quot;PrintScreen&quot;, &quot;ScrollLock&quot;, &quot;Pause&quot;, &quot;Insert&quot;, &quot;Home&quot;, &quot;PageUp&quot;, &quot;Delete&quot;, &quot;End&quot;, &quot;PageDown&quot;, &quot;Right&quot;, &quot;Left&quot;, &quot;Down&quot;, &quot;Up&quot;, &quot;Numlock&quot;, &quot;Keypad /&quot;, &quot;Keypad *&quot;, &quot;Keypad -&quot;, &quot;Keypad +&quot;, &quot;Keypad Enter&quot;, &quot;Keypad 1&quot;, &quot;Keypad 2&quot;, &quot;Keypad 3&quot;, &quot;Keypad 4&quot;, &quot;Keypad 5&quot;, &quot;Keypad 6&quot;, &quot;Keypad 7&quot;, &quot;Keypad 8&quot;, &quot;Keypad 9&quot;, &quot;Keypad 0&quot;, &quot;Keypad .&quot;, null, &quot;Application&quot;, &quot;Power&quot;, &quot;Keypad =&quot;, &quot;F13&quot;, &quot;F14&quot;, &quot;F15&quot;, &quot;F16&quot;, &quot;F17&quot;, &quot;F18&quot;, &quot;F19&quot;, &quot;F20&quot;, &quot;F21&quot;, &quot;F22&quot;, &quot;F23&quot;, &quot;F24&quot;, &quot;Execute&quot;, &quot;Help&quot;, &quot;Menu&quot;, &quot;Select&quot;, &quot;Stop&quot;, &quot;Again&quot;, &quot;Undo&quot;, &quot;Cut&quot;, &quot;Copy&quot;, &quot;Paste&quot;, &quot;Find&quot;, &quot;Mute&quot;, &quot;VolumeUp&quot;, &quot;VolumeDown&quot;, null, null, null, &quot;Keypad ,&quot;, &quot;Keypad = (AS400)&quot;, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;AltErase&quot;, &quot;SysReq&quot;, &quot;Cancel&quot;, &quot;Clear&quot;, &quot;Prior&quot;, &quot;Enter&quot;, &quot;Separator&quot;, &quot;Out&quot;, &quot;Oper&quot;, &quot;Clear / Again&quot;, &quot;CrSel&quot;, &quot;ExSel&quot;, null, null, null, null, null, null, null, null, null, null, null, &quot;Keypad 00&quot;, &quot;Keypad 000&quot;, &quot;ThousandsSeparator&quot;, &quot;DecimalSeparator&quot;, &quot;CurrencyUnit&quot;, &quot;CurrencySubUnit&quot;, &quot;Keypad (&quot;, &quot;Keypad )&quot;, &quot;Keypad {&quot;, &quot;Keypad }&quot;, &quot;Keypad Tab&quot;, &quot;Keypad Backspace&quot;, &quot;Keypad A&quot;, &quot;Keypad B&quot;, &quot;Keypad C&quot;, &quot;Keypad D&quot;, &quot;Keypad E&quot;, &quot;Keypad F&quot;, &quot;Keypad XOR&quot;, &quot;Keypad ^&quot;, &quot;Keypad %&quot;, &quot;Keypad &lt;&quot;, &quot;Keypad &gt;&quot;, &quot;Keypad &amp;&quot;, &quot;Keypad &amp;&amp;&quot;, &quot;Keypad |&quot;, &quot;Keypad ||&quot;, &quot;Keypad :&quot;, &quot;Keypad #&quot;, &quot;Keypad Space&quot;, &quot;Keypad @&quot;, &quot;Keypad !&quot;, &quot;Keypad MemStore&quot;, &quot;Keypad MemRecall&quot;, &quot;Keypad MemClear&quot;, &quot;Keypad MemAdd&quot;, &quot;Keypad MemSubtract&quot;, &quot;Keypad MemMultiply&quot;, &quot;Keypad MemDivide&quot;, &quot;Keypad +/-&quot;, &quot;Keypad Clear&quot;, &quot;Keypad ClearEntry&quot;, &quot;Keypad Binary&quot;, &quot;Keypad Octal&quot;, &quot;Keypad Decimal&quot;, &quot;Keypad Hexadecimal&quot;, null, null, &quot;Left Ctrl&quot;, &quot;Left Shift&quot;, &quot;Left Alt&quot;, &quot;Left Meta&quot;, &quot;Right Ctrl&quot;, &quot;Right Shift&quot;, &quot;Right Alt&quot;, &quot;Right Meta&quot;, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;ModeSwitch&quot;, &quot;AudioNext&quot;, &quot;AudioPrev&quot;, &quot;AudioStop&quot;, &quot;AudioPlay&quot;, &quot;AudioMute&quot;, &quot;MediaSelect&quot;, &quot;WWW&quot;, &quot;Mail&quot;, &quot;Calculator&quot;, &quot;Computer&quot;, &quot;AC Search&quot;, &quot;AC Home&quot;, &quot;AC Back&quot;, &quot;AC Forward&quot;, &quot;AC Stop&quot;, &quot;AC Refresh&quot;, &quot;AC Bookmarks&quot;, &quot;BrightnessDown&quot;, &quot;BrightnessUp&quot;, &quot;DisplaySwitch&quot;, &quot;KBDIllumToggle&quot;, &quot;KBDIllumDown&quot;, &quot;KBDIllumUp&quot;, &quot;Eject&quot;, &quot;Sleep&quot;]" line="402" static="1">
		<c path="Array"><c path="String"/></c>
		<meta><m n=":value"><e><![CDATA[[null, null, null, null, "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "Enter", "Escape", "Backspace", "Tab", "Space", "-", "=", "[", "]", "\\", "#", ";", "'", "`", ",", ".", "/", "CapsLock", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "PrintScreen", "ScrollLock", "Pause", "Insert", "Home", "PageUp", "Delete", "End", "PageDown", "Right", "Left", "Down", "Up", "Numlock", "Keypad /", "Keypad *", "Keypad -", "Keypad +", "Keypad Enter", "Keypad 1", "Keypad 2", "Keypad 3", "Keypad 4", "Keypad 5", "Keypad 6", "Keypad 7", "Keypad 8", "Keypad 9", "Keypad 0", "Keypad .", null, "Application", "Power", "Keypad =", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "Execute", "Help", "Menu", "Select", "Stop", "Again", "Undo", "Cut", "Copy", "Paste", "Find", "Mute", "VolumeUp", "VolumeDown", null, null, null, "Keypad ,", "Keypad = (AS400)", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "AltErase", "SysReq", "Cancel", "Clear", "Prior", "Enter", "Separator", "Out", "Oper", "Clear / Again", "CrSel", "ExSel", null, null, null, null, null, null, null, null, null, null, null, "Keypad 00", "Keypad 000", "ThousandsSeparator", "DecimalSeparator", "CurrencyUnit", "CurrencySubUnit", "Keypad (", "Keypad )", "Keypad {", "Keypad }", "Keypad Tab", "Keypad Backspace", "Keypad A", "Keypad B", "Keypad C", "Keypad D", "Keypad E", "Keypad F", "Keypad XOR", "Keypad ^", "Keypad %", "Keypad <", "Keypad >", "Keypad &", "Keypad &&", "Keypad |", "Keypad ||", "Keypad :", "Keypad #", "Keypad Space", "Keypad @", "Keypad !", "Keypad MemStore", "Keypad MemRecall", "Keypad MemClear", "Keypad MemAdd", "Keypad MemSubtract", "Keypad MemMultiply", "Keypad MemDivide", "Keypad +/-", "Keypad Clear", "Keypad ClearEntry", "Keypad Binary", "Keypad Octal", "Keypad Decimal", "Keypad Hexadecimal", null, null, "Left Ctrl", "Left Shift", "Left Alt", "Left Meta", "Right Ctrl", "Right Shift", "Right Alt", "Right Meta", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "ModeSwitch", "AudioNext", "AudioPrev", "AudioStop", "AudioPlay", "AudioMute", "MediaSelect", "WWW", "Mail", "Calculator", "Computer", "AC Search", "AC Home", "AC Back", "AC Forward", "AC Stop", "AC Refresh", "AC Bookmarks", "BrightnessDown", "BrightnessUp", "DisplaySwitch", "KBDIllumToggle", "KBDIllumDown", "KBDIllumUp", "Eject", "Sleep"]]]></e></m></meta>
	</scanCodeNames>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._ScanCode.ScanCode_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScanCode.hx" private="1" module="ceramic.ScanCode" final="1">
		<name public="1" set="method" line="16" static="1">
			<f a="scanCode">
				<x path="ceramic.ScanCode"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Convert a scanCode to a readable name</haxe_doc>
		</name>
		<toString set="method" line="28" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<MASK public="1" expr="(1 &lt;&lt; 30)" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e><![CDATA[(1 << 30)]]></e></m></meta>
		</MASK>
		<UNKNOWN public="1" get="inline" set="null" expr="cast 0" line="37" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNKNOWN>
		<KEY_A public="1" get="inline" set="null" expr="cast 4" line="42" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_A>
		<KEY_B public="1" get="inline" set="null" expr="cast 5" line="43" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_B>
		<KEY_C public="1" get="inline" set="null" expr="cast 6" line="44" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_C>
		<KEY_D public="1" get="inline" set="null" expr="cast 7" line="45" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_D>
		<KEY_E public="1" get="inline" set="null" expr="cast 8" line="46" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_E>
		<KEY_F public="1" get="inline" set="null" expr="cast 9" line="47" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_F>
		<KEY_G public="1" get="inline" set="null" expr="cast 10" line="48" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_G>
		<KEY_H public="1" get="inline" set="null" expr="cast 11" line="49" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_H>
		<KEY_I public="1" get="inline" set="null" expr="cast 12" line="50" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_I>
		<KEY_J public="1" get="inline" set="null" expr="cast 13" line="51" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_J>
		<KEY_K public="1" get="inline" set="null" expr="cast 14" line="52" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_K>
		<KEY_L public="1" get="inline" set="null" expr="cast 15" line="53" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_L>
		<KEY_M public="1" get="inline" set="null" expr="cast 16" line="54" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_M>
		<KEY_N public="1" get="inline" set="null" expr="cast 17" line="55" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 17</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_N>
		<KEY_O public="1" get="inline" set="null" expr="cast 18" line="56" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 18</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_O>
		<KEY_P public="1" get="inline" set="null" expr="cast 19" line="57" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 19</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_P>
		<KEY_Q public="1" get="inline" set="null" expr="cast 20" line="58" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_Q>
		<KEY_R public="1" get="inline" set="null" expr="cast 21" line="59" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 21</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_R>
		<KEY_S public="1" get="inline" set="null" expr="cast 22" line="60" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 22</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_S>
		<KEY_T public="1" get="inline" set="null" expr="cast 23" line="61" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 23</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_T>
		<KEY_U public="1" get="inline" set="null" expr="cast 24" line="62" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 24</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_U>
		<KEY_V public="1" get="inline" set="null" expr="cast 25" line="63" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 25</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_V>
		<KEY_W public="1" get="inline" set="null" expr="cast 26" line="64" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 26</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_W>
		<KEY_X public="1" get="inline" set="null" expr="cast 27" line="65" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 27</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_X>
		<KEY_Y public="1" get="inline" set="null" expr="cast 28" line="66" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 28</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_Y>
		<KEY_Z public="1" get="inline" set="null" expr="cast 29" line="67" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 29</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_Z>
		<KEY_1 public="1" get="inline" set="null" expr="cast 30" line="69" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 30</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_1>
		<KEY_2 public="1" get="inline" set="null" expr="cast 31" line="70" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 31</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_2>
		<KEY_3 public="1" get="inline" set="null" expr="cast 32" line="71" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 32</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_3>
		<KEY_4 public="1" get="inline" set="null" expr="cast 33" line="72" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 33</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_4>
		<KEY_5 public="1" get="inline" set="null" expr="cast 34" line="73" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 34</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_5>
		<KEY_6 public="1" get="inline" set="null" expr="cast 35" line="74" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 35</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_6>
		<KEY_7 public="1" get="inline" set="null" expr="cast 36" line="75" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 36</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_7>
		<KEY_8 public="1" get="inline" set="null" expr="cast 37" line="76" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 37</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_8>
		<KEY_9 public="1" get="inline" set="null" expr="cast 38" line="77" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 38</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_9>
		<KEY_0 public="1" get="inline" set="null" expr="cast 39" line="78" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 39</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KEY_0>
		<ENTER public="1" get="inline" set="null" expr="cast 40" line="80" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 40</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ENTER>
		<ESCAPE public="1" get="inline" set="null" expr="cast 41" line="81" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 41</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ESCAPE>
		<BACKSPACE public="1" get="inline" set="null" expr="cast 42" line="82" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 42</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BACKSPACE>
		<TAB public="1" get="inline" set="null" expr="cast 43" line="83" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 43</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TAB>
		<SPACE public="1" get="inline" set="null" expr="cast 44" line="84" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 44</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SPACE>
		<MINUS public="1" get="inline" set="null" expr="cast 45" line="86" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 45</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MINUS>
		<EQUALS public="1" get="inline" set="null" expr="cast 46" line="87" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 46</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EQUALS>
		<LEFTBRACKET public="1" get="inline" set="null" expr="cast 47" line="88" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 47</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFTBRACKET>
		<RIGHTBRACKET public="1" get="inline" set="null" expr="cast 48" line="89" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 48</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHTBRACKET>
		<BACKSLASH public="1" get="inline" set="null" expr="cast 49" line="105" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 49</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BACKSLASH>
		<NONUSHASH public="1" get="inline" set="null" expr="cast 50" line="119" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 50</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONUSHASH>
		<SEMICOLON public="1" get="inline" set="null" expr="cast 51" line="120" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 51</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SEMICOLON>
		<APOSTROPHE public="1" get="inline" set="null" expr="cast 52" line="121" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 52</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</APOSTROPHE>
		<GRAVE public="1" get="inline" set="null" expr="cast 53" line="140" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 53</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</GRAVE>
		<COMMA public="1" get="inline" set="null" expr="cast 54" line="141" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 54</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COMMA>
		<PERIOD public="1" get="inline" set="null" expr="cast 55" line="142" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 55</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" expr="cast 56" line="143" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 56</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SLASH>
		<CAPSLOCK public="1" get="inline" set="null" expr="cast 57" line="145" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 57</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CAPSLOCK>
		<F1 public="1" get="inline" set="null" expr="cast 58" line="147" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 58</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="cast 59" line="148" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 59</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="cast 60" line="149" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 60</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="cast 61" line="150" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 61</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="cast 62" line="151" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 62</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="cast 63" line="152" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 63</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="cast 64" line="153" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 64</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="cast 65" line="154" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 65</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="cast 66" line="155" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 66</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="cast 67" line="156" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 67</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="cast 68" line="157" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 68</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="cast 69" line="158" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 69</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F12>
		<PRINTSCREEN public="1" get="inline" set="null" expr="cast 70" line="160" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 70</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PRINTSCREEN>
		<SCROLLLOCK public="1" get="inline" set="null" expr="cast 71" line="161" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 71</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCROLLLOCK>
		<PAUSE public="1" get="inline" set="null" expr="cast 72" line="162" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 72</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAUSE>
		<INSERT public="1" get="inline" set="null" expr="cast 73" line="165" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 73</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INSERT>
		<HOME public="1" get="inline" set="null" expr="cast 74" line="166" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 74</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HOME>
		<PAGEUP public="1" get="inline" set="null" expr="cast 75" line="167" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 75</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAGEUP>
		<DELETE public="1" get="inline" set="null" expr="cast 76" line="168" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 76</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DELETE>
		<END public="1" get="inline" set="null" expr="cast 77" line="169" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 77</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</END>
		<PAGEDOWN public="1" get="inline" set="null" expr="cast 78" line="170" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 78</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PAGEDOWN>
		<RIGHT public="1" get="inline" set="null" expr="cast 79" line="171" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 79</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT>
		<LEFT public="1" get="inline" set="null" expr="cast 80" line="172" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 80</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT>
		<DOWN public="1" get="inline" set="null" expr="cast 81" line="173" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 81</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DOWN>
		<UP public="1" get="inline" set="null" expr="cast 82" line="174" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 82</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UP>
		<NUMLOCKCLEAR public="1" get="inline" set="null" expr="cast 83" line="177" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 83</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NUMLOCKCLEAR>
		<KP_DIVIDE public="1" get="inline" set="null" expr="cast 84" line="178" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 84</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DIVIDE>
		<KP_MULTIPLY public="1" get="inline" set="null" expr="cast 85" line="179" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 85</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MULTIPLY>
		<KP_MINUS public="1" get="inline" set="null" expr="cast 86" line="180" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 86</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MINUS>
		<KP_PLUS public="1" get="inline" set="null" expr="cast 87" line="181" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 87</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PLUS>
		<KP_ENTER public="1" get="inline" set="null" expr="cast 88" line="182" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 88</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_ENTER>
		<KP_1 public="1" get="inline" set="null" expr="cast 89" line="183" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 89</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_1>
		<KP_2 public="1" get="inline" set="null" expr="cast 90" line="184" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 90</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_2>
		<KP_3 public="1" get="inline" set="null" expr="cast 91" line="185" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 91</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_3>
		<KP_4 public="1" get="inline" set="null" expr="cast 92" line="186" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 92</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_4>
		<KP_5 public="1" get="inline" set="null" expr="cast 93" line="187" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 93</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_5>
		<KP_6 public="1" get="inline" set="null" expr="cast 94" line="188" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 94</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_6>
		<KP_7 public="1" get="inline" set="null" expr="cast 95" line="189" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 95</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_7>
		<KP_8 public="1" get="inline" set="null" expr="cast 96" line="190" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 96</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_8>
		<KP_9 public="1" get="inline" set="null" expr="cast 97" line="191" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 97</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_9>
		<KP_0 public="1" get="inline" set="null" expr="cast 98" line="192" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 98</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_0>
		<KP_PERIOD public="1" get="inline" set="null" expr="cast 99" line="193" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 99</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PERIOD>
		<NONUSBACKSLASH public="1" get="inline" set="null" expr="cast 100" line="206" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 100</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONUSBACKSLASH>
		<APPLICATION public="1" get="inline" set="null" expr="cast 101" line="209" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 101</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</APPLICATION>
		<POWER public="1" get="inline" set="null" expr="cast 102" line="214" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 102</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</POWER>
		<KP_EQUALS public="1" get="inline" set="null" expr="cast 103" line="215" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 103</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_EQUALS>
		<F13 public="1" get="inline" set="null" expr="cast 104" line="216" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 104</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F13>
		<F14 public="1" get="inline" set="null" expr="cast 105" line="217" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 105</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F14>
		<F15 public="1" get="inline" set="null" expr="cast 106" line="218" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 106</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F15>
		<F16 public="1" get="inline" set="null" expr="cast 107" line="219" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 107</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F16>
		<F17 public="1" get="inline" set="null" expr="cast 108" line="220" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 108</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F17>
		<F18 public="1" get="inline" set="null" expr="cast 109" line="221" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 109</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F18>
		<F19 public="1" get="inline" set="null" expr="cast 110" line="222" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 110</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F19>
		<F20 public="1" get="inline" set="null" expr="cast 111" line="223" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 111</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F20>
		<F21 public="1" get="inline" set="null" expr="cast 112" line="224" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 112</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F21>
		<F22 public="1" get="inline" set="null" expr="cast 113" line="225" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 113</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F22>
		<F23 public="1" get="inline" set="null" expr="cast 114" line="226" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 114</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F23>
		<F24 public="1" get="inline" set="null" expr="cast 115" line="227" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 115</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</F24>
		<EXECUTE public="1" get="inline" set="null" expr="cast 116" line="228" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 116</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EXECUTE>
		<HELP public="1" get="inline" set="null" expr="cast 117" line="229" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 117</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HELP>
		<MENU public="1" get="inline" set="null" expr="cast 118" line="230" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 118</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MENU>
		<SELECT public="1" get="inline" set="null" expr="cast 119" line="231" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 119</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SELECT>
		<STOP public="1" get="inline" set="null" expr="cast 120" line="232" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 120</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</STOP>
		<AGAIN public="1" get="inline" set="null" expr="cast 121" line="235" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 121</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AGAIN>
		<UNDO public="1" get="inline" set="null" expr="cast 122" line="236" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 122</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNDO>
		<CUT public="1" get="inline" set="null" expr="cast 123" line="237" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 123</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CUT>
		<COPY public="1" get="inline" set="null" expr="cast 124" line="238" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 124</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COPY>
		<PASTE public="1" get="inline" set="null" expr="cast 125" line="239" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 125</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PASTE>
		<FIND public="1" get="inline" set="null" expr="cast 126" line="240" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 126</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</FIND>
		<MUTE public="1" get="inline" set="null" expr="cast 127" line="241" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 127</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MUTE>
		<VOLUMEUP public="1" get="inline" set="null" expr="cast 128" line="242" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 128</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VOLUMEUP>
		<VOLUMEDOWN public="1" get="inline" set="null" expr="cast 129" line="243" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 129</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VOLUMEDOWN>
		<KP_COMMA public="1" get="inline" set="null" expr="cast 133" line="250" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 133</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_COMMA>
		<KP_EQUALSAS400 public="1" get="inline" set="null" expr="cast 134" line="251" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 134</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_EQUALSAS400>
		<INTERNATIONAL1 public="1" get="inline" set="null" expr="cast 135" line="254" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 135</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL1>
		<INTERNATIONAL2 public="1" get="inline" set="null" expr="cast 136" line="255" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 136</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL2>
		<INTERNATIONAL3 public="1" get="inline" set="null" expr="cast 137" line="258" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 137</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL3>
		<INTERNATIONAL4 public="1" get="inline" set="null" expr="cast 138" line="259" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 138</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL4>
		<INTERNATIONAL5 public="1" get="inline" set="null" expr="cast 139" line="260" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 139</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL5>
		<INTERNATIONAL6 public="1" get="inline" set="null" expr="cast 140" line="261" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 140</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL6>
		<INTERNATIONAL7 public="1" get="inline" set="null" expr="cast 141" line="262" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 141</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL7>
		<INTERNATIONAL8 public="1" get="inline" set="null" expr="cast 142" line="263" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 142</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL8>
		<INTERNATIONAL9 public="1" get="inline" set="null" expr="cast 143" line="264" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 143</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INTERNATIONAL9>
		<LANG1 public="1" get="inline" set="null" expr="cast 144" line="266" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 144</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG1>
		<LANG2 public="1" get="inline" set="null" expr="cast 145" line="268" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 145</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG2>
		<LANG3 public="1" get="inline" set="null" expr="cast 146" line="270" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 146</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG3>
		<LANG4 public="1" get="inline" set="null" expr="cast 147" line="272" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 147</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG4>
		<LANG5 public="1" get="inline" set="null" expr="cast 148" line="274" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 148</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG5>
		<LANG6 public="1" get="inline" set="null" expr="cast 149" line="276" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 149</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG6>
		<LANG7 public="1" get="inline" set="null" expr="cast 150" line="278" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 150</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG7>
		<LANG8 public="1" get="inline" set="null" expr="cast 151" line="280" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 151</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG8>
		<LANG9 public="1" get="inline" set="null" expr="cast 152" line="282" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 152</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANG9>
		<ALTERASE public="1" get="inline" set="null" expr="cast 153" line="284" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 153</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ALTERASE>
		<SYSREQ public="1" get="inline" set="null" expr="cast 154" line="285" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 154</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SYSREQ>
		<CANCEL public="1" get="inline" set="null" expr="cast 155" line="286" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 155</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CANCEL>
		<CLEAR public="1" get="inline" set="null" expr="cast 156" line="287" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 156</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CLEAR>
		<PRIOR public="1" get="inline" set="null" expr="cast 157" line="288" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 157</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PRIOR>
		<RETURN2 public="1" get="inline" set="null" expr="cast 158" line="289" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 158</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RETURN2>
		<SEPARATOR public="1" get="inline" set="null" expr="cast 159" line="290" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 159</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SEPARATOR>
		<OUT public="1" get="inline" set="null" expr="cast 160" line="291" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 160</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OUT>
		<OPER public="1" get="inline" set="null" expr="cast 161" line="292" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 161</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OPER>
		<CLEARAGAIN public="1" get="inline" set="null" expr="cast 162" line="293" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 162</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CLEARAGAIN>
		<CRSEL public="1" get="inline" set="null" expr="cast 163" line="294" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 163</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CRSEL>
		<EXSEL public="1" get="inline" set="null" expr="cast 164" line="295" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 164</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EXSEL>
		<KP_00 public="1" get="inline" set="null" expr="cast 176" line="297" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 176</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_00>
		<KP_000 public="1" get="inline" set="null" expr="cast 177" line="298" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 177</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_000>
		<THOUSANDSSEPARATOR public="1" get="inline" set="null" expr="cast 178" line="299" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 178</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</THOUSANDSSEPARATOR>
		<DECIMALSEPARATOR public="1" get="inline" set="null" expr="cast 179" line="300" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 179</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DECIMALSEPARATOR>
		<CURRENCYUNIT public="1" get="inline" set="null" expr="cast 180" line="301" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 180</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CURRENCYUNIT>
		<CURRENCYSUBUNIT public="1" get="inline" set="null" expr="cast 181" line="302" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 181</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CURRENCYSUBUNIT>
		<KP_LEFTPAREN public="1" get="inline" set="null" expr="cast 182" line="303" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 182</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_LEFTPAREN>
		<KP_RIGHTPAREN public="1" get="inline" set="null" expr="cast 183" line="304" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 183</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_RIGHTPAREN>
		<KP_LEFTBRACE public="1" get="inline" set="null" expr="cast 184" line="305" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 184</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_LEFTBRACE>
		<KP_RIGHTBRACE public="1" get="inline" set="null" expr="cast 185" line="306" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 185</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_RIGHTBRACE>
		<KP_TAB public="1" get="inline" set="null" expr="cast 186" line="307" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 186</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_TAB>
		<KP_BACKSPACE public="1" get="inline" set="null" expr="cast 187" line="308" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 187</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_BACKSPACE>
		<KP_A public="1" get="inline" set="null" expr="cast 188" line="309" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 188</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_A>
		<KP_B public="1" get="inline" set="null" expr="cast 189" line="310" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 189</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_B>
		<KP_C public="1" get="inline" set="null" expr="cast 190" line="311" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 190</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_C>
		<KP_D public="1" get="inline" set="null" expr="cast 191" line="312" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 191</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_D>
		<KP_E public="1" get="inline" set="null" expr="cast 192" line="313" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 192</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_E>
		<KP_F public="1" get="inline" set="null" expr="cast 193" line="314" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 193</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_F>
		<KP_XOR public="1" get="inline" set="null" expr="cast 194" line="315" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 194</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_XOR>
		<KP_POWER public="1" get="inline" set="null" expr="cast 195" line="316" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 195</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_POWER>
		<KP_PERCENT public="1" get="inline" set="null" expr="cast 196" line="317" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 196</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PERCENT>
		<KP_LESS public="1" get="inline" set="null" expr="cast 197" line="318" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 197</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_LESS>
		<KP_GREATER public="1" get="inline" set="null" expr="cast 198" line="319" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 198</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_GREATER>
		<KP_AMPERSAND public="1" get="inline" set="null" expr="cast 199" line="320" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 199</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_AMPERSAND>
		<KP_DBLAMPERSAND public="1" get="inline" set="null" expr="cast 200" line="321" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 200</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DBLAMPERSAND>
		<KP_VERTICALBAR public="1" get="inline" set="null" expr="cast 201" line="322" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 201</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_VERTICALBAR>
		<KP_DBLVERTICALBAR public="1" get="inline" set="null" expr="cast 202" line="323" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 202</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DBLVERTICALBAR>
		<KP_COLON public="1" get="inline" set="null" expr="cast 203" line="324" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 203</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_COLON>
		<KP_HASH public="1" get="inline" set="null" expr="cast 204" line="325" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 204</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_HASH>
		<KP_SPACE public="1" get="inline" set="null" expr="cast 205" line="326" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 205</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_SPACE>
		<KP_AT public="1" get="inline" set="null" expr="cast 206" line="327" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 206</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_AT>
		<KP_EXCLAM public="1" get="inline" set="null" expr="cast 207" line="328" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 207</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_EXCLAM>
		<KP_MEMSTORE public="1" get="inline" set="null" expr="cast 208" line="329" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 208</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMSTORE>
		<KP_MEMRECALL public="1" get="inline" set="null" expr="cast 209" line="330" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 209</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMRECALL>
		<KP_MEMCLEAR public="1" get="inline" set="null" expr="cast 210" line="331" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 210</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMCLEAR>
		<KP_MEMADD public="1" get="inline" set="null" expr="cast 211" line="332" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 211</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMADD>
		<KP_MEMSUBTRACT public="1" get="inline" set="null" expr="cast 212" line="333" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 212</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMSUBTRACT>
		<KP_MEMMULTIPLY public="1" get="inline" set="null" expr="cast 213" line="334" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 213</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMMULTIPLY>
		<KP_MEMDIVIDE public="1" get="inline" set="null" expr="cast 214" line="335" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 214</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_MEMDIVIDE>
		<KP_PLUSMINUS public="1" get="inline" set="null" expr="cast 215" line="336" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 215</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_PLUSMINUS>
		<KP_CLEAR public="1" get="inline" set="null" expr="cast 216" line="337" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 216</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_CLEAR>
		<KP_CLEARENTRY public="1" get="inline" set="null" expr="cast 217" line="338" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 217</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_CLEARENTRY>
		<KP_BINARY public="1" get="inline" set="null" expr="cast 218" line="339" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 218</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_BINARY>
		<KP_OCTAL public="1" get="inline" set="null" expr="cast 219" line="340" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 219</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_OCTAL>
		<KP_DECIMAL public="1" get="inline" set="null" expr="cast 220" line="341" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 220</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_DECIMAL>
		<KP_HEXADECIMAL public="1" get="inline" set="null" expr="cast 221" line="342" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 221</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KP_HEXADECIMAL>
		<LCTRL public="1" get="inline" set="null" expr="cast 224" line="344" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 224</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LCTRL>
		<LSHIFT public="1" get="inline" set="null" expr="cast 225" line="345" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 225</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LSHIFT>
		<LALT public="1" get="inline" set="null" expr="cast 226" line="347" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 226</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LALT>
		<LMETA public="1" get="inline" set="null" expr="cast 227" line="349" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 227</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LMETA>
		<RCTRL public="1" get="inline" set="null" expr="cast 228" line="350" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 228</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RCTRL>
		<RSHIFT public="1" get="inline" set="null" expr="cast 229" line="351" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 229</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RSHIFT>
		<RALT public="1" get="inline" set="null" expr="cast 230" line="353" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 230</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RALT>
		<RMETA public="1" get="inline" set="null" expr="cast 231" line="355" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 231</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RMETA>
		<MODE public="1" get="inline" set="null" expr="cast 257" line="360" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 257</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MODE>
		<AUDIONEXT public="1" get="inline" set="null" expr="cast 258" line="366" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 258</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIONEXT>
		<AUDIOPREV public="1" get="inline" set="null" expr="cast 259" line="367" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 259</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOPREV>
		<AUDIOSTOP public="1" get="inline" set="null" expr="cast 260" line="368" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 260</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOSTOP>
		<AUDIOPLAY public="1" get="inline" set="null" expr="cast 261" line="369" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 261</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOPLAY>
		<AUDIOMUTE public="1" get="inline" set="null" expr="cast 262" line="370" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 262</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUDIOMUTE>
		<MEDIASELECT public="1" get="inline" set="null" expr="cast 263" line="371" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 263</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MEDIASELECT>
		<WWW public="1" get="inline" set="null" expr="cast 264" line="372" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 264</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WWW>
		<MAIL public="1" get="inline" set="null" expr="cast 265" line="373" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 265</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MAIL>
		<CALCULATOR public="1" get="inline" set="null" expr="cast 266" line="374" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 266</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CALCULATOR>
		<COMPUTER public="1" get="inline" set="null" expr="cast 267" line="375" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 267</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COMPUTER>
		<AC_SEARCH public="1" get="inline" set="null" expr="cast 268" line="376" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 268</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_SEARCH>
		<AC_HOME public="1" get="inline" set="null" expr="cast 269" line="377" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 269</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_HOME>
		<AC_BACK public="1" get="inline" set="null" expr="cast 270" line="378" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 270</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_BACK>
		<AC_FORWARD public="1" get="inline" set="null" expr="cast 271" line="379" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 271</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_FORWARD>
		<AC_STOP public="1" get="inline" set="null" expr="cast 272" line="380" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 272</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_STOP>
		<AC_REFRESH public="1" get="inline" set="null" expr="cast 273" line="381" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 273</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_REFRESH>
		<AC_BOOKMARKS public="1" get="inline" set="null" expr="cast 274" line="382" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 274</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AC_BOOKMARKS>
		<BRIGHTNESSDOWN public="1" get="inline" set="null" expr="cast 275" line="387" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 275</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BRIGHTNESSDOWN>
		<BRIGHTNESSUP public="1" get="inline" set="null" expr="cast 276" line="388" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 276</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BRIGHTNESSUP>
		<DISPLAYSWITCH public="1" get="inline" set="null" expr="cast 277" line="391" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 277</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DISPLAYSWITCH>
		<KBDILLUMTOGGLE public="1" get="inline" set="null" expr="cast 278" line="393" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 278</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KBDILLUMTOGGLE>
		<KBDILLUMDOWN public="1" get="inline" set="null" expr="cast 279" line="394" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 279</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KBDILLUMDOWN>
		<KBDILLUMUP public="1" get="inline" set="null" expr="cast 280" line="395" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 280</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</KBDILLUMUP>
		<EJECT public="1" get="inline" set="null" expr="cast 281" line="396" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 281</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EJECT>
		<SLEEP public="1" get="inline" set="null" expr="cast 282" line="397" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 282</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SLEEP>
		<APP1 public="1" get="inline" set="null" expr="cast 283" line="399" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 283</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</APP1>
		<APP2 public="1" get="inline" set="null" expr="cast 284" line="400" static="1">
			<x path="ceramic.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 284</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</APP2>
		<scanCodeNames expr="[null, null, null, null, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;0&quot;, &quot;Enter&quot;, &quot;Escape&quot;, &quot;Backspace&quot;, &quot;Tab&quot;, &quot;Space&quot;, &quot;-&quot;, &quot;=&quot;, &quot;[&quot;, &quot;]&quot;, &quot;\\&quot;, &quot;#&quot;, &quot;;&quot;, &quot;&apos;&quot;, &quot;`&quot;, &quot;,&quot;, &quot;.&quot;, &quot;/&quot;, &quot;CapsLock&quot;, &quot;F1&quot;, &quot;F2&quot;, &quot;F3&quot;, &quot;F4&quot;, &quot;F5&quot;, &quot;F6&quot;, &quot;F7&quot;, &quot;F8&quot;, &quot;F9&quot;, &quot;F10&quot;, &quot;F11&quot;, &quot;F12&quot;, &quot;PrintScreen&quot;, &quot;ScrollLock&quot;, &quot;Pause&quot;, &quot;Insert&quot;, &quot;Home&quot;, &quot;PageUp&quot;, &quot;Delete&quot;, &quot;End&quot;, &quot;PageDown&quot;, &quot;Right&quot;, &quot;Left&quot;, &quot;Down&quot;, &quot;Up&quot;, &quot;Numlock&quot;, &quot;Keypad /&quot;, &quot;Keypad *&quot;, &quot;Keypad -&quot;, &quot;Keypad +&quot;, &quot;Keypad Enter&quot;, &quot;Keypad 1&quot;, &quot;Keypad 2&quot;, &quot;Keypad 3&quot;, &quot;Keypad 4&quot;, &quot;Keypad 5&quot;, &quot;Keypad 6&quot;, &quot;Keypad 7&quot;, &quot;Keypad 8&quot;, &quot;Keypad 9&quot;, &quot;Keypad 0&quot;, &quot;Keypad .&quot;, null, &quot;Application&quot;, &quot;Power&quot;, &quot;Keypad =&quot;, &quot;F13&quot;, &quot;F14&quot;, &quot;F15&quot;, &quot;F16&quot;, &quot;F17&quot;, &quot;F18&quot;, &quot;F19&quot;, &quot;F20&quot;, &quot;F21&quot;, &quot;F22&quot;, &quot;F23&quot;, &quot;F24&quot;, &quot;Execute&quot;, &quot;Help&quot;, &quot;Menu&quot;, &quot;Select&quot;, &quot;Stop&quot;, &quot;Again&quot;, &quot;Undo&quot;, &quot;Cut&quot;, &quot;Copy&quot;, &quot;Paste&quot;, &quot;Find&quot;, &quot;Mute&quot;, &quot;VolumeUp&quot;, &quot;VolumeDown&quot;, null, null, null, &quot;Keypad ,&quot;, &quot;Keypad = (AS400)&quot;, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;AltErase&quot;, &quot;SysReq&quot;, &quot;Cancel&quot;, &quot;Clear&quot;, &quot;Prior&quot;, &quot;Enter&quot;, &quot;Separator&quot;, &quot;Out&quot;, &quot;Oper&quot;, &quot;Clear / Again&quot;, &quot;CrSel&quot;, &quot;ExSel&quot;, null, null, null, null, null, null, null, null, null, null, null, &quot;Keypad 00&quot;, &quot;Keypad 000&quot;, &quot;ThousandsSeparator&quot;, &quot;DecimalSeparator&quot;, &quot;CurrencyUnit&quot;, &quot;CurrencySubUnit&quot;, &quot;Keypad (&quot;, &quot;Keypad )&quot;, &quot;Keypad {&quot;, &quot;Keypad }&quot;, &quot;Keypad Tab&quot;, &quot;Keypad Backspace&quot;, &quot;Keypad A&quot;, &quot;Keypad B&quot;, &quot;Keypad C&quot;, &quot;Keypad D&quot;, &quot;Keypad E&quot;, &quot;Keypad F&quot;, &quot;Keypad XOR&quot;, &quot;Keypad ^&quot;, &quot;Keypad %&quot;, &quot;Keypad &lt;&quot;, &quot;Keypad &gt;&quot;, &quot;Keypad &amp;&quot;, &quot;Keypad &amp;&amp;&quot;, &quot;Keypad |&quot;, &quot;Keypad ||&quot;, &quot;Keypad :&quot;, &quot;Keypad #&quot;, &quot;Keypad Space&quot;, &quot;Keypad @&quot;, &quot;Keypad !&quot;, &quot;Keypad MemStore&quot;, &quot;Keypad MemRecall&quot;, &quot;Keypad MemClear&quot;, &quot;Keypad MemAdd&quot;, &quot;Keypad MemSubtract&quot;, &quot;Keypad MemMultiply&quot;, &quot;Keypad MemDivide&quot;, &quot;Keypad +/-&quot;, &quot;Keypad Clear&quot;, &quot;Keypad ClearEntry&quot;, &quot;Keypad Binary&quot;, &quot;Keypad Octal&quot;, &quot;Keypad Decimal&quot;, &quot;Keypad Hexadecimal&quot;, null, null, &quot;Left Ctrl&quot;, &quot;Left Shift&quot;, &quot;Left Alt&quot;, &quot;Left Meta&quot;, &quot;Right Ctrl&quot;, &quot;Right Shift&quot;, &quot;Right Alt&quot;, &quot;Right Meta&quot;, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;ModeSwitch&quot;, &quot;AudioNext&quot;, &quot;AudioPrev&quot;, &quot;AudioStop&quot;, &quot;AudioPlay&quot;, &quot;AudioMute&quot;, &quot;MediaSelect&quot;, &quot;WWW&quot;, &quot;Mail&quot;, &quot;Calculator&quot;, &quot;Computer&quot;, &quot;AC Search&quot;, &quot;AC Home&quot;, &quot;AC Back&quot;, &quot;AC Forward&quot;, &quot;AC Stop&quot;, &quot;AC Refresh&quot;, &quot;AC Bookmarks&quot;, &quot;BrightnessDown&quot;, &quot;BrightnessUp&quot;, &quot;DisplaySwitch&quot;, &quot;KBDIllumToggle&quot;, &quot;KBDIllumDown&quot;, &quot;KBDIllumUp&quot;, &quot;Eject&quot;, &quot;Sleep&quot;]" line="402" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[[null, null, null, null, "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "Enter", "Escape", "Backspace", "Tab", "Space", "-", "=", "[", "]", "\\", "#", ";", "'", "`", ",", ".", "/", "CapsLock", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "PrintScreen", "ScrollLock", "Pause", "Insert", "Home", "PageUp", "Delete", "End", "PageDown", "Right", "Left", "Down", "Up", "Numlock", "Keypad /", "Keypad *", "Keypad -", "Keypad +", "Keypad Enter", "Keypad 1", "Keypad 2", "Keypad 3", "Keypad 4", "Keypad 5", "Keypad 6", "Keypad 7", "Keypad 8", "Keypad 9", "Keypad 0", "Keypad .", null, "Application", "Power", "Keypad =", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "Execute", "Help", "Menu", "Select", "Stop", "Again", "Undo", "Cut", "Copy", "Paste", "Find", "Mute", "VolumeUp", "VolumeDown", null, null, null, "Keypad ,", "Keypad = (AS400)", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "AltErase", "SysReq", "Cancel", "Clear", "Prior", "Enter", "Separator", "Out", "Oper", "Clear / Again", "CrSel", "ExSel", null, null, null, null, null, null, null, null, null, null, null, "Keypad 00", "Keypad 000", "ThousandsSeparator", "DecimalSeparator", "CurrencyUnit", "CurrencySubUnit", "Keypad (", "Keypad )", "Keypad {", "Keypad }", "Keypad Tab", "Keypad Backspace", "Keypad A", "Keypad B", "Keypad C", "Keypad D", "Keypad E", "Keypad F", "Keypad XOR", "Keypad ^", "Keypad %", "Keypad <", "Keypad >", "Keypad &", "Keypad &&", "Keypad |", "Keypad ||", "Keypad :", "Keypad #", "Keypad Space", "Keypad @", "Keypad !", "Keypad MemStore", "Keypad MemRecall", "Keypad MemClear", "Keypad MemAdd", "Keypad MemSubtract", "Keypad MemMultiply", "Keypad MemDivide", "Keypad +/-", "Keypad Clear", "Keypad ClearEntry", "Keypad Binary", "Keypad Octal", "Keypad Decimal", "Keypad Hexadecimal", null, null, "Left Ctrl", "Left Shift", "Left Alt", "Left Meta", "Right Ctrl", "Right Shift", "Right Alt", "Right Meta", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "ModeSwitch", "AudioNext", "AudioPrev", "AudioStop", "AudioPlay", "AudioMute", "MediaSelect", "WWW", "Mail", "Calculator", "Computer", "AC Search", "AC Home", "AC Back", "AC Forward", "AC Stop", "AC Refresh", "AC Bookmarks", "BrightnessDown", "BrightnessUp", "DisplaySwitch", "KBDIllumToggle", "KBDIllumDown", "KBDIllumUp", "Eject", "Sleep"]]]></e></m></meta>
		</scanCodeNames>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="ceramic.Scene" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Scene.hx">
		<extends path="ceramic.Layer"/>
		<implements path="tracker.Observable"/>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Scene"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Scene"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Scene"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Scene"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.Scene"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false" line="131">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<_assets expr="null" line="12">
			<c path="ceramic.Assets"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_assets>
		<invalidateStatus public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateStatus>
		<status expr="NONE" line="14">
			<x path="ceramic.SceneStatus"/>
			<meta>
				<m n=":value"><e>NONE</e></m>
				<m n="observe"/>
			</meta>
		</status>
		<unobservedStatus>
			<x path="ceramic.SceneStatus"/>
			<haxe_doc></haxe_doc>
		</unobservedStatus>
		<_dox_event_statusChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="ceramic.SceneStatus"/>
				<x path="ceramic.SceneStatus"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</_dox_event_statusChange>
		<emitStatusChange set="method" line="1095">
			<f a="current:previous">
				<x path="ceramic.SceneStatus"/>
				<x path="ceramic.SceneStatus"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</emitStatusChange>
		<onStatusChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="ceramic.SceneStatus"/>
					<x path="ceramic.SceneStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</onStatusChange>
		<onceStatusChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="ceramic.SceneStatus"/>
					<x path="ceramic.SceneStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</onceStatusChange>
		<offStatusChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="ceramic.SceneStatus"/>
					<x path="ceramic.SceneStatus"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</offStatusChange>
		<listensStatusChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when status field changes.</haxe_doc>
		</listensStatusChange>
		<assets public="1" get="accessor" set="accessor"><c path="ceramic.Assets"/></assets>
		<get_assets set="method" line="17"><f a=""><c path="ceramic.Assets"/></f></get_assets>
		<set_assets set="method" line="23"><f a="assets">
	<c path="ceramic.Assets"/>
	<c path="ceramic.Assets"/>
</f></set_assets>
		<isRootScene public="1" set="null" expr="false" line="30">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this scene is a root scene</haxe_doc>
		</isRootScene>
		<autoUpdate public="1" expr="true" line="39">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Set to `false` if you want to disable auto update on this scene object.
     * If auto update is disabled, you become responsible to explicitly call
     * `update(delta)` at every frame yourself. Use this if you want to have control over
     * when the animation update is actually happening. Don't use it to pause animation.
     * (animation can be paused with `paused` property instead)</haxe_doc>
		</autoUpdate>
		<autoUpdateWhenInactive public="1" expr="false" line="45">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If `autoUpdate` is enabled, setting `autoUpdateWhenInactive` to `true`
     * will keep updating the scene even when inactive.</haxe_doc>
		</autoUpdateWhenInactive>
		<paused public="1" expr="false" line="50">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Is this scene paused?</haxe_doc>
		</paused>
		<_boot set="method" line="62"><f a=""><x path="Void"/></f></_boot>
		<internalCreate set="method" line="85"><f a=""><x path="Void"/></f></internalCreate>
		<_fadeInDone set="method" line="94"><f a=""><x path="Void"/></f></_fadeInDone>
		<_handleAssetsComplete set="method" line="100"><f a="successful">
	<x path="Bool"/>
	<x path="Void"/>
</f></_handleAssetsComplete>
		<internalLoad set="method" line="111"><f a=""><x path="Void"/></f></internalLoad>
		<willEmitResize set="method" line="117" override="1"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitResize>
		<preload set="method" line="130">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this method to configure the scene, add assets to it...
     * example: `assets.add(Images.SOME_IMAGE);`
     * Added assets will be loaded automatically</haxe_doc>
		</preload>
		<load set="method" line="142">
			<f a="next">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override this method to perform any additional asynchronous loading.
     * `next()` must be called once the loading has finished so that the scene
     * can continue its createialization process.
     * @param next The callback to call once asynchronous loading is done</haxe_doc>
		</load>
		<create set="method" line="156">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called once the scene has finished its loading.
     * At this point, and after `create()`, `update(delta)` will be called at every frame until the scene gets destroyed</haxe_doc>
		</create>
		<ready public="1" set="method" line="165">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the scene's status becomes `READY`</haxe_doc>
		</ready>
		<update public="1" set="method" line="175">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called at every frame, but only after create() has been called and when the scene is not paused
     * @param delta</haxe_doc>
		</update>
		<resize public="1" set="method" line="186">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called if the scene size has been changed during this frame.
     * @param width new width
     * @param height new height</haxe_doc>
		</resize>
		<_fadeIn set="method" line="192">
			<f a="done">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_fadeIn>
		<_fadeOut set="method" line="198">
			<f a="done">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_fadeOut>
		<fadeIn public="1" set="method" line="211">
			<f a="done">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Play **fade-in** transition of this scene. This is automatically called right after
     * the scene is ready to use, meaning after `create()` has been called.
     * Default implementation does nothing and calls `done()` right away.
     * Override in subclasses to perform custom transitions.
     * @param done Called when the fade-in transition has finished.</haxe_doc>
		</fadeIn>
		<fadeOut public="1" set="method" line="231">
			<f a="done">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Play **fade-out** transition of this scene. This is called manually on secondary scene
     * but will be called automatically if the scene is the **main scene** and is replaced
     * by a new scene or simply removed.
     * @param done Called when the fade-out transition has finished.</haxe_doc>
		</fadeOut>
		<isReady public="1" set="method" line="244"><f a=""><x path="Bool"/></f></isReady>
		<scheduleOnceReady public="1" set="method" line="259"><f a="owner:callback">
	<c path="ceramic.Entity"/>
	<f a=""><x path="Void"/></f>
	<x path="Bool"/>
</f></scheduleOnceReady>
		<destroy public="1" set="method" line="285" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="52"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":allow"><e>ceramic.SceneSystem</e></m>
		</meta>
	</class>
	<abstract path="ceramic.SceneStatus" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SceneStatus.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._SceneStatus.SceneStatus_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SceneStatus.hx" private="1" module="ceramic.SceneStatus" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="8" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* No status. The scene is likely not assigned to anything.</haxe_doc>
	</NONE>
	<PRELOAD public="1" get="inline" set="null" expr="cast 1" line="14" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* The scene is calling the `preload()` method.
     * That happens when the scene is added as root scene or is added as a child of another visual.</haxe_doc>
	</PRELOAD>
	<LOAD public="1" get="inline" set="null" expr="cast 2" line="21" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* The scene is actually loading. Any asset that was
     * added with `assets.add()` in the `preload()` method is
     * getting loaded.</haxe_doc>
	</LOAD>
	<CREATE public="1" get="inline" set="null" expr="cast 3" line="27" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* The scene has finished loading and is calling the `create()` method
     * to fill it with any object, visual needed etc...</haxe_doc>
	</CREATE>
	<FADE_IN public="1" get="inline" set="null" expr="cast 4" line="34" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* The `create()` method has finished running so the scene is now ready to **fade in**.
     * Default fade in implementation is _instant_, but this can be changed by overriding
     * the `fadeIn()` method.</haxe_doc>
	</FADE_IN>
	<READY public="1" get="inline" set="null" expr="cast 5" line="39" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* When **fade in** has finished, the scene is marked as **ready**.</haxe_doc>
	</READY>
	<FADE_OUT public="1" get="inline" set="null" expr="cast 6" line="45" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* The scene begins to **fade out**, likely because it was explicitly asked to do so,
     * or is being replaced by another scene.</haxe_doc>
	</FADE_OUT>
	<DISABLED public="1" get="inline" set="null" expr="cast 7" line="50" static="1">
		<x path="Int"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Happens after **fade out**. When the scene has this status, it should not be used anymore.</haxe_doc>
	</DISABLED>
	<toString set="method" line="52" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._SceneStatus.SceneStatus_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SceneStatus.hx" private="1" module="ceramic.SceneStatus" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="8" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* No status. The scene is likely not assigned to anything.</haxe_doc>
		</NONE>
		<PRELOAD public="1" get="inline" set="null" expr="cast 1" line="14" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* The scene is calling the `preload()` method.
     * That happens when the scene is added as root scene or is added as a child of another visual.</haxe_doc>
		</PRELOAD>
		<LOAD public="1" get="inline" set="null" expr="cast 2" line="21" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* The scene is actually loading. Any asset that was
     * added with `assets.add()` in the `preload()` method is
     * getting loaded.</haxe_doc>
		</LOAD>
		<CREATE public="1" get="inline" set="null" expr="cast 3" line="27" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* The scene has finished loading and is calling the `create()` method
     * to fill it with any object, visual needed etc...</haxe_doc>
		</CREATE>
		<FADE_IN public="1" get="inline" set="null" expr="cast 4" line="34" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* The `create()` method has finished running so the scene is now ready to **fade in**.
     * Default fade in implementation is _instant_, but this can be changed by overriding
     * the `fadeIn()` method.</haxe_doc>
		</FADE_IN>
		<READY public="1" get="inline" set="null" expr="cast 5" line="39" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* When **fade in** has finished, the scene is marked as **ready**.</haxe_doc>
		</READY>
		<FADE_OUT public="1" get="inline" set="null" expr="cast 6" line="45" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* The scene begins to **fade out**, likely because it was explicitly asked to do so,
     * or is being replaced by another scene.</haxe_doc>
		</FADE_OUT>
		<DISABLED public="1" get="inline" set="null" expr="cast 7" line="50" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Happens after **fade out**. When the scene has this status, it should not be used anymore.</haxe_doc>
		</DISABLED>
		<toString set="method" line="52" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="ceramic.System" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/System.hx">
		<extends path="ceramic.Entity"/>
		<_dox_event_beginEarlyUpdate public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_beginEarlyUpdate>
		<emitBeginEarlyUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>beginEarlyUpdate event</haxe_doc>
		</emitBeginEarlyUpdate>
		<onBeginEarlyUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>beginEarlyUpdate event</haxe_doc>
		</onBeginEarlyUpdate>
		<onceBeginEarlyUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>beginEarlyUpdate event</haxe_doc>
		</onceBeginEarlyUpdate>
		<offBeginEarlyUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>beginEarlyUpdate event</haxe_doc>
		</offBeginEarlyUpdate>
		<listensBeginEarlyUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to beginEarlyUpdate event</haxe_doc>
		</listensBeginEarlyUpdate>
		<_dox_event_endEarlyUpdate public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_endEarlyUpdate>
		<emitEndEarlyUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>endEarlyUpdate event</haxe_doc>
		</emitEndEarlyUpdate>
		<onEndEarlyUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>endEarlyUpdate event</haxe_doc>
		</onEndEarlyUpdate>
		<onceEndEarlyUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>endEarlyUpdate event</haxe_doc>
		</onceEndEarlyUpdate>
		<offEndEarlyUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>endEarlyUpdate event</haxe_doc>
		</offEndEarlyUpdate>
		<listensEndEarlyUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to endEarlyUpdate event</haxe_doc>
		</listensEndEarlyUpdate>
		<_dox_event_beginLateUpdate public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_beginLateUpdate>
		<emitBeginLateUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>beginLateUpdate event</haxe_doc>
		</emitBeginLateUpdate>
		<onBeginLateUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>beginLateUpdate event</haxe_doc>
		</onBeginLateUpdate>
		<onceBeginLateUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>beginLateUpdate event</haxe_doc>
		</onceBeginLateUpdate>
		<offBeginLateUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>beginLateUpdate event</haxe_doc>
		</offBeginLateUpdate>
		<listensBeginLateUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to beginLateUpdate event</haxe_doc>
		</listensBeginLateUpdate>
		<_dox_event_endLateUpdate public="1" set="method" line="637">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_endLateUpdate>
		<emitEndLateUpdate set="method" line="1095">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>endLateUpdate event</haxe_doc>
		</emitEndLateUpdate>
		<onEndLateUpdate public="1" set="method" line="1199">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>endLateUpdate event</haxe_doc>
		</onEndLateUpdate>
		<onceEndLateUpdate public="1" set="method" line="1298">
			<f a="owner:handleDelta">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>endLateUpdate event</haxe_doc>
		</onceEndLateUpdate>
		<offEndLateUpdate public="1" set="method" line="1368">
			<f a="?handleDelta">
				<f a="delta">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>endLateUpdate event</haxe_doc>
		</offEndLateUpdate>
		<listensEndLateUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to endLateUpdate event</haxe_doc>
		</listensEndLateUpdate>
		<name public="1" expr="null" line="24">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* System name.
     * Useful to retrieve a system afterwards</haxe_doc>
		</name>
		<autoUpdate public="1" expr="true" line="30">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* When set to `true` (default). This system will be updated automatically.
     * If `false`, you'll need to call `earlyUpdate()` and `lateUpdate()` manually.</haxe_doc>
		</autoUpdate>
		<earlyUpdateOrder public="1" set="accessor" expr="0" line="38">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Order of earlyUpdate execution.
     * Given two systems, a system with a lower `earlyUpdateOrder` value will have
     * it's `earlyUpdate()` method called before another system's `earlyUpdate()`
     * method with a higher `order` value.</haxe_doc>
		</earlyUpdateOrder>
		<set_earlyUpdateOrder set="method" line="39"><f a="earlyUpdateOrder">
	<x path="Float"/>
	<x path="Float"/>
</f></set_earlyUpdateOrder>
		<lateUpdateOrder public="1" set="accessor" expr="0" line="53">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Order of lateUpdate execution.
     * Given two systems, a system with a lower `lateUpdateOrder` value will have
     * it's `lateUpdate()` method called before another system's `lateUpdate()`
     * method with a higher `order` value.</haxe_doc>
		</lateUpdateOrder>
		<set_lateUpdateOrder set="method" line="54"><f a="lateUpdateOrder">
	<x path="Float"/>
	<x path="Float"/>
</f></set_lateUpdateOrder>
		<destroy public="1" set="method" line="70" override="1"><f a=""><x path="Void"/></f></destroy>
		<earlyUpdate set="method" line="82">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Method automatically called right before app's `update` event
     * @param delta</haxe_doc>
		</earlyUpdate>
		<lateUpdate set="method" line="90">
			<f a="delta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Method automatically called right before app's right after `update` event
     * @param delta</haxe_doc>
		</lateUpdate>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="62"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A `System` is an object assigned to app lifecycle and used to
 * do some work such as dispatching events or manipulating entities.
 * Systems can be ordered with `order` properties</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":access"><e>ceramic.Systems</e></m>
			<m n=":allow"><e>ceramic.Systems</e></m>
		</meta>
	</class>
	<class path="ceramic.SceneSystem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SceneSystem.hx">
		<extends path="ceramic.System"/>
		<shared public="1" expr="new SceneSystem()" line="17" static="1">
			<c path="ceramic.SceneSystem"/>
			<meta>
				<m n=":value"><e>new SceneSystem()</e></m>
				<m n="lazy"/>
			</meta>
			<haxe_doc>* Shared scene system</haxe_doc>
		</shared>
		<all public="1" set="null" expr="[]" line="19">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.Scene"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
		</all>
		<_updatingScenes expr="[]" line="21">
			<c path="Array"><c path="ceramic.Scene"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_updatingScenes>
		<keepAssetsForNextMain public="1" expr="false" line="28">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If `true`, when assigning a new main scene, assets of the previous
     * main scene will be kept instead of being destroyed and can be
     * reused by the new main scene without having to reload these</haxe_doc>
		</keepAssetsForNextMain>
		<bindMainToScreenSize public="1" expr="true" line="33">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If `true`, main scene will be bound to screen size automatically</haxe_doc>
		</bindMainToScreenSize>
		<fadeOutWhenNextMainCanFadeIn public="1" expr="true" line="40">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If `true`, when assigning a new main scene, previous main
     * scene will wait until the next scene is properly loaded and can fade-in
     * before starting its own fade-out transition.</haxe_doc>
		</fadeOutWhenNextMainCanFadeIn>
		<main public="1" set="accessor" expr="null" line="45">
			<c path="ceramic.Scene"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The main scene to display on screen.</haxe_doc>
		</main>
		<autoDestroyFilter public="1" expr="true" line="51">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If set to `true` (default), any filter assigned to the system will be destroyed
     * if replaced by another filter, set to null, or if the system is destroyed.</haxe_doc>
		</autoDestroyFilter>
		<autoScaleFilter public="1" expr="true" line="57">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If set to `true` (default), a filter assigned to the system will
     * be auto-scaled to fit screen size.</haxe_doc>
		</autoScaleFilter>
		<filter public="1" set="accessor" expr="null" line="62">
			<c path="ceramic.Filter"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Assign a filter to the scene system, that will be used to render root scenes</haxe_doc>
		</filter>
		<set_filter set="method" line="63"><f a="filter">
	<c path="ceramic.Filter"/>
	<c path="ceramic.Filter"/>
</f></set_filter>
		<scaleFilter set="method" line="117"><f a=""><x path="Void"/></f></scaleFilter>
		<rootScenes public="1" set="null" expr="new Map()" line="124">
			<x path="ceramic.ReadOnlyMap">
				<c path="String"/>
				<c path="ceramic.Scene"/>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</rootScenes>
		<set_main set="method" line="126"><f a="main">
	<c path="ceramic.Scene"/>
	<c path="ceramic.Scene"/>
</f></set_main>
		<set public="1" set="method" line="146">
			<f a="name:scene:?bindToScreenSize:?keepAssets" v="::true:false">
				<c path="String"/>
				<c path="ceramic.Scene"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ keepAssets : false, bindToScreenSize : true }</e></m></meta>
			<haxe_doc>* Assign secondary scenes to display them directly on screen.
     * @param name The slot name of the scene
     * @param scene The scene to assign
     * @param bindToScreenSize (optional) Set to `false` if you don't want the scene to follow screen size
     * @param keepAssets
     *          (optional) Set to `true` if you want this scene to keep the same **assets**
     *          instance as the previous scene on the same slot.</haxe_doc>
		</set>
		<get public="1" set="method" line="256">
			<f a="name">
				<c path="String"/>
				<c path="ceramic.Scene"/>
			</f>
			<haxe_doc>* Retrieve a secondary scene from the given slot name
     * @param name The slot name of the scene to retrieve
     * @return A `Scene` instance or `null` if nothing was found</haxe_doc>
		</get>
		<setCurrentScene public="1" get="inline" set="null" line="263">
			<f a="scene:?keepAssets" v=":false">
				<c path="ceramic.Scene"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ keepAssets : false }</e></m>
				<m n=":deprecated"><e>"Deprecated: use `app.scenes.main = yourScene;` instead"</e></m>
			</meta>
		</setCurrentScene>
		<lateUpdate set="method" line="278" override="1"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></lateUpdate>
		<new set="method" line="270"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* System managing scenes display and lifecycle.
 * Use it to structure your app in different scenes.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":allow"><e>ceramic.Scene</e></m>
		</meta>
	</class>
	<class path="ceramic.Screen" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Screen.hx">
		<extends path="ceramic.Entity"/>
		<implements path="tracker.Observable"/>
		<matchedHitVisual public="1" expr="null" line="1179" static="1">
			<c path="ceramic.Visual"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Internal reference to a matched hit visual. This is used to let Visual.hit() return `false`
     * on every visual not related to the matched hit visual, if any is defined.</haxe_doc>
		</matchedHitVisual>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Screen"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Screen"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Screen"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Screen"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.Screen"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false" line="131">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<density public="1" set="null" expr="1.0" line="23">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Screen density computed from app's logical width/height
     * settings and native width/height.</haxe_doc>
		</density>
		<width public="1" set="null" expr="0" line="29">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Logical width used in app to position elements.
     * Updated when the screen is resized.</haxe_doc>
		</width>
		<height public="1" set="null" expr="0" line="35">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Logical height used in app to position elements.
     * Updated when the screen is resized.</haxe_doc>
		</height>
		<actualWidth public="1" set="null" expr="0" line="41">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The actual width available on screen, including offsets, in the same unit as `width`.
     * Updated when the screen is resized.</haxe_doc>
		</actualWidth>
		<actualHeight public="1" set="null" expr="0" line="47">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The actual height available on screen, including offsets, in the same unit as `width`.
     * Updated when the screen is resized.</haxe_doc>
		</actualHeight>
		<offsetX public="1" set="null" expr="0" line="53">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Logical x offset.
     * Updated when the screen is resized.</haxe_doc>
		</offsetX>
		<offsetY public="1" set="null" expr="0" line="59">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Logical y offset.
     * Updated when the screen is resized.</haxe_doc>
		</offsetY>
		<nativeWidth public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Native width</haxe_doc>
		</nativeWidth>
		<get_nativeWidth get="inline" set="null" line="65"><f a=""><x path="Float"/></f></get_nativeWidth>
		<nativeHeight public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Native height</haxe_doc>
		</nativeHeight>
		<get_nativeHeight get="inline" set="null" line="73"><f a=""><x path="Float"/></f></get_nativeHeight>
		<nativeDensity public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Native pixel ratio/density.</haxe_doc>
		</nativeDensity>
		<get_nativeDensity get="inline" set="null" line="81"><f a=""><x path="Float"/></f></get_nativeDensity>
		<pointerX public="1" set="null" expr="0" line="91">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Pointer x coordinate, computed from mouse and touch events.
     * When using multiple touch inputs at the same time, x will be
     * the mean value of all touches x value. Use this as a
     * convenience when you don't want to deal with multiple positions.</haxe_doc>
		</pointerX>
		<pointerY public="1" set="null" expr="0" line="99">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Pointer y coordinate, computed from mouse and touch events.
     * When using multiple touch inputs at the same time, y will be
     * the mean value of all touches y value. Use this as a
     * convenience when you don't want to deal with multiple positions.</haxe_doc>
		</pointerY>
		<pointerDeltaX public="1" set="null" expr="0" line="104">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Pointer x delta since last frame</haxe_doc>
		</pointerDeltaX>
		<pointerDeltaY public="1" set="null" expr="0" line="109">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Pointer y delta since last frame</haxe_doc>
		</pointerDeltaY>
		<mouseX public="1" set="null" expr="0" line="114">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Mouse x coordinate, computed from mouse events.</haxe_doc>
		</mouseX>
		<mouseY public="1" set="null" expr="0" line="119">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Mouse y coordinate, computed from mouse events.</haxe_doc>
		</mouseY>
		<mouseDeltaX public="1" set="null" expr="0" line="124">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Mouse x delta since last frame</haxe_doc>
		</mouseDeltaX>
		<mouseDeltaY public="1" set="null" expr="0" line="129">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Mouse y delta since last frame</haxe_doc>
		</mouseDeltaY>
		<mouseWheelDeltaX public="1" set="null" expr="0" line="134">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Mouse wheel x delta since last frame</haxe_doc>
		</mouseWheelDeltaX>
		<mouseWheelDeltaY public="1" set="null" expr="0" line="139">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Mouse wheel y delta since last frame</haxe_doc>
		</mouseWheelDeltaY>
		<touches public="1" set="null" expr="new Touches()" line="144">
			<x path="ceramic.Touches"/>
			<meta><m n=":value"><e>new Touches()</e></m></meta>
			<haxe_doc>* Touches x and y coordinates by touch index.</haxe_doc>
		</touches>
		<invalidateFocusedVisual public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateFocusedVisual>
		<focusedVisual public="1" set="accessor" expr="null" line="149">
			<c path="ceramic.Visual"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Focused visual</haxe_doc>
		</focusedVisual>
		<unobservedFocusedVisual>
			<c path="ceramic.Visual"/>
			<haxe_doc></haxe_doc>
		</unobservedFocusedVisual>
		<_dox_event_focusedVisualChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.Visual"/>
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when focusedVisual field changes.</haxe_doc>
		</_dox_event_focusedVisualChange>
		<emitFocusedVisualChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.Visual"/>
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when focusedVisual field changes.</haxe_doc>
		</emitFocusedVisualChange>
		<onFocusedVisualChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Visual"/>
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when focusedVisual field changes.</haxe_doc>
		</onFocusedVisualChange>
		<onceFocusedVisualChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Visual"/>
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when focusedVisual field changes.</haxe_doc>
		</onceFocusedVisualChange>
		<offFocusedVisualChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.Visual"/>
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when focusedVisual field changes.</haxe_doc>
		</offFocusedVisualChange>
		<listensFocusedVisualChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when focusedVisual field changes.</haxe_doc>
		</listensFocusedVisualChange>
		<set_focusedVisual set="method" line="150"><f a="focusedVisual">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
</f></set_focusedVisual>
		<invalidateTexturesDensity public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTexturesDensity>
		<texturesDensity public="1" expr="1.0" line="173">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1.0</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Ideal textures density, computed from settings
     * targetDensity and current screen state.</haxe_doc>
		</texturesDensity>
		<unobservedTexturesDensity>
			<x path="Float"/>
			<haxe_doc></haxe_doc>
		</unobservedTexturesDensity>
		<_dox_event_texturesDensityChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when texturesDensity field changes.</haxe_doc>
		</_dox_event_texturesDensityChange>
		<emitTexturesDensityChange set="method" line="1095">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when texturesDensity field changes.</haxe_doc>
		</emitTexturesDensityChange>
		<onTexturesDensityChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texturesDensity field changes.</haxe_doc>
		</onTexturesDensityChange>
		<onceTexturesDensityChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texturesDensity field changes.</haxe_doc>
		</onceTexturesDensityChange>
		<offTexturesDensityChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texturesDensity field changes.</haxe_doc>
		</offTexturesDensityChange>
		<listensTexturesDensityChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texturesDensity field changes.</haxe_doc>
		</listensTexturesDensityChange>
		<matrix expr="new Transform()" line="181">
			<c path="ceramic.Transform"/>
			<meta>
				<m n=":value"><e>new Transform()</e></m>
				<m n=":allow"><e>ceramic.Visual</e></m>
			</meta>
			<haxe_doc>* Root matrix applied to every visual.
     * This is recomputed on screen resize but
     * can be changed otherwise.</haxe_doc>
		</matrix>
		<reverseMatrix expr="new Transform()" line="187">
			<c path="ceramic.Transform"/>
			<meta>
				<m n=":value"><e>new Transform()</e></m>
				<m n=":allow"><e>ceramic.Visual</e></m>
			</meta>
			<haxe_doc>* Internal inverted matrix computed from root matrix.</haxe_doc>
		</reverseMatrix>
		<resizing expr="false" line="192">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* In order to prevent nested resizes.</haxe_doc>
		</resizing>
		<isPointerDown public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether the screen is between a `pointer down` and an `pointer up` event or not.</haxe_doc>
		</isPointerDown>
		<_numPointerDown expr="0" line="198">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numPointerDown>
		<get_isPointerDown get="inline" set="null" line="199"><f a=""><x path="Bool"/></f></get_isPointerDown>
		<pressedMouseButtons expr="new IntIntMap(16, 0.5, false)" line="201">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</pressedMouseButtons>
		<pressedTouches expr="new IntIntMap(16, 0.5, false)" line="203">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>new IntIntMap(16, 0.5, false)</e></m></meta>
		</pressedTouches>
		<prevTouchPositions expr="new IntFloatMap(16, 0.5, false)" line="205">
			<c path="ceramic.IntFloatMap"/>
			<meta><m n=":value"><e>new IntFloatMap(16, 0.5, false)</e></m></meta>
		</prevTouchPositions>
		<prevMouseX expr="0" line="207">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</prevMouseX>
		<prevMouseY expr="0" line="209">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</prevMouseY>
		<maxTouchIndex expr="-1" line="211">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</maxTouchIndex>
		<visualsListenPointerOver expr="false" line="213">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</visualsListenPointerOver>
		<_dox_event_resize public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Resize event occurs once at startup, then each time any
     * of native width, height or density changes.</haxe_doc>
		</_dox_event_resize>
		<emitResize set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resize event occurs once at startup, then each time any
     * of native width, height or density changes.</haxe_doc>
		</emitResize>
		<onResize public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Resize event occurs once at startup, then each time any
     * of native width, height or density changes.</haxe_doc>
		</onResize>
		<onceResize public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Resize event occurs once at startup, then each time any
     * of native width, height or density changes.</haxe_doc>
		</onceResize>
		<offResize public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Resize event occurs once at startup, then each time any
     * of native width, height or density changes.</haxe_doc>
		</offResize>
		<listensResize public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Resize event occurs once at startup, then each time any
     * of native width, height or density changes.</haxe_doc>
		</listensResize>
		<_dox_event_mouseDown public="1" set="method" line="637">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseDown>
		<emitMouseDown set="method" line="1095">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseDown event</haxe_doc>
		</emitMouseDown>
		<onMouseDown public="1" set="method" line="1199">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseDown event</haxe_doc>
		</onMouseDown>
		<onceMouseDown public="1" set="method" line="1298">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseDown event</haxe_doc>
		</onceMouseDown>
		<offMouseDown public="1" set="method" line="1368">
			<f a="?handleButtonIdXY">
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseDown event</haxe_doc>
		</offMouseDown>
		<listensMouseDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseDown event</haxe_doc>
		</listensMouseDown>
		<_dox_event_mouseUp public="1" set="method" line="637">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseUp>
		<emitMouseUp set="method" line="1095">
			<f a="buttonId:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseUp event</haxe_doc>
		</emitMouseUp>
		<onMouseUp public="1" set="method" line="1199">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseUp event</haxe_doc>
		</onMouseUp>
		<onceMouseUp public="1" set="method" line="1298">
			<f a="owner:handleButtonIdXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseUp event</haxe_doc>
		</onceMouseUp>
		<offMouseUp public="1" set="method" line="1368">
			<f a="?handleButtonIdXY">
				<f a="buttonId:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseUp event</haxe_doc>
		</offMouseUp>
		<listensMouseUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseUp event</haxe_doc>
		</listensMouseUp>
		<_dox_event_mouseWheel public="1" set="method" line="637">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseWheel>
		<emitMouseWheel set="method" line="1095">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseWheel event</haxe_doc>
		</emitMouseWheel>
		<onMouseWheel public="1" set="method" line="1199">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseWheel event</haxe_doc>
		</onMouseWheel>
		<onceMouseWheel public="1" set="method" line="1298">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseWheel event</haxe_doc>
		</onceMouseWheel>
		<offMouseWheel public="1" set="method" line="1368">
			<f a="?handleXY">
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseWheel event</haxe_doc>
		</offMouseWheel>
		<listensMouseWheel public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseWheel event</haxe_doc>
		</listensMouseWheel>
		<_dox_event_mouseMove public="1" set="method" line="637">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_mouseMove>
		<emitMouseMove set="method" line="1095">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>mouseMove event</haxe_doc>
		</emitMouseMove>
		<onMouseMove public="1" set="method" line="1199">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseMove event</haxe_doc>
		</onMouseMove>
		<onceMouseMove public="1" set="method" line="1298">
			<f a="owner:handleXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseMove event</haxe_doc>
		</onceMouseMove>
		<offMouseMove public="1" set="method" line="1368">
			<f a="?handleXY">
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>mouseMove event</haxe_doc>
		</offMouseMove>
		<listensMouseMove public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to mouseMove event</haxe_doc>
		</listensMouseMove>
		<_dox_event_touchDown public="1" set="method" line="637">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_touchDown>
		<emitTouchDown set="method" line="1095">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>touchDown event</haxe_doc>
		</emitTouchDown>
		<onTouchDown public="1" set="method" line="1199">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchDown event</haxe_doc>
		</onTouchDown>
		<onceTouchDown public="1" set="method" line="1298">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchDown event</haxe_doc>
		</onceTouchDown>
		<offTouchDown public="1" set="method" line="1368">
			<f a="?handleTouchIndexXY">
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchDown event</haxe_doc>
		</offTouchDown>
		<listensTouchDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to touchDown event</haxe_doc>
		</listensTouchDown>
		<_dox_event_touchUp public="1" set="method" line="637">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_touchUp>
		<emitTouchUp set="method" line="1095">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>touchUp event</haxe_doc>
		</emitTouchUp>
		<onTouchUp public="1" set="method" line="1199">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchUp event</haxe_doc>
		</onTouchUp>
		<onceTouchUp public="1" set="method" line="1298">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchUp event</haxe_doc>
		</onceTouchUp>
		<offTouchUp public="1" set="method" line="1368">
			<f a="?handleTouchIndexXY">
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchUp event</haxe_doc>
		</offTouchUp>
		<listensTouchUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to touchUp event</haxe_doc>
		</listensTouchUp>
		<_dox_event_touchMove public="1" set="method" line="637">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_touchMove>
		<emitTouchMove set="method" line="1095">
			<f a="touchIndex:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>touchMove event</haxe_doc>
		</emitTouchMove>
		<onTouchMove public="1" set="method" line="1199">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchMove event</haxe_doc>
		</onTouchMove>
		<onceTouchMove public="1" set="method" line="1298">
			<f a="owner:handleTouchIndexXY">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchMove event</haxe_doc>
		</onceTouchMove>
		<offTouchMove public="1" set="method" line="1368">
			<f a="?handleTouchIndexXY">
				<f a="touchIndex:x:y">
					<x path="Int"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>touchMove event</haxe_doc>
		</offTouchMove>
		<listensTouchMove public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to touchMove event</haxe_doc>
		</listensTouchMove>
		<_dox_event_pointerDown public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_pointerDown>
		<emitPointerDown set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>pointerDown event</haxe_doc>
		</emitPointerDown>
		<onPointerDown public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerDown event</haxe_doc>
		</onPointerDown>
		<oncePointerDown public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerDown event</haxe_doc>
		</oncePointerDown>
		<offPointerDown public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerDown event</haxe_doc>
		</offPointerDown>
		<listensPointerDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to pointerDown event</haxe_doc>
		</listensPointerDown>
		<_dox_event_pointerUp public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_pointerUp>
		<emitPointerUp set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>pointerUp event</haxe_doc>
		</emitPointerUp>
		<onPointerUp public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerUp event</haxe_doc>
		</onPointerUp>
		<oncePointerUp public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerUp event</haxe_doc>
		</oncePointerUp>
		<offPointerUp public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerUp event</haxe_doc>
		</offPointerUp>
		<listensPointerUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to pointerUp event</haxe_doc>
		</listensPointerUp>
		<_dox_event_pointerMove public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_pointerMove>
		<emitPointerMove set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>pointerMove event</haxe_doc>
		</emitPointerMove>
		<onPointerMove public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerMove event</haxe_doc>
		</onPointerMove>
		<oncePointerMove public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerMove event</haxe_doc>
		</oncePointerMove>
		<offPointerMove public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>pointerMove event</haxe_doc>
		</offPointerMove>
		<listensPointerMove public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to pointerMove event</haxe_doc>
		</listensPointerMove>
		<_dox_event_multiTouchPointerDown public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_multiTouchPointerDown>
		<emitMultiTouchPointerDown set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>multiTouchPointerDown event</haxe_doc>
		</emitMultiTouchPointerDown>
		<onMultiTouchPointerDown public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerDown event</haxe_doc>
		</onMultiTouchPointerDown>
		<onceMultiTouchPointerDown public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerDown event</haxe_doc>
		</onceMultiTouchPointerDown>
		<offMultiTouchPointerDown public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerDown event</haxe_doc>
		</offMultiTouchPointerDown>
		<listensMultiTouchPointerDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to multiTouchPointerDown event</haxe_doc>
		</listensMultiTouchPointerDown>
		<_dox_event_multiTouchPointerUp public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_multiTouchPointerUp>
		<emitMultiTouchPointerUp set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>multiTouchPointerUp event</haxe_doc>
		</emitMultiTouchPointerUp>
		<onMultiTouchPointerUp public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerUp event</haxe_doc>
		</onMultiTouchPointerUp>
		<onceMultiTouchPointerUp public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerUp event</haxe_doc>
		</onceMultiTouchPointerUp>
		<offMultiTouchPointerUp public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerUp event</haxe_doc>
		</offMultiTouchPointerUp>
		<listensMultiTouchPointerUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to multiTouchPointerUp event</haxe_doc>
		</listensMultiTouchPointerUp>
		<_dox_event_multiTouchPointerMove public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_multiTouchPointerMove>
		<emitMultiTouchPointerMove set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>multiTouchPointerMove event</haxe_doc>
		</emitMultiTouchPointerMove>
		<onMultiTouchPointerMove public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerMove event</haxe_doc>
		</onMultiTouchPointerMove>
		<onceMultiTouchPointerMove public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerMove event</haxe_doc>
		</onceMultiTouchPointerMove>
		<offMultiTouchPointerMove public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>multiTouchPointerMove event</haxe_doc>
		</offMultiTouchPointerMove>
		<listensMultiTouchPointerMove public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to multiTouchPointerMove event</haxe_doc>
		</listensMultiTouchPointerMove>
		<_dox_event_focus public="1" set="method" line="637">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_focus>
		<emitFocus set="method" line="1095">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>focus event</haxe_doc>
		</emitFocus>
		<onFocus public="1" set="method" line="1199">
			<f a="owner:handleVisual">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="visual">
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>focus event</haxe_doc>
		</onFocus>
		<onceFocus public="1" set="method" line="1298">
			<f a="owner:handleVisual">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="visual">
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>focus event</haxe_doc>
		</onceFocus>
		<offFocus public="1" set="method" line="1368">
			<f a="?handleVisual">
				<f a="visual">
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>focus event</haxe_doc>
		</offFocus>
		<listensFocus public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to focus event</haxe_doc>
		</listensFocus>
		<_dox_event_blur public="1" set="method" line="637">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_blur>
		<emitBlur set="method" line="1095">
			<f a="visual">
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>blur event</haxe_doc>
		</emitBlur>
		<onBlur public="1" set="method" line="1199">
			<f a="owner:handleVisual">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="visual">
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>blur event</haxe_doc>
		</onBlur>
		<onceBlur public="1" set="method" line="1298">
			<f a="owner:handleVisual">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="visual">
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>blur event</haxe_doc>
		</onceBlur>
		<offBlur public="1" set="method" line="1368">
			<f a="?handleVisual">
				<f a="visual">
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>blur event</haxe_doc>
		</offBlur>
		<listensBlur public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to blur event</haxe_doc>
		</listensBlur>
		<backendReady set="method" line="261"><f a=""><x path="Void"/></f></backendReady>
		<updatePointerOverState set="method" line="474"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></updatePointerOverState>
		<resize set="method" line="488"><f a=""><x path="Void"/></f></resize>
		<updateTexturesDensity set="method" line="523"><f a=""><x path="Void"/></f></updateTexturesDensity>
		<updateScaling set="method" line="546">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Recompute screen width, height and density from settings and native state.</haxe_doc>
		</updateScaling>
		<updateTransform set="method" line="617">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Recompute transform from screen width, height and density.</haxe_doc>
		</updateTransform>
		<matchFirstDownListener set="method" line="651">
			<f a="x:y:?touchIndex:?buttonId" v="::-1:-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="ceramic.Visual"/>
			</f>
			<meta><m n=":value"><e>{ buttonId : -1, touchIndex : -1 }</e></m></meta>
		</matchFirstDownListener>
		<matchFirstOverListener set="method" line="734"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="ceramic.Visual"/>
</f></matchFirstOverListener>
		<prepareMultiTouchPointerDown get="inline" set="null" line="822"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></prepareMultiTouchPointerDown>
		<prepareMultiTouchPointerUp get="inline" set="null" line="846"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></prepareMultiTouchPointerUp>
		<prepareMultiTouchPointerMove get="inline" set="null" line="875"><f a="info:isMouse">
	<c path="ceramic.TouchInfo"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></prepareMultiTouchPointerMove>
		<updatePointer get="inline" set="null" line="899"><f a=""><x path="Void"/></f></updatePointer>
		<matchedDownListeners expr="new Map()" line="1008">
			<t path="Map">
				<x path="Int"/>
				<c path="ceramic.Visual"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</matchedDownListeners>
		<matchedOverListeners expr="new Map()" line="1010">
			<t path="Map">
				<x path="Int"/>
				<c path="ceramic.Visual"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</matchedOverListeners>
		<didEmitMouseDown get="inline" set="null" line="1012"><f a="buttonId:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></didEmitMouseDown>
		<didEmitMouseUp get="inline" set="null" line="1033"><f a="buttonId:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></didEmitMouseUp>
		<updateMouseOver get="inline" set="null" line="1053"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateMouseOver>
		<didEmitTouchDown get="inline" set="null" line="1092"><f a="touchIndex:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></didEmitTouchDown>
		<didEmitTouchUp get="inline" set="null" line="1113"><f a="touchIndex:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></didEmitTouchUp>
		<updateTouchOver get="inline" set="null" line="1133"><f a="touchIndex:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateTouchOver>
		<hitVisuals expr="[]" line="1181">
			<c path="Array"><c path="ceramic.Visual"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</hitVisuals>
		<addHitVisual public="1" set="method" line="1183"><f a="visual">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></addHitVisual>
		<removeHitVisual public="1" set="method" line="1194"><f a="visual">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></removeHitVisual>
		<isHitVisual public="1" set="method" line="1209"><f a="visual">
	<c path="ceramic.Visual"/>
	<x path="Bool"/>
</f></isHitVisual>
		<resetDeltas set="method" line="1217"><f a=""><x path="Void"/></f></resetDeltas>
		<willEmitMouseMove set="method" line="1242"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitMouseMove>
		<willEmitMouseDown set="method" line="1251"><f a="buttonId:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitMouseDown>
		<willEmitMouseUp set="method" line="1289"><f a="buttonId:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitMouseUp>
		<willEmitMouseWheel set="method" line="1301"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitMouseWheel>
		<mouseAllowed public="1" get="inline" set="null" line="1323">
			<f a="owner">
				<c path="ceramic.Entity"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Return `true` if mouse events are currently allowed for the given owner.
     * This is only useful on very specific cases.</haxe_doc>
		</mouseAllowed>
		<mousePressed public="1" get="inline" set="null" line="1329">
			<f a="buttonId">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><mousePressed public="1" get="inline" set="null" line="1347"><f a="buttonId:owner">
	<x path="Int"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></mousePressed></overloads>
		</mousePressed>
		<mouseJustPressed public="1" get="inline" set="null" line="1335">
			<f a="buttonId">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><mouseJustPressed public="1" get="inline" set="null" line="1353"><f a="buttonId:owner">
	<x path="Int"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></mouseJustPressed></overloads>
		</mouseJustPressed>
		<mouseJustReleased public="1" get="inline" set="null" line="1341">
			<f a="buttonId">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><mouseJustReleased public="1" get="inline" set="null" line="1359"><f a="buttonId:owner">
	<x path="Int"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></mouseJustReleased></overloads>
		</mouseJustReleased>
		<_mousePressed set="method" line="1365"><f a="buttonId">
	<x path="Int"/>
	<x path="Bool"/>
</f></_mousePressed>
		<_mouseJustPressed set="method" line="1371"><f a="buttonId">
	<x path="Int"/>
	<x path="Bool"/>
</f></_mouseJustPressed>
		<_mouseJustReleased set="method" line="1377"><f a="buttonId">
	<x path="Int"/>
	<x path="Bool"/>
</f></_mouseJustReleased>
		<willEmitTouchMove set="method" line="1385"><f a="touchIndex:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitTouchMove>
		<willEmitTouchDown set="method" line="1402"><f a="touchIndex:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitTouchDown>
		<willEmitTouchUp set="method" line="1442"><f a="touchIndex:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></willEmitTouchUp>
		<touchPressed public="1" get="inline" set="null" line="1463">
			<f a="touchIndex">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><touchPressed public="1" get="inline" set="null" line="1481"><f a="touchIndex:owner">
	<x path="Int"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></touchPressed></overloads>
		</touchPressed>
		<touchJustPressed public="1" get="inline" set="null" line="1469">
			<f a="touchIndex">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><touchJustPressed public="1" get="inline" set="null" line="1487"><f a="touchIndex:owner">
	<x path="Int"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></touchJustPressed></overloads>
		</touchJustPressed>
		<touchJustReleased public="1" get="inline" set="null" line="1475">
			<f a="touchIndex">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><touchJustReleased public="1" get="inline" set="null" line="1493"><f a="touchIndex:owner">
	<x path="Int"/>
	<c path="ceramic.Entity"/>
	<x path="Bool"/>
</f></touchJustReleased></overloads>
		</touchJustReleased>
		<_touchPressed set="method" line="1499"><f a="touchIndex">
	<x path="Int"/>
	<x path="Bool"/>
</f></_touchPressed>
		<_touchJustPressed set="method" line="1505"><f a="touchIndex">
	<x path="Int"/>
	<x path="Bool"/>
</f></_touchJustPressed>
		<_touchJustReleased set="method" line="1512"><f a="touchIndex">
	<x path="Int"/>
	<x path="Bool"/>
</f></_touchJustReleased>
		<touchDeltaX public="1" set="method" line="1519"><f a="touchIndex">
	<x path="Int"/>
	<x path="Float"/>
</f></touchDeltaX>
		<touchDeltaY public="1" set="method" line="1526"><f a="touchIndex">
	<x path="Int"/>
	<x path="Float"/>
</f></touchDeltaY>
		<toTexture public="1" set="method" line="1535"><f a="done">
	<f a="texture">
		<c path="ceramic.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></toTexture>
		<toPixels public="1" set="method" line="1551"><f a="done">
	<f a="pixels:width:height">
		<t path="ceramic.UInt8Array"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></toPixels>
		<toPng public="1" get="inline" set="null" line="1557">
			<f a="done">
				<f a="data">
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<overloads><toPng public="1" get="inline" set="null" line="1565"><f a="path:done">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></toPng></overloads>
		</toPng>
		<_toPng set="method" line="1573"><f a="?path:done">
	<c path="String"/>
	<f a="?data">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></_toPng>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new set="method" line="255"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<abstract path="ceramic.ScreenOrientation" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScreenOrientation.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._ScreenOrientation.ScreenOrientation_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScreenOrientation.hx" private="1" module="ceramic.ScreenOrientation" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<PORTRAIT_UPRIGHT public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 0" line="7" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 1 << 0]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PORTRAIT_UPRIGHT>
	<PORTRAIT_UPSIDE_DOWN public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 1" line="9" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 1 << 1]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PORTRAIT_UPSIDE_DOWN>
	<LANDSCAPE_LEFT public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 2" line="11" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 1 << 2]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANDSCAPE_LEFT>
	<LANDSCAPE_RIGHT public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 3" line="13" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e><![CDATA[cast 1 << 3]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LANDSCAPE_RIGHT>
	<PORTRAIT public="1" get="inline" set="null" expr="cast (1 &lt;&lt; 0) | (1 &lt;&lt; 1)" line="18" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e><![CDATA[cast (1 << 0) | (1 << 1)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Both `PORTRAIT_UPRIGHT` and `PORTRAIT_UPSIDE_DOWN`</haxe_doc>
	</PORTRAIT>
	<LANDSCAPE public="1" get="inline" set="null" expr="cast (1 &lt;&lt; 2) | (1 &lt;&lt; 3)" line="23" static="1">
		<x path="ceramic.ScreenOrientation"/>
		<meta>
			<m n=":value"><e><![CDATA[cast (1 << 2) | (1 << 3)]]></e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Both `LANDSCAPE_LEFT` and `LANDSCAPE_RIGHT`</haxe_doc>
	</LANDSCAPE>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._ScreenOrientation.ScreenOrientation_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScreenOrientation.hx" private="1" module="ceramic.ScreenOrientation" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<PORTRAIT_UPRIGHT public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 0" line="7" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 1 << 0]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PORTRAIT_UPRIGHT>
		<PORTRAIT_UPSIDE_DOWN public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 1" line="9" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 1 << 1]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PORTRAIT_UPSIDE_DOWN>
		<LANDSCAPE_LEFT public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 2" line="11" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 1 << 2]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANDSCAPE_LEFT>
		<LANDSCAPE_RIGHT public="1" get="inline" set="null" expr="cast 1 &lt;&lt; 3" line="13" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e><![CDATA[cast 1 << 3]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LANDSCAPE_RIGHT>
		<PORTRAIT public="1" get="inline" set="null" expr="cast (1 &lt;&lt; 0) | (1 &lt;&lt; 1)" line="18" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e><![CDATA[cast (1 << 0) | (1 << 1)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Both `PORTRAIT_UPRIGHT` and `PORTRAIT_UPSIDE_DOWN`</haxe_doc>
		</PORTRAIT>
		<LANDSCAPE public="1" get="inline" set="null" expr="cast (1 &lt;&lt; 2) | (1 &lt;&lt; 3)" line="23" static="1">
			<x path="ceramic.ScreenOrientation"/>
			<meta>
				<m n=":value"><e><![CDATA[cast (1 << 2) | (1 << 3)]]></e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Both `LANDSCAPE_LEFT` and `LANDSCAPE_RIGHT`</haxe_doc>
		</LANDSCAPE>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<enum path="ceramic.ScreenScaling" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScreenScaling.hx">
		<FIT><haxe_doc>* Screen width and height match target size in settings.
     * Result is scaled to fit into native screen bounds.</haxe_doc></FIT>
		<FILL><haxe_doc>* Screen width and height match target size in settings.
     * Result is scaled to fill native screen area.</haxe_doc></FILL>
		<RESIZE><haxe_doc>* Screen width and height are automatically resized
     * to exactly match native screen size.</haxe_doc></RESIZE>
		<FIT_RESIZE><haxe_doc>* Either width or height is increased so that aspect ratio
     * becomes the same as as native screen's aspect ratio.
     * Result is scaled to fit exactly into native screen bounds.</haxe_doc></FIT_RESIZE>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.Log" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Log.hx">
		<formatOutput public="1" set="method" line="33" static="1">
			<f a="v:infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format the output of `trace` before printing it.</haxe_doc>
		</formatOutput>
		<trace public="1" set="dynamic" line="62" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:

			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="cs.system.Object" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Object" extern="1">
		<_Equals public="1" set="method" static="1">
			<f a="objA:objB">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"Equals"</e></m></meta>
		</_Equals>
		<ReferenceEquals public="1" set="method" static="1"><f a="objA:objB">
	<d/>
	<d/>
	<x path="Bool"/>
</f></ReferenceEquals>
		<GetType final="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<MemberwiseClone final="1" set="method">
			<f a=""><d/></f>
			<meta><m n=":protected"/></meta>
		</MemberwiseClone>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Object"</e></m>
		</meta>
	</class>
	<class path="cs.internal.Runtime" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/Runtime.hx">
		<undefined public="1" set="null" expr="new cs.system.Object()" line="74" static="1">
			<d/>
			<meta>
				<m n=":value"><e>new cs.system.Object()</e></m>
				<m n=":readOnly"/>
			</meta>
		</undefined>
		<closure public="1" set="method" line="76" static="1"><f a="obj:hash:field">
	<d/>
	<x path="Int"/>
	<c path="String"/>
	<d/>
</f></closure>
		<eq public="1" set="method" line="80" static="1"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Bool"/>
</f></eq>
		<refEq public="1" set="method" line="133" static="1"><f a="v1:v2">
	<a/>
	<a/>
	<x path="Bool"/>
</f></refEq>
		<toDouble public="1" set="method" line="141" static="1"><f a="obj">
	<d/>
	<x path="Float"/>
</f></toDouble>
		<toInt public="1" set="method" line="145" static="1"><f a="obj">
	<d/>
	<x path="Int"/>
</f></toInt>
		<isInt public="1" set="method" line="155" static="1"><f a="obj">
	<d/>
	<x path="Bool"/>
</f></isInt>
		<isUInt public="1" set="method" line="171" static="1"><f a="obj">
	<d/>
	<x path="Bool"/>
</f></isUInt>
		<compare public="1" set="method" line="187" static="1"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compare>
		<plus public="1" set="method" line="230" static="1"><f a="v1:v2">
	<d/>
	<d/>
	<d/>
</f></plus>
		<slowGetField public="1" set="method" line="254" static="1"><f a="obj:field:throwErrors">
	<d/>
	<c path="String"/>
	<x path="Bool"/>
	<d/>
</f></slowGetField>
		<slowHasField public="1" set="method" line="308" static="1"><f a="obj:field">
	<d/>
	<c path="String"/>
	<x path="Bool"/>
</f></slowHasField>
		<slowSetField public="1" set="method" line="328" static="1"><f a="obj:field:value">
	<d/>
	<c path="String"/>
	<d/>
	<d/>
</f></slowSetField>
		<callMethod public="1" set="method" line="383" static="1">
			<f a="obj:methods:methodLength:args">
				<d/>
				<c path="cs.NativeArray"><c path="cs.system.reflection.MethodBase"/></c>
				<x path="Int"/>
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</callMethod>
		<unbox public="1" set="method" line="501" static="1">
			<f a="dyn">
				<d/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</unbox>
		<mkNullable public="1" set="method" line="515" static="1">
			<f a="obj:nullableType">
				<d/>
				<c path="cs.system.Type"/>
				<d/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\n\t\tif (nullableType.ContainsGenericParameters)\n\t\t\treturn haxe.lang.Null<object>.ofDynamic<object>(obj);\n\t\treturn nullableType.GetMethod(\"_ofDynamic\").Invoke(null, new object[] { obj });\n\t"]]></e></m></meta>
		</mkNullable>
		<slowCallField public="1" set="method" line="524" static="1">
			<f a="obj:field:args">
				<d/>
				<c path="String"/>
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</slowCallField>
		<callField public="1" set="method" line="574" static="1">
			<f a="obj:field:fieldHash:args">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</callField>
		<getField public="1" set="method" line="581" static="1">
			<f a="obj:field:fieldHash:throwErrors">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getField>
		<getField_f public="1" set="method" line="589" static="1">
			<f a="obj:field:fieldHash:throwErrors">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getField_f>
		<setField public="1" set="method" line="597" static="1">
			<f a="obj:field:fieldHash:value">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setField>
		<setField_f public="1" set="method" line="605" static="1">
			<f a="obj:field:fieldHash:value">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setField_f>
		<toString public="1" set="method" line="613" static="1">
			<f a="obj">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</toString>
		<typeEq public="1" set="method" line="628" static="1"><f a="t1:t2">
	<c path="cs.system.Type"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></typeEq>
		<getGenericAttr public="1" set="method" line="653" static="1"><f a="t">
	<c path="cs.system.Type"/>
	<c path="cs.internal.GenericInterface"/>
</f></getGenericAttr>
		<genericCast public="1" params="To" set="method" line="678" static="1">
			<f a="obj">
				<d/>
				<c path="genericCast.To"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\tif (obj is To)\n\t\t\treturn (To) obj;\n\t\telse if (obj == null)\n\t\t\treturn default(To);\n\t\tif (typeof(To) == typeof(double))\n\t\t\treturn (To)(object) toDouble(obj);\n\t\telse if (typeof(To) == typeof(int))\n\t\t\treturn (To)(object) toInt(obj);\n\t\telse if (typeof(To) == typeof(float))\n\t\t\treturn (To)(object)(float)toDouble(obj);\n\t\telse if (typeof(To) == typeof(long))\n\t\t\treturn (To)(object)(long)toDouble(obj);\n\t\telse\n\t\t\treturn (To) obj;\n\t"</e></m></meta>
		</genericCast>
		<concat public="1" set="method" line="686" static="1">
			<f a="s1:s2">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":functionCode"><e>"\n\t\treturn (s1 == null ? \"null\" : s1) + (s2 == null ? \"null\" : s2);\n\t"</e></m></meta>
		</concat>
		<toBool public="1" set="method" line="690" static="1">
			<f a="dyn">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</toBool>
		<haxe_doc>This class is meant for internal compiler use only. It provides the Haxe runtime
	compatibility to the host language.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.Runtime"</e></m>
			<m n=":access"><e>String</e></m>
			<m n=":classCode"><e><![CDATA["\n\tpublic static object getField(haxe.lang.HxObject obj, string field, int fieldHash, bool throwErrors)\n\t{\n\t\tif (obj == null && !throwErrors) return null;\n\t\treturn obj.__hx_getField(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, throwErrors, false, false);\n\t}\n\n\tpublic static double getField_f(haxe.lang.HxObject obj, string field, int fieldHash, bool throwErrors)\n\t{\n\t\tif (obj == null && !throwErrors) return 0.0;\n\t\treturn obj.__hx_getField_f(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, throwErrors, false);\n\t}\n\n\tpublic static object setField(haxe.lang.HxObject obj, string field, int fieldHash, object value)\n\t{\n\t\treturn obj.__hx_setField(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, value, false);\n\t}\n\n\tpublic static double setField_f(haxe.lang.HxObject obj, string field, int fieldHash, double value)\n\t{\n\t\treturn obj.__hx_setField_f(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, value, false);\n\t}\n\n\tpublic static object callField(haxe.lang.HxObject obj, string field, int fieldHash, object[] args)\n\t{\n\t\treturn obj.__hx_invokeField(field, (fieldHash == 0) ? haxe.lang.FieldLookup.hash(field) : fieldHash, args);\n\t}\n"]]></e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="cs.system.Int32" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Int32" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IComparable_1"><x path="Int"/></implements>
		<implements path="cs.system.IEquatable_1"><x path="Int"/></implements>
		<implements path="cs.system.IConvertible"/>
		<implements path="cs.system.IFormattable"/>
		<MinValue public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":readOnly"/></meta>
		</MinValue>
		<MaxValue public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":readOnly"/></meta>
		</MaxValue>
		<Parse public="1" set="method" static="1">
			<f a="s:provider">
				<c path="String"/>
				<c path="cs.system.IFormatProvider"/>
				<x path="Int"/>
			</f>
			<overloads>
				<Parse public="1" set="method"><f a="s:style:provider">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<c path="cs.system.IFormatProvider"/>
	<x path="Int"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s">
	<c path="String"/>
	<x path="Int"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s:style">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<x path="Int"/>
</f></Parse>
			</overloads>
		</Parse>
		<TryParse public="1" set="method" static="1">
			<f a="s:result">
				<c path="String"/>
				<t path="cs.Out"><x path="Int"/></t>
				<x path="Bool"/>
			</f>
			<overloads><TryParse public="1" set="method"><f a="s:style:provider:result">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.Out"><x path="Int"/></t>
	<x path="Bool"/>
</f></TryParse></overloads>
		</TryParse>
		<CompareTo final="1" public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads><CompareTo final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></CompareTo></overloads>
		</CompareTo>
		<ToString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<overloads>
				<ToString final="1" public="1" set="method"><f a="format:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="format">
	<c path="String"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
			</overloads>
		</ToString>
		<GetTypeCode final="1" public="1" set="method"><f a=""><e path="cs.system.TypeCode"/></f></GetTypeCode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Int32"</e></m>
		</meta>
	</class>
	<class path="cs.Lib" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/Lib.hx">
		<decimalSeparator static="1"><c path="String"/></decimalSeparator>
		<applyCultureChanges public="1" set="method" line="38" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Changes the current culture settings to allow a consistent cross-target behavior.
		Currently the only change made is in regard to the decimal separator, which is always set to "."</haxe_doc>
		</applyCultureChanges>
		<nativeArray public="1" params="T" get="inline" set="null" line="59" static="1">
			<f a="arr:equalLengthRequired">
				<c path="Array"><c path="nativeArray.T"/></c>
				<x path="Bool"/>
				<c path="cs.NativeArray"><c path="nativeArray.T"/></c>
			</f>
			<haxe_doc>Returns a native array from the supplied Array. This native array is unsafe to be written on,
		as it may or may not be linked to the actual Array implementation.

		If equalLengthRequired is true, the result might be a copy of an array with the correct size.</haxe_doc>
		</nativeArray>
		<p_nativeArray params="T" set="method" line="71" static="1">
			<f a="arr:ret">
				<c path="Array"><c path="p_nativeArray.T"/></c>
				<c path="cs.system.Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</p_nativeArray>
		<as public="1" params="T" get="inline" set="null" line="85" static="1">
			<f a="obj:cl">
				<d/>
				<x path="Class"><c path="as.T"/></x>
				<c path="as.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Provides support for the "as" keyword in C#.
		If the object is not of the supplied type "T", it will return null instead of rasing an exception.

		This function will not work with Value Types (such as Int, Float, Bool...)</haxe_doc>
		</as>
		<fromNativeType public="1" get="inline" set="null" line="95" static="1">
			<f a="t">
				<c path="cs.system.Type"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc><![CDATA[Returns a Class<> equivalent to the native System.Type type.

		Currently Haxe's Class<> is equivalent to System.Type, but this is an implementation detail.
		This may change in the future, so use this function whenever you need to perform such conversion.]]></haxe_doc>
		</fromNativeType>
		<toNativeType public="1" get="inline" set="null" line="105" static="1">
			<f a="cl">
				<x path="Class"><d/></x>
				<c path="cs.system.Type"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc><![CDATA[Returns a System.Type equivalent to the Haxe Class<> type.

		Currently Haxe's Class<> is equivalent to System.Type, but this is an implementation detail.
		This may change in the future, so use this function whenever you need to perform such conversion.]]></haxe_doc>
		</toNativeType>
		<getNativeType public="1" get="inline" set="null" line="128" static="1">
			<f a="obj">
				<d/>
				<c path="cs.system.Type"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Gets the native System.Type from the supplied object. Will throw an exception in case of null being passed.</haxe_doc>
		</getNativeType>
		<array public="1" params="T" get="inline" set="null" line="147" static="1">
			<f a="native">
				<c path="cs.NativeArray"><c path="array.T"/></c>
				<c path="Array"><c path="array.T"/></c>
			</f>
			<haxe_doc>Returns a Haxe Array of a native Array.
		Unless `erase_generics` is defined, it won't copy the contents of the native array,
		so unless any operation triggers an array resize, all changes made to the Haxe array
		will affect the native array argument.</haxe_doc>
		</array>
		<rethrow public="1" get="inline" set="null" line="167" static="1">
			<f a="e">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Rethrow an exception. This is useful when manually filtering an exception in order
		to keep the previous exception stack.</haxe_doc>
		</rethrow>
		<checked public="1" params="V" get="inline" set="null" line="184" static="1">
			<f a="block">
				<c path="checked.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a "checked" block, which throws exceptions for overflows.

		Usage:
			cs.Lib.checked({
				var x = 1000;
				while(true)
				{
					x *= x;
				}
			});
		This method only exists at compile-time, so it can't be called via reflection.</haxe_doc>
		</checked>
		<lock public="1" params="O:V" get="inline" set="null" line="195" static="1">
			<f a="obj:block">
				<c path="lock.O"/>
				<c path="lock.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Ensures that one thread does not enter a critical section of code while another thread
		is in the critical section. If another thread attempts to enter a locked code, it
		will wait, block, until the object is released.

		This method only exists at compile-time, so it can't be called via reflection.</haxe_doc>
		</lock>
		<haxe_doc>Platform-specific C# Library. Provides some platform-specific functions for the C# target,
	such as conversion from haxe types to native types and vice-versa.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="cs._NativeArray.NativeArrayIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/NativeArray.hx" private="1" module="cs.NativeArray">
		<arr public="1" set="null"><c path="cs.NativeArray"><c path="cs._NativeArray.NativeArrayIterator.T"/></c></arr>
		<idx public="1" set="null"><x path="UInt"/></idx>
		<hasNext public="1" get="inline" set="null" line="73"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="75"><f a=""><c path="cs._NativeArray.NativeArrayIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="67"><f a="arr">
	<c path="cs.NativeArray"><c path="cs._NativeArray.NativeArrayIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":dce"/>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._Attribute" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._Attribute" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._Attribute"</e></m>
		</meta>
	</class>
	<class path="cs.system.Attribute" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Attribute" extern="1" abstract="1">
		<implements path="cs.system.runtime.interopservices._Attribute"/>
		<GetCustomAttribute public="1" set="method" static="1">
			<f a="element:attributeType">
				<c path="cs.system.reflection.ParameterInfo"/>
				<c path="cs.system.Type"/>
				<c path="cs.system.Attribute"/>
			</f>
			<overloads>
				<GetCustomAttribute public="1" set="method"><f a="element:attributeType:inherit">
	<c path="cs.system.reflection.MemberInfo"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.system.Attribute"/>
</f></GetCustomAttribute>
				<GetCustomAttribute public="1" set="method"><f a="element:attributeType:inherit">
	<c path="cs.system.reflection.ParameterInfo"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.system.Attribute"/>
</f></GetCustomAttribute>
				<GetCustomAttribute public="1" set="method"><f a="element:attributeType:inherit">
	<c path="cs.system.reflection.Assembly"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.system.Attribute"/>
</f></GetCustomAttribute>
				<GetCustomAttribute public="1" set="method"><f a="element:attributeType:inherit">
	<c path="cs.system.reflection.Module"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.system.Attribute"/>
</f></GetCustomAttribute>
				<GetCustomAttribute public="1" set="method"><f a="element:attributeType">
	<c path="cs.system.reflection.Module"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.Attribute"/>
</f></GetCustomAttribute>
				<GetCustomAttribute public="1" set="method"><f a="element:attributeType">
	<c path="cs.system.reflection.Assembly"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.Attribute"/>
</f></GetCustomAttribute>
				<GetCustomAttribute public="1" set="method"><f a="element:attributeType">
	<c path="cs.system.reflection.MemberInfo"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.Attribute"/>
</f></GetCustomAttribute>
			</overloads>
		</GetCustomAttribute>
		<GetCustomAttributes public="1" set="method" static="1">
			<f a="element">
				<c path="cs.system.reflection.Assembly"/>
				<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
			</f>
			<overloads>
				<GetCustomAttributes public="1" set="method"><f a="element:inherit">
	<c path="cs.system.reflection.ParameterInfo"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element:inherit">
	<c path="cs.system.reflection.MemberInfo"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element:inherit">
	<c path="cs.system.reflection.Assembly"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element:inherit">
	<c path="cs.system.reflection.Module"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element:type:inherit">
	<c path="cs.system.reflection.MemberInfo"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element:attributeType:inherit">
	<c path="cs.system.reflection.Module"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element:attributeType:inherit">
	<c path="cs.system.reflection.ParameterInfo"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element:attributeType:inherit">
	<c path="cs.system.reflection.Assembly"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element:type">
	<c path="cs.system.reflection.MemberInfo"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element:attributeType">
	<c path="cs.system.reflection.ParameterInfo"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element:attributeType">
	<c path="cs.system.reflection.Module"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element:attributeType">
	<c path="cs.system.reflection.Assembly"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element">
	<c path="cs.system.reflection.Module"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element">
	<c path="cs.system.reflection.MemberInfo"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
				<GetCustomAttributes public="1" set="method"><f a="element">
	<c path="cs.system.reflection.ParameterInfo"/>
	<c path="cs.NativeArray"><c path="cs.system.Attribute"/></c>
</f></GetCustomAttributes>
			</overloads>
		</GetCustomAttributes>
		<IsDefined public="1" set="method" static="1">
			<f a="element:attributeType">
				<c path="cs.system.reflection.Module"/>
				<c path="cs.system.Type"/>
				<x path="Bool"/>
			</f>
			<overloads>
				<IsDefined public="1" set="method"><f a="element:attributeType:inherit">
	<c path="cs.system.reflection.ParameterInfo"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
				<IsDefined public="1" set="method"><f a="element:attributeType:inherit">
	<c path="cs.system.reflection.Module"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
				<IsDefined public="1" set="method"><f a="element:attributeType:inherit">
	<c path="cs.system.reflection.Assembly"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
				<IsDefined public="1" set="method"><f a="element:attributeType:inherit">
	<c path="cs.system.reflection.MemberInfo"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
				<IsDefined public="1" set="method"><f a="element:attributeType">
	<c path="cs.system.reflection.Assembly"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsDefined>
				<IsDefined public="1" set="method"><f a="element:attributeType">
	<c path="cs.system.reflection.MemberInfo"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsDefined>
				<IsDefined public="1" set="method"><f a="element:attributeType">
	<c path="cs.system.reflection.ParameterInfo"/>
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsDefined>
			</overloads>
		</IsDefined>
		<TypeId public="1" get="accessor" set="null"><d/></TypeId>
		<get_TypeId public="1" set="method"><f a=""><d/></f></get_TypeId>
		<IsDefaultAttribute public="1" set="method"><f a=""><x path="Bool"/></f></IsDefaultAttribute>
		<Match public="1" set="method"><f a="obj">
	<d/>
	<x path="Bool"/>
</f></Match>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Attribute"</e></m>
		</meta>
	</class>
	<class path="cs.internal.GenericInterface" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/HxObject.hx" module="cs.internal.HxObject">
		<extends path="cs.system.Attribute"/>
		<generic public="1" set="null">
			<c path="cs.system.Type"/>
			<meta><m n=":readOnly"/></meta>
		</generic>
		<new public="1" set="method" line="258">
			<f a="generic">
				<c path="cs.system.Type"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":nativeGen"/>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.GenericInterface"</e></m>
		</meta>
	</class>
	<class path="cs.system.Console" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Console" extern="1" final="1">
		<CancelKeyPress static="1">
			<x path="cs.system.ConsoleCancelEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</CancelKeyPress>
		<WindowWidth public="1" get="accessor" set="accessor" static="1"><x path="Int"/></WindowWidth>
		<WindowTop public="1" get="accessor" set="accessor" static="1"><x path="Int"/></WindowTop>
		<WindowLeft public="1" get="accessor" set="accessor" static="1"><x path="Int"/></WindowLeft>
		<WindowHeight public="1" get="accessor" set="accessor" static="1"><x path="Int"/></WindowHeight>
		<TreatControlCAsInput public="1" get="accessor" set="accessor" static="1"><x path="Bool"/></TreatControlCAsInput>
		<Title public="1" get="accessor" set="accessor" static="1"><c path="String"/></Title>
		<NumberLock public="1" get="accessor" set="null" static="1"><x path="Bool"/></NumberLock>
		<LargestWindowWidth public="1" get="accessor" set="null" static="1"><x path="Int"/></LargestWindowWidth>
		<LargestWindowHeight public="1" get="accessor" set="null" static="1"><x path="Int"/></LargestWindowHeight>
		<KeyAvailable public="1" get="accessor" set="null" static="1"><x path="Bool"/></KeyAvailable>
		<ForegroundColor public="1" get="accessor" set="accessor" static="1"><e path="cs.system.ConsoleColor"/></ForegroundColor>
		<CursorVisible public="1" get="accessor" set="accessor" static="1"><x path="Bool"/></CursorVisible>
		<CursorSize public="1" get="accessor" set="accessor" static="1"><x path="Int"/></CursorSize>
		<CursorTop public="1" get="accessor" set="accessor" static="1"><x path="Int"/></CursorTop>
		<CursorLeft public="1" get="accessor" set="accessor" static="1"><x path="Int"/></CursorLeft>
		<CapsLock public="1" get="accessor" set="null" static="1"><x path="Bool"/></CapsLock>
		<BufferWidth public="1" get="accessor" set="accessor" static="1"><x path="Int"/></BufferWidth>
		<BufferHeight public="1" get="accessor" set="accessor" static="1"><x path="Int"/></BufferHeight>
		<BackgroundColor public="1" get="accessor" set="accessor" static="1"><e path="cs.system.ConsoleColor"/></BackgroundColor>
		<OutputEncoding public="1" get="accessor" set="accessor" static="1"><c path="cs.system.text.Encoding"/></OutputEncoding>
		<InputEncoding public="1" get="accessor" set="accessor" static="1"><c path="cs.system.text.Encoding"/></InputEncoding>
		<In public="1" get="accessor" set="null" static="1"><c path="cs.system.io.TextReader"/></In>
		<Out public="1" get="accessor" set="null" static="1"><c path="cs.system.io.TextWriter"/></Out>
		<Error public="1" get="accessor" set="null" static="1"><c path="cs.system.io.TextWriter"/></Error>
		<add_CancelKeyPress public="1" set="method" static="1"><f a="value">
	<x path="cs.system.ConsoleCancelEventHandler"/>
	<x path="Void"/>
</f></add_CancelKeyPress>
		<remove_CancelKeyPress public="1" set="method" static="1"><f a="value">
	<x path="cs.system.ConsoleCancelEventHandler"/>
	<x path="Void"/>
</f></remove_CancelKeyPress>
		<get_Error public="1" set="method" static="1"><f a=""><c path="cs.system.io.TextWriter"/></f></get_Error>
		<get_Out public="1" set="method" static="1"><f a=""><c path="cs.system.io.TextWriter"/></f></get_Out>
		<get_In public="1" set="method" static="1"><f a=""><c path="cs.system.io.TextReader"/></f></get_In>
		<OpenStandardError public="1" set="method" static="1">
			<f a=""><c path="cs.system.io.Stream"/></f>
			<overloads><OpenStandardError public="1" set="method"><f a="bufferSize">
	<x path="Int"/>
	<c path="cs.system.io.Stream"/>
</f></OpenStandardError></overloads>
		</OpenStandardError>
		<OpenStandardInput public="1" set="method" static="1">
			<f a=""><c path="cs.system.io.Stream"/></f>
			<overloads><OpenStandardInput public="1" set="method"><f a="bufferSize">
	<x path="Int"/>
	<c path="cs.system.io.Stream"/>
</f></OpenStandardInput></overloads>
		</OpenStandardInput>
		<OpenStandardOutput public="1" set="method" static="1">
			<f a=""><c path="cs.system.io.Stream"/></f>
			<overloads><OpenStandardOutput public="1" set="method"><f a="bufferSize">
	<x path="Int"/>
	<c path="cs.system.io.Stream"/>
</f></OpenStandardOutput></overloads>
		</OpenStandardOutput>
		<SetError public="1" set="method" static="1"><f a="newError">
	<c path="cs.system.io.TextWriter"/>
	<x path="Void"/>
</f></SetError>
		<SetIn public="1" set="method" static="1"><f a="newIn">
	<c path="cs.system.io.TextReader"/>
	<x path="Void"/>
</f></SetIn>
		<SetOut public="1" set="method" static="1"><f a="newOut">
	<c path="cs.system.io.TextWriter"/>
	<x path="Void"/>
</f></SetOut>
		<Write public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<overloads>
				<Write public="1" set="method"><f a="format:arg0:arg1:arg2:arg3">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="format:arg0:arg1:arg2">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="format:arg0:arg1">
	<c path="String"/>
	<d/>
	<d/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="buffer:index:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="format:arg">
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="format:arg0">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<d/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="buffer">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Void"/>
</f></Write>
			</overloads>
		</Write>
		<WriteLine public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<overloads>
				<WriteLine public="1" set="method"><f a="format:arg0:arg1:arg2:arg3">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="format:arg0:arg1:arg2">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="format:arg0:arg1">
	<c path="String"/>
	<d/>
	<d/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="buffer:index:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="format:arg">
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="format:arg0">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<d/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="buffer">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></WriteLine>
			</overloads>
		</WriteLine>
		<Read public="1" set="method" static="1"><f a=""><x path="Int"/></f></Read>
		<ReadLine public="1" set="method" static="1"><f a=""><c path="String"/></f></ReadLine>
		<get_InputEncoding public="1" set="method" static="1"><f a=""><c path="cs.system.text.Encoding"/></f></get_InputEncoding>
		<set_InputEncoding public="1" set="method" static="1"><f a="value">
	<c path="cs.system.text.Encoding"/>
	<c path="cs.system.text.Encoding"/>
</f></set_InputEncoding>
		<get_OutputEncoding public="1" set="method" static="1"><f a=""><c path="cs.system.text.Encoding"/></f></get_OutputEncoding>
		<set_OutputEncoding public="1" set="method" static="1"><f a="value">
	<c path="cs.system.text.Encoding"/>
	<c path="cs.system.text.Encoding"/>
</f></set_OutputEncoding>
		<get_BackgroundColor public="1" set="method" static="1"><f a=""><e path="cs.system.ConsoleColor"/></f></get_BackgroundColor>
		<set_BackgroundColor public="1" set="method" static="1"><f a="value">
	<e path="cs.system.ConsoleColor"/>
	<e path="cs.system.ConsoleColor"/>
</f></set_BackgroundColor>
		<get_BufferHeight public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_BufferHeight>
		<set_BufferHeight public="1" set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_BufferHeight>
		<get_BufferWidth public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_BufferWidth>
		<set_BufferWidth public="1" set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_BufferWidth>
		<get_CapsLock public="1" set="method" static="1"><f a=""><x path="Bool"/></f></get_CapsLock>
		<get_CursorLeft public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_CursorLeft>
		<set_CursorLeft public="1" set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_CursorLeft>
		<get_CursorTop public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_CursorTop>
		<set_CursorTop public="1" set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_CursorTop>
		<get_CursorSize public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_CursorSize>
		<set_CursorSize public="1" set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_CursorSize>
		<get_CursorVisible public="1" set="method" static="1"><f a=""><x path="Bool"/></f></get_CursorVisible>
		<set_CursorVisible public="1" set="method" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_CursorVisible>
		<get_ForegroundColor public="1" set="method" static="1"><f a=""><e path="cs.system.ConsoleColor"/></f></get_ForegroundColor>
		<set_ForegroundColor public="1" set="method" static="1"><f a="value">
	<e path="cs.system.ConsoleColor"/>
	<e path="cs.system.ConsoleColor"/>
</f></set_ForegroundColor>
		<get_KeyAvailable public="1" set="method" static="1"><f a=""><x path="Bool"/></f></get_KeyAvailable>
		<get_LargestWindowHeight public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_LargestWindowHeight>
		<get_LargestWindowWidth public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_LargestWindowWidth>
		<get_NumberLock public="1" set="method" static="1"><f a=""><x path="Bool"/></f></get_NumberLock>
		<get_Title public="1" set="method" static="1"><f a=""><c path="String"/></f></get_Title>
		<set_Title public="1" set="method" static="1"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Title>
		<get_TreatControlCAsInput public="1" set="method" static="1"><f a=""><x path="Bool"/></f></get_TreatControlCAsInput>
		<set_TreatControlCAsInput public="1" set="method" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_TreatControlCAsInput>
		<get_WindowHeight public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_WindowHeight>
		<set_WindowHeight public="1" set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_WindowHeight>
		<get_WindowLeft public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_WindowLeft>
		<set_WindowLeft public="1" set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_WindowLeft>
		<get_WindowTop public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_WindowTop>
		<set_WindowTop public="1" set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_WindowTop>
		<get_WindowWidth public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_WindowWidth>
		<set_WindowWidth public="1" set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_WindowWidth>
		<Beep public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<overloads><Beep public="1" set="method"><f a="frequency:duration">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Beep></overloads>
		</Beep>
		<Clear public="1" set="method" static="1"><f a=""><x path="Void"/></f></Clear>
		<MoveBufferArea public="1" set="method" static="1">
			<f a="sourceLeft:sourceTop:sourceWidth:sourceHeight:targetLeft:targetTop">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads><MoveBufferArea public="1" set="method"><f a="sourceLeft:sourceTop:sourceWidth:sourceHeight:targetLeft:targetTop:sourceChar:sourceForeColor:sourceBackColor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="cs.types.Char16"/>
	<e path="cs.system.ConsoleColor"/>
	<e path="cs.system.ConsoleColor"/>
	<x path="Void"/>
</f></MoveBufferArea></overloads>
		</MoveBufferArea>
		<ReadKey public="1" set="method" static="1">
			<f a=""><c path="cs.system.ConsoleKeyInfo"/></f>
			<overloads><ReadKey public="1" set="method"><f a="intercept">
	<x path="Bool"/>
	<c path="cs.system.ConsoleKeyInfo"/>
</f></ReadKey></overloads>
		</ReadKey>
		<ResetColor public="1" set="method" static="1"><f a=""><x path="Void"/></f></ResetColor>
		<SetBufferSize public="1" set="method" static="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></SetBufferSize>
		<SetCursorPosition public="1" set="method" static="1"><f a="left:top">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></SetCursorPosition>
		<SetWindowPosition public="1" set="method" static="1"><f a="left:top">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></SetWindowPosition>
		<SetWindowSize public="1" set="method" static="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></SetWindowSize>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Console"</e></m>
		</meta>
	</class>
	<class path="ceramic.Script" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Script.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<MAX_LOOP_ITERATIONS expr="1999999" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1999999</e></m></meta>
		</MAX_LOOP_ITERATIONS>
		<errorHandlers public="1" expr="[]" line="12" static="1">
			<c path="Array"><f a="error:line:char">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</errorHandlers>
		<traceHandlers public="1" expr="[]" line="14" static="1">
			<c path="Array"><f a="v:?pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</traceHandlers>
		<log public="1" set="null" expr="new Logger()" line="16" static="1">
			<c path="ceramic.Logger"/>
			<meta><m n=":value"><e>new Logger()</e></m></meta>
		</log>
		<parser expr="null" line="18" static="1">
			<c path="hscript.Parser"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</parser>
		<content public="1" set="null"><c path="String"/></content>
		<program public="1" set="null"><e path="hscript.Expr"/></program>
		<interp public="1" set="null"><c path="ceramic.Interp"/></interp>
		<module public="1" set="null"><c path="ceramic.ScriptModule"/></module>
		<ready expr="false" line="28">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</ready>
		<running expr="false" line="30">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</running>
		<broken expr="false" line="32">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</broken>
		<loopStates expr="null" line="34">
			<c path="ceramic.IntIntMap"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</loopStates>
		<destroy public="1" set="method" line="85" override="1"><f a=""><x path="Void"/></f></destroy>
		<bindAsComponent set="method" line="91"><f a=""><x path="Void"/></f></bindAsComponent>
		<run public="1" set="method" line="108"><f a=""><x path="Void"/></f></run>
		<getEntityById public="1" set="method" line="147"><f a="itemId">
	<c path="String"/>
	<c path="ceramic.Entity"/>
</f></getEntityById>
		<getModule public="1" set="method" line="177"><f a="itemId">
	<c path="String"/>
	<c path="ceramic.ScriptModule"/>
</f></getModule>
		<get public="1" set="method" line="194"><f a="name">
	<c path="String"/>
	<d/>
</f></get>
		<call public="1" set="method" line="200"><f a="name:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<callScriptMethod public="1" set="method" line="226"><f a="name:numArgs:?arg1:?arg2:?arg3">
	<c path="String"/>
	<x path="Int"/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></callScriptMethod>
		<checkLoop set="method" line="253"><f a="index">
	<x path="Int"/>
	<x path="Bool"/>
</f></checkLoop>
		<resetCheckLoop set="method" line="271"><f a="_">
	<x path="Float"/>
	<x path="Void"/>
</f></resetCheckLoop>
		<entity public="1">
			<c path="ceramic.Entity"/>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</entity>
		<setEntity set="method" line="8">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="8">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="36"><f a="content">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="hscript.Interp" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Interp.hx">
		<variables public="1"><t path="Map">
	<c path="String"/>
	<d/>
</t></variables>
		<locals><t path="Map">
	<c path="String"/>
	<a><r><d/></r></a>
</t></locals>
		<binops><t path="Map">
	<c path="String"/>
	<f a=":">
		<e path="hscript.Expr"/>
		<e path="hscript.Expr"/>
		<d/>
	</f>
</t></binops>
		<depth><x path="Int"/></depth>
		<inTry><x path="Bool"/></inTry>
		<declared><c path="Array"><a>
	<old><a><r><d/></r></a></old>
	<n><c path="String"/></n>
</a></c></declared>
		<returnValue><d/></returnValue>
		<resetVariables set="method" line="65"><f a=""><x path="Void"/></f></resetVariables>
		<posInfos public="1" set="method" line="83"><f a=""><t path="haxe.PosInfos"/></f></posInfos>
		<initOps set="method" line="91"><f a=""><x path="Void"/></f></initOps>
		<setVar set="method" line="132"><f a="name:v">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></setVar>
		<assign set="method" line="136"><f a="e1:e2">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<d/>
</f></assign>
		<assignOp set="method" line="163"><f a="op:fop">
	<c path="String"/>
	<f a=":">
		<d/>
		<d/>
		<d/>
	</f>
	<x path="Void"/>
</f></assignOp>
		<evalAssignOp set="method" line="168"><f a="op:fop:e1:e2">
	<c path="String"/>
	<f a=":">
		<d/>
		<d/>
		<d/>
	</f>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<d/>
</f></evalAssignOp>
		<increment set="method" line="199"><f a="e:prefix:delta">
	<e path="hscript.Expr"/>
	<x path="Bool"/>
	<x path="Int"/>
	<d/>
</f></increment>
		<execute public="1" set="method" line="251"><f a="expr">
	<e path="hscript.Expr"/>
	<d/>
</f></execute>
		<exprReturn set="method" line="262"><f a="e">
	<e path="hscript.Expr"/>
	<d/>
</f></exprReturn>
		<duplicate params="T" set="method" line="278"><f a="h">
	<t path="Map">
		<c path="String"/>
		<c path="duplicate.T"/>
	</t>
	<x path="haxe.ds.Map">
		<c path="String"/>
		<x path="Null"><c path="duplicate.T"/></x>
	</x>
</f></duplicate>
		<restore set="method" line="289"><f a="old">
	<x path="Int"/>
	<x path="Void"/>
</f></restore>
		<error get="inline" set="null" line="296">
			<f a="e:?rethrow" v=":false">
				<e path="hscript.Error"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ rethrow : false }</e></m></meta>
		</error>
		<rethrow get="inline" set="null" line="302"><f a="e">
	<d/>
	<x path="Void"/>
</f></rethrow>
		<resolve set="method" line="310"><f a="id">
	<c path="String"/>
	<d/>
</f></resolve>
		<expr public="1" set="method" line="320"><f a="e">
	<e path="hscript.Expr"/>
	<d/>
</f></expr>
		<doWhileLoop set="method" line="590"><f a="econd:e">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<x path="Void"/>
</f></doWhileLoop>
		<whileLoop set="method" line="607"><f a="econd:e">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<x path="Void"/>
</f></whileLoop>
		<makeIterator set="method" line="623"><f a="v">
	<d/>
	<t path="Iterator"><d/></t>
</f></makeIterator>
		<forLoop set="method" line="633"><f a="n:it:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<x path="Void"/>
</f></forLoop>
		<isMap get="inline" set="null" line="652"><f a="o">
	<d/>
	<x path="Bool"/>
</f></isMap>
		<getMapValue get="inline" set="null" line="656"><f a="map:key">
	<d/>
	<d/>
	<d/>
</f></getMapValue>
		<setMapValue get="inline" set="null" line="660"><f a="map:key:value">
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></setMapValue>
		<get set="method" line="664"><f a="o:f">
	<d/>
	<c path="String"/>
	<d/>
</f></get>
		<set set="method" line="680"><f a="o:f:v">
	<d/>
	<c path="String"/>
	<d/>
	<d/>
</f></set>
		<fcall set="method" line="686"><f a="o:f:args">
	<d/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></fcall>
		<call set="method" line="690"><f a="o:f:args">
	<d/>
	<d/>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<cnew set="method" line="694"><f a="cl:args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></cnew>
		<new public="1" set="method" line="54"><f a=""><x path="Void"/></f></new>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.Interp" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Script.hx" module="ceramic.Script">
		<extends path="hscript.Interp"/>
		<owner><c path="ceramic.Script"/></owner>
		<fcall set="method" line="291" override="1"><f a="o:f:args">
	<d/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></fcall>
		<get set="method" line="303" override="1"><f a="o:f">
	<d/>
	<c path="String"/>
	<d/>
</f></get>
		<cnew set="method" line="323" override="1"><f a="cl:args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></cnew>
		<exprReturn set="method" line="342" override="1"><f a="e">
	<e path="hscript.Expr"/>
	<d/>
</f></exprReturn>
		<new public="1" set="method" line="283"><f a="owner">
	<c path="ceramic.Script"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="ceramic.ScriptContent" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScriptContent.hx">
		<c path="String"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="ceramic.ScriptModule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScriptModule.hx">
		<owner public="1" set="null"><c path="ceramic.Script"/></owner>
		<new public="1" set="method" line="11"><f a="owner">
	<c path="ceramic.Script"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* For now, just a way to identify a script module as a type, to resolve fields dynamically from scripts.
 * Might be extended later to link with "script converted to haxe compiled code"</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<enum path="cs.system.text.regularexpressions.RegexOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.RegexOptions">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<IgnoreCase><meta><m n=":csNative"><e>1</e></m></meta></IgnoreCase>
		<Multiline><meta><m n=":csNative"><e>2</e></m></meta></Multiline>
		<ExplicitCapture><meta><m n=":csNative"><e>4</e></m></meta></ExplicitCapture>
		<Compiled><meta><m n=":csNative"><e>8</e></m></meta></Compiled>
		<Singleline><meta><m n=":csNative"><e>16</e></m></meta></Singleline>
		<IgnorePatternWhitespace><meta><m n=":csNative"><e>32</e></m></meta></IgnorePatternWhitespace>
		<RightToLeft><meta><m n=":csNative"><e>64</e></m></meta></RightToLeft>
		<ECMAScript><meta><m n=":csNative"><e>256</e></m></meta></ECMAScript>
		<CultureInvariant><meta><m n=":csNative"><e>512</e></m></meta></CultureInvariant>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Text.RegularExpressions.RegexOptions"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.text.regularexpressions.Regex" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.Regex" extern="1">
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<CacheSize public="1" get="accessor" set="accessor" static="1"><x path="Int"/></CacheSize>
		<CompileToAssembly public="1" set="method" static="1">
			<f a="regexes:aname">
				<c path="cs.NativeArray"><c path="cs.system.text.regularexpressions.RegexCompilationInfo"/></c>
				<c path="cs.system.reflection.AssemblyName"/>
				<x path="Void"/>
			</f>
			<overloads>
				<CompileToAssembly public="1" set="method"><f a="regexes:aname:attribs:resourceFile">
	<c path="cs.NativeArray"><c path="cs.system.text.regularexpressions.RegexCompilationInfo"/></c>
	<c path="cs.system.reflection.AssemblyName"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.emit.CustomAttributeBuilder"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></CompileToAssembly>
				<CompileToAssembly public="1" set="method"><f a="regexes:aname:attribs">
	<c path="cs.NativeArray"><c path="cs.system.text.regularexpressions.RegexCompilationInfo"/></c>
	<c path="cs.system.reflection.AssemblyName"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.emit.CustomAttributeBuilder"/></c>
	<x path="Void"/>
</f></CompileToAssembly>
			</overloads>
		</CompileToAssembly>
		<Escape public="1" set="method" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></Escape>
		<Unescape public="1" set="method" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></Unescape>
		<IsMatch public="1" set="method" static="1">
			<f a="input:pattern">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<overloads><IsMatch public="1" set="method"><f a="input:pattern:options">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.text.regularexpressions.RegexOptions"/>
	<x path="Bool"/>
</f></IsMatch></overloads>
		</IsMatch>
		<_IsMatch public="1" set="method" static="1">
			<f a="input:pattern">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsMatch"</e></m></meta>
			<overloads><IsMatch public="1" set="method">
	<f a="input:pattern:options">
		<c path="String"/>
		<c path="String"/>
		<e path="cs.system.text.regularexpressions.RegexOptions"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":native"><e>"IsMatch"</e></m></meta>
</IsMatch></overloads>
		</_IsMatch>
		<Match public="1" set="method" static="1">
			<f a="input:pattern">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.text.regularexpressions.Match"/>
			</f>
			<overloads><Match public="1" set="method"><f a="input:pattern:options">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.text.regularexpressions.RegexOptions"/>
	<c path="cs.system.text.regularexpressions.Match"/>
</f></Match></overloads>
		</Match>
		<_Match public="1" set="method" static="1">
			<f a="input:pattern">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.text.regularexpressions.Match"/>
			</f>
			<meta><m n=":native"><e>"Match"</e></m></meta>
			<overloads><Match public="1" set="method">
	<f a="input:pattern:options">
		<c path="String"/>
		<c path="String"/>
		<e path="cs.system.text.regularexpressions.RegexOptions"/>
		<c path="cs.system.text.regularexpressions.Match"/>
	</f>
	<meta><m n=":native"><e>"Match"</e></m></meta>
</Match></overloads>
		</_Match>
		<Matches public="1" set="method" static="1">
			<f a="input:pattern">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.text.regularexpressions.MatchCollection"/>
			</f>
			<overloads><Matches public="1" set="method"><f a="input:pattern:options">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.text.regularexpressions.RegexOptions"/>
	<c path="cs.system.text.regularexpressions.MatchCollection"/>
</f></Matches></overloads>
		</Matches>
		<_Matches public="1" set="method" static="1">
			<f a="input:pattern">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.text.regularexpressions.MatchCollection"/>
			</f>
			<meta><m n=":native"><e>"Matches"</e></m></meta>
			<overloads><Matches public="1" set="method">
	<f a="input:pattern:options">
		<c path="String"/>
		<c path="String"/>
		<e path="cs.system.text.regularexpressions.RegexOptions"/>
		<c path="cs.system.text.regularexpressions.MatchCollection"/>
	</f>
	<meta><m n=":native"><e>"Matches"</e></m></meta>
</Matches></overloads>
		</_Matches>
		<Replace public="1" set="method" static="1">
			<f a="input:pattern:evaluator">
				<c path="String"/>
				<c path="String"/>
				<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
				<c path="String"/>
			</f>
			<overloads>
				<Replace public="1" set="method"><f a="input:pattern:replacement:options">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.text.regularexpressions.RegexOptions"/>
	<c path="String"/>
</f></Replace>
				<Replace public="1" set="method"><f a="input:pattern:replacement">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></Replace>
				<Replace public="1" set="method"><f a="input:pattern:evaluator:options">
	<c path="String"/>
	<c path="String"/>
	<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
	<e path="cs.system.text.regularexpressions.RegexOptions"/>
	<c path="String"/>
</f></Replace>
			</overloads>
		</Replace>
		<_Replace public="1" set="method" static="1">
			<f a="input:pattern:evaluator">
				<c path="String"/>
				<c path="String"/>
				<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"Replace"</e></m></meta>
			<overloads>
				<Replace public="1" set="method">
					<f a="input:pattern:replacement:options">
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
						<e path="cs.system.text.regularexpressions.RegexOptions"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"Replace"</e></m></meta>
				</Replace>
				<Replace public="1" set="method">
					<f a="input:pattern:replacement">
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"Replace"</e></m></meta>
				</Replace>
				<Replace public="1" set="method">
					<f a="input:pattern:evaluator:options">
						<c path="String"/>
						<c path="String"/>
						<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
						<e path="cs.system.text.regularexpressions.RegexOptions"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"Replace"</e></m></meta>
				</Replace>
			</overloads>
		</_Replace>
		<Split public="1" set="method" static="1">
			<f a="input:pattern">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.NativeArray"><c path="String"/></c>
			</f>
			<overloads><Split public="1" set="method"><f a="input:pattern:options">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.text.regularexpressions.RegexOptions"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></Split></overloads>
		</Split>
		<_Split public="1" set="method" static="1">
			<f a="input:pattern">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.NativeArray"><c path="String"/></c>
			</f>
			<meta><m n=":native"><e>"Split"</e></m></meta>
			<overloads><Split public="1" set="method">
	<f a="input:pattern:options">
		<c path="String"/>
		<c path="String"/>
		<e path="cs.system.text.regularexpressions.RegexOptions"/>
		<c path="cs.NativeArray"><c path="String"/></c>
	</f>
	<meta><m n=":native"><e>"Split"</e></m></meta>
</Split></overloads>
		</_Split>
		<get_CacheSize public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_CacheSize>
		<set_CacheSize public="1" set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_CacheSize>
		<RightToLeft public="1" get="accessor" set="null"><x path="Bool"/></RightToLeft>
		<Options public="1" get="accessor" set="null"><e path="cs.system.text.regularexpressions.RegexOptions"/></Options>
		<capslist><c path="cs.NativeArray"><c path="String"/></c></capslist>
		<capsize><x path="Int"/></capsize>
		<factory><c path="cs.system.text.regularexpressions.RegexRunnerFactory"/></factory>
		<caps><c path="cs.system.collections.Hashtable"/></caps>
		<capnames><c path="cs.system.collections.Hashtable"/></capnames>
		<roptions><e path="cs.system.text.regularexpressions.RegexOptions"/></roptions>
		<pattern><c path="String"/></pattern>
		<get_Options final="1" public="1" set="method"><f a=""><e path="cs.system.text.regularexpressions.RegexOptions"/></f></get_Options>
		<get_RightToLeft final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_RightToLeft>
		<GetGroupNames final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></GetGroupNames>
		<GetGroupNumbers final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><x path="Int"/></c></f></GetGroupNumbers>
		<GroupNameFromNumber final="1" public="1" set="method"><f a="i">
	<x path="Int"/>
	<c path="String"/>
</f></GroupNameFromNumber>
		<GroupNumberFromName final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Int"/>
</f></GroupNumberFromName>
		<IsMatch final="1" public="1" set="method">
			<f a="input">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<overloads><IsMatch final="1" public="1" set="method"><f a="input:startat">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsMatch></overloads>
		</IsMatch>
		<Match final="1" public="1" set="method">
			<f a="input">
				<c path="String"/>
				<c path="cs.system.text.regularexpressions.Match"/>
			</f>
			<overloads>
				<Match final="1" public="1" set="method"><f a="input:startat:length">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.text.regularexpressions.Match"/>
</f></Match>
				<Match final="1" public="1" set="method"><f a="input:startat">
	<c path="String"/>
	<x path="Int"/>
	<c path="cs.system.text.regularexpressions.Match"/>
</f></Match>
			</overloads>
		</Match>
		<Matches final="1" public="1" set="method">
			<f a="input">
				<c path="String"/>
				<c path="cs.system.text.regularexpressions.MatchCollection"/>
			</f>
			<overloads><Matches final="1" public="1" set="method"><f a="input:startat">
	<c path="String"/>
	<x path="Int"/>
	<c path="cs.system.text.regularexpressions.MatchCollection"/>
</f></Matches></overloads>
		</Matches>
		<Replace final="1" public="1" set="method">
			<f a="input:evaluator">
				<c path="String"/>
				<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
				<c path="String"/>
			</f>
			<overloads>
				<Replace final="1" public="1" set="method"><f a="input:replacement:count:startat">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></Replace>
				<Replace final="1" public="1" set="method"><f a="input:replacement:count">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></Replace>
				<Replace final="1" public="1" set="method"><f a="input:replacement">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></Replace>
				<Replace final="1" public="1" set="method"><f a="input:evaluator:count:startat">
	<c path="String"/>
	<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></Replace>
				<Replace final="1" public="1" set="method"><f a="input:evaluator:count">
	<c path="String"/>
	<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
	<x path="Int"/>
	<c path="String"/>
</f></Replace>
			</overloads>
		</Replace>
		<Split final="1" public="1" set="method">
			<f a="input">
				<c path="String"/>
				<c path="cs.NativeArray"><c path="String"/></c>
			</f>
			<overloads>
				<Split final="1" public="1" set="method"><f a="input:count:startat">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></Split>
				<Split final="1" public="1" set="method"><f a="input:count">
	<c path="String"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></Split>
			</overloads>
		</Split>
		<InitializeReferences final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</InitializeReferences>
		<UseOptionC final="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</UseOptionC>
		<UseOptionR final="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</UseOptionR>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
			<overloads>
				<new final="1" set="method">
					<f a="info:context">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" public="1" set="method"><f a="pattern:options">
	<c path="String"/>
	<e path="cs.system.text.regularexpressions.RegexOptions"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="pattern">
	<c path="String"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.Regex"</e></m>
		</meta>
	</class>
	<class path="ceramic.ScriptUtils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScriptUtils.hx">
		<toHscript public="1" set="method" line="15" static="1">
			<f a="code">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts the given `inScript` to hscript.
     * This will take care of transforming a few idioms borrowed from js/ts to hscript equivalent.
     * @param inScript 
     * @return String</haxe_doc>
		</toHscript>
		<cleanCode set="method" line="169" static="1"><f a="code">
	<c path="String"/>
	<c path="String"/>
</f></cleanCode>
		<fail set="method" line="289" static="1"><f a="error:i:code">
	<d/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></fail>
		<RE_WORD expr="~/^[a-zA-Z0-9_]+/" line="297" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^[a-zA-Z0-9_]+/</e></m></meta>
		</RE_WORD>
		<RE_SEP_WORD expr="~/^[^a-zA-Z0-9_]([a-zA-Z0-9_]+)/" line="299" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^[^a-zA-Z0-9_]([a-zA-Z0-9_]+)/</e></m></meta>
		</RE_SEP_WORD>
		<RE_STRING expr="~/^(?:&quot;(?:[^&quot;\\]*(?:\\.[^&quot;\\]*)*)&quot;|&apos;(?:[^&apos;\\]*(?:\\.[^&apos;\\]*)*)&apos;|`(?:[^`\\]*(?:\\.[^`\\]*)*)`)/" line="301" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^(?:"(?:[^"\\]*(?:\\.[^"\\]*)*)"|'(?:[^'\\]*(?:\\.[^'\\]*)*)'|`(?:[^`\\]*(?:\\.[^`\\]*)*)`)/</e></m></meta>
		</RE_STRING>
		<RE_FOR_OF expr="~/^for\s*\(\s*(var\s+)?([a-zA-Z0-9_]+)\s*(of|in)\s+/" line="303" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^for\s*\(\s*(var\s+)?([a-zA-Z0-9_]+)\s*(of|in)\s+/</e></m></meta>
		</RE_FOR_OF>
		<RE_WHILE_START expr="~/^while\s*\(/" line="305" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^while\s*\(/</e></m></meta>
		</RE_WHILE_START>
		<RE_ARROW_FUNC_NO_ARG expr="~/^\(\s*\)\s*=&gt;/" line="307" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e><![CDATA[~/^\(\s*\)\s*=>/]]></e></m></meta>
		</RE_ARROW_FUNC_NO_ARG>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<enum path="ceramic.ScrollDirection" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScrollDirection.hx">
		<HORIZONTAL/>
		<VERTICAL/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.Scroller" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Scroller.hx">
		<extends path="ceramic.Visual"/>
		<_point expr="new Point(0, 0)" line="10" static="1">
			<c path="ceramic.Point"/>
			<meta><m n=":value"><e>new Point(0, 0)</e></m></meta>
		</_point>
		<threshold public="1" expr="4.0" line="97" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>4.0</e></m></meta>
		</threshold>
		<_dox_event_dragStart public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_dragStart>
		<emitDragStart set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>dragStart event</haxe_doc>
		</emitDragStart>
		<onDragStart public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dragStart event</haxe_doc>
		</onDragStart>
		<onceDragStart public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dragStart event</haxe_doc>
		</onceDragStart>
		<offDragStart public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dragStart event</haxe_doc>
		</offDragStart>
		<listensDragStart public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to dragStart event</haxe_doc>
		</listensDragStart>
		<_dox_event_dragEnd public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_dragEnd>
		<emitDragEnd set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>dragEnd event</haxe_doc>
		</emitDragEnd>
		<onDragEnd public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dragEnd event</haxe_doc>
		</onDragEnd>
		<onceDragEnd public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dragEnd event</haxe_doc>
		</onceDragEnd>
		<offDragEnd public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>dragEnd event</haxe_doc>
		</offDragEnd>
		<listensDragEnd public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to dragEnd event</haxe_doc>
		</listensDragEnd>
		<_dox_event_wheelStart public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_wheelStart>
		<emitWheelStart set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>wheelStart event</haxe_doc>
		</emitWheelStart>
		<onWheelStart public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>wheelStart event</haxe_doc>
		</onWheelStart>
		<onceWheelStart public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>wheelStart event</haxe_doc>
		</onceWheelStart>
		<offWheelStart public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>wheelStart event</haxe_doc>
		</offWheelStart>
		<listensWheelStart public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to wheelStart event</haxe_doc>
		</listensWheelStart>
		<_dox_event_wheelEnd public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_wheelEnd>
		<emitWheelEnd set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>wheelEnd event</haxe_doc>
		</emitWheelEnd>
		<onWheelEnd public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>wheelEnd event</haxe_doc>
		</onWheelEnd>
		<onceWheelEnd public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>wheelEnd event</haxe_doc>
		</onceWheelEnd>
		<offWheelEnd public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>wheelEnd event</haxe_doc>
		</offWheelEnd>
		<listensWheelEnd public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to wheelEnd event</haxe_doc>
		</listensWheelEnd>
		<_dox_event_click public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_click>
		<emitClick set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>click event</haxe_doc>
		</emitClick>
		<onClick public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>click event</haxe_doc>
		</onClick>
		<onceClick public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>click event</haxe_doc>
		</onceClick>
		<offClick public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>click event</haxe_doc>
		</offClick>
		<listensClick public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to click event</haxe_doc>
		</listensClick>
		<_dox_event_scrollerPointerDown public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_scrollerPointerDown>
		<emitScrollerPointerDown set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>scrollerPointerDown event</haxe_doc>
		</emitScrollerPointerDown>
		<onScrollerPointerDown public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>scrollerPointerDown event</haxe_doc>
		</onScrollerPointerDown>
		<onceScrollerPointerDown public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>scrollerPointerDown event</haxe_doc>
		</onceScrollerPointerDown>
		<offScrollerPointerDown public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>scrollerPointerDown event</haxe_doc>
		</offScrollerPointerDown>
		<listensScrollerPointerDown public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to scrollerPointerDown event</haxe_doc>
		</listensScrollerPointerDown>
		<_dox_event_scrollerPointerUp public="1" set="method" line="637">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_scrollerPointerUp>
		<emitScrollerPointerUp set="method" line="1095">
			<f a="info">
				<c path="ceramic.TouchInfo"/>
				<x path="Void"/>
			</f>
			<haxe_doc>scrollerPointerUp event</haxe_doc>
		</emitScrollerPointerUp>
		<onScrollerPointerUp public="1" set="method" line="1199">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>scrollerPointerUp event</haxe_doc>
		</onScrollerPointerUp>
		<onceScrollerPointerUp public="1" set="method" line="1298">
			<f a="owner:handleInfo">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>scrollerPointerUp event</haxe_doc>
		</onceScrollerPointerUp>
		<offScrollerPointerUp public="1" set="method" line="1368">
			<f a="?handleInfo">
				<f a="info">
					<c path="ceramic.TouchInfo"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>scrollerPointerUp event</haxe_doc>
		</offScrollerPointerUp>
		<listensScrollerPointerUp public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to scrollerPointerUp event</haxe_doc>
		</listensScrollerPointerUp>
		<content public="1" set="null" expr="null" line="30">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</content>
		<scrollbar public="1" set="accessor" expr="null" line="32">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scrollbar>
		<set_scrollbar set="method" line="33"><f a="scrollbar">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
</f></set_scrollbar>
		<direction public="1" expr="VERTICAL" line="47">
			<e path="ceramic.ScrollDirection"/>
			<meta><m n=":value"><e>VERTICAL</e></m></meta>
		</direction>
		<allowPointerOutside public="1" expr="true" line="49">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</allowPointerOutside>
		<scrollTransform public="1" set="null" expr="new Transform()" line="51">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</scrollTransform>
		<scrollEnabled public="1" set="accessor" expr="true" line="53">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</scrollEnabled>
		<dragEnabled public="1" expr="true" line="55">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</dragEnabled>
		<roundScrollWhenIdle public="1" set="accessor" expr="1" line="67">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* If set to a value above zero, scrollX and scrollY will be rounded when scroller is idle.
     *
     * ```haxe
     * roundScrollWhenIdle = 0; // No rounding (default)
     * roundScrollWhenIdle = 1; // Pixel perfect rounding
     * roundScrollWhenIdle = 2; // Half-pixel rounding
     * ```</haxe_doc>
		</roundScrollWhenIdle>
		<set_roundScrollWhenIdle set="method" line="68"><f a="roundScrollWhenIdle">
	<x path="Int"/>
	<x path="Int"/>
</f></set_roundScrollWhenIdle>
		<status public="1" set="accessor" expr="IDLE" line="77">
			<e path="ceramic.ScrollerStatus"/>
			<meta><m n=":value"><e>IDLE</e></m></meta>
		</status>
		<set_status set="method" line="79"><f a="status">
	<e path="ceramic.ScrollerStatus"/>
	<e path="ceramic.ScrollerStatus"/>
</f></set_status>
		<verticalToHorizontalWheel public="1" expr="false" line="105">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* When set to `true`, vertical mouse wheel event
     * will also work on horizontal scroller.</haxe_doc>
		</verticalToHorizontalWheel>
		<deceleration public="1" expr="300.0" line="107">
			<x path="Float"/>
			<meta><m n=":value"><e>300.0</e></m></meta>
		</deceleration>
		<wheelDeceleration public="1" expr="1600.0" line="109">
			<x path="Float"/>
			<meta><m n=":value"><e>1600.0</e></m></meta>
		</wheelDeceleration>
		<wheelFactor public="1" expr="1.0" line="111">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</wheelFactor>
		<wheelMomentum public="1" expr="false" line="113">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</wheelMomentum>
		<wheelEndDelay public="1" expr="0.25" line="115">
			<x path="Float"/>
			<meta><m n=":value"><e>0.25</e></m></meta>
		</wheelEndDelay>
		<overScrollResistance public="1" expr="5.0" line="117">
			<x path="Float"/>
			<meta><m n=":value"><e>5.0</e></m></meta>
		</overScrollResistance>
		<maxClickMomentum public="1" expr="100.0" line="119">
			<x path="Float"/>
			<meta><m n=":value"><e>100.0</e></m></meta>
		</maxClickMomentum>
		<bounceMomentumFactor public="1" expr="0.00075" line="121">
			<x path="Float"/>
			<meta><m n=":value"><e>0.00075</e></m></meta>
		</bounceMomentumFactor>
		<bounceMinDuration public="1" expr="0.08" line="123">
			<x path="Float"/>
			<meta><m n=":value"><e>0.08</e></m></meta>
		</bounceMinDuration>
		<bounceDurationFactor public="1" expr="0.00004" line="125">
			<x path="Float"/>
			<meta><m n=":value"><e>0.00004</e></m></meta>
		</bounceDurationFactor>
		<bounceNoMomentumDuration public="1" expr="0.1" line="127">
			<x path="Float"/>
			<meta><m n=":value"><e>0.1</e></m></meta>
		</bounceNoMomentumDuration>
		<dragFactor public="1" expr="1.0" line="129">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</dragFactor>
		<touchableStrictHierarchy public="1" expr="true" line="131">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</touchableStrictHierarchy>
		<prevPointerX expr="-999999" line="135">
			<x path="Float"/>
			<meta><m n=":value"><e>-999999</e></m></meta>
		</prevPointerX>
		<prevPointerY expr="-999999" line="137">
			<x path="Float"/>
			<meta><m n=":value"><e>-999999</e></m></meta>
		</prevPointerY>
		<destroy public="1" set="method" line="166" override="1"><f a=""><x path="Void"/></f></destroy>
		<set_scrollEnabled set="method" line="177"><f a="scrollEnabled">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_scrollEnabled>
		<set_width set="method" line="196" override="1"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="208" override="1"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<interceptPointerDown set="method" line="220" override="1"><f a="hittingVisual:x:y:touchIndex:buttonId">
	<c path="ceramic.Visual"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></interceptPointerDown>
		<interceptPointerOver set="method" line="230" override="1"><f a="hittingVisual:x:y">
	<c path="ceramic.Visual"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></interceptPointerOver>
		<scrollToBounds public="1" set="method" line="245"><f a=""><x path="Void"/></f></scrollToBounds>
		<isContentPositionInBounds public="1" set="method" line="266"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isContentPositionInBounds>
		<ensureContentPositionIsInBounds public="1" set="method" line="282"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></ensureContentPositionIsInBounds>
		<scrollX public="1" get="accessor" set="accessor"><x path="Float"/></scrollX>
		<get_scrollX get="inline" set="null" line="328"><f a=""><x path="Float"/></f></get_scrollX>
		<set_scrollX get="inline" set="null" line="331"><f a="scrollX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scrollX>
		<scrollY public="1" get="accessor" set="accessor"><x path="Float"/></scrollY>
		<get_scrollY get="inline" set="null" line="339"><f a=""><x path="Float"/></f></get_scrollY>
		<set_scrollY get="inline" set="null" line="342"><f a="scrollY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scrollY>
		<position expr="0" line="351">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</position>
		<contentStart expr="0" line="353">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</contentStart>
		<pointerStart expr="0" line="355">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pointerStart>
		<touchIndex expr="-1" line="357">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</touchIndex>
		<scrollVelocity public="1" set="null" expr="null" line="359">
			<c path="ceramic.Velocity"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scrollVelocity>
		<momentum public="1" set="null" expr="0" line="361">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</momentum>
		<overScrollRelease expr="false" line="363">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</overScrollRelease>
		<fromWheel expr="false" line="365">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</fromWheel>
		<lastWheelEventTime expr="-1" line="367">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</lastWheelEventTime>
		<canClick expr="false" line="369">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</canClick>
		<tweenX expr="null" line="371">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</tweenX>
		<tweenY expr="null" line="373">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</tweenY>
		<animating expr="false" line="375">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</animating>
		<snapping expr="false" line="377">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</snapping>
		<pointerOnScroller expr="false" line="379">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pointerOnScroller>
		<pointerOnScrollerChild expr="false" line="381">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pointerOnScrollerChild>
		<blockingDefaultScroll expr="false" line="383">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</blockingDefaultScroll>
		<startTracking set="method" line="387"><f a=""><x path="Void"/></f></startTracking>
		<stopTracking set="method" line="402"><f a=""><x path="Void"/></f></stopTracking>
		<pointerOver set="method" line="424"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></pointerOver>
		<pointerOut set="method" line="430"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></pointerOut>
		<mouseWheel set="method" line="436"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></mouseWheel>
		<pointerDown set="method" line="515"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></pointerDown>
		<pointerUp set="method" line="580"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></pointerUp>
		<screenFocus set="method" line="625"><f a="focusedVisual">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></screenFocus>
		<isOverScrollingTop public="1" get="inline" set="null" line="643"><f a=""><x path="Bool"/></f></isOverScrollingTop>
		<isOverScrollingBottom public="1" get="inline" set="null" line="649"><f a=""><x path="Bool"/></f></isOverScrollingBottom>
		<isOverScrollingLeft public="1" get="inline" set="null" line="655"><f a=""><x path="Bool"/></f></isOverScrollingLeft>
		<isOverScrollingRight public="1" get="inline" set="null" line="661"><f a=""><x path="Bool"/></f></isOverScrollingRight>
		<roundScrollIfNeeded set="method" line="669"><f a=""><x path="Void"/></f></roundScrollIfNeeded>
		<update set="method" line="686"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateScrollbar set="method" line="756"><f a=""><x path="Void"/></f></updateScrollbar>
		<scrollbarDownX expr="-1" line="785">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</scrollbarDownX>
		<scrollbarDownY expr="-1" line="787">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</scrollbarDownY>
		<scrollbarStartX expr="-1" line="789">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</scrollbarStartX>
		<scrollbarStartY expr="-1" line="791">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</scrollbarStartY>
		<bindScrollbar set="method" line="793"><f a="scrollbar">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></bindScrollbar>
		<handleScrollbarDown set="method" line="803"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handleScrollbarDown>
		<handleScrollbarUp set="method" line="820"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handleScrollbarUp>
		<handleScrollbarMove set="method" line="826"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handleScrollbarMove>
		<scrollUpdate set="method" line="843">
			<f a="pointerX:pointerY:delta:?minusDelta" v=":::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ minusDelta : 0 }</e></m></meta>
		</scrollUpdate>
		<stop public="1" set="method" line="1012" override="1"><f a=""><x path="Void"/></f></stop>
		<stopTweens public="1" get="inline" set="null" line="1023"><f a=""><x path="Void"/></f></stopTweens>
		<scrollTo public="1" set="method" line="1032"><f a="scrollX:scrollY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollTo>
		<smoothScrollTo public="1" set="method" line="1041">
			<f a="scrollX:scrollY:?duration:?easing" v="::0.15:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="ceramic.Easing"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ duration : 0.15 }</e></m></meta>
		</smoothScrollTo>
		<snapTo public="1" set="method" line="1088">
			<f a="scrollX:scrollY:?duration:?easing" v="::0.15:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="ceramic.Easing"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ duration : 0.15 }</e></m></meta>
		</snapTo>
		<bounceScroll public="1" set="method" line="1104"><f a=""><x path="Void"/></f></bounceScroll>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="141"><f a="?content">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<enum path="ceramic.ScrollerStatus" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ScrollerStatus.hx">
		<IDLE><haxe_doc>* Nothing happening</haxe_doc></IDLE>
		<TOUCHING><haxe_doc>* Being touched, but not dragging yet</haxe_doc></TOUCHING>
		<DRAGGING><haxe_doc>* Being dragged by a touch/mouse event</haxe_doc></DRAGGING>
		<SCROLLING><haxe_doc>* Scrolling after dragging has ended</haxe_doc></SCROLLING>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.SeedRandom" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SeedRandom.hx">
		<seed public="1" set="null"><x path="Float"/></seed>
		<initialSeed public="1" set="null"><x path="Float"/></initialSeed>
		<random public="1" get="inline" set="null" line="60">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns a float number between [0,1)</haxe_doc>
		</random>
		<between public="1" get="inline" set="null" line="67">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Return an integer between [min, max).</haxe_doc>
		</between>
		<reset public="1" get="inline" set="null" line="74">
			<f a="?initialSeed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Reset the initial value to that of the current seed.</haxe_doc>
		</reset>
		<new public="1" get="inline" set="null" line="46"><f a="seed">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Seeded random number generator to get reproducible sequences of values.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.SelectText" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SelectText.hx">
		<extends path="ceramic.Entity"/>
		<implements path="tracker.Observable"/>
		<implements path="ceramic.Component"/>
		<_point expr="new Point()" line="15" static="1">
			<c path="ceramic.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
		</_point>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.SelectText"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.SelectText"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.SelectText"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.SelectText"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.SelectText"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false" line="131">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<_dox_event_selection public="1" set="method" line="637">
			<f a="selectionStart:selectionEnd:inverted">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_selection>
		<emitSelection set="method" line="1095">
			<f a="selectionStart:selectionEnd:inverted">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>selection event</haxe_doc>
		</emitSelection>
		<onSelection public="1" set="method" line="1199">
			<f a="owner:handleSelectionStartSelectionEndInverted">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="selectionStart:selectionEnd:inverted">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>selection event</haxe_doc>
		</onSelection>
		<onceSelection public="1" set="method" line="1298">
			<f a="owner:handleSelectionStartSelectionEndInverted">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="selectionStart:selectionEnd:inverted">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>selection event</haxe_doc>
		</onceSelection>
		<offSelection public="1" set="method" line="1368">
			<f a="?handleSelectionStartSelectionEndInverted">
				<f a="selectionStart:selectionEnd:inverted">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>selection event</haxe_doc>
		</offSelection>
		<listensSelection public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to selection event</haxe_doc>
		</listensSelection>
		<entity public="1">
			<c path="ceramic.Text"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<selectionColor public="1"><x path="ceramic.Color"/></selectionColor>
		<textCursorColor public="1"><x path="ceramic.Color"/></textCursorColor>
		<textCursorOffsetX public="1" expr="0" line="29">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</textCursorOffsetX>
		<textCursorOffsetY public="1" expr="0" line="31">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</textCursorOffsetY>
		<textCursorHeightFactor public="1" expr="1" line="33">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</textCursorHeightFactor>
		<invalidateContainer public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateContainer>
		<container public="1" expr="null" line="38">
			<c path="ceramic.Visual"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Optional container on which pointer events are bound</haxe_doc>
		</container>
		<unobservedContainer>
			<c path="ceramic.Visual"/>
			<haxe_doc></haxe_doc>
		</unobservedContainer>
		<_dox_event_containerChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.Visual"/>
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when container field changes.</haxe_doc>
		</_dox_event_containerChange>
		<emitContainerChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.Visual"/>
				<c path="ceramic.Visual"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when container field changes.</haxe_doc>
		</emitContainerChange>
		<onContainerChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Visual"/>
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when container field changes.</haxe_doc>
		</onContainerChange>
		<onceContainerChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Visual"/>
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when container field changes.</haxe_doc>
		</onceContainerChange>
		<offContainerChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.Visual"/>
					<c path="ceramic.Visual"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when container field changes.</haxe_doc>
		</offContainerChange>
		<listensContainerChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when container field changes.</haxe_doc>
		</listensContainerChange>
		<invalidateAllowSelectingFromPointer public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateAllowSelectingFromPointer>
		<allowSelectingFromPointer public="1" expr="false" line="40">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="observe"/>
			</meta>
		</allowSelectingFromPointer>
		<unobservedAllowSelectingFromPointer>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedAllowSelectingFromPointer>
		<_dox_event_allowSelectingFromPointerChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when allowSelectingFromPointer field changes.</haxe_doc>
		</_dox_event_allowSelectingFromPointerChange>
		<emitAllowSelectingFromPointerChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when allowSelectingFromPointer field changes.</haxe_doc>
		</emitAllowSelectingFromPointerChange>
		<onAllowSelectingFromPointerChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when allowSelectingFromPointer field changes.</haxe_doc>
		</onAllowSelectingFromPointerChange>
		<onceAllowSelectingFromPointerChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when allowSelectingFromPointer field changes.</haxe_doc>
		</onceAllowSelectingFromPointerChange>
		<offAllowSelectingFromPointerChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when allowSelectingFromPointer field changes.</haxe_doc>
		</offAllowSelectingFromPointerChange>
		<listensAllowSelectingFromPointerChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when allowSelectingFromPointer field changes.</haxe_doc>
		</listensAllowSelectingFromPointerChange>
		<invalidateShowCursor public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateShowCursor>
		<showCursor public="1" expr="false" line="42">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="observe"/>
			</meta>
		</showCursor>
		<unobservedShowCursor>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedShowCursor>
		<_dox_event_showCursorChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when showCursor field changes.</haxe_doc>
		</_dox_event_showCursorChange>
		<emitShowCursorChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when showCursor field changes.</haxe_doc>
		</emitShowCursorChange>
		<onShowCursorChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when showCursor field changes.</haxe_doc>
		</onShowCursorChange>
		<onceShowCursorChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when showCursor field changes.</haxe_doc>
		</onceShowCursorChange>
		<offShowCursorChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when showCursor field changes.</haxe_doc>
		</offShowCursorChange>
		<listensShowCursorChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when showCursor field changes.</haxe_doc>
		</listensShowCursorChange>
		<invalidateSelectionStart public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateSelectionStart>
		<selectionStart public="1" expr="-1" line="44">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="observe"/>
			</meta>
		</selectionStart>
		<unobservedSelectionStart>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedSelectionStart>
		<_dox_event_selectionStartChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when selectionStart field changes.</haxe_doc>
		</_dox_event_selectionStartChange>
		<emitSelectionStartChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when selectionStart field changes.</haxe_doc>
		</emitSelectionStartChange>
		<onSelectionStartChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionStart field changes.</haxe_doc>
		</onSelectionStartChange>
		<onceSelectionStartChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionStart field changes.</haxe_doc>
		</onceSelectionStartChange>
		<offSelectionStartChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionStart field changes.</haxe_doc>
		</offSelectionStartChange>
		<listensSelectionStartChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionStart field changes.</haxe_doc>
		</listensSelectionStartChange>
		<invalidateSelectionEnd public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateSelectionEnd>
		<selectionEnd public="1" expr="-1" line="46">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="observe"/>
			</meta>
		</selectionEnd>
		<unobservedSelectionEnd>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedSelectionEnd>
		<_dox_event_selectionEndChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when selectionEnd field changes.</haxe_doc>
		</_dox_event_selectionEndChange>
		<emitSelectionEndChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when selectionEnd field changes.</haxe_doc>
		</emitSelectionEndChange>
		<onSelectionEndChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionEnd field changes.</haxe_doc>
		</onSelectionEndChange>
		<onceSelectionEndChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionEnd field changes.</haxe_doc>
		</onceSelectionEndChange>
		<offSelectionEndChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionEnd field changes.</haxe_doc>
		</offSelectionEndChange>
		<listensSelectionEndChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when selectionEnd field changes.</haxe_doc>
		</listensSelectionEndChange>
		<invalidateInvertedSelection public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateInvertedSelection>
		<invertedSelection public="1" expr="false" line="48">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="observe"/>
			</meta>
		</invertedSelection>
		<unobservedInvertedSelection>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedInvertedSelection>
		<_dox_event_invertedSelectionChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when invertedSelection field changes.</haxe_doc>
		</_dox_event_invertedSelectionChange>
		<emitInvertedSelectionChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when invertedSelection field changes.</haxe_doc>
		</emitInvertedSelectionChange>
		<onInvertedSelectionChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when invertedSelection field changes.</haxe_doc>
		</onInvertedSelectionChange>
		<onceInvertedSelectionChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when invertedSelection field changes.</haxe_doc>
		</onceInvertedSelectionChange>
		<offInvertedSelectionChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when invertedSelection field changes.</haxe_doc>
		</offInvertedSelectionChange>
		<listensInvertedSelectionChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when invertedSelection field changes.</haxe_doc>
		</listensInvertedSelectionChange>
		<invalidatePointerIsDown public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidatePointerIsDown>
		<pointerIsDown public="1" expr="false" line="50">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="observe"/>
			</meta>
		</pointerIsDown>
		<unobservedPointerIsDown>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedPointerIsDown>
		<_dox_event_pointerIsDownChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when pointerIsDown field changes.</haxe_doc>
		</_dox_event_pointerIsDownChange>
		<emitPointerIsDownChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when pointerIsDown field changes.</haxe_doc>
		</emitPointerIsDownChange>
		<onPointerIsDownChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pointerIsDown field changes.</haxe_doc>
		</onPointerIsDownChange>
		<oncePointerIsDownChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pointerIsDown field changes.</haxe_doc>
		</oncePointerIsDownChange>
		<offPointerIsDownChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pointerIsDown field changes.</haxe_doc>
		</offPointerIsDownChange>
		<listensPointerIsDownChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when pointerIsDown field changes.</haxe_doc>
		</listensPointerIsDownChange>
		<boundContainer expr="null" line="54">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</boundContainer>
		<doubleClick expr="null" line="56">
			<c path="ceramic.DoubleClick"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</doubleClick>
		<didDoubleClick expr="false" line="58">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</didDoubleClick>
		<selectionBackgrounds expr="[]" line="60">
			<c path="Array"><c path="ceramic.Quad"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</selectionBackgrounds>
		<willUpdateSelection expr="false" line="62">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</willUpdateSelection>
		<textCursor expr="null" line="64">
			<c path="ceramic.Quad"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</textCursor>
		<textCursorToggleVisibilityTime expr="1.0" line="66">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</textCursorToggleVisibilityTime>
		<bindAsComponent set="method" line="82"><f a=""><x path="Void"/></f></bindAsComponent>
		<updateFromSelection set="method" line="101"><f a=""><x path="Void"/></f></updateFromSelection>
		<updateSelectionGraphics set="method" line="117"><f a=""><x path="Void"/></f></updateSelectionGraphics>
		<doUpdateSelectionGraphics set="method" line="126"><f a=""><x path="Void"/></f></doUpdateSelectionGraphics>
		<clearSelectionGraphics set="method" line="333"><f a=""><x path="Void"/></f></clearSelectionGraphics>
		<handleShowCursorChange set="method" line="347"><f a="_:_">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></handleShowCursorChange>
		<updateCursorVisibility set="method" line="353"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></updateCursorVisibility>
		<resetCursorVisibility set="method" line="375"><f a=""><x path="Void"/></f></resetCursorVisibility>
		<updatePointerEventBindings set="method" line="386"><f a=""><x path="Void"/></f></updatePointerEventBindings>
		<indexFromScreenPosition set="method" line="428"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></indexFromScreenPosition>
		<handlePointerDown set="method" line="442"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerDown>
		<handlePointerMove set="method" line="460"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerMove>
		<handlePointerUp set="method" line="466"><f a="info">
	<c path="ceramic.TouchInfo"/>
	<x path="Void"/>
</f></handlePointerUp>
		<updateSelectionFromMovingPointer set="method" line="483"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateSelectionFromMovingPointer>
		<isSelectionBoundChararacter get="inline" set="null" line="512"><f a="c">
	<c path="String"/>
	<x path="Bool"/>
</f></isSelectionBoundChararacter>
		<handleDoubleClick set="method" line="520"><f a=""><x path="Void"/></f></handleDoubleClick>
		<bindKeyBindings set="method" line="562"><f a=""><x path="Void"/></f></bindKeyBindings>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<setEntity set="method" line="11">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="11">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="70">
			<f a="selectionColor:textCursorColor:?textCursorOffsetX:?textCursorOffsetY:?textCursorHeightFactor" v="::0:0:1">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ textCursorHeightFactor : 1, textCursorOffsetY : 0, textCursorOffsetX : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Settings" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Settings.hx">
		<implements path="tracker.Observable"/>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Settings"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.Settings"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Settings"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.Settings"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.Settings"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false" line="131">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<invalidateTargetWidth public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTargetWidth>
		<targetWidth public="1" expr="0" line="15">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Target width. Affects window size at startup (unless `windowWidth` is specified)
     * and affects screen scaling at any time.
     * Ignored if set to 0 (default)</haxe_doc>
		</targetWidth>
		<unobservedTargetWidth>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedTargetWidth>
		<_dox_event_targetWidthChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when targetWidth field changes.</haxe_doc>
		</_dox_event_targetWidthChange>
		<emitTargetWidthChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when targetWidth field changes.</haxe_doc>
		</emitTargetWidthChange>
		<onTargetWidthChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetWidth field changes.</haxe_doc>
		</onTargetWidthChange>
		<onceTargetWidthChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetWidth field changes.</haxe_doc>
		</onceTargetWidthChange>
		<offTargetWidthChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetWidth field changes.</haxe_doc>
		</offTargetWidthChange>
		<listensTargetWidthChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetWidth field changes.</haxe_doc>
		</listensTargetWidthChange>
		<invalidateTargetHeight public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTargetHeight>
		<targetHeight public="1" expr="0" line="22">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Target height. Affects window size at startup (unless `windowHeight` is specified)
     * and affects screen scaling at any time.
     * Ignored if set to 0 (default)</haxe_doc>
		</targetHeight>
		<unobservedTargetHeight>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedTargetHeight>
		<_dox_event_targetHeightChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when targetHeight field changes.</haxe_doc>
		</_dox_event_targetHeightChange>
		<emitTargetHeightChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when targetHeight field changes.</haxe_doc>
		</emitTargetHeightChange>
		<onTargetHeightChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetHeight field changes.</haxe_doc>
		</onTargetHeightChange>
		<onceTargetHeightChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetHeight field changes.</haxe_doc>
		</onceTargetHeightChange>
		<offTargetHeightChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetHeight field changes.</haxe_doc>
		</offTargetHeightChange>
		<listensTargetHeightChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetHeight field changes.</haxe_doc>
		</listensTargetHeightChange>
		<targetSize public="1" get="inline" set="null" line="31">
			<f a="targetWidth:targetHeight">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Target width and height. Affects window size at startup
     * and affects screen scaling at any time.
     * Ignored if set to 0 (default)
     * @param targetWidth Target width
     * @param targetHeight Target height</haxe_doc>
		</targetSize>
		<invalidateWindowWidth public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateWindowWidth>
		<windowWidth public="1" set="null" expr="0" line="40">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Target window width at startup
     * Uses `targetWidth` as fallback if set to 0 (default)</haxe_doc>
		</windowWidth>
		<unobservedWindowWidth>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedWindowWidth>
		<_dox_event_windowWidthChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when windowWidth field changes.</haxe_doc>
		</_dox_event_windowWidthChange>
		<emitWindowWidthChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when windowWidth field changes.</haxe_doc>
		</emitWindowWidthChange>
		<onWindowWidthChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowWidth field changes.</haxe_doc>
		</onWindowWidthChange>
		<onceWindowWidthChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowWidth field changes.</haxe_doc>
		</onceWindowWidthChange>
		<offWindowWidthChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowWidth field changes.</haxe_doc>
		</offWindowWidthChange>
		<listensWindowWidthChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowWidth field changes.</haxe_doc>
		</listensWindowWidthChange>
		<invalidateWindowHeight public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateWindowHeight>
		<windowHeight public="1" set="null" expr="0" line="46">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Target window height at startup
     * Uses `targetHeight` as fallback if set to 0 (default)</haxe_doc>
		</windowHeight>
		<unobservedWindowHeight>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedWindowHeight>
		<_dox_event_windowHeightChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when windowHeight field changes.</haxe_doc>
		</_dox_event_windowHeightChange>
		<emitWindowHeightChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when windowHeight field changes.</haxe_doc>
		</emitWindowHeightChange>
		<onWindowHeightChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowHeight field changes.</haxe_doc>
		</onWindowHeightChange>
		<onceWindowHeightChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowHeight field changes.</haxe_doc>
		</onceWindowHeightChange>
		<offWindowHeightChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowHeight field changes.</haxe_doc>
		</offWindowHeightChange>
		<listensWindowHeightChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when windowHeight field changes.</haxe_doc>
		</listensWindowHeightChange>
		<invalidateTargetDensity public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTargetDensity>
		<targetDensity public="1" expr="0" line="54">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Target density. Affects the quality of textures
     * being loaded. Changing it at runtime will update
     * texture quality if needed.
     * Ignored if set to 0 (default)</haxe_doc>
		</targetDensity>
		<unobservedTargetDensity>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedTargetDensity>
		<_dox_event_targetDensityChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when targetDensity field changes.</haxe_doc>
		</_dox_event_targetDensityChange>
		<emitTargetDensityChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when targetDensity field changes.</haxe_doc>
		</emitTargetDensityChange>
		<onTargetDensityChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetDensity field changes.</haxe_doc>
		</onTargetDensityChange>
		<onceTargetDensityChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetDensity field changes.</haxe_doc>
		</onceTargetDensityChange>
		<offTargetDensityChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetDensity field changes.</haxe_doc>
		</offTargetDensityChange>
		<listensTargetDensityChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetDensity field changes.</haxe_doc>
		</listensTargetDensityChange>
		<invalidateBackground public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateBackground>
		<background public="1" expr="Color.BLACK" line="59">
			<x path="ceramic.Color"/>
			<meta>
				<m n=":value"><e>Color.BLACK</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Background color.</haxe_doc>
		</background>
		<unobservedBackground>
			<x path="ceramic.Color"/>
			<haxe_doc></haxe_doc>
		</unobservedBackground>
		<_dox_event_backgroundChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when background field changes.</haxe_doc>
		</_dox_event_backgroundChange>
		<emitBackgroundChange set="method" line="1095">
			<f a="current:previous">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when background field changes.</haxe_doc>
		</emitBackgroundChange>
		<onBackgroundChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="ceramic.Color"/>
					<x path="ceramic.Color"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when background field changes.</haxe_doc>
		</onBackgroundChange>
		<onceBackgroundChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="ceramic.Color"/>
					<x path="ceramic.Color"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when background field changes.</haxe_doc>
		</onceBackgroundChange>
		<offBackgroundChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="ceramic.Color"/>
					<x path="ceramic.Color"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when background field changes.</haxe_doc>
		</offBackgroundChange>
		<listensBackgroundChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when background field changes.</haxe_doc>
		</listensBackgroundChange>
		<invalidateScaling public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateScaling>
		<scaling public="1" expr="FIT" line="64">
			<e path="ceramic.ScreenScaling"/>
			<meta>
				<m n=":value"><e>FIT</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Screen scaling (FIT, FILL, RESIZE or FIT_RESIZE).</haxe_doc>
		</scaling>
		<unobservedScaling>
			<e path="ceramic.ScreenScaling"/>
			<haxe_doc></haxe_doc>
		</unobservedScaling>
		<_dox_event_scalingChange public="1" set="method" line="637">
			<f a="current:previous">
				<e path="ceramic.ScreenScaling"/>
				<e path="ceramic.ScreenScaling"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when scaling field changes.</haxe_doc>
		</_dox_event_scalingChange>
		<emitScalingChange set="method" line="1095">
			<f a="current:previous">
				<e path="ceramic.ScreenScaling"/>
				<e path="ceramic.ScreenScaling"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when scaling field changes.</haxe_doc>
		</emitScalingChange>
		<onScalingChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.ScreenScaling"/>
					<e path="ceramic.ScreenScaling"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when scaling field changes.</haxe_doc>
		</onScalingChange>
		<onceScalingChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.ScreenScaling"/>
					<e path="ceramic.ScreenScaling"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when scaling field changes.</haxe_doc>
		</onceScalingChange>
		<offScalingChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<e path="ceramic.ScreenScaling"/>
					<e path="ceramic.ScreenScaling"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when scaling field changes.</haxe_doc>
		</offScalingChange>
		<listensScalingChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when scaling field changes.</haxe_doc>
		</listensScalingChange>
		<invalidateTitle public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTitle>
		<title public="1" expr="&quot;App&quot;" line="69">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"App"</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* App window title.</haxe_doc>
		</title>
		<unobservedTitle>
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</unobservedTitle>
		<_dox_event_titleChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when title field changes.</haxe_doc>
		</_dox_event_titleChange>
		<emitTitleChange set="method" line="1095">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when title field changes.</haxe_doc>
		</emitTitleChange>
		<onTitleChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when title field changes.</haxe_doc>
		</onTitleChange>
		<onceTitleChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when title field changes.</haxe_doc>
		</onceTitleChange>
		<offTitleChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when title field changes.</haxe_doc>
		</offTitleChange>
		<listensTitleChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when title field changes.</haxe_doc>
		</listensTitleChange>
		<invalidateFullscreen public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateFullscreen>
		<fullscreen public="1" expr="false" line="74">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Fullscreen enabled or not.</haxe_doc>
		</fullscreen>
		<unobservedFullscreen>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedFullscreen>
		<_dox_event_fullscreenChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when fullscreen field changes.</haxe_doc>
		</_dox_event_fullscreenChange>
		<emitFullscreenChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when fullscreen field changes.</haxe_doc>
		</emitFullscreenChange>
		<onFullscreenChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fullscreen field changes.</haxe_doc>
		</onFullscreenChange>
		<onceFullscreenChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fullscreen field changes.</haxe_doc>
		</onceFullscreenChange>
		<offFullscreenChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fullscreen field changes.</haxe_doc>
		</offFullscreenChange>
		<listensFullscreenChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when fullscreen field changes.</haxe_doc>
		</listensFullscreenChange>
		<invalidateTargetFps public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTargetFps>
		<targetFps public="1" expr="-1" line="79">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc><![CDATA[* Target FPS. Using default FPS if value < 1 or try to match the given value if >= 1.]]></haxe_doc>
		</targetFps>
		<unobservedTargetFps>
			<x path="Int"/>
			<haxe_doc></haxe_doc>
		</unobservedTargetFps>
		<_dox_event_targetFpsChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when targetFps field changes.</haxe_doc>
		</_dox_event_targetFpsChange>
		<emitTargetFpsChange set="method" line="1095">
			<f a="current:previous">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when targetFps field changes.</haxe_doc>
		</emitTargetFpsChange>
		<onTargetFpsChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetFps field changes.</haxe_doc>
		</onTargetFpsChange>
		<onceTargetFpsChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetFps field changes.</haxe_doc>
		</onceTargetFpsChange>
		<offTargetFpsChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetFps field changes.</haxe_doc>
		</offTargetFpsChange>
		<listensTargetFpsChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when targetFps field changes.</haxe_doc>
		</listensTargetFpsChange>
		<invalidateMaxDelta public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateMaxDelta>
		<maxDelta public="1" expr="0.1" line="87">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.1</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Maximum app update delta time.
     * During app update (at each frame), `app.delta` will be capped to `maxDelta`
     * if its value is above `maxDelta`.
     * If needed, use `app.realDelta` to get real elapsed time since last frame.</haxe_doc>
		</maxDelta>
		<unobservedMaxDelta>
			<x path="Float"/>
			<haxe_doc></haxe_doc>
		</unobservedMaxDelta>
		<_dox_event_maxDeltaChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when maxDelta field changes.</haxe_doc>
		</_dox_event_maxDeltaChange>
		<emitMaxDeltaChange set="method" line="1095">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when maxDelta field changes.</haxe_doc>
		</emitMaxDeltaChange>
		<onMaxDeltaChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when maxDelta field changes.</haxe_doc>
		</onMaxDeltaChange>
		<onceMaxDeltaChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when maxDelta field changes.</haxe_doc>
		</onceMaxDeltaChange>
		<offMaxDeltaChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when maxDelta field changes.</haxe_doc>
		</offMaxDeltaChange>
		<listensMaxDeltaChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when maxDelta field changes.</haxe_doc>
		</listensMaxDeltaChange>
		<invalidateOverrideDelta public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateOverrideDelta>
		<overrideDelta public="1" expr="-1" line="96">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* Override app update delta time.
     * This can be used to ignore completely the actual elapsed time between frames
     * and replace it with an explicit delta time of your choice.
     * This will affect timers, tween, systems update etc...
     * Use with caution.</haxe_doc>
		</overrideDelta>
		<unobservedOverrideDelta>
			<x path="Float"/>
			<haxe_doc></haxe_doc>
		</unobservedOverrideDelta>
		<_dox_event_overrideDeltaChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when overrideDelta field changes.</haxe_doc>
		</_dox_event_overrideDeltaChange>
		<emitOverrideDeltaChange set="method" line="1095">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when overrideDelta field changes.</haxe_doc>
		</emitOverrideDeltaChange>
		<onOverrideDeltaChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when overrideDelta field changes.</haxe_doc>
		</onOverrideDeltaChange>
		<onceOverrideDeltaChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when overrideDelta field changes.</haxe_doc>
		</onceOverrideDeltaChange>
		<offOverrideDeltaChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when overrideDelta field changes.</haxe_doc>
		</offOverrideDeltaChange>
		<listensOverrideDeltaChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when overrideDelta field changes.</haxe_doc>
		</listensOverrideDeltaChange>
		<invalidatePreventDefaultMouseWheel public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidatePreventDefaultMouseWheel>
		<preventDefaultMouseWheel public="1" expr="true" line="103">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* If set to `true` (default). Default mouse wheel events
     * will be prevented. This is relevant when running the ceramic
     * app from an `iframe` inside a page that can scroll.</haxe_doc>
		</preventDefaultMouseWheel>
		<unobservedPreventDefaultMouseWheel>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedPreventDefaultMouseWheel>
		<_dox_event_preventDefaultMouseWheelChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when preventDefaultMouseWheel field changes.</haxe_doc>
		</_dox_event_preventDefaultMouseWheelChange>
		<emitPreventDefaultMouseWheelChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when preventDefaultMouseWheel field changes.</haxe_doc>
		</emitPreventDefaultMouseWheelChange>
		<onPreventDefaultMouseWheelChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultMouseWheel field changes.</haxe_doc>
		</onPreventDefaultMouseWheelChange>
		<oncePreventDefaultMouseWheelChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultMouseWheel field changes.</haxe_doc>
		</oncePreventDefaultMouseWheelChange>
		<offPreventDefaultMouseWheelChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultMouseWheel field changes.</haxe_doc>
		</offPreventDefaultMouseWheelChange>
		<listensPreventDefaultMouseWheelChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultMouseWheel field changes.</haxe_doc>
		</listensPreventDefaultMouseWheelChange>
		<invalidatePreventDefaultTouches public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidatePreventDefaultTouches>
		<preventDefaultTouches public="1" expr="true" line="111">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* If set to `true` (default). Default touch events
     * will be prevented. This is relevant when running the ceramic
     * app from an `iframe` inside a page that can scroll,
     * on a touchscreen device.</haxe_doc>
		</preventDefaultTouches>
		<unobservedPreventDefaultTouches>
			<x path="Bool"/>
			<haxe_doc></haxe_doc>
		</unobservedPreventDefaultTouches>
		<_dox_event_preventDefaultTouchesChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when preventDefaultTouches field changes.</haxe_doc>
		</_dox_event_preventDefaultTouchesChange>
		<emitPreventDefaultTouchesChange set="method" line="1095">
			<f a="current:previous">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when preventDefaultTouches field changes.</haxe_doc>
		</emitPreventDefaultTouchesChange>
		<onPreventDefaultTouchesChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultTouches field changes.</haxe_doc>
		</onPreventDefaultTouchesChange>
		<oncePreventDefaultTouchesChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultTouches field changes.</haxe_doc>
		</oncePreventDefaultTouchesChange>
		<offPreventDefaultTouchesChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Bool"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultTouches field changes.</haxe_doc>
		</offPreventDefaultTouchesChange>
		<listensPreventDefaultTouchesChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when preventDefaultTouches field changes.</haxe_doc>
		</listensPreventDefaultTouchesChange>
		<orientation public="1" set="null" expr="NONE" line="117">
			<x path="ceramic.ScreenOrientation"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
			<haxe_doc>* Setup screen orientation. Default is `NONE`,
     * meaning nothing is enforced and project defaults will be used.</haxe_doc>
		</orientation>
		<collections public="1" set="null" expr="null" line="122">
			<f a=""><c path="ceramic.AutoCollections"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* App collections.</haxe_doc>
		</collections>
		<appInfo public="1" set="null" expr="null" line="127">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* App info (useful when dynamically loaded, not needed otherwise).</haxe_doc>
		</appInfo>
		<antialiasing public="1" set="null" expr="0" line="132">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Antialiasing value (0 means disabled).</haxe_doc>
		</antialiasing>
		<resizable public="1" set="null" expr="false" line="137">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether the window can be resized or not.</haxe_doc>
		</resizable>
		<assetsPath public="1" set="null" expr="&quot;assets&quot;" line="142">
			<c path="String"/>
			<meta><m n=":value"><e>"assets"</e></m></meta>
			<haxe_doc>* Assets path.</haxe_doc>
		</assetsPath>
		<backend public="1" set="null" expr="{ }" line="147">
			<d/>
			<meta><m n=":value"><e>{ }</e></m></meta>
			<haxe_doc>* Settings passed to backend.</haxe_doc>
		</backend>
		<defaultFont public="1" set="null" expr="&quot;font:RobotoMedium&quot;" line="152">
			<x path="ceramic.AssetId"><c path="String"/></x>
			<meta><m n=":value"><e>"font:RobotoMedium"</e></m></meta>
			<haxe_doc>* Default font</haxe_doc>
		</defaultFont>
		<defaultShader public="1" set="null" expr="&quot;shader:textured&quot;" line="157">
			<x path="ceramic.AssetId"><c path="String"/></x>
			<meta><m n=":value"><e>"shader:textured"</e></m></meta>
			<haxe_doc>* Default shader</haxe_doc>
		</defaultShader>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new set="method" line="8">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>ceramic.App</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Shader" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Shader.hx">
		<extends path="ceramic.Entity"/>
		<backendItem public="1"><x path="backend.Shader"/></backendItem>
		<asset public="1"><c path="ceramic.ShaderAsset"/></asset>
		<attributes public="1"><x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x></attributes>
		<customAttributes public="1"><x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x></customAttributes>
		<customFloatAttributesSize public="1" set="null"><x path="Int"/></customFloatAttributesSize>
		<destroy public="1" set="method" line="71" override="1"><f a=""><x path="Void"/></f></destroy>
		<clone public="1" set="method" line="83"><f a=""><c path="ceramic.Shader"/></f></clone>
		<setInt public="1" get="inline" set="null" line="94"><f a="name:value">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setFloat public="1" get="inline" set="null" line="100"><f a="name:value">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setColor public="1" get="inline" set="null" line="106"><f a="name:color">
	<c path="String"/>
	<x path="ceramic.Color"/>
	<x path="Void"/>
</f></setColor>
		<setAlphaColor public="1" get="inline" set="null" line="112"><f a="name:color">
	<c path="String"/>
	<x path="ceramic.AlphaColor"/>
	<x path="Void"/>
</f></setAlphaColor>
		<setVec2 public="1" get="inline" set="null" line="118"><f a="name:x:y">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec2>
		<setVec3 public="1" get="inline" set="null" line="124"><f a="name:x:y:z">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec3>
		<setVec4 public="1" get="inline" set="null" line="130"><f a="name:x:y:z:w">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVec4>
		<setFloatArray public="1" get="inline" set="null" line="136"><f a="name:array">
	<c path="String"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setFloatArray>
		<setTexture public="1" get="inline" set="null" line="142"><f a="name:slot:texture">
	<c path="String"/>
	<x path="Int"/>
	<c path="ceramic.Texture"/>
	<x path="Void"/>
</f></setTexture>
		<setMat4FromTransform public="1" get="inline" set="null" line="148"><f a="name:transform">
	<c path="String"/>
	<c path="ceramic.Transform"/>
	<x path="Void"/>
</f></setMat4FromTransform>
		<toString set="method" line="156" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="45"><f a="backendItem:?customAttributes">
	<x path="backend.Shader"/>
	<x path="ceramic.ReadOnlyArray"><c path="ceramic.ShaderAttribute"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.ShaderAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ShaderAsset.hx">
		<extends path="ceramic.Asset"/>
		<invalidateShader public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateShader>
		<shader public="1" expr="null" line="11">
			<c path="ceramic.Shader"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</shader>
		<unobservedShader>
			<c path="ceramic.Shader"/>
			<haxe_doc></haxe_doc>
		</unobservedShader>
		<_dox_event_shaderChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.Shader"/>
				<c path="ceramic.Shader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when shader field changes.</haxe_doc>
		</_dox_event_shaderChange>
		<emitShaderChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.Shader"/>
				<c path="ceramic.Shader"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when shader field changes.</haxe_doc>
		</emitShaderChange>
		<onShaderChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Shader"/>
					<c path="ceramic.Shader"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when shader field changes.</haxe_doc>
		</onShaderChange>
		<onceShaderChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Shader"/>
					<c path="ceramic.Shader"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when shader field changes.</haxe_doc>
		</onceShaderChange>
		<offShaderChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.Shader"/>
					<c path="ceramic.Shader"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when shader field changes.</haxe_doc>
		</offShaderChange>
		<listensShaderChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when shader field changes.</haxe_doc>
		</listensShaderChange>
		<load public="1" set="method" line="19" override="1"><f a=""><x path="Void"/></f></load>
		<assetFilesDidChange set="method" line="177" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="221" override="1"><f a=""><x path="Void"/></f></destroy>
		<toString set="method" line="234" override="1"><f a=""><c path="String"/></f></toString>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="13"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.ShaderAttribute" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ShaderAttribute.hx">
		<size public="1"><x path="Int"/></size>
		<name public="1"><c path="String"/></name>
		<toString set="method" line="19"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="10"><f a="size:name">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.Shape" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Shape.hx">
		<extends path="ceramic.Mesh"/>
		<points public="1" get="accessor" set="accessor">
			<c path="Array"><x path="Float"/></c>
			<meta><m n="editable"><e>{ minItems : 6, points : true }</e></m></meta>
			<haxe_doc>* A flat array of vertex coordinates to describe the shape.
     * `points = ...` is identical to `vertices = ... ; contentDirty = true ;`
     * Note: when editing array content without reassigning it,
     * `contentDirty` must be set to `true` to let the shape being updated accordingly.</haxe_doc>
		</points>
		<get_points get="inline" set="null" line="33"><f a=""><c path="Array"><x path="Float"/></c></f></get_points>
		<set_points get="inline" set="null" line="36"><f a="points">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
</f></set_points>
		<triangulation public="1" set="accessor" expr="POLY2TRI" line="43">
			<e path="ceramic.TriangulateMethod"/>
			<meta>
				<m n=":value"><e>POLY2TRI</e></m>
				<m n="editable"/>
			</meta>
		</triangulation>
		<set_triangulation get="inline" set="null" line="44"><f a="triangulation">
	<e path="ceramic.TriangulateMethod"/>
	<e path="ceramic.TriangulateMethod"/>
</f></set_triangulation>
		<holes public="1" expr="null" line="60">
			<c path="Array"><x path="Int"/></c>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* An array of hole indices, if any.
     * (e.g. `[5, 8]` for a 12-vertex input would mean
     * one hole with vertices 57 and another with 811).
     * Note: when editing array content without reassigning it,
     * `contentDirty` must be set to `true` to let the shape being updated accordingly.</haxe_doc>
		</holes>
		<set_holes get="inline" set="null" line="61"><f a="holes">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></set_holes>
		<autoComputeSize public="1" set="accessor" expr="true" line="71">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n="editable"><e>{ label : "Auto Size" }</e></m>
			</meta>
			<haxe_doc>* If set to `true`, width and heigh will be computed from shape points.</haxe_doc>
		</autoComputeSize>
		<set_autoComputeSize get="inline" set="null" line="72"><f a="autoComputeSize">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoComputeSize>
		<get_width set="method" line="80" override="1"><f a=""><x path="Float"/></f></get_width>
		<get_height set="method" line="87" override="1"><f a=""><x path="Float"/></f></get_height>
		<computeContent public="1" set="method" line="94" override="1"><f a=""><x path="Void"/></f></computeContent>
		<haxe_doc>* Draw shapes by triangulating vertices automatically, with optional holes in it.</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n="editable"><e>{ implicitSize : true, highlight : { points : "points", minPoints : 3, maxPoints : 999999999 }, disable : ["texture", "vertices", "indices", "uvs"] }</e></m>
		</meta>
	</class>
	<class path="ceramic.Shortcuts" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Shortcuts.hx">
		<app public="1" get="accessor" set="null" static="1">
			<c path="ceramic.App"/>
			<haxe_doc>* Shared app instance</haxe_doc>
		</app>
		<get_app get="inline" set="null" line="19" static="1"><f a=""><c path="ceramic.App"/></f></get_app>
		<screen public="1" get="accessor" set="null" static="1">
			<c path="ceramic.Screen"/>
			<haxe_doc>* Shared screen instance</haxe_doc>
		</screen>
		<get_screen get="inline" set="null" line="25" static="1"><f a=""><c path="ceramic.Screen"/></f></get_screen>
		<audio public="1" get="accessor" set="null" static="1">
			<c path="ceramic.Audio"/>
			<haxe_doc>* Shared audio instance</haxe_doc>
		</audio>
		<get_audio get="inline" set="null" line="31" static="1"><f a=""><c path="ceramic.Audio"/></f></get_audio>
		<input public="1" get="accessor" set="null" static="1">
			<c path="ceramic.Input"/>
			<haxe_doc>* Shared input instance</haxe_doc>
		</input>
		<get_input get="inline" set="null" line="37" static="1"><f a=""><c path="ceramic.Input"/></f></get_input>
		<settings public="1" get="accessor" set="null" static="1">
			<c path="ceramic.Settings"/>
			<haxe_doc>* Shared settings instance</haxe_doc>
		</settings>
		<get_settings get="inline" set="null" line="43" static="1"><f a=""><c path="ceramic.Settings"/></f></get_settings>
		<log public="1" get="accessor" set="null" static="1">
			<c path="ceramic.Logger"/>
			<haxe_doc>* Shared logger instance</haxe_doc>
		</log>
		<get_log get="inline" set="null" line="49" static="1"><f a=""><c path="ceramic.Logger"/></f></get_log>
		<systems public="1" get="accessor" set="null" static="1">
			<c path="ceramic.Systems"/>
			<haxe_doc>* Systems manager</haxe_doc>
		</systems>
		<get_systems get="inline" set="null" line="55" static="1"><f a=""><c path="ceramic.Systems"/></f></get_systems>
		<unobserve public="1" get="inline" set="null" line="61" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Ensures current `autorun` won't be affected by the code after this call.
     * `reobserve()` should be called to restore previous state.</haxe_doc>
		</unobserve>
		<reobserve public="1" get="inline" set="null" line="67" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resume observing values and resume affecting current `autorun` scope.
     * This should be called after an `unobserve()` call.</haxe_doc>
		</reobserve>
		<haxe_doc>* Shortcuts adds convenience identifiers to access ceramic app, screen, ...
 * Use it by adding `import ceramic.Shortcuts.*;` in your files.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.SlugOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Slug.hx" module="ceramic.Slug">
		<lower final="1" public="1" expr="true" line="80">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</lower>
		<remove final="1" public="1" expr="Slug.RE_SLUG_REMOVE_CHARS" line="81">
			<c path="EReg"/>
			<meta><m n=":value"><e>Slug.RE_SLUG_REMOVE_CHARS</e></m></meta>
		</remove>
		<replacement final="1" public="1" expr="&quot;-&quot;" line="82">
			<c path="String"/>
			<meta><m n=":value"><e>"-"</e></m></meta>
		</replacement>
		<new public="1" set="method" line="79">
			<f a="lower:remove:replacement">
				<x path="Null"><x path="Bool"/></x>
				<x path="Null"><c path="EReg"/></x>
				<x path="Null"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.Slug" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Slug.hx">
		<RE_SLUG_REMOVE_CHARS final="1" public="1" set="null" expr="~/[$*+~.()&apos;&quot;!\\:@\?]/" line="10" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/[$*+~.()'"!\\:@\?]/</e></m></meta>
		</RE_SLUG_REMOVE_CHARS>
		<DEFAULT_OPTIONS final="1" public="1" set="null" expr="{ }" line="12" static="1">
			<c path="ceramic.SlugOptions"/>
			<meta><m n=":value"><e>{ }</e></m></meta>
		</DEFAULT_OPTIONS>
		<charMap public="1" expr="[36 =&gt; &quot;dollar&quot;, 37 =&gt; &quot;percent&quot;, 38 =&gt; &quot;and&quot;, 60 =&gt; &quot;less&quot;, 62 =&gt; &quot;greater&quot;, 124 =&gt; &quot;or&quot;, 162 =&gt; &quot;cent&quot;, 163 =&gt; &quot;pound&quot;, 164 =&gt; &quot;currency&quot;, 165 =&gt; &quot;yen&quot;, 169 =&gt; &quot;(c)&quot;, 170 =&gt; &quot;a&quot;, 174 =&gt; &quot;(r)&quot;, 186 =&gt; &quot;o&quot;, 192 =&gt; &quot;A&quot;, 193 =&gt; &quot;A&quot;, 194 =&gt; &quot;A&quot;, 195 =&gt; &quot;A&quot;, 196 =&gt; &quot;A&quot;, 197 =&gt; &quot;A&quot;, 198 =&gt; &quot;AE&quot;, 199 =&gt; &quot;C&quot;, 200 =&gt; &quot;E&quot;, 201 =&gt; &quot;E&quot;, 202 =&gt; &quot;E&quot;, 203 =&gt; &quot;E&quot;, 204 =&gt; &quot;I&quot;, 205 =&gt; &quot;I&quot;, 206 =&gt; &quot;I&quot;, 207 =&gt; &quot;I&quot;, 208 =&gt; &quot;D&quot;, 209 =&gt; &quot;N&quot;, 210 =&gt; &quot;O&quot;, 211 =&gt; &quot;O&quot;, 212 =&gt; &quot;O&quot;, 213 =&gt; &quot;O&quot;, 214 =&gt; &quot;O&quot;, 216 =&gt; &quot;O&quot;, 217 =&gt; &quot;U&quot;, 218 =&gt; &quot;U&quot;, 219 =&gt; &quot;U&quot;, 220 =&gt; &quot;U&quot;, 221 =&gt; &quot;Y&quot;, 222 =&gt; &quot;TH&quot;, 223 =&gt; &quot;ss&quot;, 224 =&gt; &quot;a&quot;, 225 =&gt; &quot;a&quot;, 226 =&gt; &quot;a&quot;, 227 =&gt; &quot;a&quot;, 228 =&gt; &quot;a&quot;, 229 =&gt; &quot;a&quot;, 230 =&gt; &quot;ae&quot;, 231 =&gt; &quot;c&quot;, 232 =&gt; &quot;e&quot;, 233 =&gt; &quot;e&quot;, 234 =&gt; &quot;e&quot;, 235 =&gt; &quot;e&quot;, 236 =&gt; &quot;i&quot;, 237 =&gt; &quot;i&quot;, 238 =&gt; &quot;i&quot;, 239 =&gt; &quot;i&quot;, 240 =&gt; &quot;d&quot;, 241 =&gt; &quot;n&quot;, 242 =&gt; &quot;o&quot;, 243 =&gt; &quot;o&quot;, 244 =&gt; &quot;o&quot;, 245 =&gt; &quot;o&quot;, 246 =&gt; &quot;o&quot;, 248 =&gt; &quot;o&quot;, 249 =&gt; &quot;u&quot;, 250 =&gt; &quot;u&quot;, 251 =&gt; &quot;u&quot;, 252 =&gt; &quot;u&quot;, 253 =&gt; &quot;y&quot;, 254 =&gt; &quot;th&quot;, 255 =&gt; &quot;y&quot;, 256 =&gt; &quot;A&quot;, 257 =&gt; &quot;a&quot;, 258 =&gt; &quot;A&quot;, 259 =&gt; &quot;a&quot;, 260 =&gt; &quot;A&quot;, 261 =&gt; &quot;a&quot;, 262 =&gt; &quot;C&quot;, 263 =&gt; &quot;c&quot;, 268 =&gt; &quot;C&quot;, 269 =&gt; &quot;c&quot;, 270 =&gt; &quot;D&quot;, 271 =&gt; &quot;d&quot;, 272 =&gt; &quot;DJ&quot;, 273 =&gt; &quot;dj&quot;, 274 =&gt; &quot;E&quot;, 275 =&gt; &quot;e&quot;, 278 =&gt; &quot;E&quot;, 279 =&gt; &quot;e&quot;, 280 =&gt; &quot;e&quot;, 281 =&gt; &quot;e&quot;, 282 =&gt; &quot;E&quot;, 283 =&gt; &quot;e&quot;, 286 =&gt; &quot;G&quot;, 287 =&gt; &quot;g&quot;, 290 =&gt; &quot;G&quot;, 291 =&gt; &quot;g&quot;, 296 =&gt; &quot;I&quot;, 297 =&gt; &quot;i&quot;, 298 =&gt; &quot;i&quot;, 299 =&gt; &quot;i&quot;, 302 =&gt; &quot;I&quot;, 303 =&gt; &quot;i&quot;, 304 =&gt; &quot;I&quot;, 305 =&gt; &quot;i&quot;, 310 =&gt; &quot;k&quot;, 311 =&gt; &quot;k&quot;, 315 =&gt; &quot;L&quot;, 316 =&gt; &quot;l&quot;, 317 =&gt; &quot;L&quot;, 318 =&gt; &quot;l&quot;, 321 =&gt; &quot;L&quot;, 322 =&gt; &quot;l&quot;, 323 =&gt; &quot;N&quot;, 324 =&gt; &quot;n&quot;, 325 =&gt; &quot;N&quot;, 326 =&gt; &quot;n&quot;, 327 =&gt; &quot;N&quot;, 328 =&gt; &quot;n&quot;, 336 =&gt; &quot;O&quot;, 337 =&gt; &quot;o&quot;, 338 =&gt; &quot;OE&quot;, 339 =&gt; &quot;oe&quot;, 340 =&gt; &quot;R&quot;, 341 =&gt; &quot;r&quot;, 344 =&gt; &quot;R&quot;, 345 =&gt; &quot;r&quot;, 346 =&gt; &quot;S&quot;, 347 =&gt; &quot;s&quot;, 350 =&gt; &quot;S&quot;, 351 =&gt; &quot;s&quot;, 352 =&gt; &quot;S&quot;, 353 =&gt; &quot;s&quot;, 354 =&gt; &quot;T&quot;, 355 =&gt; &quot;t&quot;, 356 =&gt; &quot;T&quot;, 357 =&gt; &quot;t&quot;, 360 =&gt; &quot;U&quot;, 361 =&gt; &quot;u&quot;, 362 =&gt; &quot;u&quot;, 363 =&gt; &quot;u&quot;, 366 =&gt; &quot;U&quot;, 367 =&gt; &quot;u&quot;, 368 =&gt; &quot;U&quot;, 369 =&gt; &quot;u&quot;, 370 =&gt; &quot;U&quot;, 371 =&gt; &quot;u&quot;, 377 =&gt; &quot;Z&quot;, 378 =&gt; &quot;z&quot;, 379 =&gt; &quot;Z&quot;, 380 =&gt; &quot;z&quot;, 381 =&gt; &quot;Z&quot;, 382 =&gt; &quot;z&quot;, 402 =&gt; &quot;f&quot;, 416 =&gt; &quot;O&quot;, 417 =&gt; &quot;o&quot;, 431 =&gt; &quot;U&quot;, 432 =&gt; &quot;u&quot;, 456 =&gt; &quot;LJ&quot;, 457 =&gt; &quot;lj&quot;, 459 =&gt; &quot;NJ&quot;, 460 =&gt; &quot;nj&quot;, 536 =&gt; &quot;S&quot;, 537 =&gt; &quot;s&quot;, 538 =&gt; &quot;T&quot;, 539 =&gt; &quot;t&quot;, 730 =&gt; &quot;o&quot;, 902 =&gt; &quot;A&quot;, 904 =&gt; &quot;E&quot;, 905 =&gt; &quot;H&quot;, 906 =&gt; &quot;I&quot;, 908 =&gt; &quot;O&quot;, 910 =&gt; &quot;Y&quot;, 911 =&gt; &quot;W&quot;, 912 =&gt; &quot;i&quot;, 913 =&gt; &quot;A&quot;, 914 =&gt; &quot;B&quot;, 915 =&gt; &quot;G&quot;, 916 =&gt; &quot;D&quot;, 917 =&gt; &quot;E&quot;, 918 =&gt; &quot;Z&quot;, 919 =&gt; &quot;H&quot;, 920 =&gt; &quot;8&quot;, 921 =&gt; &quot;I&quot;, 922 =&gt; &quot;K&quot;, 923 =&gt; &quot;L&quot;, 924 =&gt; &quot;M&quot;, 925 =&gt; &quot;N&quot;, 926 =&gt; &quot;3&quot;, 927 =&gt; &quot;O&quot;, 928 =&gt; &quot;P&quot;, 929 =&gt; &quot;R&quot;, 931 =&gt; &quot;S&quot;, 932 =&gt; &quot;T&quot;, 933 =&gt; &quot;Y&quot;, 934 =&gt; &quot;F&quot;, 935 =&gt; &quot;X&quot;, 936 =&gt; &quot;PS&quot;, 937 =&gt; &quot;W&quot;, 938 =&gt; &quot;I&quot;, 939 =&gt; &quot;Y&quot;, 940 =&gt; &quot;a&quot;, 941 =&gt; &quot;e&quot;, 942 =&gt; &quot;h&quot;, 943 =&gt; &quot;i&quot;, 944 =&gt; &quot;y&quot;, 945 =&gt; &quot;a&quot;, 946 =&gt; &quot;b&quot;, 947 =&gt; &quot;g&quot;, 948 =&gt; &quot;d&quot;, 949 =&gt; &quot;e&quot;, 950 =&gt; &quot;z&quot;, 951 =&gt; &quot;h&quot;, 952 =&gt; &quot;8&quot;, 953 =&gt; &quot;i&quot;, 954 =&gt; &quot;k&quot;, 955 =&gt; &quot;l&quot;, 956 =&gt; &quot;m&quot;, 957 =&gt; &quot;n&quot;, 958 =&gt; &quot;3&quot;, 959 =&gt; &quot;o&quot;, 960 =&gt; &quot;p&quot;, 961 =&gt; &quot;r&quot;, 962 =&gt; &quot;s&quot;, 963 =&gt; &quot;s&quot;, 964 =&gt; &quot;t&quot;, 965 =&gt; &quot;y&quot;, 966 =&gt; &quot;f&quot;, 967 =&gt; &quot;x&quot;, 968 =&gt; &quot;ps&quot;, 969 =&gt; &quot;w&quot;, 970 =&gt; &quot;i&quot;, 971 =&gt; &quot;y&quot;, 972 =&gt; &quot;o&quot;, 973 =&gt; &quot;y&quot;, 974 =&gt; &quot;w&quot;, 1025 =&gt; &quot;Yo&quot;, 1026 =&gt; &quot;DJ&quot;, 1028 =&gt; &quot;Ye&quot;, 1030 =&gt; &quot;I&quot;, 1031 =&gt; &quot;Yi&quot;, 1032 =&gt; &quot;J&quot;, 1033 =&gt; &quot;LJ&quot;, 1034 =&gt; &quot;NJ&quot;, 1035 =&gt; &quot;C&quot;, 1039 =&gt; &quot;DZ&quot;, 1040 =&gt; &quot;A&quot;, 1041 =&gt; &quot;B&quot;, 1042 =&gt; &quot;V&quot;, 1043 =&gt; &quot;G&quot;, 1044 =&gt; &quot;D&quot;, 1045 =&gt; &quot;E&quot;, 1046 =&gt; &quot;Zh&quot;, 1047 =&gt; &quot;Z&quot;, 1048 =&gt; &quot;I&quot;, 1049 =&gt; &quot;J&quot;, 1050 =&gt; &quot;K&quot;, 1051 =&gt; &quot;L&quot;, 1052 =&gt; &quot;M&quot;, 1053 =&gt; &quot;N&quot;, 1054 =&gt; &quot;O&quot;, 1055 =&gt; &quot;P&quot;, 1056 =&gt; &quot;R&quot;, 1057 =&gt; &quot;S&quot;, 1058 =&gt; &quot;T&quot;, 1059 =&gt; &quot;U&quot;, 1060 =&gt; &quot;F&quot;, 1061 =&gt; &quot;H&quot;, 1062 =&gt; &quot;C&quot;, 1063 =&gt; &quot;Ch&quot;, 1064 =&gt; &quot;Sh&quot;, 1065 =&gt; &quot;Sh&quot;, 1066 =&gt; &quot;U&quot;, 1067 =&gt; &quot;Y&quot;, 1068 =&gt; &quot;&quot;, 1069 =&gt; &quot;E&quot;, 1070 =&gt; &quot;Yu&quot;, 1071 =&gt; &quot;Ya&quot;, 1072 =&gt; &quot;a&quot;, 1073 =&gt; &quot;b&quot;, 1074 =&gt; &quot;v&quot;, 1075 =&gt; &quot;g&quot;, 1076 =&gt; &quot;d&quot;, 1077 =&gt; &quot;e&quot;, 1078 =&gt; &quot;zh&quot;, 1079 =&gt; &quot;z&quot;, 1080 =&gt; &quot;i&quot;, 1081 =&gt; &quot;j&quot;, 1082 =&gt; &quot;k&quot;, 1083 =&gt; &quot;l&quot;, 1084 =&gt; &quot;m&quot;, 1085 =&gt; &quot;n&quot;, 1086 =&gt; &quot;o&quot;, 1087 =&gt; &quot;p&quot;, 1088 =&gt; &quot;r&quot;, 1089 =&gt; &quot;s&quot;, 1090 =&gt; &quot;t&quot;, 1091 =&gt; &quot;u&quot;, 1092 =&gt; &quot;f&quot;, 1093 =&gt; &quot;h&quot;, 1094 =&gt; &quot;c&quot;, 1095 =&gt; &quot;ch&quot;, 1096 =&gt; &quot;sh&quot;, 1097 =&gt; &quot;sh&quot;, 1098 =&gt; &quot;u&quot;, 1099 =&gt; &quot;y&quot;, 1100 =&gt; &quot;&quot;, 1101 =&gt; &quot;e&quot;, 1102 =&gt; &quot;yu&quot;, 1103 =&gt; &quot;ya&quot;, 1105 =&gt; &quot;yo&quot;, 1106 =&gt; &quot;dj&quot;, 1108 =&gt; &quot;ye&quot;, 1110 =&gt; &quot;i&quot;, 1111 =&gt; &quot;yi&quot;, 1112 =&gt; &quot;j&quot;, 1113 =&gt; &quot;lj&quot;, 1114 =&gt; &quot;nj&quot;, 1115 =&gt; &quot;c&quot;, 1119 =&gt; &quot;dz&quot;, 1168 =&gt; &quot;G&quot;, 1169 =&gt; &quot;g&quot;, 3647 =&gt; &quot;baht&quot;, 4304 =&gt; &quot;a&quot;, 4305 =&gt; &quot;b&quot;, 4306 =&gt; &quot;g&quot;, 4307 =&gt; &quot;d&quot;, 4308 =&gt; &quot;e&quot;, 4309 =&gt; &quot;v&quot;, 4310 =&gt; &quot;z&quot;, 4311 =&gt; &quot;t&quot;, 4312 =&gt; &quot;i&quot;, 4313 =&gt; &quot;k&quot;, 4314 =&gt; &quot;l&quot;, 4315 =&gt; &quot;m&quot;, 4316 =&gt; &quot;n&quot;, 4317 =&gt; &quot;o&quot;, 4318 =&gt; &quot;p&quot;, 4319 =&gt; &quot;zh&quot;, 4320 =&gt; &quot;r&quot;, 4321 =&gt; &quot;s&quot;, 4322 =&gt; &quot;t&quot;, 4323 =&gt; &quot;u&quot;, 4324 =&gt; &quot;f&quot;, 4325 =&gt; &quot;k&quot;, 4326 =&gt; &quot;gh&quot;, 4327 =&gt; &quot;q&quot;, 4328 =&gt; &quot;sh&quot;, 4329 =&gt; &quot;ch&quot;, 4330 =&gt; &quot;ts&quot;, 4331 =&gt; &quot;dz&quot;, 4332 =&gt; &quot;ts&quot;, 4333 =&gt; &quot;ch&quot;, 4334 =&gt; &quot;kh&quot;, 4335 =&gt; &quot;j&quot;, 4336 =&gt; &quot;h&quot;, 7838 =&gt; &quot;SS&quot;, 7840 =&gt; &quot;A&quot;, 7841 =&gt; &quot;a&quot;, 7842 =&gt; &quot;A&quot;, 7843 =&gt; &quot;a&quot;, 7844 =&gt; &quot;A&quot;, 7845 =&gt; &quot;a&quot;, 7846 =&gt; &quot;A&quot;, 7847 =&gt; &quot;a&quot;, 7848 =&gt; &quot;A&quot;, 7849 =&gt; &quot;a&quot;, 7850 =&gt; &quot;A&quot;, 7851 =&gt; &quot;a&quot;, 7852 =&gt; &quot;A&quot;, 7853 =&gt; &quot;a&quot;, 7854 =&gt; &quot;A&quot;, 7855 =&gt; &quot;a&quot;, 7856 =&gt; &quot;A&quot;, 7857 =&gt; &quot;a&quot;, 7858 =&gt; &quot;A&quot;, 7859 =&gt; &quot;a&quot;, 7860 =&gt; &quot;A&quot;, 7861 =&gt; &quot;a&quot;, 7862 =&gt; &quot;A&quot;, 7863 =&gt; &quot;a&quot;, 7864 =&gt; &quot;E&quot;, 7865 =&gt; &quot;e&quot;, 7866 =&gt; &quot;E&quot;, 7867 =&gt; &quot;e&quot;, 7868 =&gt; &quot;E&quot;, 7869 =&gt; &quot;e&quot;, 7870 =&gt; &quot;E&quot;, 7871 =&gt; &quot;e&quot;, 7872 =&gt; &quot;E&quot;, 7873 =&gt; &quot;e&quot;, 7874 =&gt; &quot;E&quot;, 7875 =&gt; &quot;e&quot;, 7876 =&gt; &quot;E&quot;, 7877 =&gt; &quot;e&quot;, 7878 =&gt; &quot;E&quot;, 7879 =&gt; &quot;e&quot;, 7880 =&gt; &quot;I&quot;, 7881 =&gt; &quot;i&quot;, 7882 =&gt; &quot;I&quot;, 7883 =&gt; &quot;i&quot;, 7884 =&gt; &quot;O&quot;, 7885 =&gt; &quot;o&quot;, 7886 =&gt; &quot;O&quot;, 7887 =&gt; &quot;o&quot;, 7888 =&gt; &quot;O&quot;, 7889 =&gt; &quot;o&quot;, 7890 =&gt; &quot;O&quot;, 7891 =&gt; &quot;o&quot;, 7892 =&gt; &quot;O&quot;, 7893 =&gt; &quot;o&quot;, 7894 =&gt; &quot;O&quot;, 7895 =&gt; &quot;o&quot;, 7896 =&gt; &quot;O&quot;, 7897 =&gt; &quot;o&quot;, 7898 =&gt; &quot;O&quot;, 7899 =&gt; &quot;o&quot;, 7900 =&gt; &quot;O&quot;, 7901 =&gt; &quot;o&quot;, 7902 =&gt; &quot;O&quot;, 7903 =&gt; &quot;o&quot;, 7904 =&gt; &quot;O&quot;, 7905 =&gt; &quot;o&quot;, 7906 =&gt; &quot;O&quot;, 7907 =&gt; &quot;o&quot;, 7908 =&gt; &quot;U&quot;, 7909 =&gt; &quot;u&quot;, 7910 =&gt; &quot;U&quot;, 7911 =&gt; &quot;u&quot;, 7912 =&gt; &quot;U&quot;, 7913 =&gt; &quot;u&quot;, 7914 =&gt; &quot;U&quot;, 7915 =&gt; &quot;u&quot;, 7916 =&gt; &quot;U&quot;, 7917 =&gt; &quot;u&quot;, 7918 =&gt; &quot;U&quot;, 7919 =&gt; &quot;u&quot;, 7920 =&gt; &quot;U&quot;, 7921 =&gt; &quot;u&quot;, 7922 =&gt; &quot;Y&quot;, 7923 =&gt; &quot;y&quot;, 7924 =&gt; &quot;Y&quot;, 7925 =&gt; &quot;y&quot;, 7926 =&gt; &quot;Y&quot;, 7927 =&gt; &quot;y&quot;, 7928 =&gt; &quot;Y&quot;, 7929 =&gt; &quot;y&quot;, 8216 =&gt; &quot;&apos;&quot;, 8217 =&gt; &quot;&apos;&quot;, 8220 =&gt; &quot;\&quot;&quot;, 8221 =&gt; &quot;\&quot;&quot;, 8224 =&gt; &quot;+&quot;, 8226 =&gt; &quot;*&quot;, 8230 =&gt; &quot;...&quot;, 8352 =&gt; &quot;ecu&quot;, 8354 =&gt; &quot;cruzeiro&quot;, 8355 =&gt; &quot;french franc&quot;, 8356 =&gt; &quot;lira&quot;, 8357 =&gt; &quot;mill&quot;, 8358 =&gt; &quot;naira&quot;, 8359 =&gt; &quot;peseta&quot;, 8360 =&gt; &quot;rupee&quot;, 8361 =&gt; &quot;won&quot;, 8362 =&gt; &quot;new shequel&quot;, 8363 =&gt; &quot;dong&quot;, 8364 =&gt; &quot;euro&quot;, 8365 =&gt; &quot;kip&quot;, 8366 =&gt; &quot;tugrik&quot;, 8367 =&gt; &quot;drachma&quot;, 8368 =&gt; &quot;penny&quot;, 8369 =&gt; &quot;peso&quot;, 8370 =&gt; &quot;guarani&quot;, 8371 =&gt; &quot;austral&quot;, 8372 =&gt; &quot;hryvnia&quot;, 8373 =&gt; &quot;cedi&quot;, 8377 =&gt; &quot;indian rupee&quot;, 8381 =&gt; &quot;russian ruble&quot;, 8383 =&gt; &quot;bitcoin&quot;, 8480 =&gt; &quot;sm&quot;, 8482 =&gt; &quot;tm&quot;, 8706 =&gt; &quot;d&quot;, 8710 =&gt; &quot;delta&quot;, 8721 =&gt; &quot;sum&quot;, 8734 =&gt; &quot;infinity&quot;, 9829 =&gt; &quot;love&quot;, 20803 =&gt; &quot;yuan&quot;, 20870 =&gt; &quot;yen&quot;, 65020 =&gt; &quot;rial&quot;]" line="14" static="1">
			<t path="Map">
				<x path="Int"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e><![CDATA[[36 => "dollar", 37 => "percent", 38 => "and", 60 => "less", 62 => "greater", 124 => "or", 162 => "cent", 163 => "pound", 164 => "currency", 165 => "yen", 169 => "(c)", 170 => "a", 174 => "(r)", 186 => "o", 192 => "A", 193 => "A", 194 => "A", 195 => "A", 196 => "A", 197 => "A", 198 => "AE", 199 => "C", 200 => "E", 201 => "E", 202 => "E", 203 => "E", 204 => "I", 205 => "I", 206 => "I", 207 => "I", 208 => "D", 209 => "N", 210 => "O", 211 => "O", 212 => "O", 213 => "O", 214 => "O", 216 => "O", 217 => "U", 218 => "U", 219 => "U", 220 => "U", 221 => "Y", 222 => "TH", 223 => "ss", 224 => "a", 225 => "a", 226 => "a", 227 => "a", 228 => "a", 229 => "a", 230 => "ae", 231 => "c", 232 => "e", 233 => "e", 234 => "e", 235 => "e", 236 => "i", 237 => "i", 238 => "i", 239 => "i", 240 => "d", 241 => "n", 242 => "o", 243 => "o", 244 => "o", 245 => "o", 246 => "o", 248 => "o", 249 => "u", 250 => "u", 251 => "u", 252 => "u", 253 => "y", 254 => "th", 255 => "y", 256 => "A", 257 => "a", 258 => "A", 259 => "a", 260 => "A", 261 => "a", 262 => "C", 263 => "c", 268 => "C", 269 => "c", 270 => "D", 271 => "d", 272 => "DJ", 273 => "dj", 274 => "E", 275 => "e", 278 => "E", 279 => "e", 280 => "e", 281 => "e", 282 => "E", 283 => "e", 286 => "G", 287 => "g", 290 => "G", 291 => "g", 296 => "I", 297 => "i", 298 => "i", 299 => "i", 302 => "I", 303 => "i", 304 => "I", 305 => "i", 310 => "k", 311 => "k", 315 => "L", 316 => "l", 317 => "L", 318 => "l", 321 => "L", 322 => "l", 323 => "N", 324 => "n", 325 => "N", 326 => "n", 327 => "N", 328 => "n", 336 => "O", 337 => "o", 338 => "OE", 339 => "oe", 340 => "R", 341 => "r", 344 => "R", 345 => "r", 346 => "S", 347 => "s", 350 => "S", 351 => "s", 352 => "S", 353 => "s", 354 => "T", 355 => "t", 356 => "T", 357 => "t", 360 => "U", 361 => "u", 362 => "u", 363 => "u", 366 => "U", 367 => "u", 368 => "U", 369 => "u", 370 => "U", 371 => "u", 377 => "Z", 378 => "z", 379 => "Z", 380 => "z", 381 => "Z", 382 => "z", 402 => "f", 416 => "O", 417 => "o", 431 => "U", 432 => "u", 456 => "LJ", 457 => "lj", 459 => "NJ", 460 => "nj", 536 => "S", 537 => "s", 538 => "T", 539 => "t", 730 => "o", 902 => "A", 904 => "E", 905 => "H", 906 => "I", 908 => "O", 910 => "Y", 911 => "W", 912 => "i", 913 => "A", 914 => "B", 915 => "G", 916 => "D", 917 => "E", 918 => "Z", 919 => "H", 920 => "8", 921 => "I", 922 => "K", 923 => "L", 924 => "M", 925 => "N", 926 => "3", 927 => "O", 928 => "P", 929 => "R", 931 => "S", 932 => "T", 933 => "Y", 934 => "F", 935 => "X", 936 => "PS", 937 => "W", 938 => "I", 939 => "Y", 940 => "a", 941 => "e", 942 => "h", 943 => "i", 944 => "y", 945 => "a", 946 => "b", 947 => "g", 948 => "d", 949 => "e", 950 => "z", 951 => "h", 952 => "8", 953 => "i", 954 => "k", 955 => "l", 956 => "m", 957 => "n", 958 => "3", 959 => "o", 960 => "p", 961 => "r", 962 => "s", 963 => "s", 964 => "t", 965 => "y", 966 => "f", 967 => "x", 968 => "ps", 969 => "w", 970 => "i", 971 => "y", 972 => "o", 973 => "y", 974 => "w", 1025 => "Yo", 1026 => "DJ", 1028 => "Ye", 1030 => "I", 1031 => "Yi", 1032 => "J", 1033 => "LJ", 1034 => "NJ", 1035 => "C", 1039 => "DZ", 1040 => "A", 1041 => "B", 1042 => "V", 1043 => "G", 1044 => "D", 1045 => "E", 1046 => "Zh", 1047 => "Z", 1048 => "I", 1049 => "J", 1050 => "K", 1051 => "L", 1052 => "M", 1053 => "N", 1054 => "O", 1055 => "P", 1056 => "R", 1057 => "S", 1058 => "T", 1059 => "U", 1060 => "F", 1061 => "H", 1062 => "C", 1063 => "Ch", 1064 => "Sh", 1065 => "Sh", 1066 => "U", 1067 => "Y", 1068 => "", 1069 => "E", 1070 => "Yu", 1071 => "Ya", 1072 => "a", 1073 => "b", 1074 => "v", 1075 => "g", 1076 => "d", 1077 => "e", 1078 => "zh", 1079 => "z", 1080 => "i", 1081 => "j", 1082 => "k", 1083 => "l", 1084 => "m", 1085 => "n", 1086 => "o", 1087 => "p", 1088 => "r", 1089 => "s", 1090 => "t", 1091 => "u", 1092 => "f", 1093 => "h", 1094 => "c", 1095 => "ch", 1096 => "sh", 1097 => "sh", 1098 => "u", 1099 => "y", 1100 => "", 1101 => "e", 1102 => "yu", 1103 => "ya", 1105 => "yo", 1106 => "dj", 1108 => "ye", 1110 => "i", 1111 => "yi", 1112 => "j", 1113 => "lj", 1114 => "nj", 1115 => "c", 1119 => "dz", 1168 => "G", 1169 => "g", 3647 => "baht", 4304 => "a", 4305 => "b", 4306 => "g", 4307 => "d", 4308 => "e", 4309 => "v", 4310 => "z", 4311 => "t", 4312 => "i", 4313 => "k", 4314 => "l", 4315 => "m", 4316 => "n", 4317 => "o", 4318 => "p", 4319 => "zh", 4320 => "r", 4321 => "s", 4322 => "t", 4323 => "u", 4324 => "f", 4325 => "k", 4326 => "gh", 4327 => "q", 4328 => "sh", 4329 => "ch", 4330 => "ts", 4331 => "dz", 4332 => "ts", 4333 => "ch", 4334 => "kh", 4335 => "j", 4336 => "h", 7838 => "SS", 7840 => "A", 7841 => "a", 7842 => "A", 7843 => "a", 7844 => "A", 7845 => "a", 7846 => "A", 7847 => "a", 7848 => "A", 7849 => "a", 7850 => "A", 7851 => "a", 7852 => "A", 7853 => "a", 7854 => "A", 7855 => "a", 7856 => "A", 7857 => "a", 7858 => "A", 7859 => "a", 7860 => "A", 7861 => "a", 7862 => "A", 7863 => "a", 7864 => "E", 7865 => "e", 7866 => "E", 7867 => "e", 7868 => "E", 7869 => "e", 7870 => "E", 7871 => "e", 7872 => "E", 7873 => "e", 7874 => "E", 7875 => "e", 7876 => "E", 7877 => "e", 7878 => "E", 7879 => "e", 7880 => "I", 7881 => "i", 7882 => "I", 7883 => "i", 7884 => "O", 7885 => "o", 7886 => "O", 7887 => "o", 7888 => "O", 7889 => "o", 7890 => "O", 7891 => "o", 7892 => "O", 7893 => "o", 7894 => "O", 7895 => "o", 7896 => "O", 7897 => "o", 7898 => "O", 7899 => "o", 7900 => "O", 7901 => "o", 7902 => "O", 7903 => "o", 7904 => "O", 7905 => "o", 7906 => "O", 7907 => "o", 7908 => "U", 7909 => "u", 7910 => "U", 7911 => "u", 7912 => "U", 7913 => "u", 7914 => "U", 7915 => "u", 7916 => "U", 7917 => "u", 7918 => "U", 7919 => "u", 7920 => "U", 7921 => "u", 7922 => "Y", 7923 => "y", 7924 => "Y", 7925 => "y", 7926 => "Y", 7927 => "y", 7928 => "Y", 7929 => "y", 8216 => "'", 8217 => "'", 8220 => "\"", 8221 => "\"", 8224 => "+", 8226 => "*", 8230 => "...", 8352 => "ecu", 8354 => "cruzeiro", 8355 => "french franc", 8356 => "lira", 8357 => "mill", 8358 => "naira", 8359 => "peseta", 8360 => "rupee", 8361 => "won", 8362 => "new shequel", 8363 => "dong", 8364 => "euro", 8365 => "kip", 8366 => "tugrik", 8367 => "drachma", 8368 => "penny", 8369 => "peso", 8370 => "guarani", 8371 => "austral", 8372 => "hryvnia", 8373 => "cedi", 8377 => "indian rupee", 8381 => "russian ruble", 8383 => "bitcoin", 8480 => "sm", 8482 => "tm", 8706 => "d", 8710 => "delta", 8721 => "sum", 8734 => "infinity", 9829 => "love", 20803 => "yuan", 20870 => "yen", 65020 => "rial"]]]></e></m></meta>
		</charMap>
		<safe final="1" public="1" set="null" expr="~/[^\w\s$*_+~.()&apos;&quot;!\-:@]/" line="62" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/[^\w\s$*_+~.()'"!\-:@]/</e></m></meta>
		</safe>
		<encode public="1" set="method" line="64" static="1"><f a="str:?options">
	<c path="String"/>
	<c path="ceramic.SlugOptions"/>
	<c path="String"/>
</f></encode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.SortVisuals" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SortVisuals.hx">
		<cmp get="inline" set="null" line="37" static="1"><f a="a:b">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
	<x path="Int"/>
</f></cmp>
		<sort public="1" get="inline" set="null" line="100" static="1">
			<f a="a">
				<c path="Array"><c path="ceramic.Visual"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
        `cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
        negative Int if `x < y`.

        This operation modifies Array `a` in place.

        This operation is stable: The order of equal elements is preserved.

        If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec set="method" line="104" static="1"><f a="a:from:to">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge set="method" line="125" static="1"><f a="a:from:pivot:to:len1:len2">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate get="inline" set="null" line="151" static="1"><f a="a:from:mid:to">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd get="inline" set="null" line="170" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper get="inline" set="null" line="179" static="1"><f a="a:from:to:val">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower get="inline" set="null" line="194" static="1"><f a="a:from:to:val">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap get="inline" set="null" line="208" static="1"><f a="a:i:j">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<compare get="inline" set="null" line="214" static="1"><f a="a:i:j">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></compare>
		<haxe_doc>SortVisuals provides a stable implementation of merge sort through its `sort`
    method. It should be used instead of `Array.sort` in cases where the order
    of equal elements has to be retained on all targets.

    This specific implementation has been modified to be exclusively used with array of `ceramic.Visual` instances.
    The compare function (and the rest of the implementation) are inlined to get the best performance out of it.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.SortVisualsByDepth" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SortVisualsByDepth.hx">
		<cmp get="inline" set="null" line="37" static="1"><f a="a:b">
	<c path="ceramic.Visual"/>
	<c path="ceramic.Visual"/>
	<x path="Int"/>
</f></cmp>
		<sort public="1" get="inline" set="null" line="63" static="1">
			<f a="a">
				<c path="Array"><c path="ceramic.Visual"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
         `cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
         negative Int if `x < y`.
 
         This operation modifies Array `a` in place.
 
         This operation is stable: The order of equal elements is preserved.
 
         If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec set="method" line="67" static="1"><f a="a:from:to">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge set="method" line="88" static="1"><f a="a:from:pivot:to:len1:len2">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate get="inline" set="null" line="114" static="1"><f a="a:from:mid:to">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd get="inline" set="null" line="133" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper get="inline" set="null" line="142" static="1"><f a="a:from:to:val">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower get="inline" set="null" line="157" static="1"><f a="a:from:to:val">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap get="inline" set="null" line="171" static="1"><f a="a:i:j">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<compare get="inline" set="null" line="177" static="1"><f a="a:i:j">
	<c path="Array"><c path="ceramic.Visual"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></compare>
		<haxe_doc>SortVisuals provides a stable implementation of merge sort through its `sort`
     method. It should be used instead of `Array.sort` in cases where the order
     of equal elements has to be retained on all targets.
     
     This specific implementation has been modified to be exclusively used with array of `ceramic.Visual` instances and sort them by depth.
     The compare function (and the rest of the implementation) are inlined to get the best performance out of it.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Sound" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Sound.hx">
		<extends path="ceramic.Entity"/>
		<backendItem public="1"><t path="backend.AudioResource"/></backendItem>
		<asset public="1"><c path="ceramic.SoundAsset"/></asset>
		<group public="1" set="accessor" expr="0" line="12">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</group>
		<set_group set="method" line="13"><f a="group">
	<x path="Int"/>
	<x path="Int"/>
</f></set_group>
		<destroy public="1" set="method" line="30" override="1"><f a=""><x path="Void"/></f></destroy>
		<volume public="1" expr="0.5" line="46">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
			<haxe_doc>* Default volume when playing this sound.</haxe_doc>
		</volume>
		<pan public="1" expr="0" line="51">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Default pan when playing this sound.</haxe_doc>
		</pan>
		<pitch public="1" expr="1" line="56">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Default pitch when playing this sound.</haxe_doc>
		</pitch>
		<duration public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Sound duration.</haxe_doc>
		</duration>
		<get_duration get="inline" set="null" line="62"><f a=""><x path="Float"/></f></get_duration>
		<play public="1" set="method" line="70">
			<f a="?position:?loop:?volume:?pan:?pitch" v="0:false:::">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.SoundPlayer"/>
			</f>
			<meta><m n=":value"><e>{ loop : false, position : 0 }</e></m></meta>
			<haxe_doc>* Play the sound at requested position. If volume/pan/pitch are not provided,
     * sound instance properties will be used instead.</haxe_doc>
		</play>
		<new public="1" set="method" line="22"><f a="backendItem">
	<t path="backend.AudioResource"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.SoundAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SoundAsset.hx">
		<extends path="ceramic.Asset"/>
		<_dox_event_replaceSound public="1" set="method" line="637">
			<f a="newSound:prevSound">
				<c path="ceramic.Sound"/>
				<c path="ceramic.Sound"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_replaceSound>
		<emitReplaceSound set="method" line="1095">
			<f a="newSound:prevSound">
				<c path="ceramic.Sound"/>
				<c path="ceramic.Sound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>replaceSound event</haxe_doc>
		</emitReplaceSound>
		<onReplaceSound public="1" set="method" line="1199">
			<f a="owner:handleNewSoundPrevSound">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newSound:prevSound">
					<c path="ceramic.Sound"/>
					<c path="ceramic.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceSound event</haxe_doc>
		</onReplaceSound>
		<onceReplaceSound public="1" set="method" line="1298">
			<f a="owner:handleNewSoundPrevSound">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="newSound:prevSound">
					<c path="ceramic.Sound"/>
					<c path="ceramic.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceSound event</haxe_doc>
		</onceReplaceSound>
		<offReplaceSound public="1" set="method" line="1368">
			<f a="?handleNewSoundPrevSound">
				<f a="newSound:prevSound">
					<c path="ceramic.Sound"/>
					<c path="ceramic.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>replaceSound event</haxe_doc>
		</offReplaceSound>
		<listensReplaceSound public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to replaceSound event</haxe_doc>
		</listensReplaceSound>
		<stream public="1" expr="false" line="12">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</stream>
		<invalidateSound public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateSound>
		<sound public="1" expr="null" line="14">
			<c path="ceramic.Sound"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</sound>
		<unobservedSound>
			<c path="ceramic.Sound"/>
			<haxe_doc></haxe_doc>
		</unobservedSound>
		<_dox_event_soundChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.Sound"/>
				<c path="ceramic.Sound"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when sound field changes.</haxe_doc>
		</_dox_event_soundChange>
		<emitSoundChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.Sound"/>
				<c path="ceramic.Sound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when sound field changes.</haxe_doc>
		</emitSoundChange>
		<onSoundChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Sound"/>
					<c path="ceramic.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when sound field changes.</haxe_doc>
		</onSoundChange>
		<onceSoundChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Sound"/>
					<c path="ceramic.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when sound field changes.</haxe_doc>
		</onceSoundChange>
		<offSoundChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.Sound"/>
					<c path="ceramic.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when sound field changes.</haxe_doc>
		</offSoundChange>
		<listensSoundChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when sound field changes.</haxe_doc>
		</listensSoundChange>
		<load public="1" set="method" line="22" override="1"><f a=""><x path="Void"/></f></load>
		<assetFilesDidChange set="method" line="118" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="139" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="16"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="ceramic.SoundPlayer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SoundPlayer.hx">
		<this><t path="backend.AudioHandle"/></this>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="ceramic._SoundPlayer.SoundPlayer_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SoundPlayer.hx" private="1" module="ceramic.SoundPlayer" final="1">
	<pause public="1" get="inline" set="null" line="10" static="1">
		<f a="this">
			<t path="backend.AudioHandle"/>
			<x path="Void"/>
		</f>
		<haxe_doc>* Pause the sound (for later resume).</haxe_doc>
	</pause>
	<resume public="1" get="inline" set="null" line="19" static="1">
		<f a="this">
			<t path="backend.AudioHandle"/>
			<x path="Void"/>
		</f>
		<haxe_doc>* Resume playing the sound.</haxe_doc>
	</resume>
	<stop public="1" get="inline" set="null" line="28" static="1">
		<f a="this">
			<t path="backend.AudioHandle"/>
			<x path="Void"/>
		</f>
		<haxe_doc>* Stop the sound.</haxe_doc>
	</stop>
	<volume public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The volume of the sound being played.</haxe_doc>
	</volume>
	<get_volume get="inline" set="null" line="38" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_volume>
	<set_volume get="inline" set="null" line="41" static="1"><f a="this:volume">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
	<pan public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The pan of the sound being played.</haxe_doc>
	</pan>
	<get_pan get="inline" set="null" line="50" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_pan>
	<set_pan get="inline" set="null" line="53" static="1"><f a="this:pan">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
	<pitch public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The pitch of the sound being played.</haxe_doc>
	</pitch>
	<get_pitch get="inline" set="null" line="62" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_pitch>
	<set_pitch get="inline" set="null" line="65" static="1"><f a="this:pitch">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_pitch>
	<position public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>* The position (in seconds) of the sound being played.</haxe_doc>
	</position>
	<get_position get="inline" set="null" line="74" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_position>
	<set_position get="inline" set="null" line="77" static="1"><f a="this:position">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
	<fadeOut public="1" set="method" line="84" static="1"><f a="this:duration">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fadeOut>
	<meta><m n=":hxGen"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._SoundPlayer.SoundPlayer_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/SoundPlayer.hx" private="1" module="ceramic.SoundPlayer" final="1">
		<pause public="1" get="inline" set="null" line="10" static="1">
			<f a="this">
				<t path="backend.AudioHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pause the sound (for later resume).</haxe_doc>
		</pause>
		<resume public="1" get="inline" set="null" line="19" static="1">
			<f a="this">
				<t path="backend.AudioHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resume playing the sound.</haxe_doc>
		</resume>
		<stop public="1" get="inline" set="null" line="28" static="1">
			<f a="this">
				<t path="backend.AudioHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stop the sound.</haxe_doc>
		</stop>
		<volume public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The volume of the sound being played.</haxe_doc>
		</volume>
		<get_volume get="inline" set="null" line="38" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_volume>
		<set_volume get="inline" set="null" line="41" static="1"><f a="this:volume">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<pan public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The pan of the sound being played.</haxe_doc>
		</pan>
		<get_pan get="inline" set="null" line="50" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_pan>
		<set_pan get="inline" set="null" line="53" static="1"><f a="this:pan">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
		<pitch public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The pitch of the sound being played.</haxe_doc>
		</pitch>
		<get_pitch get="inline" set="null" line="62" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_pitch>
		<set_pitch get="inline" set="null" line="65" static="1"><f a="this:pitch">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_pitch>
		<position public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* The position (in seconds) of the sound being played.</haxe_doc>
		</position>
		<get_position get="inline" set="null" line="74" static="1"><f a="this">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
</f></get_position>
		<set_position get="inline" set="null" line="77" static="1"><f a="this:position">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
		<fadeOut public="1" set="method" line="84" static="1"><f a="this:duration">
	<t path="backend.AudioHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fadeOut>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.State" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/State.hx">
		<extends path="ceramic.Entity"/>
		<machine public="1" set="null" expr="null" line="6">
			<c path="ceramic.StateMachine"><x path="Any"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</machine>
		<enter public="1" set="method" line="14"><f a=""><x path="Void"/></f></enter>
		<update public="1" set="method" line="20"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<exit public="1" set="method" line="26"><f a=""><x path="Void"/></f></exit>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.StateMachineImpl</e></m>
		</meta>
	</class>
	<class path="ceramic.StateMachineBase" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/StateMachineBase.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<implements path="tracker.Observable"/>
		<NO_STATE final="1" set="null" expr="null" line="10" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* A way to assign null state to generic classes and let final target do what is best as a cast</haxe_doc>
		</NO_STATE>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.StateMachineBase"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.StateMachineBase"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.StateMachineBase"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.StateMachineBase"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.StateMachineBase"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false" line="131">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<rawEntity public="1">
			<c path="ceramic.Entity"/>
			<meta>
				<m n=":noCompletion"/>
				<m n="entity"/>
				<m n=":keep"/>
			</meta>
		</rawEntity>
		<paused public="1" expr="false" line="17">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* When set to `true`, the state machine will stop calling `update()` on current state and related.</haxe_doc>
		</paused>
		<autoUpdate public="1" expr="true" line="23">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* When set to `true` (default). This state machine will be updated automatically.
     * If `false`, you'll need to call `update()` manually.</haxe_doc>
		</autoUpdate>
		<stateDefined public="1" set="null" expr="false" line="28">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Is `true` if a state has been assigned, `false` otherwise.</haxe_doc>
		</stateDefined>
		<nextStateDefined public="1" set="null" expr="false" line="33">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Is `true` if a nextState has been assigned, `false` otherwise.</haxe_doc>
		</nextStateDefined>
		<locked public="1" expr="false" line="38">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If set to `true`, changing state will be forbidden and trigger an error.</haxe_doc>
		</locked>
		<stateInstances expr="null" line="40">
			<t path="Map">
				<c path="String"/>
				<c path="ceramic.State"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</stateInstances>
		<currentStateInstance expr="null" line="42">
			<c path="ceramic.State"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</currentStateInstance>
		<update public="1" set="method" line="54"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<bindAsComponent set="method" line="60"><f a=""><x path="Void"/></f></bindAsComponent>
		<destroy public="1" set="method" line="66" override="1"><f a=""><x path="Void"/></f></destroy>
		<setEntity set="method" line="5">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="5">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="46"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.StateMachineImpl" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/StateMachineImpl.hx">
		<extends path="ceramic.StateMachineBase"/>
		<invalidateState public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateState>
		<state public="1" set="accessor" expr="StateMachineBase.NO_STATE" line="9">
			<c path="ceramic.StateMachineImpl.T"/>
			<meta>
				<m n=":value"><e>StateMachineBase.NO_STATE</e></m>
				<m n="observe"/>
			</meta>
			<haxe_doc>* The current state</haxe_doc>
		</state>
		<unobservedState>
			<c path="ceramic.StateMachineImpl.T"/>
			<haxe_doc></haxe_doc>
		</unobservedState>
		<_dox_event_stateChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.StateMachineImpl.T"/>
				<c path="ceramic.StateMachineImpl.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when state field changes.</haxe_doc>
		</_dox_event_stateChange>
		<emitStateChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.StateMachineImpl.T"/>
				<c path="ceramic.StateMachineImpl.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when state field changes.</haxe_doc>
		</emitStateChange>
		<onStateChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.StateMachineImpl.T"/>
					<c path="ceramic.StateMachineImpl.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when state field changes.</haxe_doc>
		</onStateChange>
		<onceStateChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.StateMachineImpl.T"/>
					<c path="ceramic.StateMachineImpl.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when state field changes.</haxe_doc>
		</onceStateChange>
		<offStateChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.StateMachineImpl.T"/>
					<c path="ceramic.StateMachineImpl.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when state field changes.</haxe_doc>
		</offStateChange>
		<listensStateChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when state field changes.</haxe_doc>
		</listensStateChange>
		<nextState public="1" set="null" expr="StateMachineBase.NO_STATE" line="15">
			<c path="ceramic.StateMachineImpl.T"/>
			<meta><m n=":value"><e>StateMachineBase.NO_STATE</e></m></meta>
			<haxe_doc>* When transitioning from one state to another,
     * this will be set to the next incoming state</haxe_doc>
		</nextState>
		<set_state set="method" line="17"><f a="state">
	<c path="ceramic.StateMachineImpl.T"/>
	<c path="ceramic.StateMachineImpl.T"/>
</f></set_state>
		<computeStateDefined set="method" line="54"><f a="state">
	<c path="ceramic.StateMachineImpl.T"/>
	<x path="Bool"/>
</f></computeStateDefined>
		<keyToString set="method" line="60"><f a="key">
	<c path="ceramic.StateMachineImpl.T"/>
	<c path="String"/>
</f></keyToString>
		<set public="1" set="method" line="67"><f a="key:stateInstance">
	<c path="ceramic.StateMachineImpl.T"/>
	<c path="ceramic.State"/>
	<x path="Void"/>
</f></set>
		<get public="1" set="method" line="102"><f a="key">
	<c path="ceramic.StateMachineImpl.T"/>
	<c path="ceramic.State"/>
</f></get>
		<update public="1" set="method" line="114" override="1"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<scheduleOnceEnterState public="1" set="method" line="120"><f a="owner:state:callback">
	<c path="ceramic.Entity"/>
	<c path="ceramic.StateMachineImpl.T"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></scheduleOnceEnterState>
		<scheduleOnceExitState public="1" set="method" line="134"><f a="owner:state:callback">
	<c path="ceramic.Entity"/>
	<c path="ceramic.StateMachineImpl.T"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></scheduleOnceExitState>
		<_enterState set="method" line="148"><f a=""><x path="Void"/></f></_enterState>
		<_updateState set="method" line="158"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></_updateState>
		<_exitState set="method" line="168"><f a=""><x path="Void"/></f></_exitState>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.StateMachine" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/StateMachine.hx">
		<extends path="ceramic.StateMachineImpl"><c path="ceramic.StateMachine.T"/></extends>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.StateMachineComponent" params="T:E" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/StateMachineComponent.hx">
		<extends path="ceramic.StateMachineImpl"><c path="ceramic.StateMachineComponent.T"/></extends>
		<entity public="1" set="null">
			<c path="ceramic.StateMachineComponent.E"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<setEntity set="method" line="8" override="1">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="8" override="1">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.StateMachineSystem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/StateMachineSystem.hx">
		<extends path="ceramic.System"/>
		<shared public="1" expr="new StateMachineSystem()" line="11" static="1">
			<c path="ceramic.StateMachineSystem"/>
			<meta>
				<m n=":value"><e>new StateMachineSystem()</e></m>
				<m n="lazy"/>
			</meta>
			<haxe_doc>* Shared state machine system</haxe_doc>
		</shared>
		<stateMachines expr="[]" line="13">
			<c path="Array"><c path="ceramic.StateMachineBase"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</stateMachines>
		<_updatingStateMachines expr="[]" line="15">
			<c path="Array"><c path="ceramic.StateMachineBase"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_updatingStateMachines>
		<lateUpdate set="method" line="25" override="1"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></lateUpdate>
		<new set="method" line="17"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":allow"><e>ceramic.StateMachineBase</e></m>
		</meta>
	</class>
	<class path="ceramic.Systems" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Systems.hx">
		<extends path="ceramic.Entity"/>
		<sortSystemsByEarlyUpdateOrder set="method" line="146" static="1"><f a="a:b">
	<c path="ceramic.System"/>
	<c path="ceramic.System"/>
	<x path="Int"/>
</f></sortSystemsByEarlyUpdateOrder>
		<sortSystemsByLateUpdateOrder set="method" line="157" static="1"><f a="a:b">
	<c path="ceramic.System"/>
	<c path="ceramic.System"/>
	<x path="Int"/>
</f></sortSystemsByLateUpdateOrder>
		<earlyUpdateOrderDirty expr="false" line="15">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If `true`, `earlyUpdateOrdered` list needs to be sorted</haxe_doc>
		</earlyUpdateOrderDirty>
		<lateUpdateOrderDirty expr="false" line="20">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If `true`, `lateUpdateOrdered` list needs to be sorted</haxe_doc>
		</lateUpdateOrderDirty>
		<earlyUpdateOrdered expr="[]" line="25">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.System"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* List of systems, ordered ascending according to their `earlyUpdateOrder` property</haxe_doc>
		</earlyUpdateOrdered>
		<lateUpdateOrdered expr="[]" line="30">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.System"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* List of systems, ordered ascending according to their `lateUpdateOrder` property</haxe_doc>
		</lateUpdateOrdered>
		<_udpatingSystems expr="[]" line="35">
			<c path="Array"><c path="ceramic.System"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal pre-allocated array used for iteration</haxe_doc>
		</_udpatingSystems>
		<addSystem set="method" line="43"><f a="system">
	<c path="ceramic.System"/>
	<x path="Void"/>
</f></addSystem>
		<removeSystem set="method" line="53"><f a="system">
	<c path="ceramic.System"/>
	<x path="Void"/>
</f></removeSystem>
		<earlyUpdate set="method" line="63"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></earlyUpdate>
		<lateUpdate set="method" line="96"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></lateUpdate>
		<get public="1" set="method" line="131"><f a="name">
	<c path="String"/>
	<c path="ceramic.System"/>
</f></get>
		<new set="method" line="37"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<class path="ceramic.Task" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Task.hx">
		<extends path="ceramic.Entity"/>
		<_dox_event_done public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_done>
		<emitDone set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>done event</haxe_doc>
		</emitDone>
		<onDone public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>done event</haxe_doc>
		</onDone>
		<onceDone public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>done event</haxe_doc>
		</onceDone>
		<offDone public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>done event</haxe_doc>
		</offDone>
		<listensDone public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to done event</haxe_doc>
		</listensDone>
		<_dox_event_fail public="1" set="method" line="637">
			<f a="reason">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_fail>
		<emitFail set="method" line="1095">
			<f a="reason">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>fail event</haxe_doc>
		</emitFail>
		<onFail public="1" set="method" line="1199">
			<f a="owner:handleReason">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="reason">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>fail event</haxe_doc>
		</onFail>
		<onceFail public="1" set="method" line="1298">
			<f a="owner:handleReason">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="reason">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>fail event</haxe_doc>
		</onceFail>
		<offFail public="1" set="method" line="1368">
			<f a="?handleReason">
				<f a="reason">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>fail event</haxe_doc>
		</offFail>
		<listensFail public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to fail event</haxe_doc>
		</listensFail>
		<done public="1" set="method" line="12"><f a=""><x path="Void"/></f></done>
		<fail public="1" set="method" line="18"><f a="reason">
	<c path="String"/>
	<x path="Void"/>
</f></fail>
		<run public="1" set="method" line="26"><f a=""><x path="Void"/></f></run>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Tasks" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Tasks.hx">
		<runFromArgs public="1" set="method" line="8" static="1"><f a=""><x path="Void"/></f></runFromArgs>
		<run public="1" set="method" line="32" static="1"><f a="taskName">
	<c path="String"/>
	<x path="Void"/>
</f></run>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.Text" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Text.hx">
		<extends path="ceramic.Visual"/>
		<_dox_event_glyphQuadsChange public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_glyphQuadsChange>
		<emitGlyphQuadsChange set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>glyphQuadsChange event</haxe_doc>
		</emitGlyphQuadsChange>
		<onGlyphQuadsChange public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>glyphQuadsChange event</haxe_doc>
		</onGlyphQuadsChange>
		<onceGlyphQuadsChange public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>glyphQuadsChange event</haxe_doc>
		</onceGlyphQuadsChange>
		<offGlyphQuadsChange public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>glyphQuadsChange event</haxe_doc>
		</offGlyphQuadsChange>
		<listensGlyphQuadsChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to glyphQuadsChange event</haxe_doc>
		</listensGlyphQuadsChange>
		<glyphQuads public="1" set="null" expr="[]" line="18">
			<c path="Array"><c path="ceramic.GlyphQuad"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</glyphQuads>
		<numLines public="1" get="accessor" set="null" expr="1" line="20">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</numLines>
		<get_numLines set="method" line="21"><f a=""><x path="Int"/></f></get_numLines>
		<color public="1" set="accessor" expr="Color.WHITE" line="27">
			<x path="ceramic.Color"/>
			<meta>
				<m n=":value"><e>Color.WHITE</e></m>
				<m n="editable"/>
			</meta>
		</color>
		<set_color set="method" line="28"><f a="color">
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
		<content public="1" set="accessor" expr="&quot;&quot;" line="44">
			<c path="String"/>
			<meta>
				<m n=":value"><e>""</e></m>
				<m n="editable"><e>{ multiline : true }</e></m>
			</meta>
		</content>
		<set_content set="method" line="45"><f a="content">
	<c path="String"/>
	<c path="String"/>
</f></set_content>
		<pointSize public="1" set="accessor" expr="20" line="54">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>20</e></m>
				<m n="editable"><e>{ slider : [6, 600] }</e></m>
			</meta>
		</pointSize>
		<set_pointSize set="method" line="55"><f a="pointSize">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pointSize>
		<lineHeight public="1" set="accessor" expr="1.0" line="63">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1.0</e></m>
				<m n="editable"><e>{ slider : [0, 10] }</e></m>
			</meta>
		</lineHeight>
		<set_lineHeight set="method" line="64"><f a="lineHeight">
	<x path="Float"/>
	<x path="Float"/>
</f></set_lineHeight>
		<letterSpacing public="1" set="accessor" expr="0.0" line="72">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.0</e></m>
				<m n="editable"><e>{ slider : [-100, 100] }</e></m>
			</meta>
		</letterSpacing>
		<set_letterSpacing set="method" line="73"><f a="letterSpacing">
	<x path="Float"/>
	<x path="Float"/>
</f></set_letterSpacing>
		<font public="1" set="accessor">
			<c path="ceramic.BitmapFont"/>
			<meta><m n="editable"/></meta>
		</font>
		<set_font set="method" line="82"><f a="font">
	<c path="ceramic.BitmapFont"/>
	<c path="ceramic.BitmapFont"/>
</f></set_font>
		<clipTextX public="1" set="accessor" expr="-1" line="108">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</clipTextX>
		<set_clipTextX set="method" line="109"><f a="clipTextX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_clipTextX>
		<clipTextY public="1" set="accessor" expr="-1" line="116">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</clipTextY>
		<set_clipTextY set="method" line="117"><f a="clipTextY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_clipTextY>
		<clipTextWidth public="1" set="accessor" expr="-1" line="124">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</clipTextWidth>
		<set_clipTextWidth set="method" line="125"><f a="clipTextWidth">
	<x path="Float"/>
	<x path="Float"/>
</f></set_clipTextWidth>
		<clipTextHeight public="1" set="accessor" expr="-1" line="132">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</clipTextHeight>
		<set_clipTextHeight set="method" line="133"><f a="clipTextHeight">
	<x path="Float"/>
	<x path="Float"/>
</f></set_clipTextHeight>
		<clipText public="1" set="method" line="140"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clipText>
		<preRenderedSize public="1" set="accessor" expr="-1" line="147">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</preRenderedSize>
		<set_preRenderedSize set="method" line="148"><f a="preRenderedSize">
	<x path="Int"/>
	<x path="Int"/>
</f></set_preRenderedSize>
		<handleTexturesDensityChange set="method" line="161"><f a="_:_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></handleTexturesDensityChange>
		<align public="1" set="accessor" expr="LEFT" line="166">
			<e path="ceramic.TextAlign"/>
			<meta>
				<m n=":value"><e>LEFT</e></m>
				<m n="editable"/>
			</meta>
		</align>
		<set_align set="method" line="167"><f a="align">
	<e path="ceramic.TextAlign"/>
	<e path="ceramic.TextAlign"/>
</f></set_align>
		<fitWidth public="1" set="accessor" expr="-1" line="179">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="editable"/>
			</meta>
			<haxe_doc>* If set to `true`, text will be displayed with line breaks
     * as needed so that it fits in the requested width.</haxe_doc>
		</fitWidth>
		<set_fitWidth set="method" line="180"><f a="fitWidth">
	<x path="Float"/>
	<x path="Float"/>
</f></set_fitWidth>
		<maxLineDiff public="1" set="accessor" expr="-1" line="188">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n="editable"/>
			</meta>
		</maxLineDiff>
		<set_maxLineDiff set="method" line="189"><f a="maxLineDiff">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxLineDiff>
		<set_depth set="method" line="198" override="1"><f a="depth">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depth>
		<get_width set="method" line="212" override="1"><f a=""><x path="Float"/></f></get_width>
		<scaleWidth set="method" line="217"><f a="targetWidth">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleWidth>
		<get_height set="method" line="224" override="1"><f a=""><x path="Float"/></f></get_height>
		<scaleHeight set="method" line="229"><f a="targetHeight">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleHeight>
		<set_blending set="method" line="236" override="1"><f a="blending">
	<x path="ceramic.Blending"/>
	<x path="ceramic.Blending"/>
</f></set_blending>
		<destroy public="1" set="method" line="259" override="1"><f a=""><x path="Void"/></f></destroy>
		<computeContent public="1" set="method" line="274" override="1"><f a=""><x path="Void"/></f></computeContent>
		<computeGlyphQuads set="method" line="299">
			<f a="fitWidth:maxLineDiff:?fixedNumLines" v="::-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ fixedNumLines : -1 }</e></m></meta>
		</computeGlyphQuads>
		<lineForYPosition public="1" set="method" line="653">
			<f a="y">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the line number matching the given `y` position.
     * `y` is relative this `Text` visual.</haxe_doc>
		</lineForYPosition>
		<posInLineForX public="1" set="method" line="679">
			<f a="line:x">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the character index position relative to `line` at the requested `x` value.
     * `x` is relative this `Text` visual.</haxe_doc>
		</posInLineForX>
		<indexForPosInLine public="1" set="method" line="713">
			<f a="line:posInLine">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the _global_ character index from the given `line` and `posInLine` index position relative to `line`</haxe_doc>
		</indexForPosInLine>
		<xPositionAtIndex public="1" set="method" line="738">
			<f a="index">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get an `x` position from the given character `index`.
     * `x` is relative to this `Text` visual.</haxe_doc>
		</xPositionAtIndex>
		<lineForIndex public="1" set="method" line="774">
			<f a="index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the line number (starting from zero) of the character at the given `index`</haxe_doc>
		</lineForIndex>
		<posInLineForIndex public="1" set="method" line="806">
			<f a="index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get a character index position relative to its line from its _global_ `index` position.</haxe_doc>
		</posInLineForIndex>
		<fontDestroyed set="method" line="848"><f a="_">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></fontDestroyed>
		<toString set="method" line="857" override="1"><f a=""><c path="String"/></f></toString>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="250"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A visual to layout and display text.
 * Works with UTF-8 strings.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n="editable"><e>{ implicitSize : true }</e></m>
		</meta>
	</class>
	<enum path="ceramic.TextAlign" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextAlign.hx">
		<LEFT/>
		<RIGHT/>
		<CENTER/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.TextAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextAsset.hx">
		<extends path="ceramic.Asset"/>
		<invalidateText public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateText>
		<text public="1" expr="null" line="7">
			<c path="String"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</text>
		<unobservedText>
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</unobservedText>
		<_dox_event_textChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</_dox_event_textChange>
		<emitTextChange set="method" line="1095">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</emitTextChange>
		<onTextChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</onTextChange>
		<onceTextChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</onceTextChange>
		<offTextChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</offTextChange>
		<listensTextChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when text field changes.</haxe_doc>
		</listensTextChange>
		<load public="1" set="method" line="15" override="1"><f a=""><x path="Void"/></f></load>
		<assetFilesDidChange set="method" line="64" override="1"><f a="newFiles:previousFiles">
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
	<x path="Void"/>
</f></assetFilesDidChange>
		<destroy public="1" set="method" line="85" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="9"><f a="name:?variant:?options">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><t path="ceramic.AssetOptions"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.TextInput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextInput.hx">
		<implements path="tracker.Events"/>
		<_dox_event__update public="1" set="method" line="637">
			<f a="text">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__update>
		<emitUpdate set="method" line="1095">
			<f a="text">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>update event</haxe_doc>
		</emitUpdate>
		<onUpdate public="1" set="method" line="1199">
			<f a="owner:handleText">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="text">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onUpdate>
		<onceUpdate public="1" set="method" line="1298">
			<f a="owner:handleText">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="text">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onceUpdate>
		<offUpdate public="1" set="method" line="1368">
			<f a="?handleText">
				<f a="text">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</offUpdate>
		<listensUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to update event</haxe_doc>
		</listensUpdate>
		<_dox_event__enter public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__enter>
		<emitEnter set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>enter event</haxe_doc>
		</emitEnter>
		<onEnter public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>enter event</haxe_doc>
		</onEnter>
		<onceEnter public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>enter event</haxe_doc>
		</onceEnter>
		<offEnter public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>enter event</haxe_doc>
		</offEnter>
		<listensEnter public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to enter event</haxe_doc>
		</listensEnter>
		<_dox_event__escape public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__escape>
		<emitEscape set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>escape event</haxe_doc>
		</emitEscape>
		<onEscape public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>escape event</haxe_doc>
		</onEscape>
		<onceEscape public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>escape event</haxe_doc>
		</onceEscape>
		<offEscape public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>escape event</haxe_doc>
		</offEscape>
		<listensEscape public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to escape event</haxe_doc>
		</listensEscape>
		<_dox_event__selection public="1" set="method" line="637">
			<f a="selectionStart:selectionEnd">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__selection>
		<emitSelection set="method" line="1095">
			<f a="selectionStart:selectionEnd">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>selection event</haxe_doc>
		</emitSelection>
		<onSelection public="1" set="method" line="1199">
			<f a="owner:handleSelectionStartSelectionEnd">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="selectionStart:selectionEnd">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>selection event</haxe_doc>
		</onSelection>
		<onceSelection public="1" set="method" line="1298">
			<f a="owner:handleSelectionStartSelectionEnd">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="selectionStart:selectionEnd">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>selection event</haxe_doc>
		</onceSelection>
		<offSelection public="1" set="method" line="1368">
			<f a="?handleSelectionStartSelectionEnd">
				<f a="selectionStart:selectionEnd">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>selection event</haxe_doc>
		</offSelection>
		<listensSelection public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to selection event</haxe_doc>
		</listensSelection>
		<_dox_event__stop public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__stop>
		<emitStop set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>stop event</haxe_doc>
		</emitStop>
		<onStop public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>stop event</haxe_doc>
		</onStop>
		<onceStop public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>stop event</haxe_doc>
		</onceStop>
		<offStop public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>stop event</haxe_doc>
		</offStop>
		<listensStop public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to stop event</haxe_doc>
		</listensStop>
		<inputActive expr="false" line="25">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</inputActive>
		<explicitPosInLine expr="0" line="27">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</explicitPosInLine>
		<explicitPosLine expr="0" line="29">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</explicitPosLine>
		<lshiftPressed expr="false" line="31">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lshiftPressed>
		<rshiftPressed expr="false" line="33">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rshiftPressed>
		<lctrlPressed expr="false" line="35">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lctrlPressed>
		<rctrlPressed expr="false" line="37">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rctrlPressed>
		<lmetaPressed expr="false" line="39">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lmetaPressed>
		<rmetaPressed expr="false" line="41">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rmetaPressed>
		<invertedSelection expr="false" line="43">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</invertedSelection>
		<allowMovingCursor public="1" set="null" expr="false" line="45">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</allowMovingCursor>
		<multiline public="1" set="null" expr="false" line="47">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</multiline>
		<text public="1" set="accessor" expr="&quot;&quot;" line="49">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</text>
		<selectionStart public="1" set="null" expr="-1" line="51">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</selectionStart>
		<selectionEnd public="1" set="null" expr="-1" line="53">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</selectionEnd>
		<delegate public="1" set="null" expr="null" line="55">
			<c path="ceramic.TextInputDelegate"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</delegate>
		<start public="1" set="method" line="74">
			<f a="text:x:y:w:h:?multiline:?selectionStart:?selectionEnd:?allowMovingCursor:?delegate" v=":::::false:-1:-1:false:null">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="ceramic.TextInputDelegate"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ delegate : null, allowMovingCursor : false, selectionEnd : -1, selectionStart : -1, multiline : false }</e></m></meta>
		</start>
		<stop public="1" set="method" line="99"><f a=""><x path="Void"/></f></stop>
		<updateSelection public="1" set="method" line="114"><f a="selectionStart:selectionEnd:?inverted">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></updateSelection>
		<appendText public="1" set="method" line="125"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<space public="1" set="method" line="157"><f a=""><x path="Void"/></f></space>
		<backspace public="1" set="method" line="163"><f a=""><x path="Void"/></f></backspace>
		<moveLeft public="1" set="method" line="187"><f a=""><x path="Void"/></f></moveLeft>
		<moveRight public="1" set="method" line="241"><f a=""><x path="Void"/></f></moveRight>
		<moveUp public="1" set="method" line="298"><f a=""><x path="Void"/></f></moveUp>
		<moveDown public="1" set="method" line="358"><f a=""><x path="Void"/></f></moveDown>
		<enter public="1" set="method" line="449"><f a=""><x path="Void"/></f></enter>
		<escape public="1" set="method" line="462"><f a=""><x path="Void"/></f></escape>
		<lshiftDown public="1" set="method" line="469"><f a=""><x path="Void"/></f></lshiftDown>
		<lshiftUp public="1" set="method" line="475"><f a=""><x path="Void"/></f></lshiftUp>
		<rshiftDown public="1" set="method" line="481"><f a=""><x path="Void"/></f></rshiftDown>
		<rshiftUp public="1" set="method" line="487"><f a=""><x path="Void"/></f></rshiftUp>
		<lctrlDown public="1" set="method" line="493"><f a=""><x path="Void"/></f></lctrlDown>
		<lctrlUp public="1" set="method" line="499"><f a=""><x path="Void"/></f></lctrlUp>
		<rctrlDown public="1" set="method" line="505"><f a=""><x path="Void"/></f></rctrlDown>
		<rctrlUp public="1" set="method" line="511"><f a=""><x path="Void"/></f></rctrlUp>
		<lmetaDown public="1" set="method" line="517"><f a=""><x path="Void"/></f></lmetaDown>
		<lmetaUp public="1" set="method" line="523"><f a=""><x path="Void"/></f></lmetaUp>
		<rmetaDown public="1" set="method" line="529"><f a=""><x path="Void"/></f></rmetaDown>
		<rmetaUp public="1" set="method" line="535"><f a=""><x path="Void"/></f></rmetaUp>
		<posInCurrentLine set="method" line="546">
			<f a="globalPos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the position in the current line, from the given global position in text</haxe_doc>
		</posInCurrentLine>
		<lineForPos set="method" line="570">
			<f a="globalPos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the current line (starts from 0) from the given global position in text</haxe_doc>
		</lineForPos>
		<numLines set="method" line="588"><f a=""><x path="Int"/></f></numLines>
		<globalPosForLine set="method" line="596"><f a="lineNumber:lineOffset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></globalPosForLine>
		<set_text set="method" line="625"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new set="method" line="59"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<class path="ceramic.TextureAtlas" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlas.hx">
		<extends path="ceramic.Entity"/>
		<pages public="1" expr="[]" line="10">
			<c path="Array"><c path="ceramic.TextureAtlasPage"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The pages of this atlas.</haxe_doc>
		</pages>
		<regions public="1" expr="[]" line="15">
			<c path="Array"><c path="ceramic.TextureAtlasRegion"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The texture regions of this atlas</haxe_doc>
		</regions>
		<asset public="1" expr="null" line="20">
			<c path="ceramic.AtlasAsset"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The asset related to this atlas (if any)</haxe_doc>
		</asset>
		<region public="1" set="method" line="28"><f a="name">
	<c path="String"/>
	<c path="ceramic.TextureAtlasRegion"/>
</f></region>
		<computeFrames public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Expected to be called when every page got their texture loaded,
     * in order to compute the actual frames of each region</haxe_doc>
		</computeFrames>
		<destroy public="1" set="method" line="53" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.TextureAtlasPacker" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasPacker.hx">
		<extends path="ceramic.Entity"/>
		<MIN_TEXTURE_SIZE final="1" set="null" expr="32" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</MIN_TEXTURE_SIZE>
		<MAX_TEXTURE_SIZE final="1" set="null" expr="2048" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2048</e></m></meta>
		</MAX_TEXTURE_SIZE>
		<_dox_event_finishPack public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_finishPack>
		<emitFinishPack set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>finishPack event</haxe_doc>
		</emitFinishPack>
		<onFinishPack public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>finishPack event</haxe_doc>
		</onFinishPack>
		<onceFinishPack public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>finishPack event</haxe_doc>
		</onceFinishPack>
		<offFinishPack public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>finishPack event</haxe_doc>
		</offFinishPack>
		<listensFinishPack public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to finishPack event</haxe_doc>
		</listensFinishPack>
		<atlas public="1" set="null" expr="null" line="16">
			<c path="ceramic.TextureAtlas"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</atlas>
		<spacing public="1" expr="1" line="18">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</spacing>
		<filter public="1" expr="LINEAR" line="20">
			<e path="ceramic.TextureFilter"/>
			<meta><m n=":value"><e>LINEAR</e></m></meta>
		</filter>
		<pendingRegions expr="[]" line="22">
			<c path="Array"><c path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pendingRegions>
		<pages expr="[]" line="24">
			<c path="Array"><c path="ceramic._TextureAtlasPacker.TextureAtlasPackerPage"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pages>
		<hasPendingRegions public="1" set="method" line="32"><f a=""><x path="Bool"/></f></hasPendingRegions>
		<region public="1" set="method" line="38"><f a="name">
	<c path="String"/>
	<c path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion"/>
</f></region>
		<removeRegionsWithMatcher public="1" set="method" line="65">
			<f a="?removeAtlasRegions:matcher" v="true:">
				<x path="Bool"/>
				<f a="regionName">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ removeAtlasRegions : true }</e></m></meta>
		</removeRegionsWithMatcher>
		<removeRegionsWithPrefix public="1" set="method" line="143">
			<f a="?removeAtlasRegions:prefix" v="true:">
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ removeAtlasRegions : true }</e></m></meta>
		</removeRegionsWithPrefix>
		<destroy public="1" set="method" line="149" override="1"><f a=""><x path="Void"/></f></destroy>
		<add public="1" get="inline" set="null" line="191">
			<f a="name:pixels:originalWidth:originalHeight:packedWidth:?packedHeight:?offsetX:?offsetY" v=":::::-1:0:0">
				<c path="String"/>
				<t path="ceramic.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offsetY : 0, offsetX : 0, packedHeight : -1 }</e></m></meta>
			<haxe_doc><![CDATA[* Add a region to this atlas packer from the given pixels.
     * Example usage:
     *
     * ```haxe
     * atlas.add(region1, pixels1);
     * atlas.add(region2, pixels2);
     * atlas.pack(() -> {
     *     // Done packing new regions
     * });
     * ```]]></haxe_doc>
			<overloads><add public="1" get="inline" set="null" line="233">
	<f a="variantName:sourceName:originalWidth:originalHeight:?offsetX:?offsetY" v="::::0:0">
		<c path="String"/>
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{ offsetY : 0, offsetX : 0 }</e></m></meta>
	<haxe_doc>* Add a region to this atlas packer that is a variant of
     * another existing region: it has the same packed size in pixels
     * but can have different offsets and original size.</haxe_doc>
</add></overloads>
		</add>
		<_addRegionFromPixels set="method" line="205"><f a="name:pixels:originalWidth:originalHeight:packedWidth:packedHeight:offsetX:offsetY">
	<c path="String"/>
	<t path="ceramic.UInt8Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_addRegionFromPixels>
		<_addVariantRegion set="method" line="245"><f a="variantName:sourceName:originalWidth:originalHeight:offsetX:offsetY">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_addVariantRegion>
		<pack public="1" set="method" line="268">
			<f a="done">
				<f a="atlas">
					<c path="ceramic.TextureAtlas"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pack new regions added with `add()` to the texture atlas.
     * If no texture atlas exists yet, it will be created.</haxe_doc>
		</pack>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasPacker.hx" private="1" module="ceramic.TextureAtlasPacker">
		<name public="1">
			<c path="String"/>
			<haxe_doc>* Region name</haxe_doc>
		</name>
		<originalWidth public="1" expr="0" line="540">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Original region width (including margins / transparent pixels)</haxe_doc>
		</originalWidth>
		<originalHeight public="1" expr="0" line="545">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Original region height (including margins / transparent pixels)</haxe_doc>
		</originalHeight>
		<packedWidth public="1">
			<x path="Int"/>
			<haxe_doc>* Packed region width (without margins / transparent pixels)</haxe_doc>
		</packedWidth>
		<packedHeight public="1">
			<x path="Int"/>
			<haxe_doc>* Packed region height (without margins / transparent pixels)</haxe_doc>
		</packedHeight>
		<offsetX public="1" expr="0" line="560">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* X offset to position the region to its original size</haxe_doc>
		</offsetX>
		<offsetY public="1" expr="0" line="565">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Y offset to position the region to its original size</haxe_doc>
		</offsetY>
		<pixels public="1" expr="null" line="570">
			<t path="ceramic.UInt8Array"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If the region comes from a pixels buffer, this is the buffer</haxe_doc>
		</pixels>
		<sourceRegion public="1" expr="null" line="576">
			<c path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* If the region is a variant of another region,
     * this is the other region used as source</haxe_doc>
		</sourceRegion>
		<rect public="1" expr="null" line="581">
			<c path="binpacking.Rect"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The rect describing how this region should be packed</haxe_doc>
		</rect>
		<rendered public="1" expr="false" line="586">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this region has been rendered to a page texture or not</haxe_doc>
		</rendered>
		<new public="1" set="method" line="530">
			<f a="name:originalWidth:originalHeight:packedWidth:packedHeight:offsetX:offsetY:pixels:sourceRegion:rect:rendered">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><x path="Int"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><t path="ceramic.UInt8Array"/></x>
				<x path="Null"><c path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion"/></x>
				<x path="Null"><c path="binpacking.Rect"/></x>
				<x path="Null"><x path="Bool"/></x>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc>@param rendered * Whether this region has been rendered to a page texture or not
@param rect * The rect describing how this region should be packed
@param sourceRegion * If the region is a variant of another region,
     * this is the other region used as source
@param pixels * If the region comes from a pixels buffer, this is the buffer
@param offsetY * Y offset to position the region to its original size
@param offsetX * X offset to position the region to its original size
@param packedHeight * Packed region height (without margins / transparent pixels)
@param packedWidth * Packed region width (without margins / transparent pixels)
@param originalHeight * Original region height (including margins / transparent pixels)
@param originalWidth * Original region width (including margins / transparent pixels)
@param name * Region name</haxe_doc>
		</new>
		<haxe_doc>* A region for a texture atlas packer. Not to be confused
 * with `TextureAtlasRegion` which is to be used with `TextureAtlas`,
 * while `TextureAtlasPackerRegion` is holding information to
 * pack a region with `TextureAtlasPacker` and is not a region
 * usable with an atlas yet.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
			<m n=":allow"><e>ceramic.TextureAtlasPacker</e></m>
			<m n=":allow"><e>ceramic.TextureAtlasPackerPage</e></m>
		</meta>
	</class>
	<class path="ceramic._TextureAtlasPacker.TextureAtlasPackerPage" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasPacker.hx" private="1" module="ceramic.TextureAtlasPacker">
		<spacing public="1"><x path="Int"/></spacing>
		<name public="1"><c path="String"/></name>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<regions public="1"><c path="Array"><c path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion"/></c></regions>
		<binPacker public="1"><c path="binpacking.MaxRectsPacker"/></binPacker>
		<shouldResetTexture public="1"><x path="Bool"/></shouldResetTexture>
		<new public="1" set="method" line="593">
			<f a="spacing:name:width:height:regions:binPacker:shouldResetTexture">
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="ceramic._TextureAtlasPacker.TextureAtlasPackerRegion"/></c>
				<c path="binpacking.MaxRectsPacker"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
			<m n=":allow"><e>ceramic.TextureAtlasPacker</e></m>
			<m n=":allow"><e>ceramic.TextureAtlasPackerRegion</e></m>
		</meta>
	</class>
	<class path="ceramic.TextureAtlasPage" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasPage.hx">
		<implements path="tracker.Observable"/>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="ceramic.TextureAtlasPage"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="ceramic.TextureAtlasPage"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.TextureAtlasPage"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="ceramic.TextureAtlasPage"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="ceramic.TextureAtlasPage"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false" line="131">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<invalidateName public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateName>
		<name public="1">
			<c path="String"/>
			<meta><m n="observe"/></meta>
		</name>
		<unobservedName>
			<c path="String"/>
			<haxe_doc></haxe_doc>
		</unobservedName>
		<_dox_event_nameChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when name field changes.</haxe_doc>
		</_dox_event_nameChange>
		<emitNameChange set="method" line="1095">
			<f a="current:previous">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when name field changes.</haxe_doc>
		</emitNameChange>
		<onNameChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when name field changes.</haxe_doc>
		</onNameChange>
		<onceNameChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when name field changes.</haxe_doc>
		</onceNameChange>
		<offNameChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="String"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when name field changes.</haxe_doc>
		</offNameChange>
		<listensNameChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when name field changes.</haxe_doc>
		</listensNameChange>
		<invalidateWidth public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateWidth>
		<width public="1" expr="0" line="9">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
		</width>
		<unobservedWidth>
			<x path="Float"/>
			<haxe_doc></haxe_doc>
		</unobservedWidth>
		<_dox_event_widthChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when width field changes.</haxe_doc>
		</_dox_event_widthChange>
		<emitWidthChange set="method" line="1095">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when width field changes.</haxe_doc>
		</emitWidthChange>
		<onWidthChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when width field changes.</haxe_doc>
		</onWidthChange>
		<onceWidthChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when width field changes.</haxe_doc>
		</onceWidthChange>
		<offWidthChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when width field changes.</haxe_doc>
		</offWidthChange>
		<listensWidthChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when width field changes.</haxe_doc>
		</listensWidthChange>
		<invalidateHeight public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateHeight>
		<height public="1" expr="0" line="11">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n="observe"/>
			</meta>
		</height>
		<unobservedHeight>
			<x path="Float"/>
			<haxe_doc></haxe_doc>
		</unobservedHeight>
		<_dox_event_heightChange public="1" set="method" line="637">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when height field changes.</haxe_doc>
		</_dox_event_heightChange>
		<emitHeightChange set="method" line="1095">
			<f a="current:previous">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when height field changes.</haxe_doc>
		</emitHeightChange>
		<onHeightChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when height field changes.</haxe_doc>
		</onHeightChange>
		<onceHeightChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when height field changes.</haxe_doc>
		</onceHeightChange>
		<offHeightChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when height field changes.</haxe_doc>
		</offHeightChange>
		<listensHeightChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when height field changes.</haxe_doc>
		</listensHeightChange>
		<invalidateFilter public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateFilter>
		<filter public="1" set="accessor" expr="LINEAR" line="13">
			<e path="ceramic.TextureFilter"/>
			<meta>
				<m n=":value"><e>LINEAR</e></m>
				<m n="observe"/>
			</meta>
		</filter>
		<unobservedFilter>
			<e path="ceramic.TextureFilter"/>
			<haxe_doc></haxe_doc>
		</unobservedFilter>
		<_dox_event_filterChange public="1" set="method" line="637">
			<f a="current:previous">
				<e path="ceramic.TextureFilter"/>
				<e path="ceramic.TextureFilter"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when filter field changes.</haxe_doc>
		</_dox_event_filterChange>
		<emitFilterChange set="method" line="1095">
			<f a="current:previous">
				<e path="ceramic.TextureFilter"/>
				<e path="ceramic.TextureFilter"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when filter field changes.</haxe_doc>
		</emitFilterChange>
		<onFilterChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.TextureFilter"/>
					<e path="ceramic.TextureFilter"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when filter field changes.</haxe_doc>
		</onFilterChange>
		<onceFilterChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<e path="ceramic.TextureFilter"/>
					<e path="ceramic.TextureFilter"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when filter field changes.</haxe_doc>
		</onceFilterChange>
		<offFilterChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<e path="ceramic.TextureFilter"/>
					<e path="ceramic.TextureFilter"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when filter field changes.</haxe_doc>
		</offFilterChange>
		<listensFilterChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when filter field changes.</haxe_doc>
		</listensFilterChange>
		<set_filter set="method" line="14"><f a="filter">
	<e path="ceramic.TextureFilter"/>
	<e path="ceramic.TextureFilter"/>
</f></set_filter>
		<invalidateTexture public="1" set="method" line="726">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</invalidateTexture>
		<texture public="1" set="accessor" expr="null" line="24">
			<c path="ceramic.Texture"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n="observe"/>
			</meta>
		</texture>
		<unobservedTexture>
			<c path="ceramic.Texture"/>
			<haxe_doc></haxe_doc>
		</unobservedTexture>
		<_dox_event_textureChange public="1" set="method" line="637">
			<f a="current:previous">
				<c path="ceramic.Texture"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</_dox_event_textureChange>
		<emitTextureChange set="method" line="1095">
			<f a="current:previous">
				<c path="ceramic.Texture"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</emitTextureChange>
		<onTextureChange public="1" set="method" line="1199">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</onTextureChange>
		<onceTextureChange public="1" set="method" line="1298">
			<f a="owner:handleCurrentPrevious">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="current:previous">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</onceTextureChange>
		<offTextureChange public="1" set="method" line="1368">
			<f a="?handleCurrentPrevious">
				<f a="current:previous">
					<c path="ceramic.Texture"/>
					<c path="ceramic.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</offTextureChange>
		<listensTextureChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when texture field changes.</haxe_doc>
		</listensTextureChange>
		<set_texture set="method" line="26"><f a="texture">
	<c path="ceramic.Texture"/>
	<c path="ceramic.Texture"/>
</f></set_texture>
		<unbindEvents public="1" set="method" line="1427">
			<f a=""><x path="Void"/></f>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="39">
			<f a="name:?width:?height:?filter:?texture" v=":0:0:LINEAR:null">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="ceramic.TextureFilter"/>
				<c path="ceramic.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ texture : null, filter : LINEAR, height : 0, width : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.TextureAtlasParser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasParser.hx">
		<parse public="1" set="method" line="7" static="1"><f a="rawTextureAtlas">
	<c path="String"/>
	<c path="ceramic.TextureAtlas"/>
</f></parse>
		<convertXmlTextureAtlas set="method" line="158" static="1"><f a="rawTextureAtlas">
	<c path="String"/>
	<c path="String"/>
</f></convertXmlTextureAtlas>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic._TextureAtlasParser.TextureAtlasReader" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasParser.hx" private="1" module="ceramic.TextureAtlasParser">
		<lines><c path="Array"><c path="String"/></c></lines>
		<index><x path="Int"/></index>
		<trim public="1" set="method" line="229"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></trim>
		<readLine public="1" set="method" line="234"><f a=""><c path="String"/></f></readLine>
		<nextLineKey public="1" set="method" line="242"><f a=""><c path="String"/></f></nextLineKey>
		<readValue public="1" set="method" line="261"><f a=""><c path="String"/></f></readValue>
		<readTuple public="1" set="method" line="273">
			<f a="tuple">
				<c path="Array"><d/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of tuple values read (1, 2 or 4).</haxe_doc>
		</readTuple>
		<new public="1" set="method" line="223"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.TextureAtlasParser</e></m>
		</meta>
	</class>
	<class path="ceramic.TextureTile" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureTile.hx">
		<texture public="1"><c path="ceramic.Texture"/></texture>
		<frameX public="1"><x path="Float"/></frameX>
		<frameY public="1"><x path="Float"/></frameY>
		<frameWidth public="1"><x path="Float"/></frameWidth>
		<frameHeight public="1"><x path="Float"/></frameHeight>
		<rotateFrame public="1"><x path="Bool"/></rotateFrame>
		<edgeInset public="1">
			<x path="Float"/>
			<haxe_doc>* When assigning the file to a quad, edge uvs will be adjusted by this inset.
     * Can be useful to set it to values like `0.5` in some situations like
     * preventing atlas regions from displaying bleed from siblings.</haxe_doc>
		</edgeInset>
		<frame public="1" get="inline" set="null" line="37"><f a="frameX:frameY:frameWidth:frameHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></frame>
		<toString set="method" line="46"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="25">
			<f a="texture:frameX:frameY:frameWidth:frameHeight:?rotateFrame:?edgeInset" v=":::::false:0">
				<c path="ceramic.Texture"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ edgeInset : 0, rotateFrame : false }</e></m></meta>
		</new>
		<meta>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.TextureAtlasRegion" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureAtlasRegion.hx">
		<extends path="ceramic.TextureTile"/>
		<name public="1" expr="null" line="12">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</name>
		<atlas public="1" expr="null" line="14">
			<c path="ceramic.TextureAtlas"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</atlas>
		<page public="1" expr="0" line="16">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</page>
		<packedWidth public="1" expr="0" line="21">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Width in actual pixels after rotation (if any)</haxe_doc>
		</packedWidth>
		<packedHeight public="1" expr="0" line="26">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Height in actual pixels after rotation (if any)</haxe_doc>
		</packedHeight>
		<x public="1" expr="0" line="28">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0" line="30">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<width public="1" expr="0" line="32">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</width>
		<height public="1" expr="0" line="34">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</height>
		<offsetX public="1" expr="0" line="36">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetX>
		<offsetY public="1" expr="0" line="38">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetY>
		<originalWidth public="1" expr="0" line="43">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Original width, white margins included</haxe_doc>
		</originalWidth>
		<originalHeight public="1" expr="0" line="48">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Original height, white margins included</haxe_doc>
		</originalHeight>
		<computeFrame public="1" set="method" line="68"><f a=""><x path="Void"/></f></computeFrame>
		<toString set="method" line="94" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="50"><f a="name:atlas:page">
	<c path="String"/>
	<c path="ceramic.TextureAtlas"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A texture atlas region is part of a texture atlas.
 * It is also a `TextureTile` subclass so that it can be assigned
 * to `Quad`'s `tile` property.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<enum path="ceramic.TextureFilter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureFilter.hx">
		<LINEAR/>
		<NEAREST/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.TextureTilePacker" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureTilePacker.hx">
		<extends path="ceramic.Entity"/>
		<texture public="1" set="null"><c path="ceramic.RenderTexture"/></texture>
		<padWidth public="1" set="null"><x path="Int"/></padWidth>
		<padHeight public="1" set="null"><x path="Int"/></padHeight>
		<margin public="1" set="null"><x path="Int"/></margin>
		<nextPacker public="1" expr="null" line="18">
			<c path="ceramic.TextureTilePacker"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</nextPacker>
		<areas><c path="Array"><c path="ceramic.TextureTile"/></c></areas>
		<numCols expr="0" line="22">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numCols>
		<numRows expr="0" line="24">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numRows>
		<maxPixelTextureWidth expr="0" line="26">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</maxPixelTextureWidth>
		<maxPixelTextureHeight expr="0" line="28">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</maxPixelTextureHeight>
		<destroy public="1" set="method" line="81" override="1"><f a=""><x path="Void"/></f></destroy>
		<getTileAtPosition get="inline" set="null" line="97"><f a="col:row">
	<x path="Int"/>
	<x path="Int"/>
	<c path="ceramic.TextureTile"/>
</f></getTileAtPosition>
		<setTileAtPosition get="inline" set="null" line="103"><f a="col:row:tile">
	<x path="Int"/>
	<x path="Int"/>
	<c path="ceramic.TextureTile"/>
	<x path="Void"/>
</f></setTileAtPosition>
		<allocTile public="1" set="method" line="111"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<c path="ceramic.TextureTile"/>
</f></allocTile>
		<releaseTile public="1" set="method" line="196"><f a="tile">
	<c path="ceramic.TextureTile"/>
	<x path="Void"/>
</f></releaseTile>
		<stamp public="1" set="method" line="241"><f a="tile:visual:done">
	<c path="ceramic.TextureTile"/>
	<c path="ceramic.Visual"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></stamp>
		<managesTexture public="1" set="method" line="283"><f a="texture">
	<c path="ceramic.Texture"/>
	<x path="Bool"/>
</f></managesTexture>
		<new public="1" set="method" line="30">
			<f a="autoRender:?maxPixelTextureWidth:?maxPixelTextureHeight:?padWidth:?padHeight:?margin" v=":-1:-1:16:16:1">
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ margin : 1, padHeight : 16, padWidth : 16, maxPixelTextureHeight : -1, maxPixelTextureWidth : -1 }</e></m></meta>
		</new>
		<haxe_doc>* Incremental texture tile packer that allows to alloc, release and reuse tiles as needed.</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic._TextureTilePacker.PackedTextureTile" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureTilePacker.hx" private="1" module="ceramic.TextureTilePacker">
		<extends path="ceramic.TextureTile"/>
		<col public="1" expr="-1" line="300">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The column index of this tile</haxe_doc>
		</col>
		<row public="1" expr="-1" line="305">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The row index of this tile</haxe_doc>
		</row>
		<usedCols public="1" expr="1" line="310">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* The number of column blocks used by this packed texture tile (starting from column index)</haxe_doc>
		</usedCols>
		<usedRows public="1" expr="1" line="315">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* The number of row blocks used by this packed texture tile (starting from row index)</haxe_doc>
		</usedRows>
		<new public="1" set="method" line="317"><f a="texture:frameX:frameY:frameWidth:frameHeight">
	<c path="ceramic.Texture"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Private class used internally to store additional texture tile data.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.TextureTilePacker</e></m>
		</meta>
	</class>
	<abstract path="ceramic.TextureWrap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureWrap.hx">
		<this><x path="Int"/></this>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="ceramic._TextureWrap.TextureWrap_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureWrap.hx" private="1" module="ceramic.TextureWrap" extern="1" final="1">
	<CLAMP public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="ceramic.TextureWrap"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CLAMP>
	<REPEAT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="ceramic.TextureWrap"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</REPEAT>
	<MIRROR public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="ceramic.TextureWrap"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MIRROR>
	<meta>
		<m n=":hxGen"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._TextureWrap.TextureWrap_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TextureWrap.hx" private="1" module="ceramic.TextureWrap" extern="1" final="1">
		<CLAMP public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="ceramic.TextureWrap"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CLAMP>
		<REPEAT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="ceramic.TextureWrap"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</REPEAT>
		<MIRROR public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="ceramic.TextureWrap"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MIRROR>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="ceramic.Timeline" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Timeline.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<_dox_event_startLabel public="1" set="method" line="637">
			<f a="index:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Triggered when position reaches an existing label
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</_dox_event_startLabel>
		<emitStartLabel set="method" line="1095">
			<f a="index:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Triggered when position reaches an existing label
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</emitStartLabel>
		<onStartLabel public="1" set="method" line="1199">
			<f a="owner:handleIndexName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="index:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches an existing label
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</onStartLabel>
		<onceStartLabel public="1" set="method" line="1298">
			<f a="owner:handleIndexName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="index:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches an existing label
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</onceStartLabel>
		<offStartLabel public="1" set="method" line="1368">
			<f a="?handleIndexName">
				<f a="index:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches an existing label
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</offStartLabel>
		<listensStartLabel public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches an existing label
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</listensStartLabel>
		<_dox_event_endLabel public="1" set="method" line="637">
			<f a="index:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Triggered when position reaches the end of an area following the given label.
     * Either when a new label was reached or when end of timeline was reached
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</_dox_event_endLabel>
		<emitEndLabel set="method" line="1095">
			<f a="index:name">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Triggered when position reaches the end of an area following the given label.
     * Either when a new label was reached or when end of timeline was reached
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</emitEndLabel>
		<onEndLabel public="1" set="method" line="1199">
			<f a="owner:handleIndexName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="index:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches the end of an area following the given label.
     * Either when a new label was reached or when end of timeline was reached
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</onEndLabel>
		<onceEndLabel public="1" set="method" line="1298">
			<f a="owner:handleIndexName">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="index:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches the end of an area following the given label.
     * Either when a new label was reached or when end of timeline was reached
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</onceEndLabel>
		<offEndLabel public="1" set="method" line="1368">
			<f a="?handleIndexName">
				<f a="index:name">
					<x path="Int"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches the end of an area following the given label.
     * Either when a new label was reached or when end of timeline was reached
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</offEndLabel>
		<listensEndLabel public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Triggered when position reaches the end of an area following the given label.
     * Either when a new label was reached or when end of timeline was reached
     * @param index label index (position)
     * @param name label name</haxe_doc>
		</listensEndLabel>
		<size public="1" expr="0" line="30">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Timeline size. Default `0`, meaning this timeline won't do anything.
     * By default, because `autoFitSize` is `true`, adding or updating tracks on this
     * timeline will update timeline `size` accordingly so it may not be needed to update `size` explicitly.
     * Setting `size` to `-1` means the timeline will never finish.</haxe_doc>
		</size>
		<autoFitSize public="1" expr="true" line="36">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If set to `true` (default), adding or updating tracks on this timeline will update
     * timeline size accordingly to match longest track size.</haxe_doc>
		</autoFitSize>
		<loop public="1" expr="true" line="41">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether this timeline should loop. Ignored if timeline's `size` is `-1` (not defined).</haxe_doc>
		</loop>
		<autoUpdate public="1" set="accessor" expr="true" line="46">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether this timeline should bind itself to update cycle automatically or not (default `true`).</haxe_doc>
		</autoUpdate>
		<set_autoUpdate set="method" line="47"><f a="autoUpdate">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoUpdate>
		<fps public="1" expr="30" line="60">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
			<haxe_doc>* Frames per second on this timeline.
     * Note: a lower fps doesn't mean animations won't be interpolated between frames.
     * Thus using 30 fps is still fine even if screen refreshes at 60 fps.</haxe_doc>
		</fps>
		<position public="1" set="null" expr="0" line="66">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Position on this timeline.
     * Gets back to zero when `loop=true` and position reaches a defined `size`.</haxe_doc>
		</position>
		<tracks public="1" set="null" expr="[]" line="71">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></x>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The tracks updated by this timeline</haxe_doc>
		</tracks>
		<paused public="1" set="accessor" expr="false" line="76">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this timeline is paused or not.</haxe_doc>
		</paused>
		<set_paused set="method" line="77"><f a="paused">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_paused>
		<labels public="1" set="null" expr="null" line="87">
			<x path="ceramic.ReadOnlyArray"><c path="String"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Used in pair with `labelIndexes` to manage timeline labels</haxe_doc>
		</labels>
		<labelIndexes expr="null" line="92">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Used in pair with `labels` to manage timeline labels</haxe_doc>
		</labelIndexes>
		<startPosition public="1" set="accessor" expr="-1" line="98">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc><![CDATA[* If >= 0, timeline will start from this index.
     * When timeline is looping, it will reset to this index as well at each iteration.]]></haxe_doc>
		</startPosition>
		<set_startPosition set="method" line="99"><f a="startPosition">
	<x path="Int"/>
	<x path="Int"/>
</f></set_startPosition>
		<endPosition public="1" set="accessor" expr="-1" line="111">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc><![CDATA[* If provided, timeline will stop at this index.
     * When timeline is looping, it will reset to startIndex (if >= 0).]]></haxe_doc>
		</endPosition>
		<set_endPosition set="method" line="112"><f a="endPosition">
	<x path="Int"/>
	<x path="Int"/>
</f></set_endPosition>
		<completeHandlers expr="null" line="123">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Internal array of complete handlers</haxe_doc>
		</completeHandlers>
		<completeHandlerIndexes expr="null" line="129">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Internal array of complete handler label indexes</haxe_doc>
		</completeHandlerIndexes>
		<bindAsComponent set="method" line="139"><f a=""><x path="Void"/></f></bindAsComponent>
		<bindOrUnbindUpdateIfNeeded get="inline" set="null" line="149">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function to bind or update to app
     * update event depending on current settings</haxe_doc>
		</bindOrUnbindUpdateIfNeeded>
		<update public="1" set="method" line="159"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<seek final="1" public="1" set="method" line="169">
			<f a="targetPosition">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Seek the given position (in frames) in the timeline.
     * Will take care of clamping `position` or looping it depending on `size` and `loop` properties.</haxe_doc>
		</seek>
		<animate public="1" set="method" line="183">
			<f a="name:complete">
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Animate starting from the given label name and calls complete when
     * reaching the end of label area (= when animation finishes).
     * If animation is interrupted (by playing another animation, seeking another position...),
     * complete won't be called.
     * @param name Label name
     * @param complete callback fired when animation finishes.</haxe_doc>
		</animate>
		<seekLabel public="1" set="method" line="210">
			<f a="name">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Seek position to match the given label
     * @param name Label name
     * @return The index (position) of the looping label, or -1 if no label was found</haxe_doc>
		</seekLabel>
		<resetStartAndEndPositions public="1" set="method" line="228">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Reset `startPosition` and `endPosition`</haxe_doc>
		</resetStartAndEndPositions>
		<loopLabel public="1" set="method" line="242">
			<f a="name">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Seek position to match the given label and set startPosition and endPosition
     * so that it will loop through the whole area following this label, up to the
     * position of the next label or the end of the timeline.
     * @param name Label name
     * @return The index (position) of the looping label, or -1 if no label was found</haxe_doc>
		</loopLabel>
		<apply final="1" public="1" set="method" line="268">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
			<haxe_doc>* Apply (or re-apply) every track of this timeline at the current position</haxe_doc>
		</apply>
		<inlineSeek get="inline" set="null" line="274">
			<f a="targetPosition:?forceSeek:?forceChange" v=":false:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false, forceSeek : false }</e></m></meta>
		</inlineSeek>
		<clearCompleteHandlers get="inline" set="null" line="342"><f a=""><x path="Void"/></f></clearCompleteHandlers>
		<didEmitEndLabel set="method" line="352"><f a="index:name">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></didEmitEndLabel>
		<add public="1" set="method" line="398">
			<f a="track">
				<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a track to this timeline</haxe_doc>
		</add>
		<get public="1" set="method" line="414"><f a="trackId">
	<c path="String"/>
	<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
</f></get>
		<remove public="1" set="method" line="430">
			<f a="track">
				<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a track from this timeline</haxe_doc>
		</remove>
		<fitSize public="1" set="method" line="447">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update `size` property to make it fit
     * the size of the longuest track.</haxe_doc>
		</fitSize>
		<indexOfLabelBeforeIndex public="1" set="method" line="462"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></indexOfLabelBeforeIndex>
		<labelAtIndex public="1" set="method" line="487"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></labelAtIndex>
		<indexOfLabel public="1" set="method" line="508"><f a="name">
	<c path="String"/>
	<x path="Int"/>
</f></indexOfLabel>
		<setLabel public="1" set="method" line="523"><f a="index:name">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></setLabel>
		<removeLabelAtIndex public="1" set="method" line="539"><f a="index">
	<x path="Int"/>
	<x path="Bool"/>
</f></removeLabelAtIndex>
		<removeLabel public="1" set="method" line="556"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></removeLabel>
		<sortLabels set="method" line="573"><f a=""><x path="Void"/></f></sortLabels>
		<compareLabelIndexes set="method" line="582"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></compareLabelIndexes>
		<compareLabelNames set="method" line="593"><f a="nameA:nameB">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
</f></compareLabelNames>
		<entity public="1">
			<c path="ceramic.Entity"/>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</entity>
		<setEntity set="method" line="7">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="7">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="131"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.TimelineKeyframe" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineKeyframe.hx">
		<index public="1"><x path="Int"/></index>
		<easing public="1" expr="NONE" line="8">
			<e path="ceramic.Easing"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
		</easing>
		<new public="1" set="method" line="10"><f a="index:easing">
	<x path="Int"/>
	<e path="ceramic.Easing"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.TimelineBoolKeyframe" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineBoolKeyframe.hx">
		<extends path="ceramic.TimelineKeyframe"/>
		<value public="1"><x path="Bool"/></value>
		<new public="1" set="method" line="8"><f a="value:index:easing">
	<x path="Bool"/>
	<x path="Int"/>
	<e path="ceramic.Easing"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.TimelineTrack" params="K" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineTrack.hx">
		<extends path="ceramic.Entity"/>
		<size public="1" expr="0" line="20">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Track size. Default `0`, meaning this track won't do anything.
     * By default, because `autoFitSize` is `true`, adding new keyframes to this
     * track will update `size` accordingly so it may not be needed to update `size` explicitly.
     * Setting `size` to `-1` means the track will never finish.</haxe_doc>
		</size>
		<autoFitSize public="1" expr="true" line="26">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If set to `true` (default), adding keyframes to this track will update
     * its size accordingly to match last keyframe time.</haxe_doc>
		</autoFitSize>
		<loop public="1" expr="false" line="31">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this track should loop. Ignored if track's `size` is `-1` (not defined).</haxe_doc>
		</loop>
		<locked public="1" expr="false" line="37">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this track is locked or not.
     * A locked track doesn't get updated by the timeline it is attached to, if any.</haxe_doc>
		</locked>
		<timeline public="1" set="null" expr="null" line="43">
			<c path="ceramic.Timeline"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":allow"><e>ceramic.Timeline</e></m>
			</meta>
			<haxe_doc>* Timeline on which this track is added to</haxe_doc>
		</timeline>
		<position public="1" set="null" expr="0" line="49">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Position on this track.
     * Gets back to zero when `loop=true` and position reaches a defined `size`.</haxe_doc>
		</position>
		<keyframes public="1" set="null" expr="[]" line="54">
			<x path="ceramic.ReadOnlyArray"><c path="ceramic.TimelineTrack.K"/></x>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The key frames on this track.</haxe_doc>
		</keyframes>
		<before public="1" set="null" expr="null" line="59">
			<c path="ceramic.TimelineTrack.K"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The keyframe right before or equal to current time, if any.</haxe_doc>
		</before>
		<after public="1" set="null" expr="null" line="64">
			<c path="ceramic.TimelineTrack.K"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The keyframe right after current time, if any.</haxe_doc>
		</after>
		<keyframeBeforeIndex expr="-1" line="69">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The index of the last resolved `key index before`. Used internally.</haxe_doc>
		</keyframeBeforeIndex>
		<keyframeAfterIndex expr="-1" line="74">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The index of the last resolved `key index after`. Used internally.</haxe_doc>
		</keyframeAfterIndex>
		<destroy public="1" set="method" line="82" override="1"><f a=""><x path="Void"/></f></destroy>
		<seek final="1" public="1" set="method" line="96">
			<f a="targetPosition">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Seek the given position (in frames) in the track.
     * Will take care of clamping `position` or looping it depending on `size` and `loop` properties.</haxe_doc>
		</seek>
		<inlineSeek get="inline" set="null" line="103">
			<f a="targetPosition:?forceSeek:?forceChange" v=":false:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ forceChange : false, forceSeek : false }</e></m>
				<m n=":allow"><e>ceramic.Timeline</e></m>
			</meta>
		</inlineSeek>
		<add public="1" set="method" line="144">
			<f a="keyframe">
				<c path="ceramic.TimelineTrack.K"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a keyframe to this track</haxe_doc>
		</add>
		<remove public="1" set="method" line="192">
			<f a="keyframe">
				<c path="ceramic.TimelineTrack.K"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a keyframe from this track</haxe_doc>
		</remove>
		<fitSize public="1" set="method" line="225">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update `size` property to make it fit
     * the index of the last keyframe on this track.</haxe_doc>
		</fitSize>
		<apply public="1" set="method" line="239">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
			<haxe_doc>* Apply changes that this track is responsible of. Usually called after `update(delta)` or `seek(time)`.</haxe_doc>
		</apply>
		<findKeyframeAtIndex public="1" set="method" line="245"><f a="index">
	<x path="Int"/>
	<x path="Null"><c path="ceramic.TimelineTrack.K"/></x>
</f></findKeyframeAtIndex>
		<findKeyframeBefore public="1" set="method" line="258">
			<f a="position">
				<x path="Float"/>
				<x path="Null"><c path="ceramic.TimelineTrack.K"/></x>
			</f>
			<haxe_doc>* Find the keyframe right before or equal to given `position`</haxe_doc>
		</findKeyframeBefore>
		<findKeyframeAfter public="1" set="method" line="283">
			<f a="position">
				<x path="Float"/>
				<x path="Null"><c path="ceramic.TimelineTrack.K"/></x>
			</f>
			<haxe_doc>* Find the keyframe right after given `position`</haxe_doc>
		</findKeyframeAfter>
		<computeKeyframeBefore get="inline" set="null" line="308">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal. Compute `before` keyframe, if any matching.</haxe_doc>
		</computeKeyframeBefore>
		<computeKeyframeAfter get="inline" set="null" line="358">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal. Compute `after` keyframe, if any matching.</haxe_doc>
		</computeKeyframeAfter>
		<new public="1" set="method" line="76"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A track meant to be updated by a timeline.
 * Base implementation doesn't do much by itself.
 * Create subclasses to implement details</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.TimelineBoolTrack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineBoolTrack.hx">
		<extends path="ceramic.TimelineTrack"><c path="ceramic.TimelineBoolKeyframe"/></extends>
		<_dox_event_change public="1" set="method" line="637">
			<f a="track">
				<c path="ceramic.TimelineBoolTrack"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_change>
		<emitChange set="method" line="1095">
			<f a="track">
				<c path="ceramic.TimelineBoolTrack"/>
				<x path="Void"/>
			</f>
			<haxe_doc>change event</haxe_doc>
		</emitChange>
		<onChange public="1" set="method" line="1199">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineBoolTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onChange>
		<onceChange public="1" set="method" line="1298">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineBoolTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onceChange>
		<offChange public="1" set="method" line="1368">
			<f a="?handleTrack">
				<f a="track">
					<c path="ceramic.TimelineBoolTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</offChange>
		<listensChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to change event</haxe_doc>
		</listensChange>
		<value public="1" expr="false" line="7">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</value>
		<apply public="1" set="method" line="9" override="1">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
		</apply>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<class path="ceramic.TimelineColorKeyframe" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineColorKeyframe.hx">
		<extends path="ceramic.TimelineKeyframe"/>
		<value public="1"><x path="ceramic.Color"/></value>
		<new public="1" set="method" line="8"><f a="value:index:easing">
	<x path="ceramic.Color"/>
	<x path="Int"/>
	<e path="ceramic.Easing"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.TimelineColorTrack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineColorTrack.hx">
		<extends path="ceramic.TimelineTrack"><c path="ceramic.TimelineColorKeyframe"/></extends>
		<_dox_event_change public="1" set="method" line="637">
			<f a="track">
				<c path="ceramic.TimelineColorTrack"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_change>
		<emitChange set="method" line="1095">
			<f a="track">
				<c path="ceramic.TimelineColorTrack"/>
				<x path="Void"/>
			</f>
			<haxe_doc>change event</haxe_doc>
		</emitChange>
		<onChange public="1" set="method" line="1199">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineColorTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onChange>
		<onceChange public="1" set="method" line="1298">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineColorTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onceChange>
		<offChange public="1" set="method" line="1368">
			<f a="?handleTrack">
				<f a="track">
					<c path="ceramic.TimelineColorTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</offChange>
		<listensChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to change event</haxe_doc>
		</listensChange>
		<value public="1" expr="Color.WHITE" line="7">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.WHITE</e></m></meta>
		</value>
		<apply public="1" set="method" line="9" override="1">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
		</apply>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<class path="ceramic.TimelineDegreesTrack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineDegreesTrack.hx">
		<extends path="ceramic.TimelineTrack"><c path="ceramic.TimelineFloatKeyframe"/></extends>
		<_dox_event_change public="1" set="method" line="637">
			<f a="track">
				<c path="ceramic.TimelineDegreesTrack"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_change>
		<emitChange set="method" line="1095">
			<f a="track">
				<c path="ceramic.TimelineDegreesTrack"/>
				<x path="Void"/>
			</f>
			<haxe_doc>change event</haxe_doc>
		</emitChange>
		<onChange public="1" set="method" line="1199">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineDegreesTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onChange>
		<onceChange public="1" set="method" line="1298">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineDegreesTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onceChange>
		<offChange public="1" set="method" line="1368">
			<f a="?handleTrack">
				<f a="track">
					<c path="ceramic.TimelineDegreesTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</offChange>
		<listensChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to change event</haxe_doc>
		</listensChange>
		<value public="1" expr="0.0" line="7">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</value>
		<apply public="1" set="method" line="9" override="1">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
		</apply>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<class path="ceramic.TimelineFloatArrayKeyframe" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineFloatArrayKeyframe.hx">
		<extends path="ceramic.TimelineKeyframe"/>
		<value public="1"><c path="Array"><x path="Float"/></c></value>
		<new public="1" set="method" line="8"><f a="value:index:easing">
	<c path="Array"><x path="Float"/></c>
	<x path="Int"/>
	<e path="ceramic.Easing"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.TimelineFloatArrayTrack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineFloatArrayTrack.hx">
		<extends path="ceramic.TimelineTrack"><c path="ceramic.TimelineFloatArrayKeyframe"/></extends>
		<_dox_event_change public="1" set="method" line="637">
			<f a="track">
				<c path="ceramic.TimelineFloatArrayTrack"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_change>
		<emitChange set="method" line="1095">
			<f a="track">
				<c path="ceramic.TimelineFloatArrayTrack"/>
				<x path="Void"/>
			</f>
			<haxe_doc>change event</haxe_doc>
		</emitChange>
		<onChange public="1" set="method" line="1199">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineFloatArrayTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onChange>
		<onceChange public="1" set="method" line="1298">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineFloatArrayTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onceChange>
		<offChange public="1" set="method" line="1368">
			<f a="?handleTrack">
				<f a="track">
					<c path="ceramic.TimelineFloatArrayTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</offChange>
		<listensChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to change event</haxe_doc>
		</listensChange>
		<value public="1" expr="[]" line="9">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</value>
		<apply public="1" set="method" line="11" override="1">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
		</apply>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<class path="ceramic.TimelineFloatKeyframe" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineFloatKeyframe.hx">
		<extends path="ceramic.TimelineKeyframe"/>
		<value public="1"><x path="Float"/></value>
		<new public="1" set="method" line="8"><f a="value:index:easing">
	<x path="Float"/>
	<x path="Int"/>
	<e path="ceramic.Easing"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="ceramic.TimelineFloatTrack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineFloatTrack.hx">
		<extends path="ceramic.TimelineTrack"><c path="ceramic.TimelineFloatKeyframe"/></extends>
		<_dox_event_change public="1" set="method" line="637">
			<f a="track">
				<c path="ceramic.TimelineFloatTrack"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_change>
		<emitChange set="method" line="1095">
			<f a="track">
				<c path="ceramic.TimelineFloatTrack"/>
				<x path="Void"/>
			</f>
			<haxe_doc>change event</haxe_doc>
		</emitChange>
		<onChange public="1" set="method" line="1199">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineFloatTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onChange>
		<onceChange public="1" set="method" line="1298">
			<f a="owner:handleTrack">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="track">
					<c path="ceramic.TimelineFloatTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</onceChange>
		<offChange public="1" set="method" line="1368">
			<f a="?handleTrack">
				<f a="track">
					<c path="ceramic.TimelineFloatTrack"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>change event</haxe_doc>
		</offChange>
		<listensChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to change event</haxe_doc>
		</listensChange>
		<value public="1" expr="0.0" line="7">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</value>
		<apply public="1" set="method" line="9" override="1">
			<f a="?forceChange" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceChange : false }</e></m></meta>
		</apply>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
		</meta>
	</class>
	<typedef path="ceramic.TimelineKeyframeData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineKeyframeData.hx">
		<a>
			<value><d/></value>
			<index><x path="Int"/></index>
			<easing><c path="String"/></easing>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="ceramic.TimelineTrackData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TimelineTrackData.hx">
		<a>
			<options>
				<x path="Null"><d><d/></d></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Track options</haxe_doc>
			</options>
			<loop>
				<x path="Bool"/>
				<haxe_doc>* Whether this track should loop or not</haxe_doc>
			</loop>
			<keyframes>
				<c path="Array"><t path="ceramic.TimelineKeyframeData"/></c>
				<haxe_doc>* Track keyframes. They should be sorted by frame index in ascending order</haxe_doc>
			</keyframes>
			<field>
				<c path="String"/>
				<haxe_doc>* Entity field name this track targets</haxe_doc>
			</field>
			<entity>
				<c path="String"/>
				<haxe_doc>* Entity id this track targets</haxe_doc>
			</entity>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="ceramic.Timelines" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Timelines.hx">
		<extends path="ceramic.Entity"/>
		<_dox_event_createTrack public="1" set="method" line="637">
			<f a="type:options:result">
				<c path="String"/>
				<d><d/></d>
				<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track creation
     * @param result The object that will hold the resulting track.</haxe_doc>
		</_dox_event_createTrack>
		<emitCreateTrack public="1" set="method" line="1095">
			<f a="type:options:result">
				<c path="String"/>
				<d><d/></d>
				<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to expand how timeline tracks are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track creation
     * @param result The object that will hold the resulting track.</haxe_doc>
		</emitCreateTrack>
		<onCreateTrack public="1" set="method" line="1199">
			<f a="owner:handleTypeOptionsResult">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="type:options:result">
					<c path="String"/>
					<d><d/></d>
					<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track creation
     * @param result The object that will hold the resulting track.</haxe_doc>
		</onCreateTrack>
		<onceCreateTrack public="1" set="method" line="1298">
			<f a="owner:handleTypeOptionsResult">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="type:options:result">
					<c path="String"/>
					<d><d/></d>
					<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track creation
     * @param result The object that will hold the resulting track.</haxe_doc>
		</onceCreateTrack>
		<offCreateTrack public="1" set="method" line="1368">
			<f a="?handleTypeOptionsResult">
				<f a="type:options:result">
					<c path="String"/>
					<d><d/></d>
					<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track creation
     * @param result The object that will hold the resulting track.</haxe_doc>
		</offCreateTrack>
		<listensCreateTrack public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track creation
     * @param result The object that will hold the resulting track.</haxe_doc>
		</listensCreateTrack>
		<_dox_event_bindTrack public="1" set="method" line="637">
			<f a="type:options:track:entity:field">
				<c path="String"/>
				<d><d/></d>
				<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
				<c path="ceramic.Entity"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are bound to objects.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track binding
     * @param track The track on which we bind the entity
     * @param entity The entity to bind to this track
     * @param field The entity field that should be updated by this track</haxe_doc>
		</_dox_event_bindTrack>
		<emitBindTrack public="1" set="method" line="1095">
			<f a="type:options:track:entity:field">
				<c path="String"/>
				<d><d/></d>
				<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
				<c path="ceramic.Entity"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to expand how timeline tracks are bound to objects.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track binding
     * @param track The track on which we bind the entity
     * @param entity The entity to bind to this track
     * @param field The entity field that should be updated by this track</haxe_doc>
		</emitBindTrack>
		<onBindTrack public="1" set="method" line="1199">
			<f a="owner:handleTypeOptionsTrackEntityField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="type:options:track:entity:field">
					<c path="String"/>
					<d><d/></d>
					<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
					<c path="ceramic.Entity"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are bound to objects.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track binding
     * @param track The track on which we bind the entity
     * @param entity The entity to bind to this track
     * @param field The entity field that should be updated by this track</haxe_doc>
		</onBindTrack>
		<onceBindTrack public="1" set="method" line="1298">
			<f a="owner:handleTypeOptionsTrackEntityField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="type:options:track:entity:field">
					<c path="String"/>
					<d><d/></d>
					<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
					<c path="ceramic.Entity"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are bound to objects.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track binding
     * @param track The track on which we bind the entity
     * @param entity The entity to bind to this track
     * @param field The entity field that should be updated by this track</haxe_doc>
		</onceBindTrack>
		<offBindTrack public="1" set="method" line="1368">
			<f a="?handleTypeOptionsTrackEntityField">
				<f a="type:options:track:entity:field">
					<c path="String"/>
					<d><d/></d>
					<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
					<c path="ceramic.Entity"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are bound to objects.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track binding
     * @param track The track on which we bind the entity
     * @param entity The entity to bind to this track
     * @param field The entity field that should be updated by this track</haxe_doc>
		</offBindTrack>
		<listensBindTrack public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline tracks are bound to objects.
     * @param type Type of the field being modified by the track
     * @param options Can be used to configure timeline track binding
     * @param track The track on which we bind the entity
     * @param entity The entity to bind to this track
     * @param field The entity field that should be updated by this track</haxe_doc>
		</listensBindTrack>
		<_dox_event_createKeyframe public="1" set="method" line="637">
			<f a="type:options:value:index:easing:existing:result">
				<c path="String"/>
				<d><d/></d>
				<d/>
				<x path="Int"/>
				<e path="ceramic.Easing"/>
				<x path="Null"><c path="ceramic.TimelineKeyframe"/></x>
				<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>* Used to expand how timeline keyframes are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the keyframe
     * @param options Can be used to configure timeline keyframe creation
     * @param value Value of the keyframe
     * @param time Time (in seconds) of the keyframe
     * @param easing Easing of the keyframe
     * @param existing Existing keyframe instance at the same position/time. Can be reused to prevent new allocation of keyframe instance
     * @param result The object that will hold the resulting keyframe.</haxe_doc>
		</_dox_event_createKeyframe>
		<emitCreateKeyframe public="1" set="method" line="1095">
			<f a="type:options:value:index:easing:existing:result">
				<c path="String"/>
				<d><d/></d>
				<d/>
				<x path="Int"/>
				<e path="ceramic.Easing"/>
				<x path="Null"><c path="ceramic.TimelineKeyframe"/></x>
				<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to expand how timeline keyframes are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the keyframe
     * @param options Can be used to configure timeline keyframe creation
     * @param value Value of the keyframe
     * @param time Time (in seconds) of the keyframe
     * @param easing Easing of the keyframe
     * @param existing Existing keyframe instance at the same position/time. Can be reused to prevent new allocation of keyframe instance
     * @param result The object that will hold the resulting keyframe.</haxe_doc>
		</emitCreateKeyframe>
		<onCreateKeyframe public="1" set="method" line="1199">
			<f a="owner:handleTypeOptionsValueIndexEasingExistingResult">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="type:options:value:index:easing:existing:result">
					<c path="String"/>
					<d><d/></d>
					<d/>
					<x path="Int"/>
					<e path="ceramic.Easing"/>
					<x path="Null"><c path="ceramic.TimelineKeyframe"/></x>
					<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline keyframes are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the keyframe
     * @param options Can be used to configure timeline keyframe creation
     * @param value Value of the keyframe
     * @param time Time (in seconds) of the keyframe
     * @param easing Easing of the keyframe
     * @param existing Existing keyframe instance at the same position/time. Can be reused to prevent new allocation of keyframe instance
     * @param result The object that will hold the resulting keyframe.</haxe_doc>
		</onCreateKeyframe>
		<onceCreateKeyframe public="1" set="method" line="1298">
			<f a="owner:handleTypeOptionsValueIndexEasingExistingResult">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="type:options:value:index:easing:existing:result">
					<c path="String"/>
					<d><d/></d>
					<d/>
					<x path="Int"/>
					<e path="ceramic.Easing"/>
					<x path="Null"><c path="ceramic.TimelineKeyframe"/></x>
					<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline keyframes are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the keyframe
     * @param options Can be used to configure timeline keyframe creation
     * @param value Value of the keyframe
     * @param time Time (in seconds) of the keyframe
     * @param easing Easing of the keyframe
     * @param existing Existing keyframe instance at the same position/time. Can be reused to prevent new allocation of keyframe instance
     * @param result The object that will hold the resulting keyframe.</haxe_doc>
		</onceCreateKeyframe>
		<offCreateKeyframe public="1" set="method" line="1368">
			<f a="?handleTypeOptionsValueIndexEasingExistingResult">
				<f a="type:options:value:index:easing:existing:result">
					<c path="String"/>
					<d><d/></d>
					<d/>
					<x path="Int"/>
					<e path="ceramic.Easing"/>
					<x path="Null"><c path="ceramic.TimelineKeyframe"/></x>
					<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline keyframes are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the keyframe
     * @param options Can be used to configure timeline keyframe creation
     * @param value Value of the keyframe
     * @param time Time (in seconds) of the keyframe
     * @param easing Easing of the keyframe
     * @param existing Existing keyframe instance at the same position/time. Can be reused to prevent new allocation of keyframe instance
     * @param result The object that will hold the resulting keyframe.</haxe_doc>
		</offCreateKeyframe>
		<listensCreateKeyframe public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Used to expand how timeline keyframes are created from raw data (from `Fragment` instances).
     * Respond to this event by assigning a value to the `result` argument.
     * @param type Type of the field being modified by the keyframe
     * @param options Can be used to configure timeline keyframe creation
     * @param value Value of the keyframe
     * @param time Time (in seconds) of the keyframe
     * @param easing Easing of the keyframe
     * @param existing Existing keyframe instance at the same position/time. Can be reused to prevent new allocation of keyframe instance
     * @param result The object that will hold the resulting keyframe.</haxe_doc>
		</listensCreateKeyframe>
		<handleCreateTrack set="method" line="57"><f a="type:options:result">
	<c path="String"/>
	<d><d/></d>
	<c path="ceramic.Value"><c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c></c>
	<x path="Void"/>
</f></handleCreateTrack>
		<handleBindTrack set="method" line="81"><f a="type:options:track:entity:field">
	<c path="String"/>
	<d><d/></d>
	<c path="ceramic.TimelineTrack"><c path="ceramic.TimelineKeyframe"/></c>
	<c path="ceramic.Entity"/>
	<c path="String"/>
	<x path="Void"/>
</f></handleBindTrack>
		<handleCreateKeyframe set="method" line="141"><f a="type:options:value:index:easing:existing:result">
	<c path="String"/>
	<d><d/></d>
	<d/>
	<x path="Int"/>
	<e path="ceramic.Easing"/>
	<x path="Null"><c path="ceramic.TimelineKeyframe"/></x>
	<c path="ceramic.Value"><c path="ceramic.TimelineKeyframe"/></c>
	<x path="Void"/>
</f></handleCreateKeyframe>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="47"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* App-level timeline related events.
 * You'll only need to track these events if you want to add new types of timeline tracks & keyframes
 * that can be created from raw data in `Fragment` instances.]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<enum path="cs.system.DateTimeKind" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.DateTimeKind">
		<Unspecified><meta><m n=":csNative"><e>0</e></m></meta></Unspecified>
		<Utc><meta><m n=":csNative"><e>1</e></m></meta></Utc>
		<Local><meta><m n=":csNative"><e>2</e></m></meta></Local>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.DateTimeKind"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="ceramic.Timer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Timer.hx">
		<callbacks expr="[]" line="9" static="1">
			<c path="Array"><c path="ceramic.TimerCallback"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</callbacks>
		<next expr="999999999" line="10" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>999999999</e></m></meta>
		</next>
		<now public="1" set="null" expr="0" line="16" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current time, relative to app.
     * (number of active seconds since app was started)</haxe_doc>
		</now>
		<timestamp public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Current unix time synchronized with ceramic Timer.
     * `Timer.now` and `Timer.timestamp` are garanteed to get incremented
     * exactly at the same rate, except when app frame real delta > 1s
     * (number of seconds since January 1st, 1970)]]></haxe_doc>
		</timestamp>
		<get_timestamp get="inline" set="null" line="25" static="1"><f a=""><x path="Float"/></f></get_timestamp>
		<startTimestamp public="1" set="null" expr="Date.now().getTime() / 1000.0" line="29" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Date.now().getTime() / 1000.0</e></m></meta>
		</startTimestamp>
		<update set="method" line="32" static="1">
			<f a="delta:realDelta">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>ceramic.App</e></m></meta>
		</update>
		<flush set="method" line="43" static="1"><f a=""><x path="Void"/></f></flush>
		<delay public="1" get="inline" set="null" line="112" static="1">
			<f a="owner:seconds:callback">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
			</f>
			<haxe_doc>* Execute a callback after the given delay in seconds.
     * @return a function to cancel this timer delay</haxe_doc>
		</delay>
		<interval public="1" get="inline" set="null" line="122" static="1">
			<f a="owner:seconds:callback">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
			</f>
			<haxe_doc>* Execute a callback periodically at the given interval in seconds.
     * @return a function to cancel this timer interval</haxe_doc>
		</interval>
		<schedule set="method" line="128" static="1"><f a="owner:seconds:callback:interval">
	<c path="ceramic.Entity"/>
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
</f></schedule>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.TimerCallback" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Timer.hx" module="ceramic.Timer">
		<owner public="1" expr="null" line="190">
			<c path="ceramic.Entity"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</owner>
		<callback public="1" expr="null" line="191">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</callback>
		<time public="1" expr="0" line="192">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</time>
		<interval public="1" expr="-1" line="193">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</interval>
		<cleared public="1" expr="false" line="194">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</cleared>
		<clear public="1" set="method" line="198"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="196"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Touch" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Touch.hx">
		<index public="1" set="null"><x path="Int"/></index>
		<x public="1" set="null"><x path="Float"/></x>
		<y public="1" set="null"><x path="Float"/></y>
		<deltaX public="1" set="null"><x path="Float"/></deltaX>
		<deltaY public="1" set="null"><x path="Float"/></deltaY>
		<toString set="method" line="19"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="5">
			<f a="index:x:y:deltaX:deltaY">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
			<m n=":allow"><e>ceramic.Screen</e></m>
		</meta>
	</class>
	<class path="ceramic.TouchInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TouchInfo.hx">
		<touchIndex public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* If the input is a touch input, this is the index of the touch.
     * Otherwise it will be -1.</haxe_doc>
		</touchIndex>
		<buttonId public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* If the input is a mouse input, this is the id of the mouse button.
     * Otherwise it will be -1.</haxe_doc>
		</buttonId>
		<x public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* X coordinate of the input (relative to screen).</haxe_doc>
		</x>
		<y public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Y coordinate of the input (relative to screen).</haxe_doc>
		</y>
		<hits public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether these info do hit the related visual. This is usually `true`,
     * Except when we have touch/mouse up events outside of a visual that
     * initially received a down event.</haxe_doc>
		</hits>
		<toString set="method" line="37"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="4">
			<f a="touchIndex:buttonId:x:y:hits">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc>@param hits * Whether these info do hit the related visual. This is usually `true`,
     * Except when we have touch/mouse up events outside of a visual that
     * initially received a down event.
@param y * Y coordinate of the input (relative to screen).
@param x * X coordinate of the input (relative to screen).
@param buttonId * If the input is a mouse input, this is the id of the mouse button.
     * Otherwise it will be -1.
@param touchIndex * If the input is a touch input, this is the index of the touch.
     * Otherwise it will be -1.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="ceramic.Touches" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Touches.hx">
		<this><c path="ceramic.IntMap"><c path="ceramic.Touch"/></c></this>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="ceramic._Touches.Touches_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Touches.hx" private="1" module="ceramic.Touches" final="1">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a=""><x path="ceramic.Touches"/></f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<get public="1" get="inline" set="null" line="11" static="1"><f a="this:touchIndex">
	<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
	<x path="Int"/>
	<c path="ceramic.Touch"/>
</f></get>
	<set public="1" get="inline" set="null" line="17" static="1"><f a="this:touchIndex:touch">
	<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
	<x path="Int"/>
	<c path="ceramic.Touch"/>
	<x path="Void"/>
</f></set>
	<iterator public="1" get="inline" set="null" line="23" static="1"><f a="this">
	<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
	<c path="ceramic.TouchesIterator"/>
</f></iterator>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="ceramic._Touches.Touches_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Touches.hx" private="1" module="ceramic.Touches" final="1">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a=""><x path="ceramic.Touches"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<get public="1" get="inline" set="null" line="11" static="1"><f a="this:touchIndex">
	<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
	<x path="Int"/>
	<c path="ceramic.Touch"/>
</f></get>
		<set public="1" get="inline" set="null" line="17" static="1"><f a="this:touchIndex:touch">
	<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
	<x path="Int"/>
	<c path="ceramic.Touch"/>
	<x path="Void"/>
</f></set>
		<iterator public="1" get="inline" set="null" line="23" static="1"><f a="this">
	<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
	<c path="ceramic.TouchesIterator"/>
</f></iterator>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.TouchesIterator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TouchesIterator.hx">
		<intMap><c path="ceramic.IntMap"><c path="ceramic.Touch"/></c></intMap>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" get="inline" set="null" line="22"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="32"><f a=""><c path="ceramic.Touch"/></f></next>
		<new get="inline" set="null" line="14">
			<f a="intMap">
				<c path="ceramic.IntMap"><c path="ceramic.Touch"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>ceramic.Touches</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.TrackerBackend" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TrackerBackend.hx">
		<backgroundQueue><c path="ceramic.BackgroundQueue"/></backgroundQueue>
		<onceImmediate public="1" get="inline" set="null" line="21">
			<f a="handleImmediate">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Schedule immediate callback. These callbacks need to be flushed at some point by the backend
     * @param handleImmediate the callback to schedule</haxe_doc>
		</onceImmediate>
		<readString public="1" get="inline" set="null" line="32">
			<f a="key">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Read a string for the given key
     * @param key the key to use
     * @return String or null of no string was found</haxe_doc>
		</readString>
		<saveString public="1" get="inline" set="null" line="44">
			<f a="key:str">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Save a string for the given key
     * @param key the key to use
     * @param str the string to save
     * @return Bool `true` if the save was successful</haxe_doc>
		</saveString>
		<appendString public="1" get="inline" set="null" line="57">
			<f a="key:str">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Append a string on the given key. If the key doesn't exist,
     * creates a new one with the string to append.
     * @param key the key to use
     * @param str the string to append
     * @return Bool `true` if the save was successful</haxe_doc>
		</appendString>
		<warning public="1" get="inline" set="null" line="67">
			<f a="message:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Log a warning message
     * @param message the warning message</haxe_doc>
		</warning>
		<error public="1" get="inline" set="null" line="77">
			<f a="error:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Log an error message
     * @param error the error message</haxe_doc>
		</error>
		<success public="1" get="inline" set="null" line="87">
			<f a="message:?pos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Log a success message
     * @param message the success message</haxe_doc>
		</success>
		<runInBackground public="1" get="inline" set="null" line="98">
			<f a="callback">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Run the given callback in background, if there is any background thread available
     * on this backend. Run it on the main thread otherwise like any other code
     * @param callback</haxe_doc>
		</runInBackground>
		<runInMain public="1" get="inline" set="null" line="108">
			<f a="callback">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Run the given callback in main thread
     * @param callback</haxe_doc>
		</runInMain>
		<interval public="1" get="inline" set="null" line="121">
			<f a="owner:seconds:callback">
				<c path="ceramic.Entity"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
			</f>
			<haxe_doc><![CDATA[* Execute a callback periodically at the given interval in seconds.
     * @param owner The entity that owns this interval
     * @param seconds The time in seconds between each call
     * @param callback The callback to call
     * @return Void->Void A callback to cancel the interval]]></haxe_doc>
		</interval>
		<delay public="1" get="inline" set="null" line="134">
			<f a="owner:seconds:callback">
				<c path="ceramic.Entity"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
			</f>
			<haxe_doc><![CDATA[* Execute a callback after the given delay in seconds.
     * @param owner The entity that owns this delayed call
     * @param seconds The time in seconds of delay before the call
     * @param callback The callback to call
     * @return Void->Void A callback to cancel the delayed call]]></haxe_doc>
		</delay>
		<storageDirectory public="1" get="inline" set="null" line="144">
			<f a=""><x path="Null"><c path="String"/></x></f>
			<haxe_doc>* Get storage directory (if any available)
     * @return directory as string or null if nothing available</haxe_doc>
		</storageDirectory>
		<pathJoin public="1" get="inline" set="null" line="154">
			<f a="paths">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Joins all paths in `paths` together.
     * @return joined paths as string</haxe_doc>
		</pathJoin>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.TransformPool" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TransformPool.hx">
		<availableTransforms expr="[]" line="10" static="1">
			<c path="Array"><c path="ceramic.Transform"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</availableTransforms>
		<get public="1" get="inline" set="null" line="15" static="1">
			<f a=""><c path="ceramic.Transform"/></f>
			<haxe_doc>* Get or create a transform. The transform object is ready to be used.</haxe_doc>
		</get>
		<recycle public="1" set="method" line="24" static="1">
			<f a="transform">
				<c path="ceramic.Transform"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Recycle an existing transform. The transform will be cleaned up.</haxe_doc>
		</recycle>
		<clear public="1" set="method" line="48" static="1"><f a=""><x path="Void"/></f></clear>
		<haxe_doc>* An utility to reuse transform matrix object at application level.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Triangle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Triangle.hx">
		<extends path="ceramic.Mesh"/>
		<set_width set="method" line="13" override="1"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="21" override="1"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<updateVertices get="inline" set="null" line="45"><f a=""><x path="Void"/></f></updateVertices>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A simple colored triangle, to fulfill all your triangle-shaped needs.
 * The triangle is facing top and fits exactly in `width` and `height`</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.Triangulate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Triangulate.hx">
		<poly2triPointsPool expr="[]" line="18" static="1">
			<c path="Array"><t path="poly2tri._Point.Poly2TriPoint"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</poly2triPointsPool>
		<poly2triPoints expr="[]" line="19" static="1">
			<c path="Array"><t path="poly2tri._Point.Poly2TriPoint"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</poly2triPoints>
		<poly2triSweepContext static="1"><c path="poly2tri.SweepContext"/></poly2triSweepContext>
		<poly2triSweep static="1"><c path="poly2tri.Sweep"/></poly2triSweep>
		<triangulate public="1" set="method" line="26" static="1">
			<f a="vertices:indices:?holes:?method" v=":::POLY2TRI">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
				<e path="ceramic.TriangulateMethod"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ method : POLY2TRI }</e></m></meta>
			<haxe_doc>* Triangulate the given vertices and fills the indices array accordingly</haxe_doc>
		</triangulate>
		<haxe_doc>* An utility to triangulate indices from a set of vertices</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<enum path="ceramic.TriangulateMethod" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/TriangulateMethod.hx">
		<EARCUT><haxe_doc>* Fast, but sometimes approximate</haxe_doc></EARCUT>
		<POLY2TRI><haxe_doc>* A bit slower, usually more precise</haxe_doc></POLY2TRI>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ceramic.Tween" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Tween.hx">
		<extends path="ceramic.Entity"/>
		<_tweens expr="[]" line="123" static="1">
			<c path="Array"><c path="ceramic.Tween"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_tweens>
		<_iteratedTweens expr="[]" line="124" static="1">
			<c path="Array"><c path="ceramic.Tween"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_iteratedTweens>
		<start public="1" set="method" line="126" static="1"><f a="owner:?easing:duration:fromValue:toValue:handleValueTime">
	<x path="Null"><c path="ceramic.Entity"/></x>
	<e path="ceramic.Easing"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<f a=":">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<c path="ceramic.Tween"/>
</f></start>
		<tick set="method" line="137" static="1"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></tick>
		<_computedEasingFunction expr="null" line="155" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</_computedEasingFunction>
		<_computedCustomEasing expr="null" line="156" static="1">
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</_computedCustomEasing>
		<computeEasing get="inline" set="null" line="158" static="1"><f a="easing">
	<e path="ceramic.Easing"/>
	<x path="Void"/>
</f></computeEasing>
		<ease public="1" set="method" line="243" static="1"><f a="easing:value">
	<e path="ceramic.Easing"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<easingFunction public="1" set="method" line="337" static="1">
			<f a="easing">
				<e path="ceramic.Easing"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
			</f>
			<haxe_doc><![CDATA[* Get a tween easing function as a plain Float->Float function.]]></haxe_doc>
		</easingFunction>
		<_dox_event_update public="1" set="method" line="637">
			<f a="value:time">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_update>
		<emitUpdate set="method" line="1095">
			<f a="value:time">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>update event</haxe_doc>
		</emitUpdate>
		<onUpdate public="1" set="method" line="1199">
			<f a="owner:handleValueTime">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:time">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onUpdate>
		<onceUpdate public="1" set="method" line="1298">
			<f a="owner:handleValueTime">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="value:time">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</onceUpdate>
		<offUpdate public="1" set="method" line="1368">
			<f a="?handleValueTime">
				<f a="value:time">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>update event</haxe_doc>
		</offUpdate>
		<listensUpdate public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to update event</haxe_doc>
		</listensUpdate>
		<_dox_event_complete public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_complete>
		<emitComplete set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>complete event</haxe_doc>
		</emitComplete>
		<onComplete public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</onComplete>
		<onceComplete public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</onceComplete>
		<offComplete public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>complete event</haxe_doc>
		</offComplete>
		<listensComplete public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to complete event</haxe_doc>
		</listensComplete>
		<owner><c path="ceramic.Entity"/></owner>
		<easing><e path="ceramic.Easing"/></easing>
		<duration><x path="Float"/></duration>
		<remaining><x path="Float"/></remaining>
		<fromValue><x path="Float"/></fromValue>
		<toValue><x path="Float"/></toValue>
		<computedEasing><f a=""><x path="Void"/></f></computedEasing>
		<customEasing expr="null" line="30">
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</customEasing>
		<init set="method" line="48"><f a=""><x path="Void"/></f></init>
		<updateFromTick get="inline" set="null" line="69"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></updateFromTick>
		<immediateComplete set="method" line="94"><f a=""><x path="Void"/></f></immediateComplete>
		<immediateStart set="method" line="102"><f a=""><x path="Void"/></f></immediateStart>
		<destroy public="1" set="method" line="108" override="1"><f a=""><x path="Void"/></f></destroy>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new set="method" line="34"><f a="owner:easing:duration:fromValue:toValue">
	<x path="Null"><c path="ceramic.Entity"/></x>
	<e path="ceramic.Easing"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.App</e></m>
		</meta>
	</class>
	<class path="ceramic._Tween.TweenEasingFunction" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Tween.hx" private="1" module="ceramic.Tween">
		<k public="1" expr="0" line="364" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Using `k` as static variable allows us to call easing function dynamically
     * without needing boxing of float type on c++ target when it is passed as arg.
     * (boxing of primitive types on c++ creates trash object references that give pressure to GC.
     * When we can, we try to avoid it.)</haxe_doc>
		</k>
		<customEasing public="1" expr="null" line="366" static="1">
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</customEasing>
		<custom public="1" set="method" line="370" static="1"><f a=""><x path="Void"/></f></custom>
		<none public="1" set="method" line="376" static="1"><f a=""><x path="Void"/></f></none>
		<linear public="1" set="method" line="382" static="1"><f a=""><x path="Void"/></f></linear>
		<backEaseIn public="1" set="method" line="388" static="1"><f a=""><x path="Void"/></f></backEaseIn>
		<backEaseInOut public="1" set="method" line="392" static="1"><f a=""><x path="Void"/></f></backEaseInOut>
		<backEaseOut public="1" set="method" line="398" static="1"><f a=""><x path="Void"/></f></backEaseOut>
		<quadEaseIn public="1" set="method" line="404" static="1"><f a=""><x path="Void"/></f></quadEaseIn>
		<quadEaseInOut public="1" set="method" line="408" static="1"><f a=""><x path="Void"/></f></quadEaseInOut>
		<quadEaseOut public="1" set="method" line="415" static="1"><f a=""><x path="Void"/></f></quadEaseOut>
		<cubicEaseIn public="1" set="method" line="421" static="1"><f a=""><x path="Void"/></f></cubicEaseIn>
		<cubicEaseInOut public="1" set="method" line="425" static="1"><f a=""><x path="Void"/></f></cubicEaseInOut>
		<cubicEaseOut public="1" set="method" line="429" static="1"><f a=""><x path="Void"/></f></cubicEaseOut>
		<quartEaseIn public="1" set="method" line="435" static="1"><f a=""><x path="Void"/></f></quartEaseIn>
		<quartEaseInOut public="1" set="method" line="439" static="1"><f a=""><x path="Void"/></f></quartEaseInOut>
		<quartEaseOut public="1" set="method" line="444" static="1"><f a=""><x path="Void"/></f></quartEaseOut>
		<quintEaseIn public="1" set="method" line="450" static="1"><f a=""><x path="Void"/></f></quintEaseIn>
		<quintEaseInOut public="1" set="method" line="454" static="1"><f a=""><x path="Void"/></f></quintEaseInOut>
		<quintEaseOut public="1" set="method" line="459" static="1"><f a=""><x path="Void"/></f></quintEaseOut>
		<bounceEaseIn public="1" set="method" line="465" static="1"><f a=""><x path="Void"/></f></bounceEaseIn>
		<bounceEaseInOut public="1" set="method" line="469" static="1"><f a=""><x path="Void"/></f></bounceEaseInOut>
		<bounceEaseOut public="1" set="method" line="477" static="1"><f a=""><x path="Void"/></f></bounceEaseOut>
		<_bounceEaseIn get="inline" set="null" line="481" static="1"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></_bounceEaseIn>
		<_bounceEaseOut get="inline" set="null" line="485" static="1"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></_bounceEaseOut>
		<elasticEaseIn public="1" set="method" line="504" static="1"><f a=""><x path="Void"/></f></elasticEaseIn>
		<elasticEaseInOut public="1" set="method" line="520" static="1"><f a=""><x path="Void"/></f></elasticEaseInOut>
		<elasticEaseOut public="1" set="method" line="536" static="1"><f a=""><x path="Void"/></f></elasticEaseOut>
		<expoEaseIn public="1" set="method" line="554" static="1"><f a=""><x path="Void"/></f></expoEaseIn>
		<expoEaseInOut public="1" set="method" line="558" static="1"><f a=""><x path="Void"/></f></expoEaseInOut>
		<expoEaseOut public="1" set="method" line="567" static="1"><f a=""><x path="Void"/></f></expoEaseOut>
		<sineEaseIn public="1" set="method" line="573" static="1"><f a=""><x path="Void"/></f></sineEaseIn>
		<sineEaseInOut public="1" set="method" line="577" static="1"><f a=""><x path="Void"/></f></sineEaseInOut>
		<sineEaseOut public="1" set="method" line="581" static="1"><f a=""><x path="Void"/></f></sineEaseOut>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>ceramic.Tween</e></m>
		</meta>
	</class>
	<typedef path="ceramic.UInt8Array" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/UInt8Array.hx">
		<t path="backend.UInt8Array"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="sys.thread.Mutex" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/thread/Mutex.hx">
		<native final="1" expr="new NativeMutex()" line="28">
			<c path="cs.system.threading.Mutex"/>
			<meta><m n=":value"><e>new NativeMutex()</e></m></meta>
		</native>
		<acquire public="1" set="method" line="32"><f a=""><x path="Void"/></f></acquire>
		<release public="1" set="method" line="40"><f a=""><x path="Void"/></f></release>
		<new public="1" set="method" line="30"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Utils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Utils.hx">
		<RE_ASCII_CHAR expr="~/^[a-zA-Z0-9]$/" line="18" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^[a-zA-Z0-9]$/</e></m></meta>
		</RE_ASCII_CHAR>
		<realPath public="1" set="method" line="20" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></realPath>
		<getRtti public="1" params="T" get="inline" set="null" line="31" static="1"><f a="c">
	<x path="Class"><c path="getRtti.T"/></x>
	<t path="haxe.rtti.Classdef"/>
</f></getRtti>
		<_nextUniqueIntCursor expr="0" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_nextUniqueIntCursor>
		<_nextUniqueInt0 expr="Std.int(Math.random() * 0x7ffffffe)" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 0x7ffffffe)</e></m></meta>
		</_nextUniqueInt0>
		<_nextUniqueInt1 expr="Std.int(Date.now().getTime() * 0.0001)" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Date.now().getTime() * 0.0001)</e></m></meta>
		</_nextUniqueInt1>
		<_nextUniqueInt2 expr="Std.int(Math.random() * 0x7ffffffe)" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 0x7ffffffe)</e></m></meta>
		</_nextUniqueInt2>
		<_nextUniqueInt3 expr="Std.int(Math.random() * 0x7ffffffe)" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 0x7ffffffe)</e></m></meta>
		</_nextUniqueInt3>
		<_uniqueIdMutex expr="new sys.thread.Mutex()" line="44" static="1">
			<c path="sys.thread.Mutex"/>
			<meta><m n=":value"><e>new sys.thread.Mutex()</e></m></meta>
		</_uniqueIdMutex>
		<uniqueId public="1" set="method" line="51" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Provides an identifier which is garanteed to be unique on this local device.
     * It however doesn't garantee that this identifier is not predictable.</haxe_doc>
		</uniqueId>
		<randomId public="1" set="method" line="83" static="1">
			<f a="?size" v="32">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ size : 32 }</e></m></meta>
			<haxe_doc>* Provides a random identifier which should be fairly unpredictable and
     * should have an extremely low chance to provide the same identifier twice.</haxe_doc>
		</randomId>
		<_persistentIds expr="null" line="97" static="1">
			<t path="Map">
				<x path="Int"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</_persistentIds>
		<persistentId public="1" set="method" line="106" static="1">
			<f a="?slot:?size" v="0:32">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ size : 32, slot : 0 }</e></m></meta>
			<haxe_doc>* Return a persistent identifier for this device. The identifier is expected
     * to stay the same as long as the user keeps the app installed.
     * Multiple identifiers can be generated/retrieved by using different slots (default 0).
     * Size of the persistent identifier can be provided, but will only have effect when
     * generating a new identifier.</haxe_doc>
		</persistentId>
		<resetPersistentId public="1" set="method" line="135" static="1">
			<f a="?slot" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ slot : 0 }</e></m></meta>
		</resetPersistentId>
		<base62Id public="1" get="inline" set="null" line="142" static="1"><f a="?val">
	<x path="Int"/>
	<c path="String"/>
</f></base62Id>
		<println public="1" set="method" line="166" static="1"><f a="data">
	<c path="String"/>
	<x path="Void"/>
</f></println>
		<printStackTrace public="1" set="method" line="196" static="1">
			<f a="?returnOnly" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ returnOnly : false }</e></m></meta>
		</printStackTrace>
		<stackItemToString public="1" set="method" line="284" static="1"><f a="item">
	<e path="haxe.StackItem"/>
	<c path="String"/>
</f></stackItemToString>
		<radToDeg public="1" get="inline" set="null" line="319" static="1"><f a="rad">
	<x path="Float"/>
	<x path="Float"/>
</f></radToDeg>
		<degToRad public="1" get="inline" set="null" line="323" static="1"><f a="deg">
	<x path="Float"/>
	<x path="Float"/>
</f></degToRad>
		<round public="1" get="inline" set="null" line="327" static="1">
			<f a="value:?decimals" v=":0">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ decimals : 0 }</e></m></meta>
		</round>
		<hashCode public="1" get="inline" set="null" line="344" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Java's String.hashCode() method implemented in Haxe.
     * source: https://github.com/rjanicek/janicek-core-haxe/blob/master/src/co/janicek/core/math/HashCore.hx</haxe_doc>
		</hashCode>
		<uniformFrequencyList public="1" set="method" line="361" static="1">
			<f a="values:frequencies:size">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Generate an uniform list of the requested size,
     * containing values uniformly repartited from frequencies.
     * @param values the values to put in list
     * @param probabilities the corresponding probability for each value
     * @param size the size of the final list</haxe_doc>
		</uniformFrequencyList>
		<upperCaseToCamelCase public="1" set="method" line="404" static="1">
			<f a="input:?firstLetterUppercase" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ firstLetterUppercase : true }</e></m></meta>
			<haxe_doc>* Transforms `SOME_IDENTIFIER` to `SomeIdentifier`</haxe_doc>
		</upperCaseToCamelCase>
		<camelCaseToUpperCase public="1" set="method" line="435" static="1">
			<f a="input:?firstLetterUppercase" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ firstLetterUppercase : true }</e></m></meta>
			<haxe_doc>* Transforms `SomeIdentifier`/`someIdentifier`/`some identifier` to `SOME_IDENTIFIER`</haxe_doc>
		</camelCaseToUpperCase>
		<functionEquals public="1" get="inline" set="null" line="477" static="1"><f a="functionA:functionB">
	<d/>
	<d/>
	<x path="Bool"/>
</f></functionEquals>
		<decodeUriParams public="1" set="method" line="487" static="1"><f a="raw">
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
</f></decodeUriParams>
		<sinRatio public="1" set="method" line="511" static="1">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Transforms a value between 0 and 1 to another value between 0 and 1 following a sinusoidal curve
     * @param value a value between 0 and 1. If giving a value > 1, its modulo 1 will be used.
     * @return Float]]></haxe_doc>
		</sinRatio>
		<cosRatio public="1" set="method" line="524" static="1">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Transforms a value between 0 and 1 to another value between 0 and 1 following a cosinusoidal curve
     * @param value a value between 0 and 1. If giving a value > 1, its modulo 1 will be used.
     * @return Float]]></haxe_doc>
		</cosRatio>
		<valueFromInterpolatedKey public="1" set="method" line="539" static="1">
			<f a="keys:values:interpolatedKey">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Given an array of keys and an array of matching values, interpolate a new value from interpolatedKey
     * @param keys A list of keys
     * @param values A list of values
     * @param interpolatedKey The interpolated key, used to find a matching interpolated value
     * @return Interpolated value</haxe_doc>
		</valueFromInterpolatedKey>
		<yFromInterpolatedX public="1" set="method" line="576" static="1">
			<f a="points:interpolatedX">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Given an array of X and Y values, interpolate a new Y value from interpolated X
     * @param points A list of X and Y values
     * @param interpolatedX The interpolated X key, used to find a matching interpolated Y
     * @return Interpolated Y value</haxe_doc>
		</yFromInterpolatedX>
		<command public="1" set="method" line="609" static="1"><f a="cmd:?args:?options:result">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<a>
		<detached>
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":optional"/></meta>
		</detached>
		<cwd>
			<x path="Null"><c path="String"/></x>
			<meta><m n=":optional"/></meta>
		</cwd>
	</a>
	<f a="code:out:err">
		<x path="Int"/>
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></command>
		<replaceIdentifier public="1" set="method" line="676" static="1"><f a="str:word:replacement">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></replaceIdentifier>
		<imageTypeFromBytes public="1" set="method" line="693" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="ceramic.ImageType"/>
</f></imageTypeFromBytes>
		<lerp public="1" get="inline" set="null" line="719" static="1"><f a="a:b:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></lerp>
		<haxe_doc>* Various utilities. Some of them are used by ceramic itself or its backends.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.ValueEntry" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/ValueEntry.hx">
		<extends path="ceramic.CollectionEntry"/>
		<value public="1"><c path="ceramic.ValueEntry.T"/></value>
		<new public="1" set="method" line="10"><f a="value:?id:?name">
	<c path="ceramic.ValueEntry.T"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A collection entry that can hold any value</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.Velocity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/Velocity.hx">
		<positions expr="[]" line="5">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</positions>
		<times expr="[]" line="7">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</times>
		<reset public="1" set="method" line="13"><f a=""><x path="Void"/></f></reset>
		<add public="1" set="method" line="25">
			<f a="position:?minusDelta" v=":0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ minusDelta : 0 }</e></m></meta>
		</add>
		<get public="1" set="method" line="36"><f a=""><x path="Float"/></f></get>
		<prune set="method" line="56"><f a="expireTime">
	<x path="Float"/>
	<x path="Void"/>
</f></prune>
		<toString set="method" line="70"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="ceramic.VisibleBounds" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/VisibleBounds.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<entity public="1">
			<c path="ceramic.Visual"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<bounds expr="null" line="12">
			<c path="ceramic.Visual"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</bounds>
		<bindAsComponent set="method" line="24"><f a=""><x path="Void"/></f></bindAsComponent>
		<updateBounds set="method" line="32"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></updateBounds>
		<setEntity set="method" line="8">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="8">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="16"><f a="bounds">
	<c path="ceramic.Visual"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* An utility to display visible bounds on any visual</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.VisualTransition" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/VisualTransition.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<_currentTransform expr="new Transform()" line="12" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</_currentTransform>
		<_targetTransform expr="new Transform()" line="14" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</_targetTransform>
		<_identityTransform expr="new Transform()" line="16" static="1">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</_identityTransform>
		<transition public="1" set="method" line="585" static="1"><f a="visual:?easing:duration:cb">
	<c path="ceramic.Visual"/>
	<e path="ceramic.Easing"/>
	<x path="Float"/>
	<f a="">
		<x path="ceramic.VisualTransitionProperties"/>
		<x path="Void"/>
	</f>
	<x path="Null"><c path="ceramic.Tween"/></x>
</f></transition>
		<entity public="1">
			<c path="ceramic.Visual"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<easing public="1"><e path="ceramic.Easing"/></easing>
		<duration public="1"><x path="Float"/></duration>
		<anyPropertyChanged expr="false" line="24">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</anyPropertyChanged>
		<xChanged expr="false" line="26">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</xChanged>
		<xTween expr="null" line="27">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</xTween>
		<xTarget expr="0" line="28">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</xTarget>
		<xStart expr="0" line="29">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</xStart>
		<xEnd expr="0" line="30">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</xEnd>
		<yChanged expr="false" line="32">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</yChanged>
		<yTween expr="null" line="33">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</yTween>
		<yTarget expr="0" line="34">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</yTarget>
		<yStart expr="0" line="35">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</yStart>
		<yEnd expr="0" line="36">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</yEnd>
		<scaleXChanged expr="false" line="38">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</scaleXChanged>
		<scaleXTween expr="null" line="39">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scaleXTween>
		<scaleXTarget expr="0" line="40">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scaleXTarget>
		<scaleXStart expr="0" line="41">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scaleXStart>
		<scaleXEnd expr="0" line="42">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scaleXEnd>
		<scaleYChanged expr="false" line="44">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</scaleYChanged>
		<scaleYTween expr="null" line="45">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scaleYTween>
		<scaleYTarget expr="0" line="46">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scaleYTarget>
		<scaleYStart expr="0" line="47">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scaleYStart>
		<scaleYEnd expr="0" line="48">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scaleYEnd>
		<skewXChanged expr="false" line="50">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skewXChanged>
		<skewXTween expr="null" line="51">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</skewXTween>
		<skewXTarget expr="0" line="52">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewXTarget>
		<skewXStart expr="0" line="53">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewXStart>
		<skewXEnd expr="0" line="54">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewXEnd>
		<skewYChanged expr="false" line="56">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skewYChanged>
		<skewYTween expr="null" line="57">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</skewYTween>
		<skewYTarget expr="0" line="58">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewYTarget>
		<skewYStart expr="0" line="59">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewYStart>
		<skewYEnd expr="0" line="60">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewYEnd>
		<anchorXChanged expr="false" line="62">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</anchorXChanged>
		<anchorXTween expr="null" line="63">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</anchorXTween>
		<anchorXTarget expr="0" line="64">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</anchorXTarget>
		<anchorXStart expr="0" line="65">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</anchorXStart>
		<anchorXEnd expr="0" line="66">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</anchorXEnd>
		<anchorYChanged expr="false" line="68">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</anchorYChanged>
		<anchorYTween expr="null" line="69">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</anchorYTween>
		<anchorYTarget expr="0" line="70">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</anchorYTarget>
		<anchorYStart expr="0" line="71">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</anchorYStart>
		<anchorYEnd expr="0" line="72">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</anchorYEnd>
		<rotationChanged expr="false" line="74">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rotationChanged>
		<rotationTween expr="null" line="75">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</rotationTween>
		<rotationTarget expr="0" line="76">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</rotationTarget>
		<rotationStart expr="0" line="77">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</rotationStart>
		<rotationEnd expr="0" line="78">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</rotationEnd>
		<widthChanged expr="false" line="80">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</widthChanged>
		<widthTween expr="null" line="81">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</widthTween>
		<widthTarget expr="0" line="82">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</widthTarget>
		<widthStart expr="0" line="83">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</widthStart>
		<widthEnd expr="0" line="84">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</widthEnd>
		<heightChanged expr="false" line="86">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</heightChanged>
		<heightTween expr="null" line="87">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</heightTween>
		<heightTarget expr="0" line="88">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</heightTarget>
		<heightStart expr="0" line="89">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</heightStart>
		<heightEnd expr="0" line="90">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</heightEnd>
		<colorChanged expr="false" line="92">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</colorChanged>
		<colorTween expr="null" line="93">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</colorTween>
		<colorTarget expr="Color.NONE" line="94">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</colorTarget>
		<colorStart expr="Color.NONE" line="95">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</colorStart>
		<colorEnd expr="Color.NONE" line="96">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>Color.NONE</e></m></meta>
		</colorEnd>
		<alphaChanged expr="false" line="98">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</alphaChanged>
		<alphaTween expr="null" line="99">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</alphaTween>
		<alphaTarget expr="0" line="100">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</alphaTarget>
		<alphaStart expr="0" line="101">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</alphaStart>
		<alphaEnd expr="0" line="102">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</alphaEnd>
		<translateXChanged expr="false" line="104">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</translateXChanged>
		<translateXTween expr="null" line="105">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</translateXTween>
		<translateXTarget expr="0" line="106">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</translateXTarget>
		<translateXStart expr="0" line="107">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</translateXStart>
		<translateXEnd expr="0" line="108">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</translateXEnd>
		<translateYChanged expr="false" line="110">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</translateYChanged>
		<translateYTween expr="null" line="111">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</translateYTween>
		<translateYTarget expr="0" line="112">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</translateYTarget>
		<translateYStart expr="0" line="113">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</translateYStart>
		<translateYEnd expr="0" line="114">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</translateYEnd>
		<transformChanged expr="false" line="116">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transformChanged>
		<transformAssigned expr="false" line="117">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transformAssigned>
		<transformAssignedInstance expr="null" line="118">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformAssignedInstance>
		<transformTween expr="null" line="119">
			<c path="ceramic.Tween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformTween>
		<transformTarget expr="null" line="120">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformTarget>
		<transformStart expr="null" line="121">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformStart>
		<transformEnd expr="null" line="122">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformEnd>
		<transformEndToNull expr="false" line="123">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transformEndToNull>
		<transformInTransition expr="null" line="124">
			<c path="ceramic.Transform"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transformInTransition>
		<bindAsComponent set="method" line="163"><f a=""><x path="Void"/></f></bindAsComponent>
		<run public="1" set="method" line="173"><f a="?easing:duration:cb">
	<e path="ceramic.Easing"/>
	<x path="Float"/>
	<f a="">
		<x path="ceramic.VisualTransitionProperties"/>
		<x path="Void"/>
	</f>
	<x path="Null"><c path="ceramic.Tween"/></x>
</f></run>
		<destroy public="1" set="method" line="562" override="1"><f a=""><x path="Void"/></f></destroy>
		<setEntity set="method" line="10">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="10">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="154">
			<f a="?easing:?duration" v=":0.3">
				<e path="ceramic.Easing"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ duration : 0.3 }</e></m></meta>
		</new>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":allow"><e>ceramic.VisualTransitionProperties</e></m>
		</meta>
	</class>
	<abstract path="ceramic.VisualTransitionProperties" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/VisualTransition.hx" module="ceramic.VisualTransition">
		<from><icast><c path="ceramic.VisualTransition"/></icast></from>
		<this><c path="ceramic.VisualTransition"/></this>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="ceramic._VisualTransition.VisualTransitionProperties_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/VisualTransition.hx" private="1" module="ceramic.VisualTransition" final="1">
	<x public="1" get="accessor" set="accessor" static="1"><x path="Float"/></x>
	<get_x set="method" line="602" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_x>
	<set_x set="method" line="603" static="1"><f a="this:x">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
	<y public="1" get="accessor" set="accessor" static="1"><x path="Float"/></y>
	<get_y set="method" line="613" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_y>
	<set_y set="method" line="614" static="1"><f a="this:y">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
	<pos public="1" set="method" line="623" static="1"><f a="this:x:y">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pos>
	<scaleX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></scaleX>
	<get_scaleX set="method" line="629" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_scaleX>
	<set_scaleX set="method" line="630" static="1"><f a="this:scaleX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
	<scaleY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></scaleY>
	<get_scaleY set="method" line="640" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_scaleY>
	<set_scaleY set="method" line="641" static="1"><f a="this:scaleY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
	<scale public="1" set="method" line="650" static="1">
		<f a="this:scaleX:?scaleY" v="::-1">
			<c path="ceramic.VisualTransition"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ scaleY : -1 }</e></m></meta>
	</scale>
	<translateX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></translateX>
	<get_translateX set="method" line="656" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_translateX>
	<set_translateX set="method" line="657" static="1"><f a="this:translateX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_translateX>
	<translateY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></translateY>
	<get_translateY set="method" line="667" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_translateY>
	<set_translateY set="method" line="668" static="1"><f a="this:translateY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_translateY>
	<translate public="1" set="method" line="677" static="1">
		<f a="this:translateX:?translateY" v="::-1">
			<c path="ceramic.VisualTransition"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ translateY : -1 }</e></m></meta>
	</translate>
	<skewX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></skewX>
	<get_skewX set="method" line="683" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_skewX>
	<set_skewX set="method" line="684" static="1"><f a="this:skewX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_skewX>
	<skewY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></skewY>
	<get_skewY set="method" line="694" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_skewY>
	<set_skewY set="method" line="695" static="1"><f a="this:skewY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_skewY>
	<skew public="1" set="method" line="704" static="1"><f a="this:skewX:skewY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></skew>
	<anchorX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></anchorX>
	<get_anchorX set="method" line="710" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_anchorX>
	<set_anchorX set="method" line="711" static="1"><f a="this:anchorX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_anchorX>
	<anchorY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></anchorY>
	<get_anchorY set="method" line="721" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_anchorY>
	<set_anchorY set="method" line="722" static="1"><f a="this:anchorY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_anchorY>
	<anchor public="1" set="method" line="731" static="1"><f a="this:anchorX:anchorY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></anchor>
	<rotation public="1" get="accessor" set="accessor" static="1"><x path="Float"/></rotation>
	<get_rotation set="method" line="737" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_rotation>
	<set_rotation set="method" line="738" static="1"><f a="this:rotation">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
	<width public="1" get="accessor" set="accessor" static="1"><x path="Float"/></width>
	<get_width set="method" line="748" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_width>
	<set_width set="method" line="749" static="1"><f a="this:width">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
	<height public="1" get="accessor" set="accessor" static="1"><x path="Float"/></height>
	<get_height set="method" line="759" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_height>
	<set_height set="method" line="760" static="1"><f a="this:height">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
	<size public="1" set="method" line="769" static="1"><f a="this:width:height">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></size>
	<color public="1" get="accessor" set="accessor" static="1"><x path="ceramic.Color"/></color>
	<get_color set="method" line="775" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="ceramic.Color"/>
</f></get_color>
	<set_color set="method" line="776" static="1"><f a="this:color">
	<c path="ceramic.VisualTransition"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
	<alpha public="1" get="accessor" set="accessor" static="1"><x path="Float"/></alpha>
	<get_alpha set="method" line="786" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_alpha>
	<set_alpha set="method" line="787" static="1"><f a="this:alpha">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
	<transform public="1" get="accessor" set="accessor" static="1"><c path="ceramic.Transform"/></transform>
	<get_transform set="method" line="797" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<c path="ceramic.Transform"/>
</f></get_transform>
	<set_transform set="method" line="798" static="1"><f a="this:transform">
	<c path="ceramic.VisualTransition"/>
	<c path="ceramic.Transform"/>
	<c path="ceramic.Transform"/>
</f></set_transform>
	<meta><m n=":hxGen"/></meta>
</class></impl>
	</abstract>
	<class path="ceramic._VisualTransition.VisualTransitionProperties_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/VisualTransition.hx" private="1" module="ceramic.VisualTransition" final="1">
		<x public="1" get="accessor" set="accessor" static="1"><x path="Float"/></x>
		<get_x set="method" line="602" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_x>
		<set_x set="method" line="603" static="1"><f a="this:x">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<y public="1" get="accessor" set="accessor" static="1"><x path="Float"/></y>
		<get_y set="method" line="613" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_y>
		<set_y set="method" line="614" static="1"><f a="this:y">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<pos public="1" set="method" line="623" static="1"><f a="this:x:y">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pos>
		<scaleX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></scaleX>
		<get_scaleX set="method" line="629" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_scaleX>
		<set_scaleX set="method" line="630" static="1"><f a="this:scaleX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<scaleY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></scaleY>
		<get_scaleY set="method" line="640" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_scaleY>
		<set_scaleY set="method" line="641" static="1"><f a="this:scaleY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<scale public="1" set="method" line="650" static="1">
			<f a="this:scaleX:?scaleY" v="::-1">
				<c path="ceramic.VisualTransition"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scaleY : -1 }</e></m></meta>
		</scale>
		<translateX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></translateX>
		<get_translateX set="method" line="656" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_translateX>
		<set_translateX set="method" line="657" static="1"><f a="this:translateX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_translateX>
		<translateY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></translateY>
		<get_translateY set="method" line="667" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_translateY>
		<set_translateY set="method" line="668" static="1"><f a="this:translateY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_translateY>
		<translate public="1" set="method" line="677" static="1">
			<f a="this:translateX:?translateY" v="::-1">
				<c path="ceramic.VisualTransition"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ translateY : -1 }</e></m></meta>
		</translate>
		<skewX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></skewX>
		<get_skewX set="method" line="683" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_skewX>
		<set_skewX set="method" line="684" static="1"><f a="this:skewX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_skewX>
		<skewY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></skewY>
		<get_skewY set="method" line="694" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_skewY>
		<set_skewY set="method" line="695" static="1"><f a="this:skewY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_skewY>
		<skew public="1" set="method" line="704" static="1"><f a="this:skewX:skewY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></skew>
		<anchorX public="1" get="accessor" set="accessor" static="1"><x path="Float"/></anchorX>
		<get_anchorX set="method" line="710" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_anchorX>
		<set_anchorX set="method" line="711" static="1"><f a="this:anchorX">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_anchorX>
		<anchorY public="1" get="accessor" set="accessor" static="1"><x path="Float"/></anchorY>
		<get_anchorY set="method" line="721" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_anchorY>
		<set_anchorY set="method" line="722" static="1"><f a="this:anchorY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_anchorY>
		<anchor public="1" set="method" line="731" static="1"><f a="this:anchorX:anchorY">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></anchor>
		<rotation public="1" get="accessor" set="accessor" static="1"><x path="Float"/></rotation>
		<get_rotation set="method" line="737" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_rotation>
		<set_rotation set="method" line="738" static="1"><f a="this:rotation">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<width public="1" get="accessor" set="accessor" static="1"><x path="Float"/></width>
		<get_width set="method" line="748" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_width>
		<set_width set="method" line="749" static="1"><f a="this:width">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<height public="1" get="accessor" set="accessor" static="1"><x path="Float"/></height>
		<get_height set="method" line="759" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_height>
		<set_height set="method" line="760" static="1"><f a="this:height">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<size public="1" set="method" line="769" static="1"><f a="this:width:height">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></size>
		<color public="1" get="accessor" set="accessor" static="1"><x path="ceramic.Color"/></color>
		<get_color set="method" line="775" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="ceramic.Color"/>
</f></get_color>
		<set_color set="method" line="776" static="1"><f a="this:color">
	<c path="ceramic.VisualTransition"/>
	<x path="ceramic.Color"/>
	<x path="ceramic.Color"/>
</f></set_color>
		<alpha public="1" get="accessor" set="accessor" static="1"><x path="Float"/></alpha>
		<get_alpha set="method" line="786" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
</f></get_alpha>
		<set_alpha set="method" line="787" static="1"><f a="this:alpha">
	<c path="ceramic.VisualTransition"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<transform public="1" get="accessor" set="accessor" static="1"><c path="ceramic.Transform"/></transform>
		<get_transform set="method" line="797" static="1"><f a="this">
	<c path="ceramic.VisualTransition"/>
	<c path="ceramic.Transform"/>
</f></get_transform>
		<set_transform set="method" line="798" static="1"><f a="this:transform">
	<c path="ceramic.VisualTransition"/>
	<c path="ceramic.Transform"/>
	<c path="ceramic.Transform"/>
</f></set_transform>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.WatchDirectory" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/WatchDirectory.hx">
		<extends path="ceramic.Entity"/>
		<_dox_event_directoryChange public="1" set="method" line="637">
			<f a="path:newFiles:previousFiles">
				<c path="String"/>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_directoryChange>
		<emitDirectoryChange set="method" line="1095">
			<f a="path:newFiles:previousFiles">
				<c path="String"/>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>directoryChange event</haxe_doc>
		</emitDirectoryChange>
		<onDirectoryChange public="1" set="method" line="1199">
			<f a="owner:handlePathNewFilesPreviousFiles">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="path:newFiles:previousFiles">
					<c path="String"/>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>directoryChange event</haxe_doc>
		</onDirectoryChange>
		<onceDirectoryChange public="1" set="method" line="1298">
			<f a="owner:handlePathNewFilesPreviousFiles">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="path:newFiles:previousFiles">
					<c path="String"/>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>directoryChange event</haxe_doc>
		</onceDirectoryChange>
		<offDirectoryChange public="1" set="method" line="1368">
			<f a="?handlePathNewFilesPreviousFiles">
				<f a="path:newFiles:previousFiles">
					<c path="String"/>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="ceramic.ReadOnlyMap">
						<c path="String"/>
						<x path="Float"/>
					</x>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>directoryChange event</haxe_doc>
		</offDirectoryChange>
		<listensDirectoryChange public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to directoryChange event</haxe_doc>
		</listensDirectoryChange>
		<updateInterval public="1" set="null"><x path="Float"/></updateInterval>
		<watchedDirectories public="1" set="null" expr="null" line="12">
			<x path="ceramic.ReadOnlyMap">
				<c path="String"/>
				<x path="ceramic.ReadOnlyMap">
					<c path="String"/>
					<x path="Float"/>
				</x>
			</x>
			<meta><m n=":value"><e>null</e></m></meta>
		</watchedDirectories>
		<startingToWatchDirectories expr="null" line="14">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
		</startingToWatchDirectories>
		<watchDirectory public="1" set="method" line="49"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></watchDirectory>
		<stopWatchingDirectory public="1" set="method" line="135"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></stopWatchingDirectory>
		<tick set="method" line="163"><f a=""><x path="Void"/></f></tick>
		<checkWatchedDirectory set="method" line="177"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></checkWatchedDirectory>
		<computeFilesModificationTime set="method" line="258"><f a="path">
	<c path="String"/>
	<x path="ceramic.ReadOnlyMap">
		<c path="String"/>
		<x path="Float"/>
	</x>
</f></computeFilesModificationTime>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="30">
			<f a="?updateInterval" v="1.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ updateInterval : 1.0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="ceramic.macros.DefinesMacro" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/macros/DefinesMacro.hx">
		<getDefine public="1" set="method" static="1">
			<f a="key">
				<d/>
				<d/>
			</f>
			<haxe_doc>* Shorthand for retrieving compiler flag values.</haxe_doc>
		</getDefine>
		<getFloatDefine public="1" set="method" static="1">
			<f a="key">
				<d/>
				<d/>
			</f>
			<haxe_doc>* Shorthand for retrieving compiler flag values as `Float`.</haxe_doc>
		</getFloatDefine>
		<getIntDefine public="1" set="method" static="1">
			<f a="key">
				<d/>
				<d/>
			</f>
			<haxe_doc>* Shorthand for retrieving compiler flag values as `Int`.</haxe_doc>
		</getIntDefine>
		<getBoolDefine public="1" set="method" static="1">
			<f a="key">
				<d/>
				<d/>
			</f>
			<haxe_doc>* Shorthand for retrieving compiler flag values as `Bool`.</haxe_doc>
		</getBoolDefine>
		<_stringToBool set="method" line="37" static="1"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></_stringToBool>
		<isDefined public="1" set="method" static="1">
			<f a="key">
				<d/>
				<d/>
			</f>
			<haxe_doc>* Shorthand for checking if a compiler flag is defined.</haxe_doc>
		</isDefined>
		<getDefines public="1" set="method" static="1">
			<f a=""><d/></f>
			<haxe_doc>* Shorthand for retrieving a map of all defined compiler flags.</haxe_doc>
		</getDefines>
		<haxe_doc>* Utilities to access defines from code.
 * Original source: https://code.haxe.org/category/macros/get-compiler-define-value.html</haxe_doc>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.macros.PluginsMacro" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/macros/PluginsMacro.hx">
		<initPlugins public="1" set="method" static="1">
			<f a=""><d/></f>
			<haxe_doc>* Resolves plugin classes and calls pluginInit() for each of them.</haxe_doc>
		</initPlugins>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.scriptable.ScriptableColor" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/scriptable/ScriptableColor.hx">
		<NONE final="1" public="1" set="null" expr="-1" line="15" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</NONE>
		<WHITE final="1" public="1" set="null" expr="0xFFFFFF" line="17" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFFFF</e></m></meta>
		</WHITE>
		<GRAY final="1" public="1" set="null" expr="0x808080" line="18" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x808080</e></m></meta>
		</GRAY>
		<BLACK final="1" public="1" set="null" expr="0x000000" line="19" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x000000</e></m></meta>
		</BLACK>
		<GREEN final="1" public="1" set="null" expr="0x008000" line="21" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x008000</e></m></meta>
		</GREEN>
		<LIME final="1" public="1" set="null" expr="0x00FF00" line="22" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x00FF00</e></m></meta>
		</LIME>
		<YELLOW final="1" public="1" set="null" expr="0xFFFF00" line="23" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFFF00</e></m></meta>
		</YELLOW>
		<ORANGE final="1" public="1" set="null" expr="0xFFA500" line="24" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFA500</e></m></meta>
		</ORANGE>
		<RED final="1" public="1" set="null" expr="0xFF0000" line="25" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF0000</e></m></meta>
		</RED>
		<PURPLE final="1" public="1" set="null" expr="0x800080" line="26" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x800080</e></m></meta>
		</PURPLE>
		<BLUE final="1" public="1" set="null" expr="0x0000FF" line="27" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x0000FF</e></m></meta>
		</BLUE>
		<BROWN final="1" public="1" set="null" expr="0x8B4513" line="28" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x8B4513</e></m></meta>
		</BROWN>
		<PINK final="1" public="1" set="null" expr="0xFFC0CB" line="29" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFFC0CB</e></m></meta>
		</PINK>
		<MAGENTA final="1" public="1" set="null" expr="0xFF00FF" line="30" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0xFF00FF</e></m></meta>
		</MAGENTA>
		<CYAN final="1" public="1" set="null" expr="0x00FFFF" line="31" static="1">
			<x path="ceramic.Color"/>
			<meta><m n=":value"><e>0x00FFFF</e></m></meta>
		</CYAN>
		<random public="1" set="method" line="38" static="1">
			<f a="?minSatutation:?minBrightness" v="0.5:0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ minBrightness : 0.5, minSatutation : 0.5 }</e></m></meta>
			<haxe_doc>* Generate a random color (away from white or black)
     * @return The color as a Color</haxe_doc>
		</random>
		<fromInt public="1" set="method" line="49" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Create a color from the least significant four bytes of an Int
     *
     * @param    value And Int with bytes in the format 0xRRGGBB
     * @return    The color as a Color</haxe_doc>
		</fromInt>
		<fromRGB public="1" set="method" line="62" static="1">
			<f a="red:green:blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from integer RGB values (0 to 255)
     *
     * @param red    The red value of the color from 0 to 255
     * @param green    The green value of the color from 0 to 255
     * @param blue    The green value of the color from 0 to 255
     * @return The color as a Color</haxe_doc>
		</fromRGB>
		<fromRGBFloat public="1" set="method" line="75" static="1">
			<f a="red:green:blue">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from float RGB values (0 to 1)
     *
     * @param red    The red value of the color from 0 to 1
     * @param green    The green value of the color from 0 to 1
     * @param blue    The green value of the color from 0 to 1
     * @return The color as a Color</haxe_doc>
		</fromRGBFloat>
		<fromCMYK public="1" set="method" line="89" static="1">
			<f a="cyan:magenta:yellow:black">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from CMYK values (0 to 1)
     *
     * @param cyan        The cyan value of the color from 0 to 1
     * @param magenta    The magenta value of the color from 0 to 1
     * @param yellow    The yellow value of the color from 0 to 1
     * @param black        The black value of the color from 0 to 1
     * @return The color as a Color</haxe_doc>
		</fromCMYK>
		<fromHSB public="1" set="method" line="102" static="1">
			<f a="hue:saturation:brightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from HSB (aka HSV) components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    brightness    (aka value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
     * @return    The color as a Color</haxe_doc>
		</fromHSB>
		<fromHSL public="1" set="method" line="115" static="1">
			<f a="hue:saturation:lightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from HSL components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a Color</haxe_doc>
		</fromHSL>
		<fromString public="1" set="method" line="133" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Null"><x path="ceramic.Color"/></x>
			</f>
			<haxe_doc><![CDATA[* Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.
     *
     * Examples (input -> output in hex):
     *
     * - `0x00FF00`    -> `0x00FF00`
     * - `#0000FF`     -> `0x0000FF`
     * - `GRAY`        -> `0x808080`
     * - `blue`        -> `0x0000FF`
     *
     * @param    str     The string to be parsed
     * @return    A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
		</fromString>
		<getHSBColorWheel public="1" set="method" line="143" static="1">
			<f a=""><c path="Array"><x path="ceramic.Color"/></c></f>
			<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
     *
     * @return    HSB color wheel as Array of Colors</haxe_doc>
		</getHSBColorWheel>
		<interpolate public="1" get="inline" set="null" line="156" static="1">
			<f a="color1:color2:?factor" v="::0.5">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.5 }</e></m></meta>
			<haxe_doc>* Get an interpolated color based on two different colors.
     *
     * @param     color1 The first color
     * @param     color2 The second color
     * @param     factor value from 0 to 1 representing how much to shift color1 toward color2
     * @return    The interpolated color</haxe_doc>
		</interpolate>
		<gradient public="1" set="method" line="170" static="1">
			<f a="color1:color2:steps:?ease">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="Int"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<c path="Array"><x path="ceramic.Color"/></c>
			</f>
			<haxe_doc>* Create a gradient from one color to another
     *
     * @param color1 The color to shift from
     * @param color2 The color to shift to
     * @param steps How many colors the gradient should have
     * @param ease An optional easing function, such as those provided in FlxEase
     * @return An array of colors of length steps, shifting from color1 to color2</haxe_doc>
		</gradient>
		<multiply public="1" set="method" line="178" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Multiply the RGB channels of two Colors</haxe_doc>
		</multiply>
		<add public="1" set="method" line="186" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Add the RGB channels of two Colors</haxe_doc>
		</add>
		<subtract public="1" set="method" line="194" static="1">
			<f a="lhs:rhs">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Subtract the RGB channels of one Color from another</haxe_doc>
		</subtract>
		<toHexString public="1" set="method" line="205" static="1">
			<f a="color:?prefix" v=":true">
				<x path="ceramic.Color"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ prefix : true }</e></m></meta>
			<haxe_doc>* Return a String representation of the color in the format
     *
     * @param prefix Whether to include "0x" prefix at start of string
     * @return    A string of length 10 in the format 0xAARRGGBB</haxe_doc>
		</toHexString>
		<toWebString public="1" set="method" line="215" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a String representation of the color in the format #RRGGBB
     *
     * @return    A string of length 7 in the format #RRGGBB</haxe_doc>
		</toWebString>
		<getColorInfo public="1" set="method" line="225" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Get a string of color information about this color
     *
     * @return A string containing information about this color</haxe_doc>
		</getColorInfo>
		<getDarkened public="1" set="method" line="236" static="1">
			<f a="color:?factor" v=":0.2">
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
			<haxe_doc>* Get a darkened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward black.
     * @return     A darkened version of this color</haxe_doc>
		</getDarkened>
		<getLightened public="1" set="method" line="247" static="1">
			<f a="color:?factor" v=":0.2">
				<x path="ceramic.Color"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<meta><m n=":value"><e>{ factor : 0.2 }</e></m></meta>
			<haxe_doc>* Get a lightened version of this color
     *
     * @param    factor value from 0 to 1 of how much to progress toward white.
     * @return     A lightened version of this color</haxe_doc>
		</getLightened>
		<getInverted public="1" set="method" line="257" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Get the inversion of this color
     *
     * @return The inversion of this color</haxe_doc>
		</getInverted>
		<hue public="1" set="method" line="265" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get the hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hue>
		<saturation public="1" set="method" line="273" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get the saturation of the color (from 0 to 1)</haxe_doc>
		</saturation>
		<brightness public="1" set="method" line="281" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get the brightness (aka value) of the color (from 0 to 1)</haxe_doc>
		</brightness>
		<lightness public="1" set="method" line="289" static="1">
			<f a="color">
				<x path="ceramic.Color"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get the lightness of the color (from 0 to 1)</haxe_doc>
		</lightness>
		<red public="1" set="method" line="294" static="1"><f a="color">
	<x path="ceramic.Color"/>
	<x path="Int"/>
</f></red>
		<green public="1" set="method" line="299" static="1"><f a="color">
	<x path="ceramic.Color"/>
	<x path="Int"/>
</f></green>
		<blue public="1" set="method" line="304" static="1"><f a="color">
	<x path="ceramic.Color"/>
	<x path="Int"/>
</f></blue>
		<redFloat public="1" set="method" line="309" static="1"><f a="color">
	<x path="ceramic.Color"/>
	<x path="Float"/>
</f></redFloat>
		<greenFloat public="1" set="method" line="314" static="1"><f a="color">
	<x path="ceramic.Color"/>
	<x path="Float"/>
</f></greenFloat>
		<blueFloat public="1" set="method" line="319" static="1"><f a="color">
	<x path="ceramic.Color"/>
	<x path="Float"/>
</f></blueFloat>
		<fromHSLuv public="1" set="method" line="333" static="1">
			<f a="hue:saturation:lightness">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="ceramic.Color"/>
			</f>
			<haxe_doc>* Generate a color from HSLuv components.
     *
     * @param    hue            A number between 0 and 360, indicating position on a color strip or wheel.
     * @param    saturation    A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
     * @param    lightness    A number between 0 and 1, indicating the lightness of the color
     * @return    The color as a Color</haxe_doc>
		</fromHSLuv>
		<getHSLuv public="1" set="method" line="344" static="1">
			<f a="color:?result">
				<x path="ceramic.Color"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Get HSLuv components from the color instance.
     *
     * @param result A pre-allocated array to store the result into.
     * @return    The HSLuv components as a float array</haxe_doc>
		</getHSLuv>
		<haxe_doc>* Class representing a color, based on Int. Provides a variety of methods for creating and converting colors.
 *
 * Colors can be written as Ints. This means you can pass a hex value such as
 * 0x123456 to a function expecting a Color, and it will automatically become a Color "object".
 * Similarly, Colors may be treated as Ints.
 *
 * Note that when using properties of a Color other than RGB, the values are ultimately stored as
 * RGB values, so repeatedly manipulating HSB/HSL/CMYK values may result in a gradual loss of precision.</haxe_doc>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.scriptable.ScriptableFlags" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/scriptable/ScriptableFlags.hx">
		<getBool public="1" set="method" line="5" static="1"><f a="flags:bit">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getBool>
		<setBoolAndGetFlags public="1" set="method" line="12" static="1"><f a="flags:bit:bool">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></setBoolAndGetFlags>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="ceramic.scriptable.ScriptableMeshColorMapping" params="" file="/home/runner/work/api-docs/api-docs/ceramic/runtime/src/ceramic/scriptable/ScriptableMeshColorMapping.hx">
		<MESH public="1" expr="0" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Map a single color to the whole mesh.</haxe_doc>
		</MESH>
		<INDICES public="1" expr="1" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Map a color to each indice.</haxe_doc>
		</INDICES>
		<VERTICES public="1" expr="2" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
			<haxe_doc>* Map a color to each vertex.</haxe_doc>
		</VERTICES>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="cs.Boot" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/Boot.hx">
		<init public="1" set="method" line="42" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</init>
		<meta>
			<m n=":keep"/>
			<m n=":hxGen"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<abstract path="cs.Flags" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/Flags.hx">
		<from><icast><c path="cs.Flags.T"/></icast></from>
		<this><c path="cs.Flags.T"/></this>
		<to><icast><c path="cs.Flags.T"/></icast></to>
		<haxe_doc>Use this type to have access to the bitwise operators of C# enums that have a `cs.system.FlagsAttribute` attribute.

	Usage example:

	```haxe
	import cs.system.reflection.BindingFlags;
	var binding = new Flags(BindingFlags.Public) | BindingFlags.Static | BindingFlags.NonPublic;
	```</haxe_doc>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="cs._Flags.Flags_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/Flags.hx" private="1" module="cs.Flags" final="1">
	<_new public="1" get="inline" set="null" line="40" static="1">
		<f a="?initial">
			<c path="cs.Flags.T"/>
			<x path="cs.Flags"><c path="cs.Flags.T"/></x>
		</f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new `Flags` type with an optional initial value. If no initial value was specified,
		the default enum value for an empty flags attribute is specified</haxe_doc>
	</_new>
	<add public="1" get="inline" set="null" line="47" static="1">
		<f a="this:flags">
			<c path="cs.Flags.T"/>
			<x path="cs.Flags"><c path="cs.Flags.T"/></x>
			<x path="cs.Flags"><c path="cs.Flags.T"/></x>
		</f>
		<meta><m n=":op"><e>A | B</e></m></meta>
		<haxe_doc>Accessible through the bitwise OR operator (`|`). Returns a new `Flags` type with the flags
		passed at `flags` added to it.</haxe_doc>
	</add>
	<bitAnd public="1" get="inline" set="null" line="55" static="1">
		<f a="this:flags">
			<c path="cs.Flags.T"/>
			<x path="cs.Flags"><c path="cs.Flags.T"/></x>
			<x path="cs.Flags"><c path="cs.Flags.T"/></x>
		</f>
		<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
		<haxe_doc><![CDATA[Accessible through the bitwise AND operator (`&`). Returns a new `Flags` type with
		the flags that are set on both `this` and `flags`]]></haxe_doc>
	</bitAnd>
	<bitXor public="1" get="inline" set="null" line="62" static="1">
		<f a="this:flags">
			<c path="cs.Flags.T"/>
			<x path="cs.Flags"><c path="cs.Flags.T"/></x>
			<x path="cs.Flags"><c path="cs.Flags.T"/></x>
		</f>
		<meta><m n=":op"><e>A ^ B</e></m></meta>
		<haxe_doc>Accessible through the bitwise XOR operator (`^`).</haxe_doc>
	</bitXor>
	<bitNeg public="1" get="inline" set="null" line="70" static="1">
		<f a="this">
			<c path="cs.Flags.T"/>
			<x path="cs.Flags"><c path="cs.Flags.T"/></x>
		</f>
		<meta><m n=":op"><e>~A</e></m></meta>
		<haxe_doc>Accesible through the bitwise negation operator (`~`). Returns a new `Flags` type
		with all unset flags as set - but the ones that are set already.</haxe_doc>
	</bitNeg>
	<remove public="1" get="inline" set="null" line="77" static="1">
		<f a="this:flags">
			<c path="cs.Flags.T"/>
			<x path="cs.Flags"><c path="cs.Flags.T"/></x>
			<x path="cs.Flags"><c path="cs.Flags.T"/></x>
		</f>
		<haxe_doc>Returns a new `Flags` type with all flags set by `flags` unset</haxe_doc>
	</remove>
	<has public="1" get="inline" set="null" line="84" static="1">
		<f a="this:flag">
			<c path="cs.Flags.T"/>
			<c path="cs.Flags.T"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Returns whether `flag` is present on `this` type</haxe_doc>
	</has>
	<hasAny public="1" get="inline" set="null" line="91" static="1">
		<f a="this:flags">
			<c path="cs.Flags.T"/>
			<x path="cs.Flags"><c path="cs.Flags.T"/></x>
			<x path="Bool"/>
		</f>
		<haxe_doc>Returns whether `this` type has any flag set by `flags` also set</haxe_doc>
	</hasAny>
	<hasAll public="1" get="inline" set="null" line="98" static="1">
		<f a="this:flags">
			<c path="cs.Flags.T"/>
			<x path="cs.Flags"><c path="cs.Flags.T"/></x>
			<x path="Bool"/>
		</f>
		<haxe_doc>Returns whether `this` type has all flags set by `flags` also set</haxe_doc>
	</hasAll>
	<underlying get="inline" set="null" line="103" static="1"><f a="this">
	<c path="cs.Flags.T"/>
	<x path="cs._Flags.EnumUnderlying"><c path="cs.Flags.T"/></x>
</f></underlying>
	<meta>
		<m n=":keep"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="cs._Flags.Flags_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/Flags.hx" private="1" module="cs.Flags" final="1">
		<_new public="1" get="inline" set="null" line="40" static="1">
			<f a="?initial">
				<c path="cs.Flags.T"/>
				<x path="cs.Flags"><c path="cs.Flags.T"/></x>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new `Flags` type with an optional initial value. If no initial value was specified,
		the default enum value for an empty flags attribute is specified</haxe_doc>
		</_new>
		<add public="1" get="inline" set="null" line="47" static="1">
			<f a="this:flags">
				<c path="cs.Flags.T"/>
				<x path="cs.Flags"><c path="cs.Flags.T"/></x>
				<x path="cs.Flags"><c path="cs.Flags.T"/></x>
			</f>
			<meta><m n=":op"><e>A | B</e></m></meta>
			<haxe_doc>Accessible through the bitwise OR operator (`|`). Returns a new `Flags` type with the flags
		passed at `flags` added to it.</haxe_doc>
		</add>
		<bitAnd public="1" get="inline" set="null" line="55" static="1">
			<f a="this:flags">
				<c path="cs.Flags.T"/>
				<x path="cs.Flags"><c path="cs.Flags.T"/></x>
				<x path="cs.Flags"><c path="cs.Flags.T"/></x>
			</f>
			<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
			<haxe_doc><![CDATA[Accessible through the bitwise AND operator (`&`). Returns a new `Flags` type with
		the flags that are set on both `this` and `flags`]]></haxe_doc>
		</bitAnd>
		<bitXor public="1" get="inline" set="null" line="62" static="1">
			<f a="this:flags">
				<c path="cs.Flags.T"/>
				<x path="cs.Flags"><c path="cs.Flags.T"/></x>
				<x path="cs.Flags"><c path="cs.Flags.T"/></x>
			</f>
			<meta><m n=":op"><e>A ^ B</e></m></meta>
			<haxe_doc>Accessible through the bitwise XOR operator (`^`).</haxe_doc>
		</bitXor>
		<bitNeg public="1" get="inline" set="null" line="70" static="1">
			<f a="this">
				<c path="cs.Flags.T"/>
				<x path="cs.Flags"><c path="cs.Flags.T"/></x>
			</f>
			<meta><m n=":op"><e>~A</e></m></meta>
			<haxe_doc>Accesible through the bitwise negation operator (`~`). Returns a new `Flags` type
		with all unset flags as set - but the ones that are set already.</haxe_doc>
		</bitNeg>
		<remove public="1" get="inline" set="null" line="77" static="1">
			<f a="this:flags">
				<c path="cs.Flags.T"/>
				<x path="cs.Flags"><c path="cs.Flags.T"/></x>
				<x path="cs.Flags"><c path="cs.Flags.T"/></x>
			</f>
			<haxe_doc>Returns a new `Flags` type with all flags set by `flags` unset</haxe_doc>
		</remove>
		<has public="1" get="inline" set="null" line="84" static="1">
			<f a="this:flag">
				<c path="cs.Flags.T"/>
				<c path="cs.Flags.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `flag` is present on `this` type</haxe_doc>
		</has>
		<hasAny public="1" get="inline" set="null" line="91" static="1">
			<f a="this:flags">
				<c path="cs.Flags.T"/>
				<x path="cs.Flags"><c path="cs.Flags.T"/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `this` type has any flag set by `flags` also set</haxe_doc>
		</hasAny>
		<hasAll public="1" get="inline" set="null" line="98" static="1">
			<f a="this:flags">
				<c path="cs.Flags.T"/>
				<x path="cs.Flags"><c path="cs.Flags.T"/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `this` type has all flags set by `flags` also set</haxe_doc>
		</hasAll>
		<underlying get="inline" set="null" line="103" static="1"><f a="this">
	<c path="cs.Flags.T"/>
	<x path="cs._Flags.EnumUnderlying"><c path="cs.Flags.T"/></x>
</f></underlying>
		<meta>
			<m n=":keep"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="cs._Flags.EnumUnderlying" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/Flags.hx" private="1" module="cs.Flags">
		<from><icast><c path="cs._Flags.EnumUnderlying.T"/></icast></from>
		<this><x path="cs._Flags.EnumUnderlying"><c path="cs._Flags.EnumUnderlying.T"/></x></this>
		<to><icast><c path="cs._Flags.EnumUnderlying.T"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":coreType"/>
		</meta>
		<impl><class path="cs._Flags.EnumUnderlying_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/Flags.hx" private="1" module="cs.Flags" final="1"><meta>
	<m n=":keep"/>
	<m n=":hxGen"/>
</meta></class></impl>
	</abstract>
	<typedef path="cs.Out" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/Out.hx">
		<c path="cs.Out.T"/>
		<haxe_doc>This type represents "out" types for C# function parameters.
	It only has effect on function parameters, and conversion to/from the referenced type is automatic.

	Note: Using this type should be considered a bad practice unless overriding a native function is needed.</haxe_doc>
		<meta>
			<m n=":nativeGen"/>
			<m n=":analyzer"><e>no_local_dce</e></m>
			<m n=":semantics"><e>reference</e></m>
		</meta>
	</typedef>
	<typedef path="cs.Ref" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/Ref.hx">
		<c path="cs.Ref.T"/>
		<haxe_doc>This type represents "ref" types for C# function parameters.
	It only has effect on function parameters, and conversion to/from the referenced type is automatic.

	Note: Using this type should be considered a bad practice unless overriding a native function is needed.</haxe_doc>
		<meta>
			<m n=":nativeGen"/>
			<m n=":semantics"><e>reference</e></m>
		</meta>
	</typedef>
	<abstract path="cs.Int8" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/StdTypes.hx" module="cs.StdTypes">
		<this><x path="cs.Int8"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="cs.Int16" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/StdTypes.hx" module="cs.StdTypes">
		<this><x path="cs.Int16"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="cs.Char16" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/StdTypes.hx" module="cs.StdTypes">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="cs.Char16"/></this>
		<meta>
			<m n=":valueUsed"/>
			<m n=":hxGen"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="cs.UInt8" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/StdTypes.hx" module="cs.StdTypes">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="cs.UInt8"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="cs.UInt16" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/StdTypes.hx" module="cs.StdTypes">
		<this><x path="cs.UInt16"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="cs.Int64" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/StdTypes.hx" module="cs.StdTypes">
		<from>
			<icast><x path="Int"/></icast>
			<icast><x path="Float"/></icast>
		</from>
		<this><x path="cs.Int64"/></this>
		<meta>
			<m n=":valueUsed"/>
			<m n=":hxGen"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
			<m n=":coreType"/>
		</meta>
		<impl><class path="cs._StdTypes.Int64_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/StdTypes.hx" private="1" module="cs.StdTypes" extern="1" final="1">
	<addI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="Int"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A + B</e></m>
		</meta>
	</addI>
	<add public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A + B</e></m>
		</meta>
	</add>
	<mulI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="Int"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A * B</e></m>
		</meta>
	</mulI>
	<mul public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A * B</e></m>
		</meta>
	</mul>
	<modI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="Int"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A % B</e></m>
		</meta>
	</modI>
	<mod public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A % B</e></m>
		</meta>
	</mod>
	<subI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="Int"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A - B</e></m>
		</meta>
	</subI>
	<sub public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A - B</e></m>
		</meta>
	</sub>
	<divI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="Int"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A / B</e></m>
		</meta>
	</divI>
	<div public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A / B</e></m>
		</meta>
	</div>
	<orI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="Int"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A | B</e></m>
		</meta>
	</orI>
	<or public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A | B</e></m>
		</meta>
	</or>
	<xorI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="Int"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A ^ B</e></m>
		</meta>
	</xorI>
	<xor public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A ^ B</e></m>
		</meta>
	</xor>
	<andI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="Int"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A & B]]></e></m>
		</meta>
	</andI>
	<and public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A & B]]></e></m>
		</meta>
	</and>
	<shlI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="Int"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A << B]]></e></m>
		</meta>
	</shlI>
	<shl public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A << B]]></e></m>
		</meta>
	</shl>
	<shrI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="Int"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A >> B]]></e></m>
		</meta>
	</shrI>
	<shr public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A >> B]]></e></m>
		</meta>
	</shr>
	<gt public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A > B]]></e></m>
		</meta>
	</gt>
	<gte public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A >= B]]></e></m>
		</meta>
	</gte>
	<lt public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A < B]]></e></m>
		</meta>
	</lt>
	<lte public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A <= B]]></e></m>
		</meta>
	</lte>
	<bneg public="1" set="method" static="1">
		<f a="t">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>~A</e></m>
		</meta>
	</bneg>
	<neg public="1" set="method" static="1">
		<f a="t">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>-A</e></m>
		</meta>
	</neg>
	<preIncrement public="1" set="method" static="1">
		<f a="t">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>++A</e></m>
		</meta>
	</preIncrement>
	<postIncrement public="1" set="method" static="1">
		<f a="t">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A++</e></m>
		</meta>
	</postIncrement>
	<preDecrement public="1" set="method" static="1">
		<f a="t">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>--A</e></m>
		</meta>
	</preDecrement>
	<postDecrement public="1" set="method" static="1">
		<f a="t">
			<x path="cs.Int64"/>
			<x path="cs.Int64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A--</e></m>
		</meta>
	</postDecrement>
	<meta><m n=":hxGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs._StdTypes.Int64_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/StdTypes.hx" private="1" module="cs.StdTypes" extern="1" final="1">
		<addI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="Int"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A + B</e></m>
			</meta>
		</addI>
		<add public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A + B</e></m>
			</meta>
		</add>
		<mulI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="Int"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A * B</e></m>
			</meta>
		</mulI>
		<mul public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A * B</e></m>
			</meta>
		</mul>
		<modI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="Int"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A % B</e></m>
			</meta>
		</modI>
		<mod public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A % B</e></m>
			</meta>
		</mod>
		<subI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="Int"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A - B</e></m>
			</meta>
		</subI>
		<sub public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A - B</e></m>
			</meta>
		</sub>
		<divI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="Int"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A / B</e></m>
			</meta>
		</divI>
		<div public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A / B</e></m>
			</meta>
		</div>
		<orI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="Int"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A | B</e></m>
			</meta>
		</orI>
		<or public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A | B</e></m>
			</meta>
		</or>
		<xorI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="Int"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A ^ B</e></m>
			</meta>
		</xorI>
		<xor public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A ^ B</e></m>
			</meta>
		</xor>
		<andI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="Int"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A & B]]></e></m>
			</meta>
		</andI>
		<and public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A & B]]></e></m>
			</meta>
		</and>
		<shlI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="Int"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A << B]]></e></m>
			</meta>
		</shlI>
		<shl public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A << B]]></e></m>
			</meta>
		</shl>
		<shrI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="Int"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A >> B]]></e></m>
			</meta>
		</shrI>
		<shr public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A >> B]]></e></m>
			</meta>
		</shr>
		<gt public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A > B]]></e></m>
			</meta>
		</gt>
		<gte public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A >= B]]></e></m>
			</meta>
		</gte>
		<lt public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A < B]]></e></m>
			</meta>
		</lt>
		<lte public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A <= B]]></e></m>
			</meta>
		</lte>
		<bneg public="1" set="method" static="1">
			<f a="t">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>~A</e></m>
			</meta>
		</bneg>
		<neg public="1" set="method" static="1">
			<f a="t">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>-A</e></m>
			</meta>
		</neg>
		<preIncrement public="1" set="method" static="1">
			<f a="t">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>++A</e></m>
			</meta>
		</preIncrement>
		<postIncrement public="1" set="method" static="1">
			<f a="t">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A++</e></m>
			</meta>
		</postIncrement>
		<preDecrement public="1" set="method" static="1">
			<f a="t">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>--A</e></m>
			</meta>
		</preDecrement>
		<postDecrement public="1" set="method" static="1">
			<f a="t">
				<x path="cs.Int64"/>
				<x path="cs.Int64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A--</e></m>
			</meta>
		</postDecrement>
		<meta><m n=":hxGen"/></meta>
	</class>
	<abstract path="cs.UInt64" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/StdTypes.hx" module="cs.StdTypes">
		<from>
			<icast><x path="Int"/></icast>
			<icast><x path="cs.Int64"/></icast>
			<icast><x path="Float"/></icast>
			<icast><x path="haxe.Int64"/></icast>
		</from>
		<this><x path="cs.UInt64"/></this>
		<meta>
			<m n=":hxGen"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
			<m n=":coreType"/>
		</meta>
		<impl><class path="cs._StdTypes.UInt64_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/StdTypes.hx" private="1" module="cs.StdTypes" extern="1" final="1">
	<addI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="Int"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A + B</e></m>
		</meta>
	</addI>
	<add public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A + B</e></m>
		</meta>
	</add>
	<mulI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="Int"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A * B</e></m>
		</meta>
	</mulI>
	<mul public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A * B</e></m>
		</meta>
	</mul>
	<modI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="Int"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A % B</e></m>
		</meta>
	</modI>
	<mod public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A % B</e></m>
		</meta>
	</mod>
	<subI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="Int"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A - B</e></m>
		</meta>
	</subI>
	<sub public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A - B</e></m>
		</meta>
	</sub>
	<divI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="Int"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A / B</e></m>
		</meta>
	</divI>
	<div public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A / B</e></m>
		</meta>
	</div>
	<orI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="Int"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A | B</e></m>
		</meta>
	</orI>
	<or public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A | B</e></m>
		</meta>
	</or>
	<xorI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="Int"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A ^ B</e></m>
		</meta>
	</xorI>
	<xor public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A ^ B</e></m>
		</meta>
	</xor>
	<andI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="Int"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A & B]]></e></m>
		</meta>
	</andI>
	<and public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A & B]]></e></m>
		</meta>
	</and>
	<shlI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="Int"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A << B]]></e></m>
		</meta>
	</shlI>
	<shl public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A << B]]></e></m>
		</meta>
	</shl>
	<shrI public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="Int"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A >> B]]></e></m>
		</meta>
	</shrI>
	<shr public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A >> B]]></e></m>
		</meta>
	</shr>
	<gt public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A > B]]></e></m>
		</meta>
	</gt>
	<gte public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A >= B]]></e></m>
		</meta>
	</gte>
	<lt public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A < B]]></e></m>
		</meta>
	</lt>
	<lte public="1" set="method" static="1">
		<f a="lhs:rhs">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e><![CDATA[A <= B]]></e></m>
		</meta>
	</lte>
	<bneg public="1" set="method" static="1">
		<f a="t">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>~A</e></m>
		</meta>
	</bneg>
	<neg public="1" set="method" static="1">
		<f a="t">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>-A</e></m>
		</meta>
	</neg>
	<preIncrement public="1" set="method" static="1">
		<f a="t">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>++A</e></m>
		</meta>
	</preIncrement>
	<postIncrement public="1" set="method" static="1">
		<f a="t">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A++</e></m>
		</meta>
	</postIncrement>
	<preDecrement public="1" set="method" static="1">
		<f a="t">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>--A</e></m>
		</meta>
	</preDecrement>
	<postDecrement public="1" set="method" static="1">
		<f a="t">
			<x path="cs.UInt64"/>
			<x path="cs.UInt64"/>
		</f>
		<meta>
			<m n=":noExpr"/>
			<m n=":op"><e>A--</e></m>
		</meta>
	</postDecrement>
	<meta><m n=":hxGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs._StdTypes.UInt64_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/StdTypes.hx" private="1" module="cs.StdTypes" extern="1" final="1">
		<addI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="Int"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A + B</e></m>
			</meta>
		</addI>
		<add public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A + B</e></m>
			</meta>
		</add>
		<mulI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="Int"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A * B</e></m>
			</meta>
		</mulI>
		<mul public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A * B</e></m>
			</meta>
		</mul>
		<modI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="Int"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A % B</e></m>
			</meta>
		</modI>
		<mod public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A % B</e></m>
			</meta>
		</mod>
		<subI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="Int"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A - B</e></m>
			</meta>
		</subI>
		<sub public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A - B</e></m>
			</meta>
		</sub>
		<divI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="Int"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A / B</e></m>
			</meta>
		</divI>
		<div public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A / B</e></m>
			</meta>
		</div>
		<orI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="Int"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A | B</e></m>
			</meta>
		</orI>
		<or public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A | B</e></m>
			</meta>
		</or>
		<xorI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="Int"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A ^ B</e></m>
			</meta>
		</xorI>
		<xor public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A ^ B</e></m>
			</meta>
		</xor>
		<andI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="Int"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A & B]]></e></m>
			</meta>
		</andI>
		<and public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A & B]]></e></m>
			</meta>
		</and>
		<shlI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="Int"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A << B]]></e></m>
			</meta>
		</shlI>
		<shl public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A << B]]></e></m>
			</meta>
		</shl>
		<shrI public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="Int"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A >> B]]></e></m>
			</meta>
		</shrI>
		<shr public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A >> B]]></e></m>
			</meta>
		</shr>
		<gt public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A > B]]></e></m>
			</meta>
		</gt>
		<gte public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A >= B]]></e></m>
			</meta>
		</gte>
		<lt public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A < B]]></e></m>
			</meta>
		</lt>
		<lte public="1" set="method" static="1">
			<f a="lhs:rhs">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e><![CDATA[A <= B]]></e></m>
			</meta>
		</lte>
		<bneg public="1" set="method" static="1">
			<f a="t">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>~A</e></m>
			</meta>
		</bneg>
		<neg public="1" set="method" static="1">
			<f a="t">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>-A</e></m>
			</meta>
		</neg>
		<preIncrement public="1" set="method" static="1">
			<f a="t">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>++A</e></m>
			</meta>
		</preIncrement>
		<postIncrement public="1" set="method" static="1">
			<f a="t">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A++</e></m>
			</meta>
		</postIncrement>
		<preDecrement public="1" set="method" static="1">
			<f a="t">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>--A</e></m>
			</meta>
		</preDecrement>
		<postDecrement public="1" set="method" static="1">
			<f a="t">
				<x path="cs.UInt64"/>
				<x path="cs.UInt64"/>
			</f>
			<meta>
				<m n=":noExpr"/>
				<m n=":op"><e>A--</e></m>
			</meta>
		</postDecrement>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="cs.internal.FieldHashConflict" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/FieldLookup.hx" module="cs.internal.FieldLookup" final="1">
		<hash public="1" set="null">
			<x path="Int"/>
			<meta><m n=":readOnly"/></meta>
		</hash>
		<name public="1" set="null">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</name>
		<value public="1"><d/></value>
		<next public="1"><c path="cs.internal.FieldHashConflict"/></next>
		<new public="1" set="method" line="33">
			<f a="hash:name:value:next">
				<x path="Int"/>
				<c path="String"/>
				<d/>
				<c path="cs.internal.FieldHashConflict"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.FieldHashConflict"</e></m>
			<m n=":nativeGen"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="cs.internal.FieldLookup" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/FieldLookup.hx" final="1">
		<fieldIds static="1">
			<c path="cs.NativeArray"><x path="Int"/></c>
			<meta><m n=":protected"/></meta>
		</fieldIds>
		<fields static="1">
			<c path="cs.NativeArray"><c path="String"/></c>
			<meta><m n=":protected"/></meta>
		</fields>
		<length static="1">
			<x path="Int"/>
			<meta><m n=":protected"/></meta>
		</length>
		<addFields set="method" line="53" static="1"><f a="nids:nfields">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Void"/>
</f></addFields>
		<doHash get="inline" set="null" line="111" static="1"><f a="s">
	<c path="String"/>
	<x path="Int"/>
</f></doHash>
		<lookupHash public="1" set="method" line="120" static="1"><f a="key">
	<x path="Int"/>
	<c path="String"/>
</f></lookupHash>
		<hash public="1" set="method" line="140" static="1"><f a="s">
	<c path="String"/>
	<x path="Int"/>
</f></hash>
		<findHash public="1" set="method" line="180" static="1"><f a="hash:hashs:length">
	<x path="Int"/>
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
</f></findHash>
		<removeInt public="1" set="method" line="199" static="1"><f a="a:length:pos">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></removeInt>
		<removeFloat public="1" set="method" line="204" static="1"><f a="a:length:pos">
	<c path="cs.NativeArray"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></removeFloat>
		<removeDynamic public="1" set="method" line="209" static="1"><f a="a:length:pos">
	<c path="cs.NativeArray"><d/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></removeDynamic>
		<__insert params="T" get="inline" set="null" line="214" static="1"><f a="a:length:pos:x">
	<c path="cs.NativeArray"><c path="__insert.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="__insert.T"/>
	<c path="cs.NativeArray"><c path="__insert.T"/></c>
</f></__insert>
		<insertInt public="1" set="method" line="246" static="1"><f a="a:length:pos:x">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><x path="Int"/></c>
</f></insertInt>
		<insertFloat public="1" set="method" line="249" static="1"><f a="a:length:pos:x">
	<c path="cs.NativeArray"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<c path="cs.NativeArray"><x path="Float"/></c>
</f></insertFloat>
		<insertDynamic public="1" set="method" line="252" static="1"><f a="a:length:pos:x">
	<c path="cs.NativeArray"><d/></c>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<c path="cs.NativeArray"><d/></c>
</f></insertDynamic>
		<insertString public="1" set="method" line="255" static="1"><f a="a:length:pos:x">
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></insertString>
		<getHashConflict public="1" set="method" line="257" static="1"><f a="head:hash:name">
	<c path="cs.internal.FieldHashConflict"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="cs.internal.FieldHashConflict"/>
</f></getHashConflict>
		<setHashConflict public="1" set="method" line="267" static="1"><f a="head:hash:name:value">
	<t path="cs.Ref"><c path="cs.internal.FieldHashConflict"/></t>
	<x path="Int"/>
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></setHashConflict>
		<deleteHashConflict public="1" set="method" line="279" static="1"><f a="head:hash:name">
	<t path="cs.Ref"><c path="cs.internal.FieldHashConflict"/></t>
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
</f></deleteHashConflict>
		<addHashConflictNames public="1" set="method" line="305" static="1"><f a="head:arr">
	<c path="cs.internal.FieldHashConflict"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></addHashConflictNames>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.FieldLookup"</e></m>
			<m n=":classCode"><e>"#pragma warning disable 628\n"</e></m>
			<m n=":nativeGen"/>
			<m n=":keep"/>
			<m n=":static"/>
		</meta>
	</class>
	<class path="cs.internal.Function" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/Function.hx">
		<new set="method" line="31"><f a="arity:type">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>These classes are automatically generated by the compiler. They are only
	here so there is an option for e.g. defining them as externs if you are compiling
	in modules (untested).</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":keep"/>
			<m n=":abstract"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.Function"</e></m>
		</meta>
	</class>
	<class path="cs.internal._Function.VarArgsBase" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/Function.hx" private="1" module="cs.internal.Function">
		<extends path="cs.internal.Function"/>
		<__hx_invokeDynamic public="1" set="method" line="35"><f a="dynArgs">
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></__hx_invokeDynamic>
		<meta>
			<m n=":nativeGen"/>
			<m n=":keep"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.VarArgsBase"</e></m>
		</meta>
	</class>
	<class path="cs.internal.VarArgsFunction" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/Function.hx" module="cs.internal.Function">
		<extends path="cs.internal._Function.VarArgsBase"/>
		<fun><f a="">
	<c path="Array"><d/></c>
	<d/>
</f></fun>
		<__hx_invokeDynamic public="1" set="method" line="48" override="1"><f a="dynArgs">
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></__hx_invokeDynamic>
		<new public="1" set="method" line="43"><f a="fun">
	<f a="">
		<c path="Array"><d/></c>
		<d/>
	</f>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":keep"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.VarArgsFunction"</e></m>
		</meta>
	</class>
	<class path="cs.internal.Closure" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/Function.hx" module="cs.internal.Function">
		<extends path="cs.internal._Function.VarArgsBase"/>
		<obj><d/></obj>
		<field><c path="String"/></field>
		<hash><x path="Int"/></hash>
		<__hx_invokeDynamic public="1" set="method" line="65" override="1"><f a="dynArgs">
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></__hx_invokeDynamic>
		<Equals public="1" set="method" line="69"><f a="obj">
	<d/>
	<x path="Bool"/>
</f></Equals>
		<GetHashCode public="1" set="method" line="76">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</GetHashCode>
		<new public="1" set="method" line="58"><f a="obj:field:hash">
	<d/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":keep"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.Closure"</e></m>
		</meta>
	</class>
	<typedef path="cs.internal._HxObject.StdType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/HxObject.hx" private="1" module="cs.internal.HxObject">
		<c path="Type"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="cs.internal.IHxObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/HxObject.hx" module="cs.internal.HxObject" interface="1"><meta>
	<m n=":directlyUsed"/>
	<m n=":hxGen"/>
	<m n=":keep"/>
	<m n=":native"><e>"haxe.lang.IHxObject"</e></m>
</meta></class>
	<class path="cs.internal.HxObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/HxObject.hx">
		<implements path="cs.internal.IHxObject"/>
		<__hx_deleteField public="1" set="method" line="33"><f a="field:hash">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></__hx_deleteField>
		<meta>
			<m n=":hxGen"/>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.HxObject"</e></m>
		</meta>
	</class>
	<class path="cs.internal.DynamicObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/HxObject.hx" module="cs.internal.HxObject">
		<extends path="cs.internal.HxObject"/>
		<__hx_toString_depth expr="0" line="56" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":skipReflection"/>
			</meta>
		</__hx_toString_depth>
		<__hx_hashes>
			<c path="cs.NativeArray"><x path="Int"/></c>
			<meta><m n=":skipReflection"/></meta>
		</__hx_hashes>
		<__hx_dynamics>
			<c path="cs.NativeArray"><d/></c>
			<meta><m n=":skipReflection"/></meta>
		</__hx_dynamics>
		<__hx_hashes_f>
			<c path="cs.NativeArray"><x path="Int"/></c>
			<meta><m n=":skipReflection"/></meta>
		</__hx_hashes_f>
		<__hx_dynamics_f>
			<c path="cs.NativeArray"><x path="Float"/></c>
			<meta><m n=":skipReflection"/></meta>
		</__hx_dynamics_f>
		<__hx_length>
			<x path="Int"/>
			<meta><m n=":skipReflection"/></meta>
		</__hx_length>
		<__hx_length_f>
			<x path="Int"/>
			<meta><m n=":skipReflection"/></meta>
		</__hx_length_f>
		<__hx_conflicts>
			<c path="cs.internal.FieldHashConflict"/>
			<meta><m n=":skipReflection"/></meta>
		</__hx_conflicts>
		<__hx_deleteField public="1" set="method" line="76" override="1"><f a="field:hash">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></__hx_deleteField>
		<__hx_getField public="1" set="method" line="98"><f a="field:hash:throwErrors:isCheck:handleProperties">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<d/>
</f></__hx_getField>
		<__hx_setField public="1" set="method" line="118"><f a="field:hash:value:handleProperties">
	<c path="String"/>
	<x path="Int"/>
	<d/>
	<x path="Bool"/>
	<d/>
</f></__hx_setField>
		<__hx_getField_f public="1" set="method" line="146"><f a="field:hash:throwErrors:handleProperties">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></__hx_getField_f>
		<__hx_setField_f public="1" set="method" line="166"><f a="field:hash:value:handleProperties">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></__hx_setField_f>
		<__hx_getFields public="1" set="method" line="191"><f a="baseArr">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></__hx_getFields>
		<__hx_invokeField public="1" set="method" line="201">
			<f a="field:hash:dynargs">
				<c path="String"/>
				<x path="Int"/>
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__hx_invokeField>
		<toString public="1" set="method" line="213">
			<f a=""><c path="String"/></f>
			<meta><m n=":skipReflection"/></meta>
		</toString>
		<__hx_toString public="1" set="method" line="228">
			<f a=""><c path="String"/></f>
			<meta><m n=":skipReflection"/></meta>
		</__hx_toString>
		<new public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<meta><m n=":overload"/></meta>
			<overloads><new public="1" set="method" line="66">
	<f a="hashes:dynamics:hashes_f:dynamics_f">
		<c path="cs.NativeArray"><x path="Int"/></c>
		<c path="cs.NativeArray"><d/></c>
		<c path="cs.NativeArray"><x path="Int"/></c>
		<c path="cs.NativeArray"><x path="Float"/></c>
		<x path="Void"/>
	</f>
	<meta><m n=":overload"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.DynamicObject"</e></m>
		</meta>
	</class>
	<class path="cs.internal.IGenericObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/HxObject.hx" module="cs.internal.HxObject" interface="1"><meta>
	<m n=":directlyUsed"/>
	<m n=":hxGen"/>
	<m n=":keep"/>
	<m n=":native"><e>"haxe.lang.IGenericObject"</e></m>
</meta></class>
	<class path="cs.internal.HxEnum" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/HxObject.hx" module="cs.internal.HxObject">
		<paramsToString set="method" line="290" static="1">
			<f a="tag:params">
				<c path="String"/>
				<x path="haxe.ds.Vector"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":protected"/></meta>
		</paramsToString>
		<paramsGetHashCode set="method" line="306" static="1">
			<f a="index:params">
				<x path="Int"/>
				<x path="haxe.ds.Vector"><d/></x>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":protected"/>
			</meta>
		</paramsGetHashCode>
		<_hx_index set="null">
			<x path="Int"/>
			<meta><m n=":readOnly"/></meta>
		</_hx_index>
		<getTag public="1" set="method" line="278"><f a=""><c path="String"/></f></getTag>
		<getParams public="1" set="method" line="282"><f a=""><c path="Array"><a/></c></f></getParams>
		<toString public="1" set="method" line="286"><f a=""><c path="String"/></f></toString>
		<new set="method" line="274">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":protected"/>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.Enum"</e></m>
			<m n=":nativeGen"/>
		</meta>
	</class>
	<class path="cs.internal._Null.Nullable" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/Null.hx" private="1" module="cs.internal.Null">
		<ofDynamic public="1" params="D" set="method" line="79" static="1">
			<f a="obj">
				<d/>
				<c path="cs.internal._Null.Nullable"><c path="ofDynamic.D"/></c>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["if (obj == null) {\n\t\t\t\treturn new haxe.lang.Null<D>(default(D), false);\n\t\t\t} else if (typeof(D).Equals(typeof(double))) {\n\t\t\t\treturn new haxe.lang.Null<D>((D) (object) haxe.lang.Runtime.toDouble(obj), true);\n\t\t\t} else if (typeof(D).Equals(typeof(int))) {\n\t\t\t\treturn new haxe.lang.Null<D>((D) (object) haxe.lang.Runtime.toInt(obj), true);\n\t\t\t} else {\n\t\t\t\treturn new haxe.lang.Null<D>((D) obj, true);\n\t\t\t}"]]></e></m></meta>
		</ofDynamic>
		<value public="1" set="null">
			<c path="cs.internal._Null.Nullable.T"/>
			<meta><m n=":readOnly"/></meta>
		</value>
		<hasValue public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":readOnly"/></meta>
		</hasValue>
		<toDynamic public="1" set="method" line="83"><f a=""><d/></f></toDynamic>
		<new public="1" set="method" line="62">
			<f a="v:hasValue">
				<c path="cs.internal._Null.Nullable.T"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":classCode"><e><![CDATA["//This function is here to be used with Reflection, when the haxe.lang.Null type is known\n\t\tpublic static haxe.lang.Null<T> _ofDynamic(object obj) {\n\t\t\tif (obj == null) {\n\t\t\t\treturn new haxe.lang.Null<T>(default(T), false);\n\t\t\t} else if (typeof(T).Equals(typeof(double))) {\n\t\t\t\treturn new haxe.lang.Null<T>((T) (object) haxe.lang.Runtime.toDouble(obj), true);\n\t\t\t} else if (typeof(T).Equals(typeof(int))) {\n\t\t\t\treturn new haxe.lang.Null<T>((T) (object) haxe.lang.Runtime.toInt(obj), true);\n\t\t\t} else {\n\t\t\t\treturn new haxe.lang.Null<T>((T) obj, true);\n\t\t\t}\n\t\t}\n\n\t\tpublic static implicit operator haxe.lang.Null<T>(T val) {\n\t\t\treturn new haxe.lang.Null<T>(val, true);\n\t\t}\n\n\t\tpublic static implicit operator Null<T>(__NoValue__ noValue) {\n\t\t\treturn new haxe.lang.Null<T>(default(T), false);\n\t\t}\n\n\t\tpublic sealed class __NoValue__ {\n\t\t\tprivate __NoValue__() {}\n\t\t}\n\n\t\toverride public string ToString() {\n\t\t\tif (!hasValue) return \"null\";\n\t\t\telse return value.ToString();\n\t\t}\n"]]></e></m>
			<m n=":keep"/>
			<m n=":struct"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.Null"</e></m>
		</meta>
	</class>
	<typedef path="cs.internal._StringExt.NativeString" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/StringExt.hx" private="1" module="cs.internal.StringExt">
		<c path="cs.system.String"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="cs.system.collections.generic.IEnumerable_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.generic.IEnumerable_1" extern="1" interface="1">
		<extends path="cs.system.collections.IEnumerable"/>
		<GetEnumerator public="1" set="method"><f a=""><c path="cs.system.collections.generic.IEnumerator_1"><c path="cs.system.collections.generic.IEnumerable_1.T0"/></c></f></GetEnumerator>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Generic.IEnumerable`1"</e></m>
		</meta>
	</class>
	<class path="cs.system.String" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.String" extern="1" final="1">
		<implements path="cs.system.collections.generic.IEnumerable_1"><t path="cs.types.Char16"/></implements>
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IConvertible"/>
		<implements path="cs.system.IComparable_1"><c path="String"/></implements>
		<implements path="cs.system.IEquatable_1"><c path="String"/></implements>
		<implements path="cs.system.collections.IEnumerable"/>
		<Empty public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</Empty>
		<_Equals public="1" set="method" static="1">
			<f a="a:b">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"Equals"</e></m></meta>
			<overloads><Equals public="1" set="method">
	<f a="a:b:comparisonType">
		<c path="String"/>
		<c path="String"/>
		<e path="cs.system.StringComparison"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":native"><e>"Equals"</e></m></meta>
</Equals></overloads>
		</_Equals>
		<Compare public="1" set="method" static="1">
			<f a="strA:strB">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<overloads>
				<Compare public="1" set="method"><f a="strA:indexA:strB:indexB:length:culture:options">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.globalization.CultureInfo"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></Compare>
				<Compare public="1" set="method"><f a="strA:strB:culture:options">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.globalization.CultureInfo"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></Compare>
				<Compare public="1" set="method"><f a="strA:indexA:strB:indexB:length:comparisonType">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="cs.system.StringComparison"/>
	<x path="Int"/>
</f></Compare>
				<Compare public="1" set="method"><f a="strA:strB:comparisonType">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.StringComparison"/>
	<x path="Int"/>
</f></Compare>
				<Compare public="1" set="method"><f a="strA:indexA:strB:indexB:length:ignoreCase:culture">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="cs.system.globalization.CultureInfo"/>
	<x path="Int"/>
</f></Compare>
				<Compare public="1" set="method"><f a="strA:indexA:strB:indexB:length:ignoreCase">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></Compare>
				<Compare public="1" set="method"><f a="strA:indexA:strB:indexB:length">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Compare>
				<Compare public="1" set="method"><f a="strA:strB:ignoreCase:culture">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.globalization.CultureInfo"/>
	<x path="Int"/>
</f></Compare>
				<Compare public="1" set="method"><f a="strA:strB:ignoreCase">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></Compare>
			</overloads>
		</Compare>
		<CompareOrdinal public="1" set="method" static="1">
			<f a="strA:strB">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<overloads><CompareOrdinal public="1" set="method"><f a="strA:indexA:strB:indexB:length">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></CompareOrdinal></overloads>
		</CompareOrdinal>
		<IsNullOrEmpty public="1" set="method" static="1"><f a="value">
	<c path="String"/>
	<x path="Bool"/>
</f></IsNullOrEmpty>
		<Format public="1" set="method" static="1">
			<f a="format:arg0">
				<c path="String"/>
				<d/>
				<c path="String"/>
			</f>
			<overloads>
				<Format public="1" set="method"><f a="provider:format:args">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="String"/>
</f></Format>
				<Format public="1" set="method"><f a="format:args">
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="String"/>
</f></Format>
				<Format public="1" set="method"><f a="format:arg0:arg1:arg2">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></Format>
				<Format public="1" set="method"><f a="format:arg0:arg1">
	<c path="String"/>
	<d/>
	<d/>
	<c path="String"/>
</f></Format>
			</overloads>
		</Format>
		<Copy public="1" set="method" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></Copy>
		<Concat public="1" set="method" static="1">
			<f a="arg0">
				<d/>
				<c path="String"/>
			</f>
			<overloads>
				<Concat public="1" set="method"><f a="values">
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="String"/>
</f></Concat>
				<Concat public="1" set="method"><f a="args">
	<c path="cs.NativeArray"><d/></c>
	<c path="String"/>
</f></Concat>
				<Concat public="1" set="method"><f a="str0:str1:str2:str3">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></Concat>
				<Concat public="1" set="method"><f a="str0:str1:str2">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></Concat>
				<Concat public="1" set="method"><f a="str0:str1">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></Concat>
				<Concat public="1" set="method"><f a="arg0:arg1:arg2:arg3">
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></Concat>
				<Concat public="1" set="method"><f a="arg0:arg1:arg2">
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></Concat>
				<Concat public="1" set="method"><f a="arg0:arg1">
	<d/>
	<d/>
	<c path="String"/>
</f></Concat>
			</overloads>
		</Concat>
		<Intern public="1" set="method" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></Intern>
		<IsInterned public="1" set="method" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></IsInterned>
		<Join public="1" set="method" static="1">
			<f a="separator:value">
				<c path="String"/>
				<c path="cs.NativeArray"><c path="String"/></c>
				<c path="String"/>
			</f>
			<overloads><Join public="1" set="method"><f a="separator:value:startIndex:count">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></Join></overloads>
		</Join>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Length public="1" get="accessor" set="null"><x path="Int"/></Length>
		<get_Chars final="1" public="1" set="method"><f a="index">
	<x path="Int"/>
	<t path="cs.types.Char16"/>
</f></get_Chars>
		<Clone final="1" public="1" set="method"><f a=""><d/></f></Clone>
		<GetTypeCode final="1" public="1" set="method"><f a=""><e path="cs.system.TypeCode"/></f></GetTypeCode>
		<CopyTo final="1" public="1" set="method"><f a="sourceIndex:destination:destinationIndex:count">
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<ToCharArray final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><t path="cs.types.Char16"/></c></f>
			<overloads><ToCharArray final="1" public="1" set="method"><f a="startIndex:length">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
</f></ToCharArray></overloads>
		</ToCharArray>
		<Split final="1" public="1" set="method">
			<f a="separator">
				<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
				<c path="cs.NativeArray"><c path="String"/></c>
			</f>
			<overloads>
				<Split final="1" public="1" set="method"><f a="separator:options">
	<c path="cs.NativeArray"><c path="String"/></c>
	<e path="cs.system.StringSplitOptions"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></Split>
				<Split final="1" public="1" set="method"><f a="separator:options">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<e path="cs.system.StringSplitOptions"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></Split>
				<Split final="1" public="1" set="method"><f a="separator:count:options">
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Int"/>
	<e path="cs.system.StringSplitOptions"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></Split>
				<Split final="1" public="1" set="method"><f a="separator:count:options">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<e path="cs.system.StringSplitOptions"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></Split>
				<Split final="1" public="1" set="method"><f a="separator:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></Split>
			</overloads>
		</Split>
		<Substring final="1" public="1" set="method">
			<f a="startIndex">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<overloads><Substring final="1" public="1" set="method"><f a="startIndex:length">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></Substring></overloads>
		</Substring>
		<Trim final="1" public="1" set="method">
			<f a=""><c path="String"/></f>
			<overloads><Trim final="1" public="1" set="method"><f a="trimChars">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<c path="String"/>
</f></Trim></overloads>
		</Trim>
		<TrimStart final="1" public="1" set="method"><f a="trimChars">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<c path="String"/>
</f></TrimStart>
		<TrimEnd final="1" public="1" set="method"><f a="trimChars">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<c path="String"/>
</f></TrimEnd>
		<CompareTo final="1" public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads><CompareTo final="1" public="1" set="method"><f a="strB">
	<c path="String"/>
	<x path="Int"/>
</f></CompareTo></overloads>
		</CompareTo>
		<EndsWith final="1" public="1" set="method">
			<f a="value">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<overloads>
				<EndsWith final="1" public="1" set="method"><f a="value:comparisonType">
	<c path="String"/>
	<e path="cs.system.StringComparison"/>
	<x path="Bool"/>
</f></EndsWith>
				<EndsWith final="1" public="1" set="method"><f a="value:ignoreCase:culture">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.globalization.CultureInfo"/>
	<x path="Bool"/>
</f></EndsWith>
			</overloads>
		</EndsWith>
		<IndexOfAny final="1" public="1" set="method">
			<f a="anyOf">
				<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
				<x path="Int"/>
			</f>
			<overloads>
				<IndexOfAny final="1" public="1" set="method"><f a="anyOf:startIndex:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOfAny>
				<IndexOfAny final="1" public="1" set="method"><f a="anyOf:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOfAny>
			</overloads>
		</IndexOfAny>
		<IndexOf final="1" public="1" set="method">
			<f a="value:comparisonType">
				<c path="String"/>
				<e path="cs.system.StringComparison"/>
				<x path="Int"/>
			</f>
			<overloads>
				<IndexOf final="1" public="1" set="method"><f a="value:startIndex:count">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf final="1" public="1" set="method"><f a="value:startIndex">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf final="1" public="1" set="method"><f a="value:startIndex:count">
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf final="1" public="1" set="method"><f a="value:startIndex">
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf final="1" public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf final="1" public="1" set="method"><f a="value:startIndex:count:comparisonType">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="cs.system.StringComparison"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf final="1" public="1" set="method"><f a="value:startIndex:comparisonType">
	<c path="String"/>
	<x path="Int"/>
	<e path="cs.system.StringComparison"/>
	<x path="Int"/>
</f></IndexOf>
			</overloads>
		</IndexOf>
		<LastIndexOf final="1" public="1" set="method">
			<f a="value:comparisonType">
				<c path="String"/>
				<e path="cs.system.StringComparison"/>
				<x path="Int"/>
			</f>
			<overloads>
				<LastIndexOf final="1" public="1" set="method"><f a="value:startIndex:count">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf final="1" public="1" set="method"><f a="value:startIndex">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf final="1" public="1" set="method"><f a="value:startIndex:count">
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf final="1" public="1" set="method"><f a="value:startIndex">
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf final="1" public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf final="1" public="1" set="method"><f a="value:startIndex:count:comparisonType">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="cs.system.StringComparison"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf final="1" public="1" set="method"><f a="value:startIndex:comparisonType">
	<c path="String"/>
	<x path="Int"/>
	<e path="cs.system.StringComparison"/>
	<x path="Int"/>
</f></LastIndexOf>
			</overloads>
		</LastIndexOf>
		<LastIndexOfAny final="1" public="1" set="method">
			<f a="anyOf">
				<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
				<x path="Int"/>
			</f>
			<overloads>
				<LastIndexOfAny final="1" public="1" set="method"><f a="anyOf:startIndex:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOfAny>
				<LastIndexOfAny final="1" public="1" set="method"><f a="anyOf:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOfAny>
			</overloads>
		</LastIndexOfAny>
		<Contains final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Bool"/>
</f></Contains>
		<Normalize final="1" public="1" set="method">
			<f a=""><c path="String"/></f>
			<overloads><Normalize final="1" public="1" set="method"><f a="normalizationForm">
	<e path="cs.system.text.NormalizationForm"/>
	<c path="String"/>
</f></Normalize></overloads>
		</Normalize>
		<IsNormalized final="1" public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<overloads><IsNormalized final="1" public="1" set="method"><f a="normalizationForm">
	<e path="cs.system.text.NormalizationForm"/>
	<x path="Bool"/>
</f></IsNormalized></overloads>
		</IsNormalized>
		<Remove final="1" public="1" set="method">
			<f a="startIndex">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<overloads><Remove final="1" public="1" set="method"><f a="startIndex:count">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></Remove></overloads>
		</Remove>
		<PadLeft final="1" public="1" set="method">
			<f a="totalWidth">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<overloads><PadLeft final="1" public="1" set="method"><f a="totalWidth:paddingChar">
	<x path="Int"/>
	<t path="cs.types.Char16"/>
	<c path="String"/>
</f></PadLeft></overloads>
		</PadLeft>
		<PadRight final="1" public="1" set="method">
			<f a="totalWidth">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<overloads><PadRight final="1" public="1" set="method"><f a="totalWidth:paddingChar">
	<x path="Int"/>
	<t path="cs.types.Char16"/>
	<c path="String"/>
</f></PadRight></overloads>
		</PadRight>
		<StartsWith final="1" public="1" set="method">
			<f a="value">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<overloads>
				<StartsWith final="1" public="1" set="method"><f a="value:ignoreCase:culture">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.globalization.CultureInfo"/>
	<x path="Bool"/>
</f></StartsWith>
				<StartsWith final="1" public="1" set="method"><f a="value:comparisonType">
	<c path="String"/>
	<e path="cs.system.StringComparison"/>
	<x path="Bool"/>
</f></StartsWith>
			</overloads>
		</StartsWith>
		<Replace final="1" public="1" set="method">
			<f a="oldChar:newChar">
				<t path="cs.types.Char16"/>
				<t path="cs.types.Char16"/>
				<c path="String"/>
			</f>
			<overloads><Replace final="1" public="1" set="method"><f a="oldValue:newValue">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></Replace></overloads>
		</Replace>
		<ToLower final="1" public="1" set="method">
			<f a=""><c path="String"/></f>
			<overloads><ToLower final="1" public="1" set="method"><f a="culture">
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="String"/>
</f></ToLower></overloads>
		</ToLower>
		<ToLowerInvariant final="1" public="1" set="method"><f a=""><c path="String"/></f></ToLowerInvariant>
		<ToUpper final="1" public="1" set="method">
			<f a=""><c path="String"/></f>
			<overloads><ToUpper final="1" public="1" set="method"><f a="culture">
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="String"/>
</f></ToUpper></overloads>
		</ToUpper>
		<ToUpperInvariant final="1" public="1" set="method"><f a=""><c path="String"/></f></ToUpperInvariant>
		<ToString public="1" set="method">
			<f a=""><c path="String"/></f>
			<overloads><ToString final="1" public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString></overloads>
		</ToString>
		<Insert final="1" public="1" set="method"><f a="startIndex:value">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></Insert>
		<get_Length final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Length>
		<GetEnumerator final="1" public="1" set="method">
			<f a=""><c path="cs.system.CharEnumerator"/></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</GetEnumerator>
		<new final="1" public="1" set="method">
			<f a="value:startIndex:length">
				<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="c:count">
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.String"</e></m>
		</meta>
	</class>
	<class path="cs.internal.StringExt" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/StringExt.hx">
		<empty set="null" expr="new NativeString(cast 0, 0)" line="30" static="1">
			<c path="cs.system.String"/>
			<meta>
				<m n=":value"><e>new NativeString(cast 0, 0)</e></m>
				<m n=":readOnly"/>
			</meta>
		</empty>
		<charAt public="1" set="method" line="32" static="1"><f a="me:index">
	<t path="cs.internal._StringExt.NativeString"/>
	<x path="Int"/>
	<t path="cs.internal._StringExt.NativeString"/>
</f></charAt>
		<charCodeAt public="1" set="method" line="39" static="1"><f a="me:index">
	<t path="cs.internal._StringExt.NativeString"/>
	<x path="Int"/>
	<x path="Null"><x path="Int"/></x>
</f></charCodeAt>
		<indexOf public="1" set="method" line="46" static="1"><f a="me:str:?startIndex">
	<t path="cs.internal._StringExt.NativeString"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOf>
		<lastIndexOf public="1" set="method" line="60" static="1">
			<f a="me:str:?startIndex">
				<t path="cs.internal._StringExt.NativeString"/>
				<t path="cs.internal._StringExt.NativeString"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</lastIndexOf>
		<split public="1" set="method" line="102" static="1">
			<f a="me:delimiter">
				<t path="cs.internal._StringExt.NativeString"/>
				<t path="cs.internal._StringExt.NativeString"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</split>
		<substr public="1" set="method" line="119" static="1"><f a="me:pos:?len">
	<t path="cs.internal._StringExt.NativeString"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></substr>
		<substring public="1" set="method" line="146" static="1"><f a="me:startIndex:?endIndex">
	<t path="cs.internal._StringExt.NativeString"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></substring>
		<toString public="1" set="method" line="170" static="1"><f a="me">
	<t path="cs.internal._StringExt.NativeString"/>
	<t path="cs.internal._StringExt.NativeString"/>
</f></toString>
		<toLowerCase public="1" set="method" line="174" static="1"><f a="me">
	<t path="cs.internal._StringExt.NativeString"/>
	<c path="String"/>
</f></toLowerCase>
		<toUpperCase public="1" set="method" line="178" static="1"><f a="me">
	<t path="cs.internal._StringExt.NativeString"/>
	<c path="String"/>
</f></toUpperCase>
		<toNativeString public="1" set="method" line="182" static="1"><f a="me">
	<t path="cs.internal._StringExt.NativeString"/>
	<t path="cs.internal._StringExt.NativeString"/>
</f></toNativeString>
		<fromCharCode public="1" set="method" line="186" static="1"><f a="code">
	<x path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":keep"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.StringExt"</e></m>
		</meta>
	</class>
	<class path="cs.internal.StringRefl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/internal/StringExt.hx" module="cs.internal.StringExt">
		<fields public="1" expr="[&quot;length&quot;, &quot;toUpperCase&quot;, &quot;toLowerCase&quot;, &quot;charAt&quot;, &quot;charCodeAt&quot;, &quot;indexOf&quot;, &quot;lastIndexOf&quot;, &quot;split&quot;, &quot;substr&quot;, &quot;substring&quot;]" line="193" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["length", "toUpperCase", "toLowerCase", "charAt", "charCodeAt", "indexOf", "lastIndexOf", "split", "substr", "substring"]</e></m></meta>
		</fields>
		<handleGetField public="1" set="method" line="197" static="1"><f a="str:f:throwErrors">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<d/>
</f></handleGetField>
		<handleCallField public="1" set="method" line="211" static="1"><f a="str:f:args">
	<t path="cs.internal._StringExt.NativeString"/>
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></handleCallField>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":keep"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"haxe.lang.StringRefl"</e></m>
		</meta>
	</class>
	<class path="haxe.io.Input" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Input.hx">
		<readByte public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="64">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<readAll public="1" set="method" line="106">
			<f a="?bufsize">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return all available data.

		The `bufsize` optional argument specifies the size of chunks by
		which data is read. Its default value is target-specific.</haxe_doc>
		</readAll>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="cs.io.NativeInput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/io/NativeInput.hx">
		<extends path="haxe.io.Input"/>
		<stream><c path="cs.system.io.Stream"/></stream>
		<_eof><x path="Bool"/></_eof>
		<readByte public="1" set="method" line="44" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="53" override="1"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="68"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="37"><f a="stream">
	<c path="cs.system.io.Stream"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.io.Output" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Output.hx">
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<writeFullBytes public="1" set="method" line="120">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Unlike `writeBytes`, this method tries to write the exact `len` amount of bytes.</haxe_doc>
		</writeFullBytes>
		<writeString public="1" set="method" line="278">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `s` string.</haxe_doc>
		</writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the `writeByte` and maybe the `write`, `flush` and `close`
	methods. See `File.write` and `String.write` for two ways of creating an
	Output.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="cs.io.NativeOutput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/io/NativeOutput.hx">
		<extends path="haxe.io.Output"/>
		<stream><c path="cs.system.io.Stream"/></stream>
		<writeByte public="1" set="method" line="40" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<close public="1" set="method" line="44"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="34"><f a="stream">
	<c path="cs.system.io.Stream"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="cs.system.Delegate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Delegate" extern="1" abstract="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<CreateDelegate public="1" set="method" static="1">
			<f a="type:firstArgument:method:throwOnBindFailure">
				<c path="cs.system.Type"/>
				<d/>
				<c path="cs.system.reflection.MethodInfo"/>
				<x path="Bool"/>
				<c path="cs.system.Delegate"/>
			</f>
			<overloads>
				<CreateDelegate public="1" set="method"><f a="type:target:method:ignoreCase">
	<c path="cs.system.Type"/>
	<d/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Delegate"/>
</f></CreateDelegate>
				<CreateDelegate public="1" set="method"><f a="type:target:method:ignoreCase:throwOnBindFailure">
	<c path="cs.system.Type"/>
	<d/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="cs.system.Delegate"/>
</f></CreateDelegate>
				<CreateDelegate public="1" set="method"><f a="type:target:method:ignoreCase">
	<c path="cs.system.Type"/>
	<c path="cs.system.Type"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Delegate"/>
</f></CreateDelegate>
				<CreateDelegate public="1" set="method"><f a="type:target:method">
	<c path="cs.system.Type"/>
	<c path="cs.system.Type"/>
	<c path="String"/>
	<c path="cs.system.Delegate"/>
</f></CreateDelegate>
				<CreateDelegate public="1" set="method"><f a="type:target:method:ignoreCase:throwOnBindFailure">
	<c path="cs.system.Type"/>
	<c path="cs.system.Type"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="cs.system.Delegate"/>
</f></CreateDelegate>
				<CreateDelegate public="1" set="method"><f a="type:target:method">
	<c path="cs.system.Type"/>
	<d/>
	<c path="String"/>
	<c path="cs.system.Delegate"/>
</f></CreateDelegate>
				<CreateDelegate public="1" set="method"><f a="type:method">
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.MethodInfo"/>
	<c path="cs.system.Delegate"/>
</f></CreateDelegate>
				<CreateDelegate public="1" set="method"><f a="type:method:throwOnBindFailure">
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.MethodInfo"/>
	<x path="Bool"/>
	<c path="cs.system.Delegate"/>
</f></CreateDelegate>
				<CreateDelegate public="1" set="method"><f a="type:firstArgument:method">
	<c path="cs.system.Type"/>
	<d/>
	<c path="cs.system.reflection.MethodInfo"/>
	<c path="cs.system.Delegate"/>
</f></CreateDelegate>
			</overloads>
		</CreateDelegate>
		<Combine public="1" set="method" static="1">
			<f a="a:b">
				<c path="cs.system.Delegate"/>
				<c path="cs.system.Delegate"/>
				<c path="cs.system.Delegate"/>
			</f>
			<overloads><Combine public="1" set="method"><f a="delegates">
	<c path="cs.NativeArray"><c path="cs.system.Delegate"/></c>
	<c path="cs.system.Delegate"/>
</f></Combine></overloads>
		</Combine>
		<Remove public="1" set="method" static="1"><f a="source:value">
	<c path="cs.system.Delegate"/>
	<c path="cs.system.Delegate"/>
	<c path="cs.system.Delegate"/>
</f></Remove>
		<RemoveAll public="1" set="method" static="1"><f a="source:value">
	<c path="cs.system.Delegate"/>
	<c path="cs.system.Delegate"/>
	<c path="cs.system.Delegate"/>
</f></RemoveAll>
		<op_Equality public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Delegate"/>
	<c path="cs.system.Delegate"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Delegate"/>
	<c path="cs.system.Delegate"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Target public="1" get="accessor" set="null"><d/></Target>
		<Method public="1" get="accessor" set="null"><c path="cs.system.reflection.MethodInfo"/></Method>
		<get_Method final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.MethodInfo"/></f></get_Method>
		<get_Target final="1" public="1" set="method"><f a=""><d/></f></get_Target>
		<DynamicInvoke final="1" public="1" set="method"><f a="args">
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></DynamicInvoke>
		<DynamicInvokeImpl set="method">
			<f a="args">
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<meta><m n=":protected"/></meta>
		</DynamicInvokeImpl>
		<Clone public="1" set="method"><f a=""><d/></f></Clone>
		<GetMethodImpl set="method">
			<f a=""><c path="cs.system.reflection.MethodInfo"/></f>
			<meta><m n=":protected"/></meta>
		</GetMethodImpl>
		<GetObjectData public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<GetInvocationList public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Delegate"/></c></f></GetInvocationList>
		<CombineImpl set="method">
			<f a="d">
				<c path="cs.system.Delegate"/>
				<c path="cs.system.Delegate"/>
			</f>
			<meta><m n=":protected"/></meta>
		</CombineImpl>
		<RemoveImpl set="method">
			<f a="d">
				<c path="cs.system.Delegate"/>
				<c path="cs.system.Delegate"/>
			</f>
			<meta><m n=":protected"/></meta>
		</RemoveImpl>
		<new final="1" set="method">
			<f a="target:method">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
			<overloads><new final="1" set="method">
	<f a="target:method">
		<c path="cs.system.Type"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":protected"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Delegate"</e></m>
		</meta>
	</class>
	<class path="cs.system.MulticastDelegate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.MulticastDelegate" extern="1" abstract="1">
		<extends path="cs.system.Delegate"/>
		<op_Equality public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.MulticastDelegate"/>
	<c path="cs.system.MulticastDelegate"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.MulticastDelegate"/>
	<c path="cs.system.MulticastDelegate"/>
	<x path="Bool"/>
</f></op_Inequality>
		<GetObjectData public="1" set="method" override="1"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<DynamicInvokeImpl final="1" set="method" override="1">
			<f a="args">
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<meta><m n=":protected"/></meta>
		</DynamicInvokeImpl>
		<GetInvocationList final="1" public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.Delegate"/></c></f></GetInvocationList>
		<CombineImpl final="1" set="method" override="1">
			<f a="follow">
				<c path="cs.system.Delegate"/>
				<c path="cs.system.Delegate"/>
			</f>
			<meta><m n=":protected"/></meta>
		</CombineImpl>
		<RemoveImpl final="1" set="method" override="1">
			<f a="value">
				<c path="cs.system.Delegate"/>
				<c path="cs.system.Delegate"/>
			</f>
			<meta><m n=":protected"/></meta>
		</RemoveImpl>
		<new final="1" set="method">
			<f a="target:method">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
			<overloads><new final="1" set="method">
	<f a="target:method">
		<c path="cs.system.Type"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":protected"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.MulticastDelegate"</e></m>
		</meta>
	</class>
	<class path="cs.system.Delegate_Action_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Action_1" module="cs.system.Action_1" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" params="T0" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Action_1"><c path="op_Addition.T0"/></x>
	<x path="cs.system.Action_1"><c path="op_Addition.T0"/></x>
	<x path="cs.system.Action_1"><c path="op_Addition.T0"/></x>
</f></op_Addition>
		<op_Subtraction public="1" params="T0" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Action_1"><c path="op_Subtraction.T0"/></x>
	<x path="cs.system.Action_1"><c path="op_Subtraction.T0"/></x>
	<x path="cs.system.Action_1"><c path="op_Subtraction.T0"/></x>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="obj">
	<c path="cs.system.Delegate_Action_1.T0"/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="obj:callback:object">
	<c path="cs.system.Delegate_Action_1.T0"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Action`1"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.Action_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Action_1">
		<from><icast field="FromHaxeFunction"><f a="">
	<c path="FromHaxeFunction.T0"/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.Delegate_Action_1"><c path="cs.system.Action_1.T0"/></c></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._Action_1.Action_1_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Action_1" private="1" module="cs.system.Action_1" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="cs.system.Action_1.T0"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.Action_1"><c path="cs.system.Action_1.T0"/></x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" params="T0" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="FromHaxeFunction.T0"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.Action_1"><c path="FromHaxeFunction.T0"/></x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_Action_1"><c path="cs.system.Action_1.T0"/></c>
	<c path="cs.system.Delegate_Action_1"><c path="cs.system.Action_1.T0"/></c>
</f></AsDelegate>
	<Add public="1" params="T0" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Action_1"><c path="Add.T0"/></x>
			<x path="cs.system.Action_1"><c path="Add.T0"/></x>
			<x path="cs.system.Action_1"><c path="Add.T0"/></x>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" params="T0" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Action_1"><c path="Remove.T0"/></x>
			<x path="cs.system.Action_1"><c path="Remove.T0"/></x>
			<x path="cs.system.Action_1"><c path="Remove.T0"/></x>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._Action_1.Action_1_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Action_1" private="1" module="cs.system.Action_1" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="cs.system.Action_1.T0"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.Action_1"><c path="cs.system.Action_1.T0"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" params="T0" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="FromHaxeFunction.T0"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.Action_1"><c path="FromHaxeFunction.T0"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_Action_1"><c path="cs.system.Action_1.T0"/></c>
	<c path="cs.system.Delegate_Action_1"><c path="cs.system.Action_1.T0"/></c>
</f></AsDelegate>
		<Add public="1" params="T0" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Action_1"><c path="Add.T0"/></x>
				<x path="cs.system.Action_1"><c path="Add.T0"/></x>
				<x path="cs.system.Action_1"><c path="Add.T0"/></x>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" params="T0" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Action_1"><c path="Remove.T0"/></x>
				<x path="cs.system.Action_1"><c path="Remove.T0"/></x>
				<x path="cs.system.Action_1"><c path="Remove.T0"/></x>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<enum path="cs.system.ActivationContext_ContextForm" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ActivationContext" module="cs.system.ActivationContext">
		<Loose><meta><m n=":csNative"><e>0</e></m></meta></Loose>
		<StoreBounded><meta><m n=":csNative"><e>1</e></m></meta></StoreBounded>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.ActivationContext.ContextForm"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.IDisposable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.IDisposable" extern="1" interface="1">
		<Dispose public="1" set="method"><f a=""><x path="Void"/></f></Dispose>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IDisposable"</e></m>
		</meta>
	</class>
	<class path="cs.system.ActivationContext" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ActivationContext" extern="1" final="1">
		<implements path="cs.system.IDisposable"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<CreatePartialActivationContext public="1" set="method" static="1">
			<f a="identity">
				<c path="cs.system.ApplicationIdentity"/>
				<c path="cs.system.ActivationContext"/>
			</f>
			<overloads><CreatePartialActivationContext public="1" set="method"><f a="identity:manifestPaths">
	<c path="cs.system.ApplicationIdentity"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.system.ActivationContext"/>
</f></CreatePartialActivationContext></overloads>
		</CreatePartialActivationContext>
		<Identity public="1" get="accessor" set="null"><c path="cs.system.ApplicationIdentity"/></Identity>
		<Form public="1" get="accessor" set="null"><e path="cs.system.ActivationContext_ContextForm"/></Form>
		<get_Form final="1" public="1" set="method"><f a=""><e path="cs.system.ActivationContext_ContextForm"/></f></get_Form>
		<get_Identity final="1" public="1" set="method"><f a=""><c path="cs.system.ApplicationIdentity"/></f></get_Identity>
		<Dispose final="1" public="1" set="method"><f a=""><x path="Void"/></f></Dispose>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ActivationContext"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._Activator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._Activator" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._Activator"</e></m>
		</meta>
	</class>
	<class path="cs.system.Activator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Activator" extern="1" final="1">
		<implements path="cs.system.runtime.interopservices._Activator"/>
		<CreateComInstanceFrom public="1" set="method" static="1">
			<f a="assemblyName:typeName">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.runtime.remoting.ObjectHandle"/>
			</f>
			<overloads><CreateComInstanceFrom public="1" set="method"><f a="assemblyName:typeName:hashValue:hashAlgorithm">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<e path="cs.system.configuration.assemblies.AssemblyHashAlgorithm"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateComInstanceFrom></overloads>
		</CreateComInstanceFrom>
		<CreateInstanceFrom public="1" set="method" static="1">
			<f a="assemblyFile:typeName">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.runtime.remoting.ObjectHandle"/>
			</f>
			<overloads>
				<CreateInstanceFrom public="1" set="method"><f a="domain:assemblyFile:typeName:ignoreCase:bindingAttr:binder:args:culture:activationAttributes:securityAttributes">
	<c path="cs.system.AppDomain"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstanceFrom>
				<CreateInstanceFrom public="1" set="method"><f a="domain:assemblyFile:typeName">
	<c path="cs.system.AppDomain"/>
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstanceFrom>
				<CreateInstanceFrom public="1" set="method"><f a="assemblyFile:typeName:ignoreCase:bindingAttr:binder:args:culture:activationAttributes:securityInfo">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstanceFrom>
				<CreateInstanceFrom public="1" set="method"><f a="assemblyFile:typeName:activationAttributes">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstanceFrom>
			</overloads>
		</CreateInstanceFrom>
		<CreateInstance public="1" set="method" static="1">
			<f a="assemblyName:typeName">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.runtime.remoting.ObjectHandle"/>
			</f>
			<overloads>
				<CreateInstance public="1" set="method"><f a="type:nonPublic">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<d/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="type:bindingAttr:binder:args:culture:activationAttributes">
	<c path="cs.system.Type"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="type:bindingAttr:binder:args:culture">
	<c path="cs.system.Type"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<d/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="type:args:activationAttributes">
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="type:args">
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="type">
	<c path="cs.system.Type"/>
	<d/>
</f></CreateInstance>
				<CreateInstance public="1" params="M0" set="method"><f a=""><c path="CreateInstance.M0"/></f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="domain:assemblyName:typeName:ignoreCase:bindingAttr:binder:args:culture:activationAttributes:securityAttributes">
	<c path="cs.system.AppDomain"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="domain:assemblyName:typeName">
	<c path="cs.system.AppDomain"/>
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="activationContext:activationCustomData">
	<c path="cs.system.ActivationContext"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="activationContext">
	<c path="cs.system.ActivationContext"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="assemblyName:typeName:ignoreCase:bindingAttr:binder:args:culture:activationAttributes:securityInfo">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="assemblyName:typeName:activationAttributes">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstance>
			</overloads>
		</CreateInstance>
		<GetObject public="1" set="method" static="1">
			<f a="type:url">
				<c path="cs.system.Type"/>
				<c path="String"/>
				<d/>
			</f>
			<overloads><GetObject public="1" set="method"><f a="type:url:state">
	<c path="cs.system.Type"/>
	<c path="String"/>
	<d/>
	<d/>
</f></GetObject></overloads>
		</GetObject>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Activator"</e></m>
		</meta>
	</class>
	<class path="cs.system.AppDomain_Initializer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AppDomain" module="cs.system.AppDomain" extern="1">
		<Initialize final="1" public="1" set="method"><f a=""><x path="Void"/></f></Initialize>
		<new final="1" public="1" set="method"><f a="initializer:arguments">
	<x path="cs.system.AppDomainInitializer"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.AppDomain.Initializer"</e></m>
		</meta>
	</class>
	<class path="cs.system.AppDomain_Loader" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AppDomain" module="cs.system.AppDomain" extern="1">
		<Load final="1" public="1" set="method"><f a=""><x path="Void"/></f></Load>
		<new final="1" public="1" set="method"><f a="assembly">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.AppDomain.Loader"</e></m>
		</meta>
	</class>
	<class path="cs.system.MarshalByRefObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.MarshalByRefObject" extern="1" abstract="1">
		<CreateObjRef public="1" set="method"><f a="requestedType">
	<c path="cs.system.Type"/>
	<c path="cs.system.runtime.remoting.ObjRef"/>
</f></CreateObjRef>
		<GetLifetimeService final="1" public="1" set="method"><f a=""><d/></f></GetLifetimeService>
		<InitializeLifetimeService public="1" set="method"><f a=""><d/></f></InitializeLifetimeService>
		<MemberwiseClone final="1" set="method">
			<f a="cloneIdentity">
				<x path="Bool"/>
				<c path="cs.system.MarshalByRefObject"/>
			</f>
			<meta><m n=":protected"/></meta>
		</MemberwiseClone>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.MarshalByRefObject"</e></m>
		</meta>
	</class>
	<class path="cs.system._AppDomain" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system._AppDomain" extern="1" interface="1">
		<UnhandledException>
			<x path="cs.system.UnhandledExceptionEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</UnhandledException>
		<TypeResolve>
			<x path="cs.system.ResolveEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</TypeResolve>
		<ResourceResolve>
			<x path="cs.system.ResolveEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</ResourceResolve>
		<ProcessExit>
			<x path="cs.system.EventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</ProcessExit>
		<DomainUnload>
			<x path="cs.system.EventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</DomainUnload>
		<AssemblyResolve>
			<x path="cs.system.ResolveEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</AssemblyResolve>
		<AssemblyLoad>
			<x path="cs.system.AssemblyLoadEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</AssemblyLoad>
		<ShadowCopyFiles public="1" get="accessor" set="null"><x path="Bool"/></ShadowCopyFiles>
		<RelativeSearchPath public="1" get="accessor" set="null"><c path="String"/></RelativeSearchPath>
		<FriendlyName public="1" get="accessor" set="null"><c path="String"/></FriendlyName>
		<Evidence public="1" get="accessor" set="null"><c path="cs.system.security.policy.Evidence"/></Evidence>
		<DynamicDirectory public="1" get="accessor" set="null"><c path="String"/></DynamicDirectory>
		<BaseDirectory public="1" get="accessor" set="null"><c path="String"/></BaseDirectory>
		<add_AssemblyLoad public="1" set="method"><f a="value">
	<x path="cs.system.AssemblyLoadEventHandler"/>
	<x path="Void"/>
</f></add_AssemblyLoad>
		<remove_AssemblyLoad public="1" set="method"><f a="value">
	<x path="cs.system.AssemblyLoadEventHandler"/>
	<x path="Void"/>
</f></remove_AssemblyLoad>
		<add_AssemblyResolve public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></add_AssemblyResolve>
		<remove_AssemblyResolve public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></remove_AssemblyResolve>
		<add_DomainUnload public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></add_DomainUnload>
		<remove_DomainUnload public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></remove_DomainUnload>
		<add_ProcessExit public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></add_ProcessExit>
		<remove_ProcessExit public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></remove_ProcessExit>
		<add_ResourceResolve public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></add_ResourceResolve>
		<remove_ResourceResolve public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></remove_ResourceResolve>
		<add_TypeResolve public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></add_TypeResolve>
		<remove_TypeResolve public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></remove_TypeResolve>
		<add_UnhandledException public="1" set="method"><f a="value">
	<x path="cs.system.UnhandledExceptionEventHandler"/>
	<x path="Void"/>
</f></add_UnhandledException>
		<remove_UnhandledException public="1" set="method"><f a="value">
	<x path="cs.system.UnhandledExceptionEventHandler"/>
	<x path="Void"/>
</f></remove_UnhandledException>
		<get_BaseDirectory public="1" set="method"><f a=""><c path="String"/></f></get_BaseDirectory>
		<get_DynamicDirectory public="1" set="method"><f a=""><c path="String"/></f></get_DynamicDirectory>
		<get_Evidence public="1" set="method"><f a=""><c path="cs.system.security.policy.Evidence"/></f></get_Evidence>
		<get_FriendlyName public="1" set="method"><f a=""><c path="String"/></f></get_FriendlyName>
		<get_RelativeSearchPath public="1" set="method"><f a=""><c path="String"/></f></get_RelativeSearchPath>
		<get_ShadowCopyFiles public="1" set="method"><f a=""><x path="Bool"/></f></get_ShadowCopyFiles>
		<AppendPrivatePath public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></AppendPrivatePath>
		<ClearPrivatePath public="1" set="method"><f a=""><x path="Void"/></f></ClearPrivatePath>
		<ClearShadowCopyPath public="1" set="method"><f a=""><x path="Void"/></f></ClearShadowCopyPath>
		<CreateInstance public="1" set="method">
			<f a="assemblyName:typeName">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.runtime.remoting.ObjectHandle"/>
			</f>
			<overloads>
				<CreateInstance public="1" set="method"><f a="assemblyName:typeName:ignoreCase:bindingAttr:binder:args:culture:activationAttributes:securityAttributes">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="assemblyName:typeName:activationAttributes">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstance>
			</overloads>
		</CreateInstance>
		<CreateInstanceFrom public="1" set="method">
			<f a="assemblyFile:typeName">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.runtime.remoting.ObjectHandle"/>
			</f>
			<overloads>
				<CreateInstanceFrom public="1" set="method"><f a="assemblyFile:typeName:ignoreCase:bindingAttr:binder:args:culture:activationAttributes:securityAttributes">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstanceFrom>
				<CreateInstanceFrom public="1" set="method"><f a="assemblyFile:typeName:activationAttributes">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstanceFrom>
			</overloads>
		</CreateInstanceFrom>
		<DefineDynamicAssembly public="1" set="method">
			<f a="name:access">
				<c path="cs.system.reflection.AssemblyName"/>
				<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
				<c path="cs.system.reflection.emit.AssemblyBuilder"/>
			</f>
			<overloads>
				<DefineDynamicAssembly public="1" set="method"><f a="name:access:dir:evidence:requiredPermissions:optionalPermissions:refusedPermissions:isSynchronized">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<x path="Bool"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly public="1" set="method"><f a="name:access:dir:evidence:requiredPermissions:optionalPermissions:refusedPermissions">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly public="1" set="method"><f a="name:access:dir:requiredPermissions:optionalPermissions:refusedPermissions">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="String"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly public="1" set="method"><f a="name:access:evidence:requiredPermissions:optionalPermissions:refusedPermissions">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly public="1" set="method"><f a="name:access:requiredPermissions:optionalPermissions:refusedPermissions">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly public="1" set="method"><f a="name:access:dir:evidence">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly public="1" set="method"><f a="name:access:dir">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="String"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly public="1" set="method"><f a="name:access:evidence">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
			</overloads>
		</DefineDynamicAssembly>
		<DoCallBack public="1" set="method"><f a="theDelegate">
	<x path="cs.system.CrossAppDomainDelegate"/>
	<x path="Void"/>
</f></DoCallBack>
		<ExecuteAssembly public="1" set="method">
			<f a="assemblyFile">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<overloads>
				<ExecuteAssembly public="1" set="method"><f a="assemblyFile:assemblySecurity:args">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Int"/>
</f></ExecuteAssembly>
				<ExecuteAssembly public="1" set="method"><f a="assemblyFile:assemblySecurity">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<x path="Int"/>
</f></ExecuteAssembly>
			</overloads>
		</ExecuteAssembly>
		<GetAssemblies public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.Assembly"/></c></f></GetAssemblies>
		<GetData public="1" set="method"><f a="name">
	<c path="String"/>
	<d/>
</f></GetData>
		<GetLifetimeService public="1" set="method"><f a=""><d/></f></GetLifetimeService>
		<GetType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<InitializeLifetimeService public="1" set="method"><f a=""><d/></f></InitializeLifetimeService>
		<Load public="1" set="method">
			<f a="assemblyRef">
				<c path="cs.system.reflection.AssemblyName"/>
				<c path="cs.system.reflection.Assembly"/>
			</f>
			<overloads>
				<Load public="1" set="method"><f a="rawAssembly:rawSymbolStore:securityEvidence">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load public="1" set="method"><f a="assemblyString:assemblySecurity">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load public="1" set="method"><f a="rawAssembly:rawSymbolStore">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load public="1" set="method"><f a="assemblyRef:assemblySecurity">
	<c path="cs.system.reflection.AssemblyName"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load public="1" set="method"><f a="assemblyString">
	<c path="String"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load public="1" set="method"><f a="rawAssembly">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
			</overloads>
		</Load>
		<SetAppDomainPolicy public="1" set="method"><f a="domainPolicy">
	<c path="cs.system.security.policy.PolicyLevel"/>
	<x path="Void"/>
</f></SetAppDomainPolicy>
		<SetCachePath public="1" set="method"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></SetCachePath>
		<SetData public="1" set="method"><f a="name:data">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></SetData>
		<SetPrincipalPolicy public="1" set="method"><f a="policy">
	<e path="cs.system.security.principal.PrincipalPolicy"/>
	<x path="Void"/>
</f></SetPrincipalPolicy>
		<SetShadowCopyPath public="1" set="method"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></SetShadowCopyPath>
		<SetThreadPrincipal public="1" set="method"><f a="principal">
	<c path="cs.system.security.principal.IPrincipal"/>
	<x path="Void"/>
</f></SetThreadPrincipal>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System._AppDomain"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.IEvidenceFactory" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.IEvidenceFactory" extern="1" interface="1">
		<Evidence public="1" get="accessor" set="null"><c path="cs.system.security.policy.Evidence"/></Evidence>
		<get_Evidence public="1" set="method"><f a=""><c path="cs.system.security.policy.Evidence"/></f></get_Evidence>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.IEvidenceFactory"</e></m>
		</meta>
	</class>
	<class path="cs.system.AppDomain" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AppDomain" extern="1" final="1">
		<extends path="cs.system.MarshalByRefObject"/>
		<implements path="cs.system._AppDomain"/>
		<implements path="cs.system.security.IEvidenceFactory"/>
		<CurrentDomain public="1" get="accessor" set="null" static="1"><c path="cs.system.AppDomain"/></CurrentDomain>
		<get_CurrentDomain public="1" set="method" static="1"><f a=""><c path="cs.system.AppDomain"/></f></get_CurrentDomain>
		<CreateDomain public="1" set="method" static="1">
			<f a="friendlyName">
				<c path="String"/>
				<c path="cs.system.AppDomain"/>
			</f>
			<overloads>
				<CreateDomain public="1" set="method"><f a="friendlyName:securityInfo:appBasePath:appRelativeSearchPath:shadowCopyFiles:adInit:adInitArgs">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="cs.system.AppDomainInitializer"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.system.AppDomain"/>
</f></CreateDomain>
				<CreateDomain public="1" set="method"><f a="friendlyName:securityInfo:info:grantSet:fullTrustAssemblies">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.AppDomainSetup"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.NativeArray"><c path="cs.system.security.policy.StrongName"/></c>
	<c path="cs.system.AppDomain"/>
</f></CreateDomain>
				<CreateDomain public="1" set="method"><f a="friendlyName:securityInfo:appBasePath:appRelativeSearchPath:shadowCopyFiles">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.AppDomain"/>
</f></CreateDomain>
				<CreateDomain public="1" set="method"><f a="friendlyName:securityInfo:info">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.AppDomainSetup"/>
	<c path="cs.system.AppDomain"/>
</f></CreateDomain>
				<CreateDomain public="1" set="method"><f a="friendlyName:securityInfo">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.AppDomain"/>
</f></CreateDomain>
			</overloads>
		</CreateDomain>
		<Unload public="1" set="method" static="1"><f a="domain">
	<c path="cs.system.AppDomain"/>
	<x path="Void"/>
</f></Unload>
		<GetCurrentThreadId public="1" set="method" static="1"><f a=""><x path="Int"/></f></GetCurrentThreadId>
		<ReflectionOnlyAssemblyResolve>
			<x path="cs.system.ResolveEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</ReflectionOnlyAssemblyResolve>
		<UnhandledException>
			<x path="cs.system.UnhandledExceptionEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</UnhandledException>
		<TypeResolve>
			<x path="cs.system.ResolveEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</TypeResolve>
		<ResourceResolve>
			<x path="cs.system.ResolveEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</ResourceResolve>
		<ProcessExit>
			<x path="cs.system.EventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</ProcessExit>
		<DomainUnload>
			<x path="cs.system.EventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</DomainUnload>
		<AssemblyResolve>
			<x path="cs.system.ResolveEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</AssemblyResolve>
		<AssemblyLoad>
			<x path="cs.system.AssemblyLoadEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</AssemblyLoad>
		<Id public="1" get="accessor" set="null"><x path="Int"/></Id>
		<ApplicationIdentity public="1" get="accessor" set="null"><c path="cs.system.ApplicationIdentity"/></ApplicationIdentity>
		<ActivationContext public="1" get="accessor" set="null"><c path="cs.system.ActivationContext"/></ActivationContext>
		<DomainManager public="1" get="accessor" set="null"><c path="cs.system.AppDomainManager"/></DomainManager>
		<Evidence public="1" get="accessor" set="null"><c path="cs.system.security.policy.Evidence"/></Evidence>
		<FriendlyName public="1" get="accessor" set="null"><c path="String"/></FriendlyName>
		<ShadowCopyFiles public="1" get="accessor" set="null"><x path="Bool"/></ShadowCopyFiles>
		<DynamicDirectory public="1" get="accessor" set="null"><c path="String"/></DynamicDirectory>
		<RelativeSearchPath public="1" get="accessor" set="null"><c path="String"/></RelativeSearchPath>
		<BaseDirectory public="1" get="accessor" set="null"><c path="String"/></BaseDirectory>
		<ApplicationTrust public="1" get="accessor" set="null"><c path="cs.system.security.policy.ApplicationTrust"/></ApplicationTrust>
		<SetupInformation public="1" get="accessor" set="null"><c path="cs.system.AppDomainSetup"/></SetupInformation>
		<add_AssemblyLoad final="1" public="1" set="method"><f a="value">
	<x path="cs.system.AssemblyLoadEventHandler"/>
	<x path="Void"/>
</f></add_AssemblyLoad>
		<remove_AssemblyLoad final="1" public="1" set="method"><f a="value">
	<x path="cs.system.AssemblyLoadEventHandler"/>
	<x path="Void"/>
</f></remove_AssemblyLoad>
		<add_AssemblyResolve final="1" public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></add_AssemblyResolve>
		<remove_AssemblyResolve final="1" public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></remove_AssemblyResolve>
		<add_DomainUnload final="1" public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></add_DomainUnload>
		<remove_DomainUnload final="1" public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></remove_DomainUnload>
		<add_ProcessExit final="1" public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></add_ProcessExit>
		<remove_ProcessExit final="1" public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></remove_ProcessExit>
		<add_ResourceResolve final="1" public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></add_ResourceResolve>
		<remove_ResourceResolve final="1" public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></remove_ResourceResolve>
		<add_TypeResolve final="1" public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></add_TypeResolve>
		<remove_TypeResolve final="1" public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></remove_TypeResolve>
		<add_UnhandledException final="1" public="1" set="method"><f a="value">
	<x path="cs.system.UnhandledExceptionEventHandler"/>
	<x path="Void"/>
</f></add_UnhandledException>
		<remove_UnhandledException final="1" public="1" set="method"><f a="value">
	<x path="cs.system.UnhandledExceptionEventHandler"/>
	<x path="Void"/>
</f></remove_UnhandledException>
		<add_ReflectionOnlyAssemblyResolve final="1" public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></add_ReflectionOnlyAssemblyResolve>
		<remove_ReflectionOnlyAssemblyResolve final="1" public="1" set="method"><f a="value">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="Void"/>
</f></remove_ReflectionOnlyAssemblyResolve>
		<get_SetupInformation final="1" public="1" set="method"><f a=""><c path="cs.system.AppDomainSetup"/></f></get_SetupInformation>
		<get_ApplicationTrust final="1" public="1" set="method"><f a=""><c path="cs.system.security.policy.ApplicationTrust"/></f></get_ApplicationTrust>
		<get_BaseDirectory final="1" public="1" set="method"><f a=""><c path="String"/></f></get_BaseDirectory>
		<get_RelativeSearchPath final="1" public="1" set="method"><f a=""><c path="String"/></f></get_RelativeSearchPath>
		<get_DynamicDirectory final="1" public="1" set="method"><f a=""><c path="String"/></f></get_DynamicDirectory>
		<get_ShadowCopyFiles final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_ShadowCopyFiles>
		<get_FriendlyName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_FriendlyName>
		<get_Evidence final="1" public="1" set="method"><f a=""><c path="cs.system.security.policy.Evidence"/></f></get_Evidence>
		<AppendPrivatePath final="1" public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></AppendPrivatePath>
		<ClearPrivatePath final="1" public="1" set="method"><f a=""><x path="Void"/></f></ClearPrivatePath>
		<ClearShadowCopyPath final="1" public="1" set="method"><f a=""><x path="Void"/></f></ClearShadowCopyPath>
		<CreateComInstanceFrom final="1" public="1" set="method">
			<f a="assemblyName:typeName">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.runtime.remoting.ObjectHandle"/>
			</f>
			<overloads><CreateComInstanceFrom final="1" public="1" set="method"><f a="assemblyFile:typeName:hashValue:hashAlgorithm">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<e path="cs.system.configuration.assemblies.AssemblyHashAlgorithm"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateComInstanceFrom></overloads>
		</CreateComInstanceFrom>
		<CreateInstance final="1" public="1" set="method">
			<f a="assemblyName:typeName">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.runtime.remoting.ObjectHandle"/>
			</f>
			<overloads>
				<CreateInstance final="1" public="1" set="method"><f a="assemblyName:typeName:ignoreCase:bindingAttr:binder:args:culture:activationAttributes:securityAttributes">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstance>
				<CreateInstance final="1" public="1" set="method"><f a="assemblyName:typeName:activationAttributes">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstance>
			</overloads>
		</CreateInstance>
		<CreateInstanceAndUnwrap final="1" public="1" set="method">
			<f a="assemblyName:typeName">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<overloads>
				<CreateInstanceAndUnwrap final="1" public="1" set="method"><f a="assemblyName:typeName:ignoreCase:bindingAttr:binder:args:culture:activationAttributes:securityAttributes">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<d/>
</f></CreateInstanceAndUnwrap>
				<CreateInstanceAndUnwrap final="1" public="1" set="method"><f a="assemblyName:typeName:activationAttributes">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></CreateInstanceAndUnwrap>
			</overloads>
		</CreateInstanceAndUnwrap>
		<CreateInstanceFrom final="1" public="1" set="method">
			<f a="assemblyFile:typeName">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.runtime.remoting.ObjectHandle"/>
			</f>
			<overloads>
				<CreateInstanceFrom final="1" public="1" set="method"><f a="assemblyFile:typeName:ignoreCase:bindingAttr:binder:args:culture:activationAttributes:securityAttributes">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstanceFrom>
				<CreateInstanceFrom final="1" public="1" set="method"><f a="assemblyFile:typeName:activationAttributes">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstanceFrom>
			</overloads>
		</CreateInstanceFrom>
		<CreateInstanceFromAndUnwrap final="1" public="1" set="method">
			<f a="assemblyName:typeName">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<overloads>
				<CreateInstanceFromAndUnwrap final="1" public="1" set="method"><f a="assemblyName:typeName:ignoreCase:bindingAttr:binder:args:culture:activationAttributes:securityAttributes">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<d/>
</f></CreateInstanceFromAndUnwrap>
				<CreateInstanceFromAndUnwrap final="1" public="1" set="method"><f a="assemblyName:typeName:activationAttributes">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></CreateInstanceFromAndUnwrap>
			</overloads>
		</CreateInstanceFromAndUnwrap>
		<DefineDynamicAssembly final="1" public="1" set="method">
			<f a="name:access">
				<c path="cs.system.reflection.AssemblyName"/>
				<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
				<c path="cs.system.reflection.emit.AssemblyBuilder"/>
			</f>
			<overloads>
				<DefineDynamicAssembly final="1" public="1" set="method"><f a="name:access:assemblyAttributes">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="cs.system.collections.generic.IEnumerable_1"><c path="cs.system.reflection.emit.CustomAttributeBuilder"/></c>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly final="1" public="1" set="method"><f a="name:access:dir:evidence:requiredPermissions:optionalPermissions:refusedPermissions:isSynchronized:assemblyAttributes">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<x path="Bool"/>
	<c path="cs.system.collections.generic.IEnumerable_1"><c path="cs.system.reflection.emit.CustomAttributeBuilder"/></c>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly final="1" public="1" set="method"><f a="name:access:dir:evidence:requiredPermissions:optionalPermissions:refusedPermissions:isSynchronized">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<x path="Bool"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly final="1" public="1" set="method"><f a="name:access:dir:evidence:requiredPermissions:optionalPermissions:refusedPermissions">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly final="1" public="1" set="method"><f a="name:access:dir:requiredPermissions:optionalPermissions:refusedPermissions">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="String"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly final="1" public="1" set="method"><f a="name:access:evidence:requiredPermissions:optionalPermissions:refusedPermissions">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly final="1" public="1" set="method"><f a="name:access:requiredPermissions:optionalPermissions:refusedPermissions">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly final="1" public="1" set="method"><f a="name:access:dir:evidence">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly final="1" public="1" set="method"><f a="name:access:dir">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="String"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
				<DefineDynamicAssembly final="1" public="1" set="method"><f a="name:access:evidence">
	<c path="cs.system.reflection.AssemblyName"/>
	<e path="cs.system.reflection.emit.AssemblyBuilderAccess"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.emit.AssemblyBuilder"/>
</f></DefineDynamicAssembly>
			</overloads>
		</DefineDynamicAssembly>
		<DoCallBack final="1" public="1" set="method"><f a="callBackDelegate">
	<x path="cs.system.CrossAppDomainDelegate"/>
	<x path="Void"/>
</f></DoCallBack>
		<ExecuteAssembly final="1" public="1" set="method">
			<f a="assemblyFile">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<overloads>
				<ExecuteAssembly final="1" public="1" set="method"><f a="assemblyFile:assemblySecurity:args:hashValue:hashAlgorithm">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<e path="cs.system.configuration.assemblies.AssemblyHashAlgorithm"/>
	<x path="Int"/>
</f></ExecuteAssembly>
				<ExecuteAssembly final="1" public="1" set="method"><f a="assemblyFile:assemblySecurity:args">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Int"/>
</f></ExecuteAssembly>
				<ExecuteAssembly final="1" public="1" set="method"><f a="assemblyFile:assemblySecurity">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<x path="Int"/>
</f></ExecuteAssembly>
			</overloads>
		</ExecuteAssembly>
		<GetAssemblies final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.Assembly"/></c></f></GetAssemblies>
		<GetData final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<d/>
</f></GetData>
		<GetType final="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<InitializeLifetimeService public="1" set="method" override="1"><f a=""><d/></f></InitializeLifetimeService>
		<Load final="1" public="1" set="method">
			<f a="assemblyRef">
				<c path="cs.system.reflection.AssemblyName"/>
				<c path="cs.system.reflection.Assembly"/>
			</f>
			<overloads>
				<Load final="1" public="1" set="method"><f a="rawAssembly:rawSymbolStore:securityEvidence">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load final="1" public="1" set="method"><f a="rawAssembly:rawSymbolStore">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load final="1" public="1" set="method"><f a="rawAssembly">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load final="1" public="1" set="method"><f a="assemblyString:assemblySecurity">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load final="1" public="1" set="method"><f a="assemblyString">
	<c path="String"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load final="1" public="1" set="method"><f a="assemblyRef:assemblySecurity">
	<c path="cs.system.reflection.AssemblyName"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
			</overloads>
		</Load>
		<SetAppDomainPolicy final="1" public="1" set="method"><f a="domainPolicy">
	<c path="cs.system.security.policy.PolicyLevel"/>
	<x path="Void"/>
</f></SetAppDomainPolicy>
		<SetCachePath final="1" public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></SetCachePath>
		<SetPrincipalPolicy final="1" public="1" set="method"><f a="policy">
	<e path="cs.system.security.principal.PrincipalPolicy"/>
	<x path="Void"/>
</f></SetPrincipalPolicy>
		<SetShadowCopyFiles final="1" public="1" set="method"><f a=""><x path="Void"/></f></SetShadowCopyFiles>
		<SetShadowCopyPath final="1" public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></SetShadowCopyPath>
		<SetThreadPrincipal final="1" public="1" set="method"><f a="principal">
	<c path="cs.system.security.principal.IPrincipal"/>
	<x path="Void"/>
</f></SetThreadPrincipal>
		<IsFinalizingForUnload final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsFinalizingForUnload>
		<SetData final="1" public="1" set="method">
			<f a="name:data">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<overloads><SetData final="1" public="1" set="method"><f a="name:data:permission">
	<c path="String"/>
	<d/>
	<c path="cs.system.security.IPermission"/>
	<x path="Void"/>
</f></SetData></overloads>
		</SetData>
		<SetDynamicBase final="1" public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></SetDynamicBase>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<get_DomainManager final="1" public="1" set="method"><f a=""><c path="cs.system.AppDomainManager"/></f></get_DomainManager>
		<get_ActivationContext final="1" public="1" set="method"><f a=""><c path="cs.system.ActivationContext"/></f></get_ActivationContext>
		<get_ApplicationIdentity final="1" public="1" set="method"><f a=""><c path="cs.system.ApplicationIdentity"/></f></get_ApplicationIdentity>
		<get_Id final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Id>
		<ApplyPolicy final="1" public="1" set="method"><f a="assemblyName">
	<c path="String"/>
	<c path="String"/>
</f></ApplyPolicy>
		<ExecuteAssemblyByName final="1" public="1" set="method">
			<f a="assemblyName">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<overloads>
				<ExecuteAssemblyByName final="1" public="1" set="method"><f a="assemblyName:assemblySecurity:args">
	<c path="cs.system.reflection.AssemblyName"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Int"/>
</f></ExecuteAssemblyByName>
				<ExecuteAssemblyByName final="1" public="1" set="method"><f a="assemblyName:assemblySecurity:args">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Int"/>
</f></ExecuteAssemblyByName>
				<ExecuteAssemblyByName final="1" public="1" set="method"><f a="assemblyName:assemblySecurity">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<x path="Int"/>
</f></ExecuteAssemblyByName>
			</overloads>
		</ExecuteAssemblyByName>
		<IsDefaultAppDomain final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsDefaultAppDomain>
		<ReflectionOnlyGetAssemblies final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.Assembly"/></c></f></ReflectionOnlyGetAssemblies>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.AppDomain"</e></m>
		</meta>
	</class>
	<class path="cs.system.Delegate_AppDomainInitializer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AppDomainInitializer" module="cs.system.AppDomainInitializer" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.AppDomainInitializer"/>
	<x path="cs.system.AppDomainInitializer"/>
	<x path="cs.system.AppDomainInitializer"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.AppDomainInitializer"/>
	<x path="cs.system.AppDomainInitializer"/>
	<x path="cs.system.AppDomainInitializer"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="args">
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="args:callback:object">
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.AppDomainInitializer"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.AppDomainInitializer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AppDomainInitializer">
		<from><icast field="FromHaxeFunction"><f a="">
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.Delegate_AppDomainInitializer"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._AppDomainInitializer.AppDomainInitializer_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AppDomainInitializer" private="1" module="cs.system.AppDomainInitializer" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="cs.NativeArray"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<x path="cs.system.AppDomainInitializer"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="cs.NativeArray"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<x path="cs.system.AppDomainInitializer"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_AppDomainInitializer"/>
	<c path="cs.system.Delegate_AppDomainInitializer"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.AppDomainInitializer"/>
			<x path="cs.system.AppDomainInitializer"/>
			<x path="cs.system.AppDomainInitializer"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.AppDomainInitializer"/>
			<x path="cs.system.AppDomainInitializer"/>
			<x path="cs.system.AppDomainInitializer"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._AppDomainInitializer.AppDomainInitializer_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AppDomainInitializer" private="1" module="cs.system.AppDomainInitializer" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="cs.NativeArray"><c path="String"/></c>
					<x path="Void"/>
				</f>
				<x path="cs.system.AppDomainInitializer"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="cs.NativeArray"><c path="String"/></c>
					<x path="Void"/>
				</f>
				<x path="cs.system.AppDomainInitializer"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_AppDomainInitializer"/>
	<c path="cs.system.Delegate_AppDomainInitializer"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.AppDomainInitializer"/>
				<x path="cs.system.AppDomainInitializer"/>
				<x path="cs.system.AppDomainInitializer"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.AppDomainInitializer"/>
				<x path="cs.system.AppDomainInitializer"/>
				<x path="cs.system.AppDomainInitializer"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.AppDomainManager" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AppDomainManager" extern="1">
		<extends path="cs.system.MarshalByRefObject"/>
		<CreateDomainHelper set="method" static="1">
			<f a="friendlyName:securityInfo:appDomainInfo">
				<c path="String"/>
				<c path="cs.system.security.policy.Evidence"/>
				<c path="cs.system.AppDomainSetup"/>
				<c path="cs.system.AppDomain"/>
			</f>
			<meta><m n=":protected"/></meta>
		</CreateDomainHelper>
		<InitializationFlags public="1" get="accessor" set="accessor"><e path="cs.system.AppDomainManagerInitializationOptions"/></InitializationFlags>
		<HostSecurityManager public="1" get="accessor" set="null"><c path="cs.system.security.HostSecurityManager"/></HostSecurityManager>
		<HostExecutionContextManager public="1" get="accessor" set="null"><c path="cs.system.threading.HostExecutionContextManager"/></HostExecutionContextManager>
		<EntryAssembly public="1" get="accessor" set="null"><c path="cs.system.reflection.Assembly"/></EntryAssembly>
		<ApplicationActivator public="1" get="accessor" set="null"><c path="cs.system.runtime.hosting.ApplicationActivator"/></ApplicationActivator>
		<get_ApplicationActivator public="1" set="method"><f a=""><c path="cs.system.runtime.hosting.ApplicationActivator"/></f></get_ApplicationActivator>
		<get_EntryAssembly public="1" set="method"><f a=""><c path="cs.system.reflection.Assembly"/></f></get_EntryAssembly>
		<get_HostExecutionContextManager public="1" set="method"><f a=""><c path="cs.system.threading.HostExecutionContextManager"/></f></get_HostExecutionContextManager>
		<get_HostSecurityManager public="1" set="method"><f a=""><c path="cs.system.security.HostSecurityManager"/></f></get_HostSecurityManager>
		<get_InitializationFlags final="1" public="1" set="method"><f a=""><e path="cs.system.AppDomainManagerInitializationOptions"/></f></get_InitializationFlags>
		<set_InitializationFlags final="1" public="1" set="method"><f a="value">
	<e path="cs.system.AppDomainManagerInitializationOptions"/>
	<e path="cs.system.AppDomainManagerInitializationOptions"/>
</f></set_InitializationFlags>
		<CreateDomain public="1" set="method"><f a="friendlyName:securityInfo:appDomainInfo">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.AppDomainSetup"/>
	<c path="cs.system.AppDomain"/>
</f></CreateDomain>
		<InitializeNewDomain public="1" set="method"><f a="appDomainInfo">
	<c path="cs.system.AppDomainSetup"/>
	<x path="Void"/>
</f></InitializeNewDomain>
		<CheckSecuritySettings public="1" set="method"><f a="state">
	<c path="cs.system.security.SecurityState"/>
	<x path="Bool"/>
</f></CheckSecuritySettings>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.AppDomainManager"</e></m>
		</meta>
	</class>
	<enum path="cs.system.AppDomainManagerInitializationOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AppDomainManagerInitializationOptions">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<RegisterWithHost><meta><m n=":csNative"><e>1</e></m></meta></RegisterWithHost>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.AppDomainManagerInitializationOptions"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.IAppDomainSetup" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.IAppDomainSetup" extern="1" interface="1">
		<ShadowCopyFiles public="1" get="accessor" set="accessor"><c path="String"/></ShadowCopyFiles>
		<ShadowCopyDirectories public="1" get="accessor" set="accessor"><c path="String"/></ShadowCopyDirectories>
		<PrivateBinPathProbe public="1" get="accessor" set="accessor"><c path="String"/></PrivateBinPathProbe>
		<PrivateBinPath public="1" get="accessor" set="accessor"><c path="String"/></PrivateBinPath>
		<LicenseFile public="1" get="accessor" set="accessor"><c path="String"/></LicenseFile>
		<DynamicBase public="1" get="accessor" set="accessor"><c path="String"/></DynamicBase>
		<ConfigurationFile public="1" get="accessor" set="accessor"><c path="String"/></ConfigurationFile>
		<CachePath public="1" get="accessor" set="accessor"><c path="String"/></CachePath>
		<ApplicationName public="1" get="accessor" set="accessor"><c path="String"/></ApplicationName>
		<ApplicationBase public="1" get="accessor" set="accessor"><c path="String"/></ApplicationBase>
		<get_ApplicationBase public="1" set="method"><f a=""><c path="String"/></f></get_ApplicationBase>
		<set_ApplicationBase public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ApplicationBase>
		<get_ApplicationName public="1" set="method"><f a=""><c path="String"/></f></get_ApplicationName>
		<set_ApplicationName public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ApplicationName>
		<get_CachePath public="1" set="method"><f a=""><c path="String"/></f></get_CachePath>
		<set_CachePath public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_CachePath>
		<get_ConfigurationFile public="1" set="method"><f a=""><c path="String"/></f></get_ConfigurationFile>
		<set_ConfigurationFile public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ConfigurationFile>
		<get_DynamicBase public="1" set="method"><f a=""><c path="String"/></f></get_DynamicBase>
		<set_DynamicBase public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_DynamicBase>
		<get_LicenseFile public="1" set="method"><f a=""><c path="String"/></f></get_LicenseFile>
		<set_LicenseFile public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_LicenseFile>
		<get_PrivateBinPath public="1" set="method"><f a=""><c path="String"/></f></get_PrivateBinPath>
		<set_PrivateBinPath public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_PrivateBinPath>
		<get_PrivateBinPathProbe public="1" set="method"><f a=""><c path="String"/></f></get_PrivateBinPathProbe>
		<set_PrivateBinPathProbe public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_PrivateBinPathProbe>
		<get_ShadowCopyDirectories public="1" set="method"><f a=""><c path="String"/></f></get_ShadowCopyDirectories>
		<set_ShadowCopyDirectories public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ShadowCopyDirectories>
		<get_ShadowCopyFiles public="1" set="method"><f a=""><c path="String"/></f></get_ShadowCopyFiles>
		<set_ShadowCopyFiles public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ShadowCopyFiles>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IAppDomainSetup"</e></m>
		</meta>
	</class>
	<class path="cs.system.AppDomainSetup" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AppDomainSetup" extern="1" final="1">
		<implements path="cs.system.IAppDomainSetup"/>
		<DisallowApplicationBaseProbing public="1" get="accessor" set="accessor"><x path="Bool"/></DisallowApplicationBaseProbing>
		<ApplicationTrust public="1" get="accessor" set="accessor"><c path="cs.system.security.policy.ApplicationTrust"/></ApplicationTrust>
		<AppDomainInitializerArguments public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><c path="String"/></c></AppDomainInitializerArguments>
		<AppDomainInitializer public="1" get="accessor" set="accessor"><x path="cs.system.AppDomainInitializer"/></AppDomainInitializer>
		<ActivationArguments public="1" get="accessor" set="accessor"><c path="cs.system.runtime.hosting.ActivationArguments"/></ActivationArguments>
		<DisallowCodeDownload public="1" get="accessor" set="accessor"><x path="Bool"/></DisallowCodeDownload>
		<DisallowBindingRedirects public="1" get="accessor" set="accessor"><x path="Bool"/></DisallowBindingRedirects>
		<ShadowCopyFiles public="1" get="accessor" set="accessor"><c path="String"/></ShadowCopyFiles>
		<ShadowCopyDirectories public="1" get="accessor" set="accessor"><c path="String"/></ShadowCopyDirectories>
		<PrivateBinPathProbe public="1" get="accessor" set="accessor"><c path="String"/></PrivateBinPathProbe>
		<PrivateBinPath public="1" get="accessor" set="accessor"><c path="String"/></PrivateBinPath>
		<LoaderOptimization public="1" get="accessor" set="accessor"><e path="cs.system.LoaderOptimization"/></LoaderOptimization>
		<LicenseFile public="1" get="accessor" set="accessor"><c path="String"/></LicenseFile>
		<DynamicBase public="1" get="accessor" set="accessor"><c path="String"/></DynamicBase>
		<DisallowPublisherPolicy public="1" get="accessor" set="accessor"><x path="Bool"/></DisallowPublisherPolicy>
		<ConfigurationFile public="1" get="accessor" set="accessor"><c path="String"/></ConfigurationFile>
		<CachePath public="1" get="accessor" set="accessor"><c path="String"/></CachePath>
		<ApplicationName public="1" get="accessor" set="accessor"><c path="String"/></ApplicationName>
		<ApplicationBase public="1" get="accessor" set="accessor"><c path="String"/></ApplicationBase>
		<get_ApplicationBase final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ApplicationBase>
		<set_ApplicationBase final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ApplicationBase>
		<get_ApplicationName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ApplicationName>
		<set_ApplicationName final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ApplicationName>
		<get_CachePath final="1" public="1" set="method"><f a=""><c path="String"/></f></get_CachePath>
		<set_CachePath final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_CachePath>
		<get_ConfigurationFile final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ConfigurationFile>
		<set_ConfigurationFile final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ConfigurationFile>
		<get_DisallowPublisherPolicy final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_DisallowPublisherPolicy>
		<set_DisallowPublisherPolicy final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DisallowPublisherPolicy>
		<get_DynamicBase final="1" public="1" set="method"><f a=""><c path="String"/></f></get_DynamicBase>
		<set_DynamicBase final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_DynamicBase>
		<get_LicenseFile final="1" public="1" set="method"><f a=""><c path="String"/></f></get_LicenseFile>
		<set_LicenseFile final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_LicenseFile>
		<get_LoaderOptimization final="1" public="1" set="method"><f a=""><e path="cs.system.LoaderOptimization"/></f></get_LoaderOptimization>
		<set_LoaderOptimization final="1" public="1" set="method"><f a="value">
	<e path="cs.system.LoaderOptimization"/>
	<e path="cs.system.LoaderOptimization"/>
</f></set_LoaderOptimization>
		<get_PrivateBinPath final="1" public="1" set="method"><f a=""><c path="String"/></f></get_PrivateBinPath>
		<set_PrivateBinPath final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_PrivateBinPath>
		<get_PrivateBinPathProbe final="1" public="1" set="method"><f a=""><c path="String"/></f></get_PrivateBinPathProbe>
		<set_PrivateBinPathProbe final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_PrivateBinPathProbe>
		<get_ShadowCopyDirectories final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ShadowCopyDirectories>
		<set_ShadowCopyDirectories final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ShadowCopyDirectories>
		<get_ShadowCopyFiles final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ShadowCopyFiles>
		<set_ShadowCopyFiles final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ShadowCopyFiles>
		<get_DisallowBindingRedirects final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_DisallowBindingRedirects>
		<set_DisallowBindingRedirects final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DisallowBindingRedirects>
		<get_DisallowCodeDownload final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_DisallowCodeDownload>
		<set_DisallowCodeDownload final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DisallowCodeDownload>
		<get_ActivationArguments final="1" public="1" set="method"><f a=""><c path="cs.system.runtime.hosting.ActivationArguments"/></f></get_ActivationArguments>
		<set_ActivationArguments final="1" public="1" set="method"><f a="value">
	<c path="cs.system.runtime.hosting.ActivationArguments"/>
	<c path="cs.system.runtime.hosting.ActivationArguments"/>
</f></set_ActivationArguments>
		<get_AppDomainInitializer final="1" public="1" set="method"><f a=""><x path="cs.system.AppDomainInitializer"/></f></get_AppDomainInitializer>
		<set_AppDomainInitializer final="1" public="1" set="method"><f a="value">
	<x path="cs.system.AppDomainInitializer"/>
	<x path="cs.system.AppDomainInitializer"/>
</f></set_AppDomainInitializer>
		<get_AppDomainInitializerArguments final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></get_AppDomainInitializerArguments>
		<set_AppDomainInitializerArguments final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></set_AppDomainInitializerArguments>
		<get_ApplicationTrust final="1" public="1" set="method"><f a=""><c path="cs.system.security.policy.ApplicationTrust"/></f></get_ApplicationTrust>
		<set_ApplicationTrust final="1" public="1" set="method"><f a="value">
	<c path="cs.system.security.policy.ApplicationTrust"/>
	<c path="cs.system.security.policy.ApplicationTrust"/>
</f></set_ApplicationTrust>
		<get_DisallowApplicationBaseProbing final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_DisallowApplicationBaseProbing>
		<set_DisallowApplicationBaseProbing final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DisallowApplicationBaseProbing>
		<GetConfigurationBytes final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetConfigurationBytes>
		<SetConfigurationBytes final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetConfigurationBytes>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="activationContext">
	<c path="cs.system.ActivationContext"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="activationArguments">
	<c path="cs.system.runtime.hosting.ActivationArguments"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.AppDomainSetup"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._Exception" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._Exception" extern="1" interface="1">
		<TargetSite public="1" get="accessor" set="null"><c path="cs.system.reflection.MethodBase"/></TargetSite>
		<StackTrace public="1" get="accessor" set="null"><c path="String"/></StackTrace>
		<Source public="1" get="accessor" set="accessor"><c path="String"/></Source>
		<Message public="1" get="accessor" set="null"><c path="String"/></Message>
		<InnerException public="1" get="accessor" set="null"><c path="cs.system.Exception"/></InnerException>
		<HelpLink public="1" get="accessor" set="accessor"><c path="String"/></HelpLink>
		<get_HelpLink public="1" set="method"><f a=""><c path="String"/></f></get_HelpLink>
		<set_HelpLink public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_HelpLink>
		<get_InnerException public="1" set="method"><f a=""><c path="cs.system.Exception"/></f></get_InnerException>
		<get_Message public="1" set="method"><f a=""><c path="String"/></f></get_Message>
		<get_Source public="1" set="method"><f a=""><c path="String"/></f></get_Source>
		<set_Source public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Source>
		<get_StackTrace public="1" set="method"><f a=""><c path="String"/></f></get_StackTrace>
		<get_TargetSite public="1" set="method"><f a=""><c path="cs.system.reflection.MethodBase"/></f></get_TargetSite>
		<GetBaseException public="1" set="method"><f a=""><c path="cs.system.Exception"/></f></GetBaseException>
		<GetObjectData public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<GetType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._Exception"</e></m>
		</meta>
	</class>
	<class path="cs.system.Exception" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Exception" extern="1">
		<implements path="cs.system.runtime.interopservices._Exception"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<Data public="1" get="accessor" set="null"><c path="cs.system.collections.IDictionary"/></Data>
		<TargetSite public="1" get="accessor" set="null"><c path="cs.system.reflection.MethodBase"/></TargetSite>
		<StackTrace public="1" get="accessor" set="null"><c path="String"/></StackTrace>
		<Source public="1" get="accessor" set="accessor"><c path="String"/></Source>
		<Message public="1" get="accessor" set="null"><c path="String"/></Message>
		<HResult get="null" set="null"><x path="Int"/></HResult>
		<HelpLink public="1" get="accessor" set="accessor"><c path="String"/></HelpLink>
		<InnerException public="1" get="accessor" set="null"><c path="cs.system.Exception"/></InnerException>
		<get_InnerException final="1" public="1" set="method"><f a=""><c path="cs.system.Exception"/></f></get_InnerException>
		<get_HelpLink public="1" set="method"><f a=""><c path="String"/></f></get_HelpLink>
		<set_HelpLink public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_HelpLink>
		<get_HResult final="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":protected"/></meta>
		</get_HResult>
		<set_HResult final="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":protected"/></meta>
		</set_HResult>
		<get_Message public="1" set="method"><f a=""><c path="String"/></f></get_Message>
		<get_Source public="1" set="method"><f a=""><c path="String"/></f></get_Source>
		<set_Source public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Source>
		<get_StackTrace public="1" set="method"><f a=""><c path="String"/></f></get_StackTrace>
		<get_TargetSite final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.MethodBase"/></f></get_TargetSite>
		<get_Data public="1" set="method"><f a=""><c path="cs.system.collections.IDictionary"/></f></get_Data>
		<GetBaseException public="1" set="method"><f a=""><c path="cs.system.Exception"/></f></GetBaseException>
		<GetObjectData public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<GetType final="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="message:innerException">
	<c path="String"/>
	<c path="cs.system.Exception"/>
	<x path="Void"/>
</f></new>
				<new final="1" set="method">
					<f a="info:context">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" public="1" set="method"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Exception"</e></m>
		</meta>
	</class>
	<class path="cs.system.ApplicationException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ApplicationException" extern="1">
		<extends path="cs.system.Exception"/>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" set="method">
					<f a="info:context">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" public="1" set="method"><f a="message:innerException">
	<c path="String"/>
	<c path="cs.system.Exception"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ApplicationException"</e></m>
		</meta>
	</class>
	<class path="cs.system.ApplicationIdentity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ApplicationIdentity" extern="1" final="1">
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<FullName public="1" get="accessor" set="null"><c path="String"/></FullName>
		<CodeBase public="1" get="accessor" set="null"><c path="String"/></CodeBase>
		<get_CodeBase final="1" public="1" set="method"><f a=""><c path="String"/></f></get_CodeBase>
		<get_FullName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_FullName>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<new final="1" public="1" set="method"><f a="applicationIdentityFullName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ApplicationIdentity"</e></m>
		</meta>
	</class>
	<class path="cs.system.SystemException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.SystemException" extern="1">
		<extends path="cs.system.Exception"/>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="message:innerException">
	<c path="String"/>
	<c path="cs.system.Exception"/>
	<x path="Void"/>
</f></new>
				<new final="1" set="method">
					<f a="info:context">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" public="1" set="method"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.SystemException"</e></m>
		</meta>
	</class>
	<class path="cs.system.ArgumentException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ArgumentException" extern="1">
		<extends path="cs.system.SystemException"/>
		<Message public="1" get="accessor" set="null" override="1"><c path="String"/></Message>
		<ParamName public="1" get="accessor" set="null"><c path="String"/></ParamName>
		<get_ParamName public="1" set="method"><f a=""><c path="String"/></f></get_ParamName>
		<get_Message public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Message>
		<GetObjectData public="1" set="method" override="1"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" set="method">
					<f a="info:context">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" public="1" set="method"><f a="message:paramName:innerException">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.Exception"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="message:paramName">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="message:innerException">
	<c path="String"/>
	<c path="cs.system.Exception"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ArgumentException"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.IEnumerator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.IEnumerator" extern="1" interface="1">
		<Current public="1" get="accessor" set="null"><d/></Current>
		<get_Current public="1" set="method"><f a=""><d/></f></get_Current>
		<MoveNext public="1" set="method"><f a=""><x path="Bool"/></f></MoveNext>
		<Reset public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.IEnumerator"</e></m>
		</meta>
	</class>
	<class path="cs.system.Array_SimpleEnumerator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Array" module="cs.system.Array" extern="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.collections.IEnumerator"/>
		<Current public="1" get="accessor" set="null"><d/></Current>
		<get_Current final="1" public="1" set="method"><f a=""><d/></f></get_Current>
		<MoveNext final="1" public="1" set="method"><f a=""><x path="Bool"/></f></MoveNext>
		<Reset final="1" public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<Clone final="1" public="1" set="method"><f a=""><d/></f></Clone>
		<new final="1" public="1" set="method"><f a="arrayToEnumerate">
	<c path="cs.system.Array"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Array.SimpleEnumerator"</e></m>
		</meta>
	</class>
	<class path="cs.system.Array_Delegate_Swapper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Array" module="cs.system.Array" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Array_Swapper"/>
	<x path="cs.system.Array_Swapper"/>
	<x path="cs.system.Array_Swapper"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Array_Swapper"/>
	<x path="cs.system.Array_Swapper"/>
	<x path="cs.system.Array_Swapper"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="i:j">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="i:j:callback:object">
	<x path="Int"/>
	<x path="Int"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Array.Swapper"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.Array_Swapper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Array" module="cs.system.Array">
		<from><icast field="FromHaxeFunction"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.Array_Delegate_Swapper"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._Array.Array_Swapper_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Array" private="1" module="cs.system.Array" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.Array_Swapper"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.Array_Swapper"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Array_Delegate_Swapper"/>
	<c path="cs.system.Array_Delegate_Swapper"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Array_Swapper"/>
			<x path="cs.system.Array_Swapper"/>
			<x path="cs.system.Array_Swapper"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Array_Swapper"/>
			<x path="cs.system.Array_Swapper"/>
			<x path="cs.system.Array_Swapper"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._Array.Array_Swapper_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Array" private="1" module="cs.system.Array" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.Array_Swapper"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.Array_Swapper"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Array_Delegate_Swapper"/>
	<c path="cs.system.Array_Delegate_Swapper"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Array_Swapper"/>
				<x path="cs.system.Array_Swapper"/>
				<x path="cs.system.Array_Swapper"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Array_Swapper"/>
				<x path="cs.system.Array_Swapper"/>
				<x path="cs.system.Array_Swapper"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.collections.generic.IEnumerator_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.generic.IEnumerator_1" extern="1" interface="1">
		<extends path="cs.system.IDisposable"/>
		<extends path="cs.system.collections.IEnumerator"/>
		<Current public="1" get="accessor" set="null"><c path="cs.system.collections.generic.IEnumerator_1.T0"/></Current>
		<get_Current public="1" set="method"><f a=""><c path="cs.system.collections.generic.IEnumerator_1.T0"/></f></get_Current>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Generic.IEnumerator`1"</e></m>
		</meta>
	</class>
	<class path="cs.system.Array_InternalEnumerator_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Array" module="cs.system.Array" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.collections.generic.IEnumerator_1"><c path="cs.system.Array_InternalEnumerator_1.T0"/></implements>
		<implements path="cs.system.IDisposable"/>
		<implements path="cs.system.collections.IEnumerator"/>
		<Current public="1" get="accessor" set="null">
			<c path="cs.system.Array_InternalEnumerator_1.T0"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</Current>
		<Dispose final="1" public="1" set="method"><f a=""><x path="Void"/></f></Dispose>
		<MoveNext final="1" public="1" set="method"><f a=""><x path="Bool"/></f></MoveNext>
		<get_Current final="1" public="1" set="method">
			<f a=""><c path="cs.system.Array_InternalEnumerator_1.T0"/></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</get_Current>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Array.InternalEnumerator`1"</e></m>
		</meta>
	</class>
	<class path="cs.system.EventArgs" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.EventArgs" extern="1">
		<Empty public="1" set="null" static="1">
			<c path="cs.system.EventArgs"/>
			<meta><m n=":readOnly"/></meta>
		</Empty>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.EventArgs"</e></m>
		</meta>
	</class>
	<class path="cs.system.AssemblyLoadEventArgs" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AssemblyLoadEventArgs" extern="1">
		<extends path="cs.system.EventArgs"/>
		<LoadedAssembly public="1" get="accessor" set="null"><c path="cs.system.reflection.Assembly"/></LoadedAssembly>
		<get_LoadedAssembly final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.Assembly"/></f></get_LoadedAssembly>
		<new final="1" public="1" set="method"><f a="loadedAssembly">
	<c path="cs.system.reflection.Assembly"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.AssemblyLoadEventArgs"</e></m>
		</meta>
	</class>
	<class path="cs.system.Delegate_AssemblyLoadEventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AssemblyLoadEventHandler" module="cs.system.AssemblyLoadEventHandler" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.AssemblyLoadEventHandler"/>
	<x path="cs.system.AssemblyLoadEventHandler"/>
	<x path="cs.system.AssemblyLoadEventHandler"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.AssemblyLoadEventHandler"/>
	<x path="cs.system.AssemblyLoadEventHandler"/>
	<x path="cs.system.AssemblyLoadEventHandler"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="sender:args">
	<d/>
	<c path="cs.system.AssemblyLoadEventArgs"/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="sender:args:callback:object">
	<d/>
	<c path="cs.system.AssemblyLoadEventArgs"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.AssemblyLoadEventHandler"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.AssemblyLoadEventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AssemblyLoadEventHandler">
		<from><icast field="FromHaxeFunction"><f a=":">
	<d/>
	<c path="cs.system.AssemblyLoadEventArgs"/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.Delegate_AssemblyLoadEventHandler"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._AssemblyLoadEventHandler.AssemblyLoadEventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AssemblyLoadEventHandler" private="1" module="cs.system.AssemblyLoadEventHandler" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.AssemblyLoadEventArgs"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.AssemblyLoadEventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.AssemblyLoadEventArgs"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.AssemblyLoadEventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_AssemblyLoadEventHandler"/>
	<c path="cs.system.Delegate_AssemblyLoadEventHandler"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.AssemblyLoadEventHandler"/>
			<x path="cs.system.AssemblyLoadEventHandler"/>
			<x path="cs.system.AssemblyLoadEventHandler"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.AssemblyLoadEventHandler"/>
			<x path="cs.system.AssemblyLoadEventHandler"/>
			<x path="cs.system.AssemblyLoadEventHandler"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._AssemblyLoadEventHandler.AssemblyLoadEventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AssemblyLoadEventHandler" private="1" module="cs.system.AssemblyLoadEventHandler" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.AssemblyLoadEventArgs"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.AssemblyLoadEventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.AssemblyLoadEventArgs"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.AssemblyLoadEventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_AssemblyLoadEventHandler"/>
	<c path="cs.system.Delegate_AssemblyLoadEventHandler"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.AssemblyLoadEventHandler"/>
				<x path="cs.system.AssemblyLoadEventHandler"/>
				<x path="cs.system.AssemblyLoadEventHandler"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.AssemblyLoadEventHandler"/>
				<x path="cs.system.AssemblyLoadEventHandler"/>
				<x path="cs.system.AssemblyLoadEventHandler"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.Delegate_AsyncCallback" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AsyncCallback" module="cs.system.AsyncCallback" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.AsyncCallback"/>
	<x path="cs.system.AsyncCallback"/>
	<x path="cs.system.AsyncCallback"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.AsyncCallback"/>
	<x path="cs.system.AsyncCallback"/>
	<x path="cs.system.AsyncCallback"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="ar">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="ar:callback:object">
	<c path="cs.system.IAsyncResult"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.AsyncCallback"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.AsyncCallback" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AsyncCallback">
		<from><icast field="FromHaxeFunction"><f a="">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.Delegate_AsyncCallback"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._AsyncCallback.AsyncCallback_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AsyncCallback" private="1" module="cs.system.AsyncCallback" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="cs.system.IAsyncResult"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.AsyncCallback"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="cs.system.IAsyncResult"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.AsyncCallback"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_AsyncCallback"/>
	<c path="cs.system.Delegate_AsyncCallback"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.AsyncCallback"/>
			<x path="cs.system.AsyncCallback"/>
			<x path="cs.system.AsyncCallback"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.AsyncCallback"/>
			<x path="cs.system.AsyncCallback"/>
			<x path="cs.system.AsyncCallback"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._AsyncCallback.AsyncCallback_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.AsyncCallback" private="1" module="cs.system.AsyncCallback" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="cs.system.IAsyncResult"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.AsyncCallback"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="cs.system.IAsyncResult"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.AsyncCallback"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_AsyncCallback"/>
	<c path="cs.system.Delegate_AsyncCallback"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.AsyncCallback"/>
				<x path="cs.system.AsyncCallback"/>
				<x path="cs.system.AsyncCallback"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.AsyncCallback"/>
				<x path="cs.system.AsyncCallback"/>
				<x path="cs.system.AsyncCallback"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<enum path="cs.system.Base64FormattingOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Base64FormattingOptions">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<InsertLineBreaks><meta><m n=":csNative"><e>1</e></m></meta></InsertLineBreaks>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Base64FormattingOptions"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.BitConverter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.BitConverter" extern="1" final="1">
		<IsLittleEndian public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":readOnly"/></meta>
		</IsLittleEndian>
		<DoubleToInt64Bits public="1" set="method" static="1"><f a="value">
	<x path="Float"/>
	<x path="haxe.Int64"/>
</f></DoubleToInt64Bits>
		<Int64BitsToDouble public="1" set="method" static="1"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Float"/>
</f></Int64BitsToDouble>
		<GetBytes public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
			</f>
			<overloads>
				<GetBytes public="1" set="method"><f a="value">
	<x path="Float"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></GetBytes>
				<GetBytes public="1" set="method"><f a="value">
	<x path="Single"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></GetBytes>
				<GetBytes public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></GetBytes>
				<GetBytes public="1" set="method"><f a="value">
	<x path="UInt"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></GetBytes>
				<GetBytes public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></GetBytes>
				<GetBytes public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></GetBytes>
				<GetBytes public="1" set="method"><f a="value">
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></GetBytes>
				<GetBytes public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></GetBytes>
				<GetBytes public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></GetBytes>
			</overloads>
		</GetBytes>
		<ToBoolean public="1" set="method" static="1"><f a="value:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Bool"/>
</f></ToBoolean>
		<ToChar public="1" set="method" static="1"><f a="value:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
		<ToInt16 public="1" set="method" static="1"><f a="value:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
		<ToInt32 public="1" set="method" static="1"><f a="value:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
</f></ToInt32>
		<ToInt64 public="1" set="method" static="1"><f a="value:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
		<ToUInt16 public="1" set="method" static="1"><f a="value:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
		<ToUInt32 public="1" set="method" static="1"><f a="value:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="UInt"/>
</f></ToUInt32>
		<ToUInt64 public="1" set="method" static="1"><f a="value:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
		<ToSingle public="1" set="method" static="1"><f a="value:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Single"/>
</f></ToSingle>
		<ToDouble public="1" set="method" static="1"><f a="value:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Float"/>
</f></ToDouble>
		<ToString public="1" set="method" static="1">
			<f a="value">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<c path="String"/>
			</f>
			<overloads>
				<ToString public="1" set="method"><f a="value:startIndex:length">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:startIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<c path="String"/>
</f></ToString>
			</overloads>
		</ToString>
		<_ToString public="1" set="method" static="1">
			<f a="value">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"ToString"</e></m></meta>
			<overloads>
				<ToString public="1" set="method">
					<f a="value:startIndex:length">
						<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
						<x path="Int"/>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:startIndex">
						<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
			</overloads>
		</_ToString>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.BitConverter"</e></m>
		</meta>
	</class>
	<class path="cs.system.Byte" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Byte" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.IComparable_1"><t path="cs.types.UInt8"/></implements>
		<implements path="cs.system.IEquatable_1"><t path="cs.types.UInt8"/></implements>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IConvertible"/>
		<implements path="cs.system.IFormattable"/>
		<MaxValue public="1" set="null" static="1">
			<t path="cs.types.UInt8"/>
			<meta><m n=":readOnly"/></meta>
		</MaxValue>
		<MinValue public="1" set="null" static="1">
			<t path="cs.types.UInt8"/>
			<meta><m n=":readOnly"/></meta>
		</MinValue>
		<Parse public="1" set="method" static="1">
			<f a="s:provider">
				<c path="String"/>
				<c path="cs.system.IFormatProvider"/>
				<t path="cs.types.UInt8"/>
			</f>
			<overloads>
				<Parse public="1" set="method"><f a="s">
	<c path="String"/>
	<t path="cs.types.UInt8"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s:style:provider">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.UInt8"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s:style">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<t path="cs.types.UInt8"/>
</f></Parse>
			</overloads>
		</Parse>
		<TryParse public="1" set="method" static="1">
			<f a="s:result">
				<c path="String"/>
				<t path="cs.Out"><t path="cs.types.UInt8"/></t>
				<x path="Bool"/>
			</f>
			<overloads><TryParse public="1" set="method"><f a="s:style:provider:result">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.Out"><t path="cs.types.UInt8"/></t>
	<x path="Bool"/>
</f></TryParse></overloads>
		</TryParse>
		<CompareTo final="1" public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads><CompareTo final="1" public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<x path="Int"/>
</f></CompareTo></overloads>
		</CompareTo>
		<ToString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<overloads>
				<ToString final="1" public="1" set="method"><f a="format:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="format">
	<c path="String"/>
	<c path="String"/>
</f></ToString>
			</overloads>
		</ToString>
		<GetTypeCode final="1" public="1" set="method"><f a=""><e path="cs.system.TypeCode"/></f></GetTypeCode>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Byte"</e></m>
		</meta>
	</class>
	<class path="cs.system.Char" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Char" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.IComparable_1"><t path="cs.types.Char16"/></implements>
		<implements path="cs.system.IEquatable_1"><t path="cs.types.Char16"/></implements>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IConvertible"/>
		<MinValue public="1" set="null" static="1">
			<t path="cs.types.Char16"/>
			<meta><m n=":readOnly"/></meta>
		</MinValue>
		<MaxValue public="1" set="null" static="1">
			<t path="cs.types.Char16"/>
			<meta><m n=":readOnly"/></meta>
		</MaxValue>
		<ConvertFromUtf32 public="1" set="method" static="1"><f a="utf32">
	<x path="Int"/>
	<c path="String"/>
</f></ConvertFromUtf32>
		<ConvertToUtf32 public="1" set="method" static="1">
			<f a="highSurrogate:lowSurrogate">
				<t path="cs.types.Char16"/>
				<t path="cs.types.Char16"/>
				<x path="Int"/>
			</f>
			<overloads><ConvertToUtf32 public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ConvertToUtf32></overloads>
		</ConvertToUtf32>
		<IsSurrogatePair public="1" set="method" static="1">
			<f a="highSurrogate:lowSurrogate">
				<t path="cs.types.Char16"/>
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsSurrogatePair public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsSurrogatePair></overloads>
		</IsSurrogatePair>
		<GetNumericValue public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Float"/>
			</f>
			<overloads><GetNumericValue public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
</f></GetNumericValue></overloads>
		</GetNumericValue>
		<GetUnicodeCategory public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<e path="cs.system.globalization.UnicodeCategory"/>
			</f>
			<overloads><GetUnicodeCategory public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<e path="cs.system.globalization.UnicodeCategory"/>
</f></GetUnicodeCategory></overloads>
		</GetUnicodeCategory>
		<IsControl public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsControl public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsControl></overloads>
		</IsControl>
		<IsDigit public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsDigit public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsDigit></overloads>
		</IsDigit>
		<IsHighSurrogate public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsHighSurrogate public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsHighSurrogate></overloads>
		</IsHighSurrogate>
		<IsLetter public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsLetter public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsLetter></overloads>
		</IsLetter>
		<IsLetterOrDigit public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsLetterOrDigit public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsLetterOrDigit></overloads>
		</IsLetterOrDigit>
		<IsLower public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsLower public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsLower></overloads>
		</IsLower>
		<IsLowSurrogate public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsLowSurrogate public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsLowSurrogate></overloads>
		</IsLowSurrogate>
		<IsNumber public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsNumber public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsNumber></overloads>
		</IsNumber>
		<IsPunctuation public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsPunctuation public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsPunctuation></overloads>
		</IsPunctuation>
		<IsSeparator public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsSeparator public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsSeparator></overloads>
		</IsSeparator>
		<IsSurrogate public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsSurrogate public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsSurrogate></overloads>
		</IsSurrogate>
		<IsSymbol public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsSymbol public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsSymbol></overloads>
		</IsSymbol>
		<IsUpper public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsUpper public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsUpper></overloads>
		</IsUpper>
		<IsWhiteSpace public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsWhiteSpace public="1" set="method"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsWhiteSpace></overloads>
		</IsWhiteSpace>
		<TryParse public="1" set="method" static="1"><f a="s:result">
	<c path="String"/>
	<t path="cs.Out"><t path="cs.types.Char16"/></t>
	<x path="Bool"/>
</f></TryParse>
		<Parse public="1" set="method" static="1"><f a="s">
	<c path="String"/>
	<t path="cs.types.Char16"/>
</f></Parse>
		<ToLower public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<t path="cs.types.Char16"/>
			</f>
			<overloads><ToLower public="1" set="method"><f a="c:culture">
	<t path="cs.types.Char16"/>
	<c path="cs.system.globalization.CultureInfo"/>
	<t path="cs.types.Char16"/>
</f></ToLower></overloads>
		</ToLower>
		<ToLowerInvariant public="1" set="method" static="1"><f a="c">
	<t path="cs.types.Char16"/>
	<t path="cs.types.Char16"/>
</f></ToLowerInvariant>
		<ToUpper public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<t path="cs.types.Char16"/>
			</f>
			<overloads><ToUpper public="1" set="method"><f a="c:culture">
	<t path="cs.types.Char16"/>
	<c path="cs.system.globalization.CultureInfo"/>
	<t path="cs.types.Char16"/>
</f></ToUpper></overloads>
		</ToUpper>
		<ToUpperInvariant public="1" set="method" static="1"><f a="c">
	<t path="cs.types.Char16"/>
	<t path="cs.types.Char16"/>
</f></ToUpperInvariant>
		<ToString public="1" set="method" static="1"><f a="c">
	<t path="cs.types.Char16"/>
	<c path="String"/>
</f></ToString>
		<_ToString public="1" set="method" static="1">
			<f a="c">
				<t path="cs.types.Char16"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"ToString"</e></m></meta>
		</_ToString>
		<CompareTo final="1" public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads><CompareTo final="1" public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Int"/>
</f></CompareTo></overloads>
		</CompareTo>
		<ToString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<overloads><ToString final="1" public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString></overloads>
		</ToString>
		<GetTypeCode final="1" public="1" set="method"><f a=""><e path="cs.system.TypeCode"/></f></GetTypeCode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Char"</e></m>
		</meta>
	</class>
	<class path="cs.system.CharEnumerator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.CharEnumerator" extern="1" final="1">
		<implements path="cs.system.collections.generic.IEnumerator_1"><t path="cs.types.Char16"/></implements>
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.IDisposable"/>
		<implements path="cs.system.collections.IEnumerator"/>
		<Current public="1" get="accessor" set="null">
			<t path="cs.types.Char16"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</Current>
		<get_Current final="1" public="1" set="method">
			<f a=""><t path="cs.types.Char16"/></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</get_Current>
		<Clone final="1" public="1" set="method"><f a=""><d/></f></Clone>
		<MoveNext final="1" public="1" set="method"><f a=""><x path="Bool"/></f></MoveNext>
		<Reset final="1" public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.CharEnumerator"</e></m>
		</meta>
	</class>
	<class path="cs.system.Delegate_Comparison_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Comparison_1" module="cs.system.Comparison_1" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" params="T0" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Comparison_1"><c path="op_Addition.T0"/></x>
	<x path="cs.system.Comparison_1"><c path="op_Addition.T0"/></x>
	<x path="cs.system.Comparison_1"><c path="op_Addition.T0"/></x>
</f></op_Addition>
		<op_Subtraction public="1" params="T0" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Comparison_1"><c path="op_Subtraction.T0"/></x>
	<x path="cs.system.Comparison_1"><c path="op_Subtraction.T0"/></x>
	<x path="cs.system.Comparison_1"><c path="op_Subtraction.T0"/></x>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="x:y">
	<c path="cs.system.Delegate_Comparison_1.T0"/>
	<c path="cs.system.Delegate_Comparison_1.T0"/>
	<x path="Int"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="x:y:callback:object">
	<c path="cs.system.Delegate_Comparison_1.T0"/>
	<c path="cs.system.Delegate_Comparison_1.T0"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Int"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Comparison`1"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.Comparison_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Comparison_1">
		<from><icast field="FromHaxeFunction"><f a=":">
	<c path="FromHaxeFunction.T0"/>
	<c path="FromHaxeFunction.T0"/>
	<x path="Int"/>
</f></icast></from>
		<this><c path="cs.system.Delegate_Comparison_1"><c path="cs.system.Comparison_1.T0"/></c></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._Comparison_1.Comparison_1_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Comparison_1" private="1" module="cs.system.Comparison_1" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<c path="cs.system.Comparison_1.T0"/>
				<c path="cs.system.Comparison_1.T0"/>
				<x path="Int"/>
			</f>
			<x path="cs.system.Comparison_1"><c path="cs.system.Comparison_1.T0"/></x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" params="T0" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<c path="FromHaxeFunction.T0"/>
				<c path="FromHaxeFunction.T0"/>
				<x path="Int"/>
			</f>
			<x path="cs.system.Comparison_1"><c path="FromHaxeFunction.T0"/></x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_Comparison_1"><c path="cs.system.Comparison_1.T0"/></c>
	<c path="cs.system.Delegate_Comparison_1"><c path="cs.system.Comparison_1.T0"/></c>
</f></AsDelegate>
	<Add public="1" params="T0" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Comparison_1"><c path="Add.T0"/></x>
			<x path="cs.system.Comparison_1"><c path="Add.T0"/></x>
			<x path="cs.system.Comparison_1"><c path="Add.T0"/></x>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" params="T0" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Comparison_1"><c path="Remove.T0"/></x>
			<x path="cs.system.Comparison_1"><c path="Remove.T0"/></x>
			<x path="cs.system.Comparison_1"><c path="Remove.T0"/></x>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._Comparison_1.Comparison_1_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Comparison_1" private="1" module="cs.system.Comparison_1" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<c path="cs.system.Comparison_1.T0"/>
					<c path="cs.system.Comparison_1.T0"/>
					<x path="Int"/>
				</f>
				<x path="cs.system.Comparison_1"><c path="cs.system.Comparison_1.T0"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" params="T0" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<c path="FromHaxeFunction.T0"/>
					<c path="FromHaxeFunction.T0"/>
					<x path="Int"/>
				</f>
				<x path="cs.system.Comparison_1"><c path="FromHaxeFunction.T0"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_Comparison_1"><c path="cs.system.Comparison_1.T0"/></c>
	<c path="cs.system.Delegate_Comparison_1"><c path="cs.system.Comparison_1.T0"/></c>
</f></AsDelegate>
		<Add public="1" params="T0" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Comparison_1"><c path="Add.T0"/></x>
				<x path="cs.system.Comparison_1"><c path="Add.T0"/></x>
				<x path="cs.system.Comparison_1"><c path="Add.T0"/></x>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" params="T0" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Comparison_1"><c path="Remove.T0"/></x>
				<x path="cs.system.Comparison_1"><c path="Remove.T0"/></x>
				<x path="cs.system.Comparison_1"><c path="Remove.T0"/></x>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.Console_Delegate_InternalCancelHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Console" module="cs.system.Console" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Console_InternalCancelHandler"/>
	<x path="cs.system.Console_InternalCancelHandler"/>
	<x path="cs.system.Console_InternalCancelHandler"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Console_InternalCancelHandler"/>
	<x path="cs.system.Console_InternalCancelHandler"/>
	<x path="cs.system.Console_InternalCancelHandler"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a=""><x path="Void"/></f></Invoke>
		<BeginInvoke public="1" set="method"><f a="callback:object">
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Console.InternalCancelHandler"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.Console_InternalCancelHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Console" module="cs.system.Console">
		<from><icast field="FromHaxeFunction"><f a=""><x path="Void"/></f></icast></from>
		<this><c path="cs.system.Console_Delegate_InternalCancelHandler"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._Console.Console_InternalCancelHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Console" private="1" module="cs.system.Console" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=""><x path="Void"/></f>
			<x path="cs.system.Console_InternalCancelHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=""><x path="Void"/></f>
			<x path="cs.system.Console_InternalCancelHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Console_Delegate_InternalCancelHandler"/>
	<c path="cs.system.Console_Delegate_InternalCancelHandler"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Console_InternalCancelHandler"/>
			<x path="cs.system.Console_InternalCancelHandler"/>
			<x path="cs.system.Console_InternalCancelHandler"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Console_InternalCancelHandler"/>
			<x path="cs.system.Console_InternalCancelHandler"/>
			<x path="cs.system.Console_InternalCancelHandler"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._Console.Console_InternalCancelHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Console" private="1" module="cs.system.Console" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=""><x path="Void"/></f>
				<x path="cs.system.Console_InternalCancelHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=""><x path="Void"/></f>
				<x path="cs.system.Console_InternalCancelHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Console_Delegate_InternalCancelHandler"/>
	<c path="cs.system.Console_Delegate_InternalCancelHandler"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Console_InternalCancelHandler"/>
				<x path="cs.system.Console_InternalCancelHandler"/>
				<x path="cs.system.Console_InternalCancelHandler"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Console_InternalCancelHandler"/>
				<x path="cs.system.Console_InternalCancelHandler"/>
				<x path="cs.system.Console_InternalCancelHandler"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.Console_WindowsConsole_Delegate_WindowsCancelHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Console" module="cs.system.Console" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
	<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
	<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
	<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
	<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="keyCode">
	<x path="Int"/>
	<x path="Bool"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="keyCode:callback:object">
	<x path="Int"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Bool"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Console.WindowsConsole.WindowsCancelHandler"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.Console_WindowsConsole_WindowsCancelHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Console" module="cs.system.Console">
		<from><icast field="FromHaxeFunction"><f a="">
	<x path="Int"/>
	<x path="Bool"/>
</f></icast></from>
		<this><c path="cs.system.Console_WindowsConsole_Delegate_WindowsCancelHandler"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._Console.Console_WindowsConsole_WindowsCancelHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Console" private="1" module="cs.system.Console" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Console_WindowsConsole_Delegate_WindowsCancelHandler"/>
	<c path="cs.system.Console_WindowsConsole_Delegate_WindowsCancelHandler"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
			<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
			<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
			<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
			<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._Console.Console_WindowsConsole_WindowsCancelHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Console" private="1" module="cs.system.Console" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<x path="Int"/>
					<x path="Bool"/>
				</f>
				<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<x path="Int"/>
					<x path="Bool"/>
				</f>
				<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Console_WindowsConsole_Delegate_WindowsCancelHandler"/>
	<c path="cs.system.Console_WindowsConsole_Delegate_WindowsCancelHandler"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
				<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
				<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
				<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
				<x path="cs.system.Console_WindowsConsole_WindowsCancelHandler"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.Console_WindowsConsole" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Console" module="cs.system.Console" extern="1">
		<ctrlHandlerAdded public="1" static="1"><x path="Bool"/></ctrlHandlerAdded>
		<GetInputCodePage public="1" set="method" static="1"><f a=""><x path="Int"/></f></GetInputCodePage>
		<GetOutputCodePage public="1" set="method" static="1"><f a=""><x path="Int"/></f></GetOutputCodePage>
		<AddCtrlHandler public="1" set="method" static="1"><f a=""><x path="Void"/></f></AddCtrlHandler>
		<RemoveCtrlHandler public="1" set="method" static="1"><f a=""><x path="Void"/></f></RemoveCtrlHandler>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Console.WindowsConsole"</e></m>
		</meta>
	</class>
	<class path="cs.system.ConsoleCancelEventArgs" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ConsoleCancelEventArgs" extern="1" final="1">
		<extends path="cs.system.EventArgs"/>
		<SpecialKey public="1" get="accessor" set="null"><e path="cs.system.ConsoleSpecialKey"/></SpecialKey>
		<Cancel public="1" get="accessor" set="accessor"><x path="Bool"/></Cancel>
		<get_Cancel final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_Cancel>
		<set_Cancel final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_Cancel>
		<get_SpecialKey final="1" public="1" set="method"><f a=""><e path="cs.system.ConsoleSpecialKey"/></f></get_SpecialKey>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ConsoleCancelEventArgs"</e></m>
		</meta>
	</class>
	<class path="cs.system.Delegate_ConsoleCancelEventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ConsoleCancelEventHandler" module="cs.system.ConsoleCancelEventHandler" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.ConsoleCancelEventHandler"/>
	<x path="cs.system.ConsoleCancelEventHandler"/>
	<x path="cs.system.ConsoleCancelEventHandler"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.ConsoleCancelEventHandler"/>
	<x path="cs.system.ConsoleCancelEventHandler"/>
	<x path="cs.system.ConsoleCancelEventHandler"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="sender:e">
	<d/>
	<c path="cs.system.ConsoleCancelEventArgs"/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="sender:e:callback:object">
	<d/>
	<c path="cs.system.ConsoleCancelEventArgs"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ConsoleCancelEventHandler"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.ConsoleCancelEventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ConsoleCancelEventHandler">
		<from><icast field="FromHaxeFunction"><f a=":">
	<d/>
	<c path="cs.system.ConsoleCancelEventArgs"/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.Delegate_ConsoleCancelEventHandler"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._ConsoleCancelEventHandler.ConsoleCancelEventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ConsoleCancelEventHandler" private="1" module="cs.system.ConsoleCancelEventHandler" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.ConsoleCancelEventArgs"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.ConsoleCancelEventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.ConsoleCancelEventArgs"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.ConsoleCancelEventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_ConsoleCancelEventHandler"/>
	<c path="cs.system.Delegate_ConsoleCancelEventHandler"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.ConsoleCancelEventHandler"/>
			<x path="cs.system.ConsoleCancelEventHandler"/>
			<x path="cs.system.ConsoleCancelEventHandler"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.ConsoleCancelEventHandler"/>
			<x path="cs.system.ConsoleCancelEventHandler"/>
			<x path="cs.system.ConsoleCancelEventHandler"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._ConsoleCancelEventHandler.ConsoleCancelEventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ConsoleCancelEventHandler" private="1" module="cs.system.ConsoleCancelEventHandler" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.ConsoleCancelEventArgs"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.ConsoleCancelEventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.ConsoleCancelEventArgs"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.ConsoleCancelEventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_ConsoleCancelEventHandler"/>
	<c path="cs.system.Delegate_ConsoleCancelEventHandler"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.ConsoleCancelEventHandler"/>
				<x path="cs.system.ConsoleCancelEventHandler"/>
				<x path="cs.system.ConsoleCancelEventHandler"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.ConsoleCancelEventHandler"/>
				<x path="cs.system.ConsoleCancelEventHandler"/>
				<x path="cs.system.ConsoleCancelEventHandler"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<enum path="cs.system.ConsoleColor" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ConsoleColor">
		<Black><meta><m n=":csNative"><e>0</e></m></meta></Black>
		<DarkBlue><meta><m n=":csNative"><e>1</e></m></meta></DarkBlue>
		<DarkGreen><meta><m n=":csNative"><e>2</e></m></meta></DarkGreen>
		<DarkCyan><meta><m n=":csNative"><e>3</e></m></meta></DarkCyan>
		<DarkRed><meta><m n=":csNative"><e>4</e></m></meta></DarkRed>
		<DarkMagenta><meta><m n=":csNative"><e>5</e></m></meta></DarkMagenta>
		<DarkYellow><meta><m n=":csNative"><e>6</e></m></meta></DarkYellow>
		<Gray><meta><m n=":csNative"><e>7</e></m></meta></Gray>
		<DarkGray><meta><m n=":csNative"><e>8</e></m></meta></DarkGray>
		<Blue><meta><m n=":csNative"><e>9</e></m></meta></Blue>
		<Green><meta><m n=":csNative"><e>10</e></m></meta></Green>
		<Cyan><meta><m n=":csNative"><e>11</e></m></meta></Cyan>
		<Red><meta><m n=":csNative"><e>12</e></m></meta></Red>
		<Magenta><meta><m n=":csNative"><e>13</e></m></meta></Magenta>
		<Yellow><meta><m n=":csNative"><e>14</e></m></meta></Yellow>
		<White><meta><m n=":csNative"><e>15</e></m></meta></White>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.ConsoleColor"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.ConsoleKey" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ConsoleKey">
		<Backspace><meta><m n=":csNative"><e>8</e></m></meta></Backspace>
		<Tab><meta><m n=":csNative"><e>9</e></m></meta></Tab>
		<Clear><meta><m n=":csNative"><e>12</e></m></meta></Clear>
		<Enter><meta><m n=":csNative"><e>13</e></m></meta></Enter>
		<Pause><meta><m n=":csNative"><e>19</e></m></meta></Pause>
		<Escape><meta><m n=":csNative"><e>27</e></m></meta></Escape>
		<Spacebar><meta><m n=":csNative"><e>32</e></m></meta></Spacebar>
		<PageUp><meta><m n=":csNative"><e>33</e></m></meta></PageUp>
		<PageDown><meta><m n=":csNative"><e>34</e></m></meta></PageDown>
		<End><meta><m n=":csNative"><e>35</e></m></meta></End>
		<Home><meta><m n=":csNative"><e>36</e></m></meta></Home>
		<LeftArrow><meta><m n=":csNative"><e>37</e></m></meta></LeftArrow>
		<UpArrow><meta><m n=":csNative"><e>38</e></m></meta></UpArrow>
		<RightArrow><meta><m n=":csNative"><e>39</e></m></meta></RightArrow>
		<DownArrow><meta><m n=":csNative"><e>40</e></m></meta></DownArrow>
		<Select><meta><m n=":csNative"><e>41</e></m></meta></Select>
		<Print><meta><m n=":csNative"><e>42</e></m></meta></Print>
		<Execute><meta><m n=":csNative"><e>43</e></m></meta></Execute>
		<PrintScreen><meta><m n=":csNative"><e>44</e></m></meta></PrintScreen>
		<Insert><meta><m n=":csNative"><e>45</e></m></meta></Insert>
		<Delete><meta><m n=":csNative"><e>46</e></m></meta></Delete>
		<Help><meta><m n=":csNative"><e>47</e></m></meta></Help>
		<D0><meta><m n=":csNative"><e>48</e></m></meta></D0>
		<D1><meta><m n=":csNative"><e>49</e></m></meta></D1>
		<D2><meta><m n=":csNative"><e>50</e></m></meta></D2>
		<D3><meta><m n=":csNative"><e>51</e></m></meta></D3>
		<D4><meta><m n=":csNative"><e>52</e></m></meta></D4>
		<D5><meta><m n=":csNative"><e>53</e></m></meta></D5>
		<D6><meta><m n=":csNative"><e>54</e></m></meta></D6>
		<D7><meta><m n=":csNative"><e>55</e></m></meta></D7>
		<D8><meta><m n=":csNative"><e>56</e></m></meta></D8>
		<D9><meta><m n=":csNative"><e>57</e></m></meta></D9>
		<A><meta><m n=":csNative"><e>65</e></m></meta></A>
		<B><meta><m n=":csNative"><e>66</e></m></meta></B>
		<C><meta><m n=":csNative"><e>67</e></m></meta></C>
		<D><meta><m n=":csNative"><e>68</e></m></meta></D>
		<E><meta><m n=":csNative"><e>69</e></m></meta></E>
		<F><meta><m n=":csNative"><e>70</e></m></meta></F>
		<G><meta><m n=":csNative"><e>71</e></m></meta></G>
		<H><meta><m n=":csNative"><e>72</e></m></meta></H>
		<I><meta><m n=":csNative"><e>73</e></m></meta></I>
		<J><meta><m n=":csNative"><e>74</e></m></meta></J>
		<K><meta><m n=":csNative"><e>75</e></m></meta></K>
		<L><meta><m n=":csNative"><e>76</e></m></meta></L>
		<M><meta><m n=":csNative"><e>77</e></m></meta></M>
		<N><meta><m n=":csNative"><e>78</e></m></meta></N>
		<O><meta><m n=":csNative"><e>79</e></m></meta></O>
		<P><meta><m n=":csNative"><e>80</e></m></meta></P>
		<Q><meta><m n=":csNative"><e>81</e></m></meta></Q>
		<R><meta><m n=":csNative"><e>82</e></m></meta></R>
		<S><meta><m n=":csNative"><e>83</e></m></meta></S>
		<T><meta><m n=":csNative"><e>84</e></m></meta></T>
		<U><meta><m n=":csNative"><e>85</e></m></meta></U>
		<V><meta><m n=":csNative"><e>86</e></m></meta></V>
		<W><meta><m n=":csNative"><e>87</e></m></meta></W>
		<X><meta><m n=":csNative"><e>88</e></m></meta></X>
		<Y><meta><m n=":csNative"><e>89</e></m></meta></Y>
		<Z><meta><m n=":csNative"><e>90</e></m></meta></Z>
		<LeftWindows><meta><m n=":csNative"><e>91</e></m></meta></LeftWindows>
		<RightWindows><meta><m n=":csNative"><e>92</e></m></meta></RightWindows>
		<Applications><meta><m n=":csNative"><e>93</e></m></meta></Applications>
		<Sleep><meta><m n=":csNative"><e>95</e></m></meta></Sleep>
		<NumPad0><meta><m n=":csNative"><e>96</e></m></meta></NumPad0>
		<NumPad1><meta><m n=":csNative"><e>97</e></m></meta></NumPad1>
		<NumPad2><meta><m n=":csNative"><e>98</e></m></meta></NumPad2>
		<NumPad3><meta><m n=":csNative"><e>99</e></m></meta></NumPad3>
		<NumPad4><meta><m n=":csNative"><e>100</e></m></meta></NumPad4>
		<NumPad5><meta><m n=":csNative"><e>101</e></m></meta></NumPad5>
		<NumPad6><meta><m n=":csNative"><e>102</e></m></meta></NumPad6>
		<NumPad7><meta><m n=":csNative"><e>103</e></m></meta></NumPad7>
		<NumPad8><meta><m n=":csNative"><e>104</e></m></meta></NumPad8>
		<NumPad9><meta><m n=":csNative"><e>105</e></m></meta></NumPad9>
		<Multiply><meta><m n=":csNative"><e>106</e></m></meta></Multiply>
		<Add><meta><m n=":csNative"><e>107</e></m></meta></Add>
		<Separator><meta><m n=":csNative"><e>108</e></m></meta></Separator>
		<Subtract><meta><m n=":csNative"><e>109</e></m></meta></Subtract>
		<Decimal><meta><m n=":csNative"><e>110</e></m></meta></Decimal>
		<Divide><meta><m n=":csNative"><e>111</e></m></meta></Divide>
		<F1><meta><m n=":csNative"><e>112</e></m></meta></F1>
		<F2><meta><m n=":csNative"><e>113</e></m></meta></F2>
		<F3><meta><m n=":csNative"><e>114</e></m></meta></F3>
		<F4><meta><m n=":csNative"><e>115</e></m></meta></F4>
		<F5><meta><m n=":csNative"><e>116</e></m></meta></F5>
		<F6><meta><m n=":csNative"><e>117</e></m></meta></F6>
		<F7><meta><m n=":csNative"><e>118</e></m></meta></F7>
		<F8><meta><m n=":csNative"><e>119</e></m></meta></F8>
		<F9><meta><m n=":csNative"><e>120</e></m></meta></F9>
		<F10><meta><m n=":csNative"><e>121</e></m></meta></F10>
		<F11><meta><m n=":csNative"><e>122</e></m></meta></F11>
		<F12><meta><m n=":csNative"><e>123</e></m></meta></F12>
		<F13><meta><m n=":csNative"><e>124</e></m></meta></F13>
		<F14><meta><m n=":csNative"><e>125</e></m></meta></F14>
		<F15><meta><m n=":csNative"><e>126</e></m></meta></F15>
		<F16><meta><m n=":csNative"><e>127</e></m></meta></F16>
		<F17><meta><m n=":csNative"><e>128</e></m></meta></F17>
		<F18><meta><m n=":csNative"><e>129</e></m></meta></F18>
		<F19><meta><m n=":csNative"><e>130</e></m></meta></F19>
		<F20><meta><m n=":csNative"><e>131</e></m></meta></F20>
		<F21><meta><m n=":csNative"><e>132</e></m></meta></F21>
		<F22><meta><m n=":csNative"><e>133</e></m></meta></F22>
		<F23><meta><m n=":csNative"><e>134</e></m></meta></F23>
		<F24><meta><m n=":csNative"><e>135</e></m></meta></F24>
		<BrowserBack><meta><m n=":csNative"><e>166</e></m></meta></BrowserBack>
		<BrowserForward><meta><m n=":csNative"><e>167</e></m></meta></BrowserForward>
		<BrowserRefresh><meta><m n=":csNative"><e>168</e></m></meta></BrowserRefresh>
		<BrowserStop><meta><m n=":csNative"><e>169</e></m></meta></BrowserStop>
		<BrowserSearch><meta><m n=":csNative"><e>170</e></m></meta></BrowserSearch>
		<BrowserFavorites><meta><m n=":csNative"><e>171</e></m></meta></BrowserFavorites>
		<BrowserHome><meta><m n=":csNative"><e>172</e></m></meta></BrowserHome>
		<VolumeMute><meta><m n=":csNative"><e>173</e></m></meta></VolumeMute>
		<VolumeDown><meta><m n=":csNative"><e>174</e></m></meta></VolumeDown>
		<VolumeUp><meta><m n=":csNative"><e>175</e></m></meta></VolumeUp>
		<MediaNext><meta><m n=":csNative"><e>176</e></m></meta></MediaNext>
		<MediaPrevious><meta><m n=":csNative"><e>177</e></m></meta></MediaPrevious>
		<MediaStop><meta><m n=":csNative"><e>178</e></m></meta></MediaStop>
		<MediaPlay><meta><m n=":csNative"><e>179</e></m></meta></MediaPlay>
		<LaunchMail><meta><m n=":csNative"><e>180</e></m></meta></LaunchMail>
		<LaunchMediaSelect><meta><m n=":csNative"><e>181</e></m></meta></LaunchMediaSelect>
		<LaunchApp1><meta><m n=":csNative"><e>182</e></m></meta></LaunchApp1>
		<LaunchApp2><meta><m n=":csNative"><e>183</e></m></meta></LaunchApp2>
		<Oem1><meta><m n=":csNative"><e>186</e></m></meta></Oem1>
		<OemPlus><meta><m n=":csNative"><e>187</e></m></meta></OemPlus>
		<OemComma><meta><m n=":csNative"><e>188</e></m></meta></OemComma>
		<OemMinus><meta><m n=":csNative"><e>189</e></m></meta></OemMinus>
		<OemPeriod><meta><m n=":csNative"><e>190</e></m></meta></OemPeriod>
		<Oem2><meta><m n=":csNative"><e>191</e></m></meta></Oem2>
		<Oem3><meta><m n=":csNative"><e>192</e></m></meta></Oem3>
		<Oem4><meta><m n=":csNative"><e>219</e></m></meta></Oem4>
		<Oem5><meta><m n=":csNative"><e>220</e></m></meta></Oem5>
		<Oem6><meta><m n=":csNative"><e>221</e></m></meta></Oem6>
		<Oem7><meta><m n=":csNative"><e>222</e></m></meta></Oem7>
		<Oem8><meta><m n=":csNative"><e>223</e></m></meta></Oem8>
		<Oem102><meta><m n=":csNative"><e>226</e></m></meta></Oem102>
		<Process><meta><m n=":csNative"><e>229</e></m></meta></Process>
		<Packet><meta><m n=":csNative"><e>231</e></m></meta></Packet>
		<Attention><meta><m n=":csNative"><e>246</e></m></meta></Attention>
		<CrSel><meta><m n=":csNative"><e>247</e></m></meta></CrSel>
		<ExSel><meta><m n=":csNative"><e>248</e></m></meta></ExSel>
		<EraseEndOfFile><meta><m n=":csNative"><e>249</e></m></meta></EraseEndOfFile>
		<Play><meta><m n=":csNative"><e>250</e></m></meta></Play>
		<Zoom><meta><m n=":csNative"><e>251</e></m></meta></Zoom>
		<NoName><meta><m n=":csNative"><e>252</e></m></meta></NoName>
		<Pa1><meta><m n=":csNative"><e>253</e></m></meta></Pa1>
		<OemClear><meta><m n=":csNative"><e>254</e></m></meta></OemClear>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.ConsoleKey"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.ConsoleKeyInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ConsoleKeyInfo" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.ConsoleKeyInfo"/>
	<c path="cs.system.ConsoleKeyInfo"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.ConsoleKeyInfo"/>
	<c path="cs.system.ConsoleKeyInfo"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Modifiers public="1" get="accessor" set="null"><e path="cs.system.ConsoleModifiers"/></Modifiers>
		<KeyChar public="1" get="accessor" set="null"><t path="cs.types.Char16"/></KeyChar>
		<Key public="1" get="accessor" set="null"><e path="cs.system.ConsoleKey"/></Key>
		<get_Key final="1" public="1" set="method"><f a=""><e path="cs.system.ConsoleKey"/></f></get_Key>
		<get_KeyChar final="1" public="1" set="method"><f a=""><t path="cs.types.Char16"/></f></get_KeyChar>
		<get_Modifiers final="1" public="1" set="method"><f a=""><e path="cs.system.ConsoleModifiers"/></f></get_Modifiers>
		<new final="1" public="1" set="method"><f a="keyChar:key:shift:alt:control">
	<t path="cs.types.Char16"/>
	<e path="cs.system.ConsoleKey"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ConsoleKeyInfo"</e></m>
		</meta>
	</class>
	<enum path="cs.system.ConsoleModifiers" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ConsoleModifiers">
		<Alt><meta><m n=":csNative"><e>1</e></m></meta></Alt>
		<Shift><meta><m n=":csNative"><e>2</e></m></meta></Shift>
		<Control><meta><m n=":csNative"><e>4</e></m></meta></Control>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.ConsoleModifiers"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.ConsoleSpecialKey" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ConsoleSpecialKey">
		<ControlC><meta><m n=":csNative"><e>0</e></m></meta></ControlC>
		<ControlBreak><meta><m n=":csNative"><e>1</e></m></meta></ControlBreak>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.ConsoleSpecialKey"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.ContextBoundObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ContextBoundObject" extern="1" abstract="1">
		<extends path="cs.system.MarshalByRefObject"/>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ContextBoundObject"</e></m>
		</meta>
	</class>
	<class path="cs.system.Convert" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Convert" extern="1" final="1">
		<DBNull public="1" set="null" static="1">
			<d/>
			<meta><m n=":readOnly"/></meta>
		</DBNull>
		<FromBase64CharArray public="1" set="method" static="1"><f a="inArray:offset:length">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></FromBase64CharArray>
		<FromBase64String public="1" set="method" static="1"><f a="s">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></FromBase64String>
		<GetTypeCode public="1" set="method" static="1"><f a="value">
	<d/>
	<e path="cs.system.TypeCode"/>
</f></GetTypeCode>
		<IsDBNull public="1" set="method" static="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></IsDBNull>
		<ToBase64CharArray public="1" set="method" static="1">
			<f a="inArray:offsetIn:length:outArray:offsetOut">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<overloads><ToBase64CharArray public="1" set="method"><f a="inArray:offsetIn:length:outArray:offsetOut:options">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<e path="cs.system.Base64FormattingOptions"/>
	<x path="Int"/>
</f></ToBase64CharArray></overloads>
		</ToBase64CharArray>
		<ToBase64String public="1" set="method" static="1">
			<f a="inArray">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<c path="String"/>
			</f>
			<overloads>
				<ToBase64String public="1" set="method"><f a="inArray:offset:length:options">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<e path="cs.system.Base64FormattingOptions"/>
	<c path="String"/>
</f></ToBase64String>
				<ToBase64String public="1" set="method"><f a="inArray:options">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<e path="cs.system.Base64FormattingOptions"/>
	<c path="String"/>
</f></ToBase64String>
				<ToBase64String public="1" set="method"><f a="inArray:offset:length">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></ToBase64String>
			</overloads>
		</ToBase64String>
		<ToBoolean public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<overloads>
				<ToBoolean public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Bool"/>
</f></ToBoolean>
				<ToBoolean public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<x path="Bool"/>
</f></ToBoolean>
			</overloads>
		</ToBoolean>
		<ToByte public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<t path="cs.types.UInt8"/>
			</f>
			<overloads>
				<ToByte public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<d/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<x path="UInt"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value:fromBase">
	<c path="String"/>
	<x path="Int"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<c path="String"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<x path="Single"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<x path="Float"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
				<ToByte public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
			</overloads>
		</ToByte>
		<ToChar public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<t path="cs.types.Char16"/>
			</f>
			<overloads>
				<ToChar public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<d/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<x path="UInt"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<c path="String"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<x path="Single"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<x path="Int"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<x path="Float"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
				<ToChar public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<t path="cs.types.Char16"/>
</f></ToChar>
			</overloads>
		</ToChar>
		<ToDateTime public="1" set="method" static="1">
			<f a="value">
				<c path="String"/>
				<c path="cs.system.DateTime"/>
			</f>
			<overloads>
				<ToDateTime public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<x path="UInt"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<d/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<x path="Single"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<x path="Int"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<x path="Float"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value">
	<x path="Bool"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
				<ToDateTime public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
			</overloads>
		</ToDateTime>
		<ToDecimal public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<c path="cs.system.Decimal"/>
			</f>
			<overloads>
				<ToDecimal public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<d/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<x path="UInt"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<x path="Int"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<x path="Single"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<x path="Float"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
				<ToDecimal public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
			</overloads>
		</ToDecimal>
		<ToDouble public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<overloads>
				<ToDouble public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<d/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Float"/>
</f></ToDouble>
				<ToDouble public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<x path="Float"/>
</f></ToDouble>
			</overloads>
		</ToDouble>
		<ToInt16 public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<t path="cs.types.Int16"/>
			</f>
			<overloads>
				<ToInt16 public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<d/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value:fromBase">
	<c path="String"/>
	<x path="Int"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<c path="String"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<x path="Int"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<x path="Single"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<x path="Float"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
				<ToInt16 public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
			</overloads>
		</ToInt16>
		<ToInt32 public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<overloads>
				<ToInt32 public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<d/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value:fromBase">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Int"/>
</f></ToInt32>
				<ToInt32 public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<x path="Int"/>
</f></ToInt32>
			</overloads>
		</ToInt32>
		<ToInt64 public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<x path="haxe.Int64"/>
			</f>
			<overloads>
				<ToInt64 public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<d/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value:fromBase">
	<c path="String"/>
	<x path="Int"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
				<ToInt64 public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<x path="haxe.Int64"/>
</f></ToInt64>
			</overloads>
		</ToInt64>
		<ToSByte public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<t path="cs.types.Int8"/>
			</f>
			<overloads>
				<ToSByte public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<d/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<x path="UInt"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value:fromBase">
	<c path="String"/>
	<x path="Int"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<c path="String"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<x path="Single"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<x path="Float"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
				<ToSByte public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
			</overloads>
		</ToSByte>
		<ToSingle public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<x path="Single"/>
			</f>
			<overloads>
				<ToSingle public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<d/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Single"/>
</f></ToSingle>
				<ToSingle public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<x path="Single"/>
</f></ToSingle>
			</overloads>
		</ToSingle>
		<ToString public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<overloads>
				<ToString public="1" set="method"><f a="value:provider">
	<t path="cs.types.UInt16"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<t path="cs.types.UInt64"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<x path="UInt"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<x path="UInt"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<t path="cs.types.Int16"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:toBase">
	<t path="cs.types.Int16"/>
	<x path="Int"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<t path="cs.types.Int8"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<d/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<x path="haxe.Int64"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:toBase">
	<x path="haxe.Int64"/>
	<x path="Int"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<x path="Int"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:toBase">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<x path="Int"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<x path="Single"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<x path="Single"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<x path="Float"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<x path="Float"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<t path="cs.types.Char16"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:toBase">
	<t path="cs.types.UInt8"/>
	<x path="Int"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<t path="cs.types.UInt8"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a="value:provider">
	<x path="Bool"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
			</overloads>
		</ToString>
		<_ToString public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"ToString"</e></m></meta>
			<overloads>
				<ToString public="1" set="method">
					<f a="value:provider">
						<t path="cs.types.UInt16"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<t path="cs.types.UInt16"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<t path="cs.types.UInt64"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<t path="cs.types.UInt64"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<x path="UInt"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<x path="UInt"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<c path="String"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<c path="String"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<t path="cs.types.Int16"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:toBase">
						<t path="cs.types.Int16"/>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<t path="cs.types.Int16"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<t path="cs.types.Int8"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<t path="cs.types.Int8"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<d/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<d/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<x path="haxe.Int64"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:toBase">
						<x path="haxe.Int64"/>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<x path="haxe.Int64"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<x path="Int"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:toBase">
						<x path="Int"/>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<x path="Int"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<x path="Single"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<x path="Single"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<x path="Float"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<x path="Float"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<c path="cs.system.Decimal"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<c path="cs.system.Decimal"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<c path="cs.system.DateTime"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<c path="cs.system.DateTime"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<t path="cs.types.Char16"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<t path="cs.types.Char16"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:toBase">
						<t path="cs.types.UInt8"/>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<t path="cs.types.UInt8"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value">
						<t path="cs.types.UInt8"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
				<ToString public="1" set="method">
					<f a="value:provider">
						<x path="Bool"/>
						<c path="cs.system.IFormatProvider"/>
						<c path="String"/>
					</f>
					<meta><m n=":native"><e>"ToString"</e></m></meta>
				</ToString>
			</overloads>
		</_ToString>
		<ToUInt16 public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<t path="cs.types.UInt16"/>
			</f>
			<overloads>
				<ToUInt16 public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<d/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<x path="UInt"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value:fromBase">
	<c path="String"/>
	<x path="Int"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<c path="String"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<x path="Int"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<x path="Single"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<x path="Float"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
				<ToUInt16 public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
			</overloads>
		</ToUInt16>
		<ToUInt32 public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<x path="UInt"/>
			</f>
			<overloads>
				<ToUInt32 public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<d/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value:fromBase">
	<c path="String"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="UInt"/>
</f></ToUInt32>
				<ToUInt32 public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<x path="UInt"/>
</f></ToUInt32>
			</overloads>
		</ToUInt32>
		<ToUInt64 public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<t path="cs.types.UInt64"/>
			</f>
			<overloads>
				<ToUInt64 public="1" set="method"><f a="value:provider">
	<d/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<d/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<x path="UInt"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value:fromBase">
	<c path="String"/>
	<x path="Int"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<c path="String"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<x path="Int"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<x path="Single"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<x path="Float"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
				<ToUInt64 public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
			</overloads>
		</ToUInt64>
		<ChangeType public="1" set="method" static="1">
			<f a="value:conversionType">
				<d/>
				<c path="cs.system.Type"/>
				<d/>
			</f>
			<overloads>
				<ChangeType public="1" set="method"><f a="value:typeCode:provider">
	<d/>
	<e path="cs.system.TypeCode"/>
	<c path="cs.system.IFormatProvider"/>
	<d/>
</f></ChangeType>
				<ChangeType public="1" set="method"><f a="value:conversionType:provider">
	<d/>
	<c path="cs.system.Type"/>
	<c path="cs.system.IFormatProvider"/>
	<d/>
</f></ChangeType>
				<ChangeType public="1" set="method"><f a="value:typeCode">
	<d/>
	<e path="cs.system.TypeCode"/>
	<d/>
</f></ChangeType>
			</overloads>
		</ChangeType>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Convert"</e></m>
		</meta>
	</class>
	<class path="cs.system.Delegate_Converter_2" params="T0:T1" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Converter_2" module="cs.system.Converter_2" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" params="T0:T1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Converter_2">
		<c path="op_Addition.T0"/>
		<c path="op_Addition.T1"/>
	</x>
	<x path="cs.system.Converter_2">
		<c path="op_Addition.T0"/>
		<c path="op_Addition.T1"/>
	</x>
	<x path="cs.system.Converter_2">
		<c path="op_Addition.T0"/>
		<c path="op_Addition.T1"/>
	</x>
</f></op_Addition>
		<op_Subtraction public="1" params="T0:T1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Converter_2">
		<c path="op_Subtraction.T0"/>
		<c path="op_Subtraction.T1"/>
	</x>
	<x path="cs.system.Converter_2">
		<c path="op_Subtraction.T0"/>
		<c path="op_Subtraction.T1"/>
	</x>
	<x path="cs.system.Converter_2">
		<c path="op_Subtraction.T0"/>
		<c path="op_Subtraction.T1"/>
	</x>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="input">
	<c path="cs.system.Delegate_Converter_2.T0"/>
	<c path="cs.system.Delegate_Converter_2.T1"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="input:callback:object">
	<c path="cs.system.Delegate_Converter_2.T0"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<c path="cs.system.Delegate_Converter_2.T1"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Converter`2"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.Converter_2" params="T0:T1" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Converter_2">
		<from><icast field="FromHaxeFunction"><f a="">
	<c path="FromHaxeFunction.T0"/>
	<c path="FromHaxeFunction.T1"/>
</f></icast></from>
		<this><c path="cs.system.Delegate_Converter_2">
	<c path="cs.system.Converter_2.T0"/>
	<c path="cs.system.Converter_2.T1"/>
</c></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._Converter_2.Converter_2_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Converter_2" private="1" module="cs.system.Converter_2" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="cs.system.Converter_2.T0"/>
				<c path="cs.system.Converter_2.T1"/>
			</f>
			<x path="cs.system.Converter_2">
				<c path="cs.system.Converter_2.T0"/>
				<c path="cs.system.Converter_2.T1"/>
			</x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" params="T0:T1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="FromHaxeFunction.T0"/>
				<c path="FromHaxeFunction.T1"/>
			</f>
			<x path="cs.system.Converter_2">
				<c path="FromHaxeFunction.T0"/>
				<c path="FromHaxeFunction.T1"/>
			</x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_Converter_2">
		<c path="cs.system.Converter_2.T0"/>
		<c path="cs.system.Converter_2.T1"/>
	</c>
	<c path="cs.system.Delegate_Converter_2">
		<c path="cs.system.Converter_2.T0"/>
		<c path="cs.system.Converter_2.T1"/>
	</c>
</f></AsDelegate>
	<Add public="1" params="T0:T1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Converter_2">
				<c path="Add.T0"/>
				<c path="Add.T1"/>
			</x>
			<x path="cs.system.Converter_2">
				<c path="Add.T0"/>
				<c path="Add.T1"/>
			</x>
			<x path="cs.system.Converter_2">
				<c path="Add.T0"/>
				<c path="Add.T1"/>
			</x>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" params="T0:T1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Converter_2">
				<c path="Remove.T0"/>
				<c path="Remove.T1"/>
			</x>
			<x path="cs.system.Converter_2">
				<c path="Remove.T0"/>
				<c path="Remove.T1"/>
			</x>
			<x path="cs.system.Converter_2">
				<c path="Remove.T0"/>
				<c path="Remove.T1"/>
			</x>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._Converter_2.Converter_2_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Converter_2" private="1" module="cs.system.Converter_2" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="cs.system.Converter_2.T0"/>
					<c path="cs.system.Converter_2.T1"/>
				</f>
				<x path="cs.system.Converter_2">
					<c path="cs.system.Converter_2.T0"/>
					<c path="cs.system.Converter_2.T1"/>
				</x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" params="T0:T1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="FromHaxeFunction.T0"/>
					<c path="FromHaxeFunction.T1"/>
				</f>
				<x path="cs.system.Converter_2">
					<c path="FromHaxeFunction.T0"/>
					<c path="FromHaxeFunction.T1"/>
				</x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_Converter_2">
		<c path="cs.system.Converter_2.T0"/>
		<c path="cs.system.Converter_2.T1"/>
	</c>
	<c path="cs.system.Delegate_Converter_2">
		<c path="cs.system.Converter_2.T0"/>
		<c path="cs.system.Converter_2.T1"/>
	</c>
</f></AsDelegate>
		<Add public="1" params="T0:T1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Converter_2">
					<c path="Add.T0"/>
					<c path="Add.T1"/>
				</x>
				<x path="cs.system.Converter_2">
					<c path="Add.T0"/>
					<c path="Add.T1"/>
				</x>
				<x path="cs.system.Converter_2">
					<c path="Add.T0"/>
					<c path="Add.T1"/>
				</x>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" params="T0:T1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Converter_2">
					<c path="Remove.T0"/>
					<c path="Remove.T1"/>
				</x>
				<x path="cs.system.Converter_2">
					<c path="Remove.T0"/>
					<c path="Remove.T1"/>
				</x>
				<x path="cs.system.Converter_2">
					<c path="Remove.T0"/>
					<c path="Remove.T1"/>
				</x>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.Delegate_CrossAppDomainDelegate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.CrossAppDomainDelegate" module="cs.system.CrossAppDomainDelegate" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.CrossAppDomainDelegate"/>
	<x path="cs.system.CrossAppDomainDelegate"/>
	<x path="cs.system.CrossAppDomainDelegate"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.CrossAppDomainDelegate"/>
	<x path="cs.system.CrossAppDomainDelegate"/>
	<x path="cs.system.CrossAppDomainDelegate"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a=""><x path="Void"/></f></Invoke>
		<BeginInvoke public="1" set="method"><f a="callback:object">
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.CrossAppDomainDelegate"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.CrossAppDomainDelegate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.CrossAppDomainDelegate">
		<from><icast field="FromHaxeFunction"><f a=""><x path="Void"/></f></icast></from>
		<this><c path="cs.system.Delegate_CrossAppDomainDelegate"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._CrossAppDomainDelegate.CrossAppDomainDelegate_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.CrossAppDomainDelegate" private="1" module="cs.system.CrossAppDomainDelegate" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=""><x path="Void"/></f>
			<x path="cs.system.CrossAppDomainDelegate"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=""><x path="Void"/></f>
			<x path="cs.system.CrossAppDomainDelegate"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_CrossAppDomainDelegate"/>
	<c path="cs.system.Delegate_CrossAppDomainDelegate"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.CrossAppDomainDelegate"/>
			<x path="cs.system.CrossAppDomainDelegate"/>
			<x path="cs.system.CrossAppDomainDelegate"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.CrossAppDomainDelegate"/>
			<x path="cs.system.CrossAppDomainDelegate"/>
			<x path="cs.system.CrossAppDomainDelegate"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._CrossAppDomainDelegate.CrossAppDomainDelegate_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.CrossAppDomainDelegate" private="1" module="cs.system.CrossAppDomainDelegate" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=""><x path="Void"/></f>
				<x path="cs.system.CrossAppDomainDelegate"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=""><x path="Void"/></f>
				<x path="cs.system.CrossAppDomainDelegate"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_CrossAppDomainDelegate"/>
	<c path="cs.system.Delegate_CrossAppDomainDelegate"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.CrossAppDomainDelegate"/>
				<x path="cs.system.CrossAppDomainDelegate"/>
				<x path="cs.system.CrossAppDomainDelegate"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.CrossAppDomainDelegate"/>
				<x path="cs.system.CrossAppDomainDelegate"/>
				<x path="cs.system.CrossAppDomainDelegate"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<enum path="cs.system.DateTime_Which" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.DateTime" module="cs.system.DateTime">
		<Day><meta><m n=":csNative"><e>0</e></m></meta></Day>
		<DayYear><meta><m n=":csNative"><e>1</e></m></meta></DayYear>
		<Month><meta><m n=":csNative"><e>2</e></m></meta></Month>
		<Year><meta><m n=":csNative"><e>3</e></m></meta></Year>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.DateTime.Which"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.DayOfWeek" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.DayOfWeek">
		<Sunday><meta><m n=":csNative"><e>0</e></m></meta></Sunday>
		<Monday><meta><m n=":csNative"><e>1</e></m></meta></Monday>
		<Tuesday><meta><m n=":csNative"><e>2</e></m></meta></Tuesday>
		<Wednesday><meta><m n=":csNative"><e>3</e></m></meta></Wednesday>
		<Thursday><meta><m n=":csNative"><e>4</e></m></meta></Thursday>
		<Friday><meta><m n=":csNative"><e>5</e></m></meta></Friday>
		<Saturday><meta><m n=":csNative"><e>6</e></m></meta></Saturday>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.DayOfWeek"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.Decimal" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Decimal" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.IComparable_1"><c path="cs.system.Decimal"/></implements>
		<implements path="cs.system.IEquatable_1"><c path="cs.system.Decimal"/></implements>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IConvertible"/>
		<implements path="cs.system.IFormattable"/>
		<Zero public="1" set="null" static="1">
			<c path="cs.system.Decimal"/>
			<meta><m n=":readOnly"/></meta>
		</Zero>
		<One public="1" set="null" static="1">
			<c path="cs.system.Decimal"/>
			<meta><m n=":readOnly"/></meta>
		</One>
		<MinusOne public="1" set="null" static="1">
			<c path="cs.system.Decimal"/>
			<meta><m n=":readOnly"/></meta>
		</MinusOne>
		<MaxValue public="1" set="null" static="1">
			<c path="cs.system.Decimal"/>
			<meta><m n=":readOnly"/></meta>
		</MaxValue>
		<MinValue public="1" set="null" static="1">
			<c path="cs.system.Decimal"/>
			<meta><m n=":readOnly"/></meta>
		</MinValue>
		<FromOACurrency public="1" set="method" static="1"><f a="cy">
	<x path="haxe.Int64"/>
	<c path="cs.system.Decimal"/>
</f></FromOACurrency>
		<GetBits public="1" set="method" static="1"><f a="d">
	<c path="cs.system.Decimal"/>
	<c path="cs.NativeArray"><x path="Int"/></c>
</f></GetBits>
		<Negate public="1" set="method" static="1"><f a="d">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Negate>
		<Add public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Add>
		<Subtract public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Subtract>
		<_Equals public="1" set="method" static="1">
			<f a="d1:d2">
				<c path="cs.system.Decimal"/>
				<c path="cs.system.Decimal"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"Equals"</e></m></meta>
		</_Equals>
		<Floor public="1" set="method" static="1"><f a="d">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Floor>
		<Truncate public="1" set="method" static="1"><f a="d">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Truncate>
		<Round public="1" set="method" static="1">
			<f a="d:decimals">
				<c path="cs.system.Decimal"/>
				<x path="Int"/>
				<c path="cs.system.Decimal"/>
			</f>
			<overloads>
				<Round public="1" set="method"><f a="d:mode">
	<c path="cs.system.Decimal"/>
	<e path="cs.system.MidpointRounding"/>
	<c path="cs.system.Decimal"/>
</f></Round>
				<Round public="1" set="method"><f a="d">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Round>
				<Round public="1" set="method"><f a="d:decimals:mode">
	<c path="cs.system.Decimal"/>
	<x path="Int"/>
	<e path="cs.system.MidpointRounding"/>
	<c path="cs.system.Decimal"/>
</f></Round>
			</overloads>
		</Round>
		<Multiply public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Multiply>
		<Divide public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Divide>
		<Remainder public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Remainder>
		<Compare public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<x path="Int"/>
</f></Compare>
		<Ceiling public="1" set="method" static="1"><f a="d">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></Ceiling>
		<Parse public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="cs.system.Decimal"/>
			</f>
			<overloads>
				<Parse public="1" set="method"><f a="s:style:provider">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.system.Decimal"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.system.Decimal"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s:style">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<c path="cs.system.Decimal"/>
</f></Parse>
			</overloads>
		</Parse>
		<TryParse public="1" set="method" static="1">
			<f a="s:result">
				<c path="String"/>
				<t path="cs.Out"><c path="cs.system.Decimal"/></t>
				<x path="Bool"/>
			</f>
			<overloads><TryParse public="1" set="method"><f a="s:style:provider:result">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.Out"><c path="cs.system.Decimal"/></t>
	<x path="Bool"/>
</f></TryParse></overloads>
		</TryParse>
		<ToByte public="1" set="method" static="1">
			<f a="value">
				<c path="cs.system.Decimal"/>
				<t path="cs.types.UInt8"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</ToByte>
		<ToDouble public="1" set="method" static="1">
			<f a="d">
				<c path="cs.system.Decimal"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</ToDouble>
		<ToInt16 public="1" set="method" static="1">
			<f a="value">
				<c path="cs.system.Decimal"/>
				<t path="cs.types.Int16"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</ToInt16>
		<ToInt32 public="1" set="method" static="1">
			<f a="d">
				<c path="cs.system.Decimal"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</ToInt32>
		<ToInt64 public="1" set="method" static="1">
			<f a="d">
				<c path="cs.system.Decimal"/>
				<x path="haxe.Int64"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</ToInt64>
		<ToOACurrency public="1" set="method" static="1"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="haxe.Int64"/>
</f></ToOACurrency>
		<ToSByte public="1" set="method" static="1">
			<f a="value">
				<c path="cs.system.Decimal"/>
				<t path="cs.types.Int8"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</ToSByte>
		<ToSingle public="1" set="method" static="1">
			<f a="d">
				<c path="cs.system.Decimal"/>
				<x path="Single"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</ToSingle>
		<ToUInt16 public="1" set="method" static="1">
			<f a="value">
				<c path="cs.system.Decimal"/>
				<t path="cs.types.UInt16"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</ToUInt16>
		<ToUInt32 public="1" set="method" static="1">
			<f a="d">
				<c path="cs.system.Decimal"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</ToUInt32>
		<ToUInt64 public="1" set="method" static="1">
			<f a="d">
				<c path="cs.system.Decimal"/>
				<t path="cs.types.UInt64"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</ToUInt64>
		<op_Addition public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></op_Addition>
		<op_Decrement public="1" set="method" static="1"><f a="d">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></op_Decrement>
		<op_Increment public="1" set="method" static="1"><f a="d">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></op_Increment>
		<op_Subtraction public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></op_Subtraction>
		<op_UnaryNegation public="1" set="method" static="1"><f a="d">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></op_UnaryNegation>
		<op_UnaryPlus public="1" set="method" static="1"><f a="d">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></op_UnaryPlus>
		<op_Multiply public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></op_Multiply>
		<op_Division public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></op_Division>
		<op_Modulus public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
</f></op_Modulus>
		<op_Implicit public="1" set="method" static="1">
			<f a="value">
				<t path="cs.types.UInt8"/>
				<c path="cs.system.Decimal"/>
			</f>
			<overloads>
				<op_Implicit public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<c path="cs.system.Decimal"/>
</f></op_Implicit>
				<op_Implicit public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<c path="cs.system.Decimal"/>
</f></op_Implicit>
				<op_Implicit public="1" set="method"><f a="value">
	<x path="UInt"/>
	<c path="cs.system.Decimal"/>
</f></op_Implicit>
				<op_Implicit public="1" set="method"><f a="value">
	<x path="Int"/>
	<c path="cs.system.Decimal"/>
</f></op_Implicit>
				<op_Implicit public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<c path="cs.system.Decimal"/>
</f></op_Implicit>
				<op_Implicit public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<c path="cs.system.Decimal"/>
</f></op_Implicit>
				<op_Implicit public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<c path="cs.system.Decimal"/>
</f></op_Implicit>
				<op_Implicit public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<c path="cs.system.Decimal"/>
</f></op_Implicit>
			</overloads>
		</op_Implicit>
		<op_Explicit public="1" set="method" static="1">
			<f a="value">
				<x path="Single"/>
				<c path="cs.system.Decimal"/>
			</f>
			<overloads>
				<op_Explicit public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="Float"/>
</f></op_Explicit>
				<op_Explicit public="1" set="method"><f a="value">
	<x path="Float"/>
	<c path="cs.system.Decimal"/>
</f></op_Explicit>
			</overloads>
		</op_Explicit>
		<op_Inequality public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<x path="Bool"/>
</f></op_Inequality>
		<op_Equality public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_GreaterThan public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<x path="Bool"/>
</f></op_GreaterThan>
		<op_GreaterThanOrEqual public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<x path="Bool"/>
</f></op_GreaterThanOrEqual>
		<op_LessThan public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<x path="Bool"/>
</f></op_LessThan>
		<op_LessThanOrEqual public="1" set="method" static="1"><f a="d1:d2">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.Decimal"/>
	<x path="Bool"/>
</f></op_LessThanOrEqual>
		<CompareTo final="1" public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads><CompareTo final="1" public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="Int"/>
</f></CompareTo></overloads>
		</CompareTo>
		<GetTypeCode final="1" public="1" set="method"><f a=""><e path="cs.system.TypeCode"/></f></GetTypeCode>
		<ToString final="1" public="1" set="method" override="1">
			<f a="format:provider">
				<c path="String"/>
				<c path="cs.system.IFormatProvider"/>
				<c path="String"/>
			</f>
			<overloads>
				<ToString final="1" public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="format">
	<c path="String"/>
	<c path="String"/>
</f></ToString>
				<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
			</overloads>
		</ToString>
		<new final="1" public="1" set="method">
			<f a="lo:mid:hi:isNegative:scale">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<t path="cs.types.UInt8"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="bits">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Decimal"</e></m>
		</meta>
	</class>
	<class path="cs.system.Enum" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Enum" extern="1" abstract="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IConvertible"/>
		<implements path="cs.system.IFormattable"/>
		<GetValues public="1" set="method" static="1"><f a="enumType">
	<c path="cs.system.Type"/>
	<c path="cs.system.Array"/>
</f></GetValues>
		<GetNames public="1" set="method" static="1"><f a="enumType">
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetNames>
		<GetName public="1" set="method" static="1"><f a="enumType:value">
	<c path="cs.system.Type"/>
	<d/>
	<c path="String"/>
</f></GetName>
		<IsDefined public="1" set="method" static="1"><f a="enumType:value">
	<c path="cs.system.Type"/>
	<d/>
	<x path="Bool"/>
</f></IsDefined>
		<GetUnderlyingType public="1" set="method" static="1"><f a="enumType">
	<c path="cs.system.Type"/>
	<c path="cs.system.Type"/>
</f></GetUnderlyingType>
		<Parse public="1" set="method" static="1">
			<f a="enumType:value">
				<c path="cs.system.Type"/>
				<c path="String"/>
				<d/>
			</f>
			<overloads><Parse public="1" set="method"><f a="enumType:value:ignoreCase">
	<c path="cs.system.Type"/>
	<c path="String"/>
	<x path="Bool"/>
	<d/>
</f></Parse></overloads>
		</Parse>
		<ToObject public="1" set="method" static="1">
			<f a="enumType:value">
				<c path="cs.system.Type"/>
				<t path="cs.types.UInt8"/>
				<d/>
			</f>
			<overloads>
				<ToObject public="1" set="method"><f a="enumType:value">
	<c path="cs.system.Type"/>
	<t path="cs.types.UInt64"/>
	<d/>
</f></ToObject>
				<ToObject public="1" set="method"><f a="enumType:value">
	<c path="cs.system.Type"/>
	<x path="UInt"/>
	<d/>
</f></ToObject>
				<ToObject public="1" set="method"><f a="enumType:value">
	<c path="cs.system.Type"/>
	<t path="cs.types.UInt16"/>
	<d/>
</f></ToObject>
				<ToObject public="1" set="method"><f a="enumType:value">
	<c path="cs.system.Type"/>
	<t path="cs.types.Int8"/>
	<d/>
</f></ToObject>
				<ToObject public="1" set="method"><f a="enumType:value">
	<c path="cs.system.Type"/>
	<d/>
	<d/>
</f></ToObject>
				<ToObject public="1" set="method"><f a="enumType:value">
	<c path="cs.system.Type"/>
	<x path="haxe.Int64"/>
	<d/>
</f></ToObject>
				<ToObject public="1" set="method"><f a="enumType:value">
	<c path="cs.system.Type"/>
	<x path="Int"/>
	<d/>
</f></ToObject>
				<ToObject public="1" set="method"><f a="enumType:value">
	<c path="cs.system.Type"/>
	<t path="cs.types.Int16"/>
	<d/>
</f></ToObject>
			</overloads>
		</ToObject>
		<Format public="1" set="method" static="1"><f a="enumType:value:format">
	<c path="cs.system.Type"/>
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></Format>
		<GetTypeCode final="1" public="1" set="method"><f a=""><e path="cs.system.TypeCode"/></f></GetTypeCode>
		<CompareTo final="1" public="1" set="method"><f a="target">
	<d/>
	<x path="Int"/>
</f></CompareTo>
		<ToString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<overloads>
				<ToString final="1" public="1" set="method"><f a="format:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="format">
	<c path="String"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
			</overloads>
		</ToString>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Enum"</e></m>
		</meta>
	</class>
	<enum path="cs.system.Environment_SpecialFolderOption" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Environment" module="cs.system.Environment">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<DoNotVerify><meta><m n=":csNative"><e>16384</e></m></meta></DoNotVerify>
		<Create><meta><m n=":csNative"><e>32768</e></m></meta></Create>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Environment.SpecialFolderOption"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.Environment_SpecialFolder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Environment" module="cs.system.Environment">
		<Desktop><meta><m n=":csNative"><e>0</e></m></meta></Desktop>
		<Programs><meta><m n=":csNative"><e>2</e></m></meta></Programs>
		<MyDocuments><meta><m n=":csNative"><e>5</e></m></meta></MyDocuments>
		<Personal><meta><m n=":csNative"><e>5</e></m></meta></Personal>
		<Favorites><meta><m n=":csNative"><e>6</e></m></meta></Favorites>
		<Startup><meta><m n=":csNative"><e>7</e></m></meta></Startup>
		<Recent><meta><m n=":csNative"><e>8</e></m></meta></Recent>
		<SendTo><meta><m n=":csNative"><e>9</e></m></meta></SendTo>
		<StartMenu><meta><m n=":csNative"><e>11</e></m></meta></StartMenu>
		<MyMusic><meta><m n=":csNative"><e>13</e></m></meta></MyMusic>
		<DesktopDirectory><meta><m n=":csNative"><e>16</e></m></meta></DesktopDirectory>
		<MyComputer><meta><m n=":csNative"><e>17</e></m></meta></MyComputer>
		<Templates><meta><m n=":csNative"><e>21</e></m></meta></Templates>
		<ApplicationData><meta><m n=":csNative"><e>26</e></m></meta></ApplicationData>
		<LocalApplicationData><meta><m n=":csNative"><e>28</e></m></meta></LocalApplicationData>
		<InternetCache><meta><m n=":csNative"><e>32</e></m></meta></InternetCache>
		<Cookies><meta><m n=":csNative"><e>33</e></m></meta></Cookies>
		<History><meta><m n=":csNative"><e>34</e></m></meta></History>
		<CommonApplicationData><meta><m n=":csNative"><e>35</e></m></meta></CommonApplicationData>
		<System><meta><m n=":csNative"><e>37</e></m></meta></System>
		<ProgramFiles><meta><m n=":csNative"><e>38</e></m></meta></ProgramFiles>
		<MyPictures><meta><m n=":csNative"><e>39</e></m></meta></MyPictures>
		<CommonProgramFiles><meta><m n=":csNative"><e>43</e></m></meta></CommonProgramFiles>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Environment.SpecialFolder"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.Environment" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Environment" extern="1" final="1">
		<ProcessorCount public="1" get="accessor" set="null" static="1"><x path="Int"/></ProcessorCount>
		<WorkingSet public="1" get="accessor" set="null" static="1"><x path="haxe.Int64"/></WorkingSet>
		<Version public="1" get="accessor" set="null" static="1"><c path="cs.system.Version"/></Version>
		<UserName public="1" get="accessor" set="null" static="1"><c path="String"/></UserName>
		<UserInteractive public="1" get="accessor" set="null" static="1"><x path="Bool"/></UserInteractive>
		<UserDomainName public="1" get="accessor" set="null" static="1"><c path="String"/></UserDomainName>
		<TickCount public="1" get="accessor" set="null" static="1"><x path="Int"/></TickCount>
		<SystemDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></SystemDirectory>
		<StackTrace public="1" get="accessor" set="null" static="1"><c path="String"/></StackTrace>
		<OSVersion public="1" get="accessor" set="null" static="1"><c path="cs.system.OperatingSystem"/></OSVersion>
		<NewLine public="1" get="accessor" set="null" static="1"><c path="String"/></NewLine>
		<MachineName public="1" get="accessor" set="null" static="1"><c path="String"/></MachineName>
		<HasShutdownStarted public="1" get="accessor" set="null" static="1"><x path="Bool"/></HasShutdownStarted>
		<ExitCode public="1" get="accessor" set="accessor" static="1"><x path="Int"/></ExitCode>
		<CurrentDirectory public="1" get="accessor" set="accessor" static="1"><c path="String"/></CurrentDirectory>
		<CommandLine public="1" get="accessor" set="null" static="1"><c path="String"/></CommandLine>
		<get_CommandLine public="1" set="method" static="1"><f a=""><c path="String"/></f></get_CommandLine>
		<get_CurrentDirectory public="1" set="method" static="1"><f a=""><c path="String"/></f></get_CurrentDirectory>
		<set_CurrentDirectory public="1" set="method" static="1"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_CurrentDirectory>
		<get_ExitCode public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_ExitCode>
		<set_ExitCode public="1" set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_ExitCode>
		<get_HasShutdownStarted public="1" set="method" static="1"><f a=""><x path="Bool"/></f></get_HasShutdownStarted>
		<get_MachineName public="1" set="method" static="1"><f a=""><c path="String"/></f></get_MachineName>
		<get_NewLine public="1" set="method" static="1"><f a=""><c path="String"/></f></get_NewLine>
		<get_OSVersion public="1" set="method" static="1"><f a=""><c path="cs.system.OperatingSystem"/></f></get_OSVersion>
		<get_StackTrace public="1" set="method" static="1"><f a=""><c path="String"/></f></get_StackTrace>
		<get_SystemDirectory public="1" set="method" static="1"><f a=""><c path="String"/></f></get_SystemDirectory>
		<get_TickCount public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_TickCount>
		<get_UserDomainName public="1" set="method" static="1"><f a=""><c path="String"/></f></get_UserDomainName>
		<get_UserInteractive public="1" set="method" static="1"><f a=""><x path="Bool"/></f></get_UserInteractive>
		<get_UserName public="1" set="method" static="1"><f a=""><c path="String"/></f></get_UserName>
		<get_Version public="1" set="method" static="1"><f a=""><c path="cs.system.Version"/></f></get_Version>
		<get_WorkingSet public="1" set="method" static="1"><f a=""><x path="haxe.Int64"/></f></get_WorkingSet>
		<Exit public="1" set="method" static="1"><f a="exitCode">
	<x path="Int"/>
	<x path="Void"/>
</f></Exit>
		<ExpandEnvironmentVariables public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></ExpandEnvironmentVariables>
		<GetCommandLineArgs public="1" set="method" static="1"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></GetCommandLineArgs>
		<GetEnvironmentVariable public="1" set="method" static="1">
			<f a="variable">
				<c path="String"/>
				<c path="String"/>
			</f>
			<overloads><GetEnvironmentVariable public="1" set="method"><f a="variable:target">
	<c path="String"/>
	<e path="cs.system.EnvironmentVariableTarget"/>
	<c path="String"/>
</f></GetEnvironmentVariable></overloads>
		</GetEnvironmentVariable>
		<GetEnvironmentVariables public="1" set="method" static="1">
			<f a=""><c path="cs.system.collections.IDictionary"/></f>
			<overloads><GetEnvironmentVariables public="1" set="method"><f a="target">
	<e path="cs.system.EnvironmentVariableTarget"/>
	<c path="cs.system.collections.IDictionary"/>
</f></GetEnvironmentVariables></overloads>
		</GetEnvironmentVariables>
		<GetFolderPath public="1" set="method" static="1"><f a="folder">
	<e path="cs.system.Environment_SpecialFolder"/>
	<c path="String"/>
</f></GetFolderPath>
		<GetLogicalDrives public="1" set="method" static="1"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></GetLogicalDrives>
		<SetEnvironmentVariable public="1" set="method" static="1">
			<f a="variable:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><SetEnvironmentVariable public="1" set="method"><f a="variable:value:target">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.EnvironmentVariableTarget"/>
	<x path="Void"/>
</f></SetEnvironmentVariable></overloads>
		</SetEnvironmentVariable>
		<FailFast public="1" set="method" static="1"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></FailFast>
		<get_ProcessorCount public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_ProcessorCount>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Environment"</e></m>
		</meta>
	</class>
	<enum path="cs.system.EnvironmentVariableTarget" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.EnvironmentVariableTarget">
		<Process><meta><m n=":csNative"><e>0</e></m></meta></Process>
		<User><meta><m n=":csNative"><e>1</e></m></meta></User>
		<Machine><meta><m n=":csNative"><e>2</e></m></meta></Machine>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.EnvironmentVariableTarget"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.Delegate_EventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.EventHandler" module="cs.system.EventHandler" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.EventHandler"/>
	<x path="cs.system.EventHandler"/>
	<x path="cs.system.EventHandler"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.EventHandler"/>
	<x path="cs.system.EventHandler"/>
	<x path="cs.system.EventHandler"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="sender:e">
	<d/>
	<c path="cs.system.EventArgs"/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="sender:e:callback:object">
	<d/>
	<c path="cs.system.EventArgs"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.EventHandler"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.EventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.EventHandler">
		<from><icast field="FromHaxeFunction"><f a=":">
	<d/>
	<c path="cs.system.EventArgs"/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.Delegate_EventHandler"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._EventHandler.EventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.EventHandler" private="1" module="cs.system.EventHandler" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.EventArgs"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.EventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.EventArgs"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.EventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_EventHandler"/>
	<c path="cs.system.Delegate_EventHandler"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.EventHandler"/>
			<x path="cs.system.EventHandler"/>
			<x path="cs.system.EventHandler"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.EventHandler"/>
			<x path="cs.system.EventHandler"/>
			<x path="cs.system.EventHandler"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._EventHandler.EventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.EventHandler" private="1" module="cs.system.EventHandler" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.EventArgs"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.EventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.EventArgs"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.EventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_EventHandler"/>
	<c path="cs.system.Delegate_EventHandler"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.EventHandler"/>
				<x path="cs.system.EventHandler"/>
				<x path="cs.system.EventHandler"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.EventHandler"/>
				<x path="cs.system.EventHandler"/>
				<x path="cs.system.EventHandler"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.Guid_GuidParser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Guid" module="cs.system.Guid" extern="1">
		<Parse final="1" public="1" set="method">
			<f a="format:guid">
				<e path="cs.system.Guid_Format"/>
				<t path="cs.Out"><c path="cs.system.Guid"/></t>
				<x path="Bool"/>
			</f>
			<overloads><Parse final="1" public="1" set="method"><f a="guid">
	<t path="cs.Out"><c path="cs.system.Guid"/></t>
	<x path="Bool"/>
</f></Parse></overloads>
		</Parse>
		<new final="1" public="1" set="method"><f a="src">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Guid.GuidParser"</e></m>
		</meta>
	</class>
	<enum path="cs.system.Guid_Format" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Guid" module="cs.system.Guid">
		<N><meta><m n=":csNative"><e>0</e></m></meta></N>
		<D><meta><m n=":csNative"><e>1</e></m></meta></D>
		<B><meta><m n=":csNative"><e>2</e></m></meta></B>
		<P><meta><m n=":csNative"><e>3</e></m></meta></P>
		<X><meta><m n=":csNative"><e>4</e></m></meta></X>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Guid.Format"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.Guid" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Guid" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.IComparable_1"><c path="cs.system.Guid"/></implements>
		<implements path="cs.system.IEquatable_1"><c path="cs.system.Guid"/></implements>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IFormattable"/>
		<Empty public="1" set="null" static="1">
			<c path="cs.system.Guid"/>
			<meta><m n=":readOnly"/></meta>
		</Empty>
		<NewGuid public="1" set="method" static="1"><f a=""><c path="cs.system.Guid"/></f></NewGuid>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.Guid"/>
	<c path="cs.system.Guid"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.Guid"/>
	<c path="cs.system.Guid"/>
	<x path="Bool"/>
</f></op_Inequality>
		<CompareTo final="1" public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads><CompareTo final="1" public="1" set="method"><f a="value">
	<c path="cs.system.Guid"/>
	<x path="Int"/>
</f></CompareTo></overloads>
		</CompareTo>
		<ToByteArray final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></ToByteArray>
		<ToString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<overloads>
				<ToString final="1" public="1" set="method"><f a="format:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="format">
	<c path="String"/>
	<c path="String"/>
</f></ToString>
			</overloads>
		</ToString>
		<new final="1" public="1" set="method">
			<f a="b">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="a:b:c:d:e:f:g:h:i:j:k">
	<x path="UInt"/>
	<t path="cs.types.UInt16"/>
	<t path="cs.types.UInt16"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="a:b:c:d:e:f:g:h:i:j:k">
	<x path="Int"/>
	<t path="cs.types.Int16"/>
	<t path="cs.types.Int16"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<t path="cs.types.UInt8"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="a:b:c:d">
	<x path="Int"/>
	<t path="cs.types.Int16"/>
	<t path="cs.types.Int16"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="g">
	<c path="String"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Guid"</e></m>
		</meta>
	</class>
	<class path="cs.system.IAsyncResult" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.IAsyncResult" extern="1" interface="1">
		<IsCompleted public="1" get="accessor" set="null"><x path="Bool"/></IsCompleted>
		<CompletedSynchronously public="1" get="accessor" set="null"><x path="Bool"/></CompletedSynchronously>
		<AsyncWaitHandle public="1" get="accessor" set="null"><c path="cs.system.threading.WaitHandle"/></AsyncWaitHandle>
		<AsyncState public="1" get="accessor" set="null"><d/></AsyncState>
		<get_AsyncState public="1" set="method"><f a=""><d/></f></get_AsyncState>
		<get_AsyncWaitHandle public="1" set="method"><f a=""><c path="cs.system.threading.WaitHandle"/></f></get_AsyncWaitHandle>
		<get_CompletedSynchronously public="1" set="method"><f a=""><x path="Bool"/></f></get_CompletedSynchronously>
		<get_IsCompleted public="1" set="method"><f a=""><x path="Bool"/></f></get_IsCompleted>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IAsyncResult"</e></m>
		</meta>
	</class>
	<class path="cs.system.IFormatProvider" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.IFormatProvider" extern="1" interface="1">
		<GetFormat public="1" set="method"><f a="formatType">
	<c path="cs.system.Type"/>
	<d/>
</f></GetFormat>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IFormatProvider"</e></m>
		</meta>
	</class>
	<class path="cs.system.IServiceProvider" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.IServiceProvider" extern="1" interface="1">
		<GetService public="1" set="method"><f a="serviceType">
	<c path="cs.system.Type"/>
	<d/>
</f></GetService>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IServiceProvider"</e></m>
		</meta>
	</class>
	<class path="cs.system.Int64" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Int64" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IConvertible"/>
		<implements path="cs.system.IComparable_1"><x path="haxe.Int64"/></implements>
		<implements path="cs.system.IEquatable_1"><x path="haxe.Int64"/></implements>
		<implements path="cs.system.IFormattable"/>
		<MinValue public="1" set="null" static="1">
			<x path="haxe.Int64"/>
			<meta><m n=":readOnly"/></meta>
		</MinValue>
		<MaxValue public="1" set="null" static="1">
			<x path="haxe.Int64"/>
			<meta><m n=":readOnly"/></meta>
		</MaxValue>
		<Parse public="1" set="method" static="1">
			<f a="s:provider">
				<c path="String"/>
				<c path="cs.system.IFormatProvider"/>
				<x path="haxe.Int64"/>
			</f>
			<overloads>
				<Parse public="1" set="method"><f a="s:style:provider">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<c path="cs.system.IFormatProvider"/>
	<x path="haxe.Int64"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s">
	<c path="String"/>
	<x path="haxe.Int64"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s:style">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<x path="haxe.Int64"/>
</f></Parse>
			</overloads>
		</Parse>
		<TryParse public="1" set="method" static="1">
			<f a="s:result">
				<c path="String"/>
				<t path="cs.Out"><x path="haxe.Int64"/></t>
				<x path="Bool"/>
			</f>
			<overloads><TryParse public="1" set="method"><f a="s:style:provider:result">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.Out"><x path="haxe.Int64"/></t>
	<x path="Bool"/>
</f></TryParse></overloads>
		</TryParse>
		<CompareTo final="1" public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads><CompareTo final="1" public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Int"/>
</f></CompareTo></overloads>
		</CompareTo>
		<ToString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<overloads>
				<ToString final="1" public="1" set="method"><f a="format:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="format">
	<c path="String"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
			</overloads>
		</ToString>
		<GetTypeCode final="1" public="1" set="method"><f a=""><e path="cs.system.TypeCode"/></f></GetTypeCode>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Int64"</e></m>
		</meta>
	</class>
	<class path="cs.system.IntPtr" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.IntPtr" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<Size public="1" get="accessor" set="null" static="1"><x path="Int"/></Size>
		<Zero public="1" set="null" static="1">
			<c path="cs.system.IntPtr"/>
			<meta><m n=":readOnly"/></meta>
		</Zero>
		<get_Size public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_Size>
		<op_Equality public="1" set="method" static="1"><f a="value1:value2">
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="value1:value2">
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Bool"/>
</f></op_Inequality>
		<op_Explicit public="1" set="method" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="cs.system.IntPtr"/>
			</f>
			<overloads><op_Explicit public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<c path="cs.system.IntPtr"/>
</f></op_Explicit></overloads>
		</op_Explicit>
		<ToInt32 final="1" public="1" set="method"><f a=""><x path="Int"/></f></ToInt32>
		<ToInt64 final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></ToInt64>
		<ToString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<overloads><ToString final="1" public="1" set="method"><f a="format">
	<c path="String"/>
	<c path="String"/>
</f></ToString></overloads>
		</ToString>
		<new final="1" public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads><new final="1" public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IntPtr"</e></m>
		</meta>
	</class>
	<enum path="cs.system.LoaderOptimization" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.LoaderOptimization">
		<NotSpecified><meta><m n=":csNative"><e>0</e></m></meta></NotSpecified>
		<SingleDomain><meta><m n=":csNative"><e>1</e></m></meta></SingleDomain>
		<MultiDomain><meta><m n=":csNative"><e>2</e></m></meta></MultiDomain>
		<MultiDomainHost><meta><m n=":csNative"><e>3</e></m></meta></MultiDomainHost>
		<DomainMask><meta><m n=":csNative"><e>3</e></m></meta></DomainMask>
		<DisallowBindings><meta><m n=":csNative"><e>4</e></m></meta></DisallowBindings>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.LoaderOptimization"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.LocalDataStoreSlot" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.LocalDataStoreSlot" extern="1" final="1"><meta>
	<m n=":nativeGen"/>
	<m n=":libType"/>
	<m n=":csNative"/>
	<m n=":native"><e>"System.LocalDataStoreSlot"</e></m>
</meta></class>
	<class path="cs.system.MemberAccessException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.MemberAccessException" extern="1">
		<extends path="cs.system.SystemException"/>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="message:inner">
	<c path="String"/>
	<c path="cs.system.Exception"/>
	<x path="Void"/>
</f></new>
				<new final="1" set="method">
					<f a="info:context">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" public="1" set="method"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.MemberAccessException"</e></m>
		</meta>
	</class>
	<enum path="cs.system.MidpointRounding" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.MidpointRounding">
		<ToEven><meta><m n=":csNative"><e>0</e></m></meta></ToEven>
		<AwayFromZero><meta><m n=":csNative"><e>1</e></m></meta></AwayFromZero>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.MidpointRounding"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.MissingMemberException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.MissingMemberException" extern="1">
		<extends path="cs.system.MemberAccessException"/>
		<Message public="1" get="accessor" set="null" override="1"><c path="String"/></Message>
		<Signature><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></Signature>
		<MemberName><c path="String"/></MemberName>
		<ClassName><c path="String"/></ClassName>
		<GetObjectData public="1" set="method" override="1"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<get_Message public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Message>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="className:memberName">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" set="method">
					<f a="info:context">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" public="1" set="method"><f a="message:inner">
	<c path="String"/>
	<c path="cs.system.Exception"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.MissingMemberException"</e></m>
		</meta>
	</class>
	<class path="cs.system.ModuleHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ModuleHandle" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<EmptyHandle public="1" set="null" static="1">
			<c path="cs.system.ModuleHandle"/>
			<meta><m n=":readOnly"/></meta>
		</EmptyHandle>
		<op_Equality public="1" set="method" static="1"><f a="left:right">
	<c path="cs.system.ModuleHandle"/>
	<c path="cs.system.ModuleHandle"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="left:right">
	<c path="cs.system.ModuleHandle"/>
	<c path="cs.system.ModuleHandle"/>
	<x path="Bool"/>
</f></op_Inequality>
		<MDStreamVersion public="1" get="accessor" set="null"><x path="Int"/></MDStreamVersion>
		<get_MDStreamVersion final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_MDStreamVersion>
		<ResolveFieldHandle final="1" public="1" set="method">
			<f a="fieldToken">
				<x path="Int"/>
				<c path="cs.system.RuntimeFieldHandle"/>
			</f>
			<overloads><ResolveFieldHandle final="1" public="1" set="method"><f a="fieldToken:typeInstantiationContext:methodInstantiationContext">
	<x path="Int"/>
	<c path="cs.NativeArray"><c path="cs.system.RuntimeTypeHandle"/></c>
	<c path="cs.NativeArray"><c path="cs.system.RuntimeTypeHandle"/></c>
	<c path="cs.system.RuntimeFieldHandle"/>
</f></ResolveFieldHandle></overloads>
		</ResolveFieldHandle>
		<ResolveMethodHandle final="1" public="1" set="method">
			<f a="methodToken">
				<x path="Int"/>
				<c path="cs.system.RuntimeMethodHandle"/>
			</f>
			<overloads><ResolveMethodHandle final="1" public="1" set="method"><f a="methodToken:typeInstantiationContext:methodInstantiationContext">
	<x path="Int"/>
	<c path="cs.NativeArray"><c path="cs.system.RuntimeTypeHandle"/></c>
	<c path="cs.NativeArray"><c path="cs.system.RuntimeTypeHandle"/></c>
	<c path="cs.system.RuntimeMethodHandle"/>
</f></ResolveMethodHandle></overloads>
		</ResolveMethodHandle>
		<ResolveTypeHandle final="1" public="1" set="method">
			<f a="typeToken">
				<x path="Int"/>
				<c path="cs.system.RuntimeTypeHandle"/>
			</f>
			<overloads><ResolveTypeHandle final="1" public="1" set="method"><f a="typeToken:typeInstantiationContext:methodInstantiationContext">
	<x path="Int"/>
	<c path="cs.NativeArray"><c path="cs.system.RuntimeTypeHandle"/></c>
	<c path="cs.NativeArray"><c path="cs.system.RuntimeTypeHandle"/></c>
	<c path="cs.system.RuntimeTypeHandle"/>
</f></ResolveTypeHandle></overloads>
		</ResolveTypeHandle>
		<GetRuntimeFieldHandleFromMetadataToken final="1" public="1" set="method"><f a="fieldToken">
	<x path="Int"/>
	<c path="cs.system.RuntimeFieldHandle"/>
</f></GetRuntimeFieldHandleFromMetadataToken>
		<GetRuntimeMethodHandleFromMetadataToken final="1" public="1" set="method"><f a="methodToken">
	<x path="Int"/>
	<c path="cs.system.RuntimeMethodHandle"/>
</f></GetRuntimeMethodHandleFromMetadataToken>
		<GetRuntimeTypeHandleFromMetadataToken final="1" public="1" set="method"><f a="typeToken">
	<x path="Int"/>
	<c path="cs.system.RuntimeTypeHandle"/>
</f></GetRuntimeTypeHandleFromMetadataToken>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ModuleHandle"</e></m>
		</meta>
	</class>
	<class path="cs.system.NullReferenceException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.NullReferenceException" extern="1">
		<extends path="cs.system.SystemException"/>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" set="method">
					<f a="info:context">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" public="1" set="method"><f a="message:innerException">
	<c path="String"/>
	<c path="cs.system.Exception"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.NullReferenceException"</e></m>
		</meta>
	</class>
	<class path="cs.system.OperatingSystem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.OperatingSystem" extern="1" final="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<VersionString public="1" get="accessor" set="null"><c path="String"/></VersionString>
		<ServicePack public="1" get="accessor" set="null"><c path="String"/></ServicePack>
		<Version public="1" get="accessor" set="null"><c path="cs.system.Version"/></Version>
		<Platform public="1" get="accessor" set="null"><e path="cs.system.PlatformID"/></Platform>
		<get_Platform final="1" public="1" set="method"><f a=""><e path="cs.system.PlatformID"/></f></get_Platform>
		<get_Version final="1" public="1" set="method"><f a=""><c path="cs.system.Version"/></f></get_Version>
		<get_ServicePack final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ServicePack>
		<get_VersionString final="1" public="1" set="method"><f a=""><c path="String"/></f></get_VersionString>
		<Clone final="1" public="1" set="method"><f a=""><d/></f></Clone>
		<GetObjectData final="1" public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<new final="1" public="1" set="method"><f a="platform:version">
	<e path="cs.system.PlatformID"/>
	<c path="cs.system.Version"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.OperatingSystem"</e></m>
		</meta>
	</class>
	<enum path="cs.system.PlatformID" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.PlatformID">
		<Win32S><meta><m n=":csNative"><e>0</e></m></meta></Win32S>
		<Win32Windows><meta><m n=":csNative"><e>1</e></m></meta></Win32Windows>
		<Win32NT><meta><m n=":csNative"><e>2</e></m></meta></Win32NT>
		<WinCE><meta><m n=":csNative"><e>3</e></m></meta></WinCE>
		<Unix><meta><m n=":csNative"><e>4</e></m></meta></Unix>
		<Xbox><meta><m n=":csNative"><e>5</e></m></meta></Xbox>
		<MacOSX><meta><m n=":csNative"><e>6</e></m></meta></MacOSX>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.PlatformID"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.Delegate_Predicate_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Predicate_1" module="cs.system.Predicate_1" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" params="T0" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Predicate_1"><c path="op_Addition.T0"/></x>
	<x path="cs.system.Predicate_1"><c path="op_Addition.T0"/></x>
	<x path="cs.system.Predicate_1"><c path="op_Addition.T0"/></x>
</f></op_Addition>
		<op_Subtraction public="1" params="T0" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.Predicate_1"><c path="op_Subtraction.T0"/></x>
	<x path="cs.system.Predicate_1"><c path="op_Subtraction.T0"/></x>
	<x path="cs.system.Predicate_1"><c path="op_Subtraction.T0"/></x>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="obj">
	<c path="cs.system.Delegate_Predicate_1.T0"/>
	<x path="Bool"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="obj:callback:object">
	<c path="cs.system.Delegate_Predicate_1.T0"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Bool"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Predicate`1"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.Predicate_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Predicate_1">
		<from><icast field="FromHaxeFunction"><f a="">
	<c path="FromHaxeFunction.T0"/>
	<x path="Bool"/>
</f></icast></from>
		<this><c path="cs.system.Delegate_Predicate_1"><c path="cs.system.Predicate_1.T0"/></c></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._Predicate_1.Predicate_1_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Predicate_1" private="1" module="cs.system.Predicate_1" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="cs.system.Predicate_1.T0"/>
				<x path="Bool"/>
			</f>
			<x path="cs.system.Predicate_1"><c path="cs.system.Predicate_1.T0"/></x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" params="T0" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="FromHaxeFunction.T0"/>
				<x path="Bool"/>
			</f>
			<x path="cs.system.Predicate_1"><c path="FromHaxeFunction.T0"/></x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_Predicate_1"><c path="cs.system.Predicate_1.T0"/></c>
	<c path="cs.system.Delegate_Predicate_1"><c path="cs.system.Predicate_1.T0"/></c>
</f></AsDelegate>
	<Add public="1" params="T0" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Predicate_1"><c path="Add.T0"/></x>
			<x path="cs.system.Predicate_1"><c path="Add.T0"/></x>
			<x path="cs.system.Predicate_1"><c path="Add.T0"/></x>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" params="T0" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.Predicate_1"><c path="Remove.T0"/></x>
			<x path="cs.system.Predicate_1"><c path="Remove.T0"/></x>
			<x path="cs.system.Predicate_1"><c path="Remove.T0"/></x>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._Predicate_1.Predicate_1_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Predicate_1" private="1" module="cs.system.Predicate_1" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="cs.system.Predicate_1.T0"/>
					<x path="Bool"/>
				</f>
				<x path="cs.system.Predicate_1"><c path="cs.system.Predicate_1.T0"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" params="T0" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="FromHaxeFunction.T0"/>
					<x path="Bool"/>
				</f>
				<x path="cs.system.Predicate_1"><c path="FromHaxeFunction.T0"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_Predicate_1"><c path="cs.system.Predicate_1.T0"/></c>
	<c path="cs.system.Delegate_Predicate_1"><c path="cs.system.Predicate_1.T0"/></c>
</f></AsDelegate>
		<Add public="1" params="T0" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Predicate_1"><c path="Add.T0"/></x>
				<x path="cs.system.Predicate_1"><c path="Add.T0"/></x>
				<x path="cs.system.Predicate_1"><c path="Add.T0"/></x>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" params="T0" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.Predicate_1"><c path="Remove.T0"/></x>
				<x path="cs.system.Predicate_1"><c path="Remove.T0"/></x>
				<x path="cs.system.Predicate_1"><c path="Remove.T0"/></x>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.ResolveEventArgs" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ResolveEventArgs" extern="1">
		<extends path="cs.system.EventArgs"/>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<new final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ResolveEventArgs"</e></m>
		</meta>
	</class>
	<class path="cs.system.Delegate_ResolveEventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ResolveEventHandler" module="cs.system.ResolveEventHandler" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="cs.system.ResolveEventHandler"/>
	<x path="cs.system.ResolveEventHandler"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.ResolveEventHandler"/>
	<x path="cs.system.ResolveEventHandler"/>
	<x path="cs.system.ResolveEventHandler"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="sender:args">
	<d/>
	<c path="cs.system.ResolveEventArgs"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="sender:args:callback:object">
	<d/>
	<c path="cs.system.ResolveEventArgs"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<c path="cs.system.reflection.Assembly"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ResolveEventHandler"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.ResolveEventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ResolveEventHandler">
		<from><icast field="FromHaxeFunction"><f a=":">
	<d/>
	<c path="cs.system.ResolveEventArgs"/>
	<c path="cs.system.reflection.Assembly"/>
</f></icast></from>
		<this><c path="cs.system.Delegate_ResolveEventHandler"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._ResolveEventHandler.ResolveEventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ResolveEventHandler" private="1" module="cs.system.ResolveEventHandler" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.ResolveEventArgs"/>
				<c path="cs.system.reflection.Assembly"/>
			</f>
			<x path="cs.system.ResolveEventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.ResolveEventArgs"/>
				<c path="cs.system.reflection.Assembly"/>
			</f>
			<x path="cs.system.ResolveEventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_ResolveEventHandler"/>
	<c path="cs.system.Delegate_ResolveEventHandler"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.ResolveEventHandler"/>
			<x path="cs.system.ResolveEventHandler"/>
			<x path="cs.system.ResolveEventHandler"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.ResolveEventHandler"/>
			<x path="cs.system.ResolveEventHandler"/>
			<x path="cs.system.ResolveEventHandler"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._ResolveEventHandler.ResolveEventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.ResolveEventHandler" private="1" module="cs.system.ResolveEventHandler" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.ResolveEventArgs"/>
					<c path="cs.system.reflection.Assembly"/>
				</f>
				<x path="cs.system.ResolveEventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.ResolveEventArgs"/>
					<c path="cs.system.reflection.Assembly"/>
				</f>
				<x path="cs.system.ResolveEventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_ResolveEventHandler"/>
	<c path="cs.system.Delegate_ResolveEventHandler"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.ResolveEventHandler"/>
				<x path="cs.system.ResolveEventHandler"/>
				<x path="cs.system.ResolveEventHandler"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.ResolveEventHandler"/>
				<x path="cs.system.ResolveEventHandler"/>
				<x path="cs.system.ResolveEventHandler"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.RuntimeFieldHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.RuntimeFieldHandle" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<op_Equality public="1" set="method" static="1"><f a="left:right">
	<c path="cs.system.RuntimeFieldHandle"/>
	<c path="cs.system.RuntimeFieldHandle"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="left:right">
	<c path="cs.system.RuntimeFieldHandle"/>
	<c path="cs.system.RuntimeFieldHandle"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Value public="1" get="accessor" set="null"><c path="cs.system.IntPtr"/></Value>
		<get_Value final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_Value>
		<GetObjectData final="1" public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.RuntimeFieldHandle"</e></m>
		</meta>
	</class>
	<class path="cs.system.RuntimeMethodHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.RuntimeMethodHandle" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<op_Equality public="1" set="method" static="1"><f a="left:right">
	<c path="cs.system.RuntimeMethodHandle"/>
	<c path="cs.system.RuntimeMethodHandle"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="left:right">
	<c path="cs.system.RuntimeMethodHandle"/>
	<c path="cs.system.RuntimeMethodHandle"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Value public="1" get="accessor" set="null"><c path="cs.system.IntPtr"/></Value>
		<get_Value final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_Value>
		<GetObjectData final="1" public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<GetFunctionPointer final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></GetFunctionPointer>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.RuntimeMethodHandle"</e></m>
		</meta>
	</class>
	<class path="cs.system.RuntimeTypeHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.RuntimeTypeHandle" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<op_Equality public="1" set="method" static="1">
			<f a="left:right">
				<c path="cs.system.RuntimeTypeHandle"/>
				<d/>
				<x path="Bool"/>
			</f>
			<overloads><op_Equality public="1" set="method"><f a="left:right">
	<d/>
	<c path="cs.system.RuntimeTypeHandle"/>
	<x path="Bool"/>
</f></op_Equality></overloads>
		</op_Equality>
		<op_Inequality public="1" set="method" static="1">
			<f a="left:right">
				<c path="cs.system.RuntimeTypeHandle"/>
				<d/>
				<x path="Bool"/>
			</f>
			<overloads><op_Inequality public="1" set="method"><f a="left:right">
	<d/>
	<c path="cs.system.RuntimeTypeHandle"/>
	<x path="Bool"/>
</f></op_Inequality></overloads>
		</op_Inequality>
		<Value public="1" get="accessor" set="null"><c path="cs.system.IntPtr"/></Value>
		<get_Value final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_Value>
		<GetObjectData final="1" public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<GetModuleHandle final="1" public="1" set="method"><f a=""><c path="cs.system.ModuleHandle"/></f></GetModuleHandle>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.RuntimeTypeHandle"</e></m>
		</meta>
	</class>
	<enum path="cs.system.StringComparison" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.StringComparison">
		<CurrentCulture><meta><m n=":csNative"><e>0</e></m></meta></CurrentCulture>
		<CurrentCultureIgnoreCase><meta><m n=":csNative"><e>1</e></m></meta></CurrentCultureIgnoreCase>
		<InvariantCulture><meta><m n=":csNative"><e>2</e></m></meta></InvariantCulture>
		<InvariantCultureIgnoreCase><meta><m n=":csNative"><e>3</e></m></meta></InvariantCultureIgnoreCase>
		<Ordinal><meta><m n=":csNative"><e>4</e></m></meta></Ordinal>
		<OrdinalIgnoreCase><meta><m n=":csNative"><e>5</e></m></meta></OrdinalIgnoreCase>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.StringComparison"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.StringSplitOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.StringSplitOptions">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<RemoveEmptyEntries><meta><m n=":csNative"><e>1</e></m></meta></RemoveEmptyEntries>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.StringSplitOptions"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.TimeSpan_Parser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.TimeSpan" module="cs.system.TimeSpan" extern="1">
		<AtEnd public="1" get="accessor" set="null"><x path="Bool"/></AtEnd>
		<get_AtEnd final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_AtEnd>
		<Execute final="1" public="1" set="method"><f a="tryParse:result">
	<x path="Bool"/>
	<t path="cs.Out"><c path="cs.system.TimeSpan"/></t>
	<x path="Bool"/>
</f></Execute>
		<new final="1" public="1" set="method"><f a="src">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.TimeSpan.Parser"</e></m>
		</meta>
	</class>
	<enum path="cs.system.TimeSpan_ParseError" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.TimeSpan" module="cs.system.TimeSpan">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<Format><meta><m n=":csNative"><e>1</e></m></meta></Format>
		<Overflow><meta><m n=":csNative"><e>2</e></m></meta></Overflow>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.TimeSpan.ParseError"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.TimeSpan" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.TimeSpan" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IComparable_1"><c path="cs.system.TimeSpan"/></implements>
		<implements path="cs.system.IEquatable_1"><c path="cs.system.TimeSpan"/></implements>
		<Zero public="1" set="null" static="1">
			<c path="cs.system.TimeSpan"/>
			<meta><m n=":readOnly"/></meta>
		</Zero>
		<MinValue public="1" set="null" static="1">
			<c path="cs.system.TimeSpan"/>
			<meta><m n=":readOnly"/></meta>
		</MinValue>
		<MaxValue public="1" set="null" static="1">
			<c path="cs.system.TimeSpan"/>
			<meta><m n=":readOnly"/></meta>
		</MaxValue>
		<TicksPerSecond public="1" set="null" static="1">
			<x path="haxe.Int64"/>
			<meta><m n=":readOnly"/></meta>
		</TicksPerSecond>
		<TicksPerMinute public="1" set="null" static="1">
			<x path="haxe.Int64"/>
			<meta><m n=":readOnly"/></meta>
		</TicksPerMinute>
		<TicksPerMillisecond public="1" set="null" static="1">
			<x path="haxe.Int64"/>
			<meta><m n=":readOnly"/></meta>
		</TicksPerMillisecond>
		<TicksPerHour public="1" set="null" static="1">
			<x path="haxe.Int64"/>
			<meta><m n=":readOnly"/></meta>
		</TicksPerHour>
		<TicksPerDay public="1" set="null" static="1">
			<x path="haxe.Int64"/>
			<meta><m n=":readOnly"/></meta>
		</TicksPerDay>
		<Compare public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
	<x path="Int"/>
</f></Compare>
		<_Equals public="1" set="method" static="1">
			<f a="t1:t2">
				<c path="cs.system.TimeSpan"/>
				<c path="cs.system.TimeSpan"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"Equals"</e></m></meta>
		</_Equals>
		<FromDays public="1" set="method" static="1"><f a="value">
	<x path="Float"/>
	<c path="cs.system.TimeSpan"/>
</f></FromDays>
		<FromHours public="1" set="method" static="1"><f a="value">
	<x path="Float"/>
	<c path="cs.system.TimeSpan"/>
</f></FromHours>
		<FromMinutes public="1" set="method" static="1"><f a="value">
	<x path="Float"/>
	<c path="cs.system.TimeSpan"/>
</f></FromMinutes>
		<FromSeconds public="1" set="method" static="1"><f a="value">
	<x path="Float"/>
	<c path="cs.system.TimeSpan"/>
</f></FromSeconds>
		<FromMilliseconds public="1" set="method" static="1"><f a="value">
	<x path="Float"/>
	<c path="cs.system.TimeSpan"/>
</f></FromMilliseconds>
		<FromTicks public="1" set="method" static="1"><f a="value">
	<x path="haxe.Int64"/>
	<c path="cs.system.TimeSpan"/>
</f></FromTicks>
		<Parse public="1" set="method" static="1"><f a="s">
	<c path="String"/>
	<c path="cs.system.TimeSpan"/>
</f></Parse>
		<TryParse public="1" set="method" static="1"><f a="s:result">
	<c path="String"/>
	<t path="cs.Out"><c path="cs.system.TimeSpan"/></t>
	<x path="Bool"/>
</f></TryParse>
		<op_Addition public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
</f></op_Addition>
		<op_Equality public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_GreaterThan public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
</f></op_GreaterThan>
		<op_GreaterThanOrEqual public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
</f></op_GreaterThanOrEqual>
		<op_Inequality public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
</f></op_Inequality>
		<op_LessThan public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
</f></op_LessThan>
		<op_LessThanOrEqual public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
</f></op_LessThanOrEqual>
		<op_Subtraction public="1" set="method" static="1"><f a="t1:t2">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
</f></op_Subtraction>
		<op_UnaryNegation public="1" set="method" static="1"><f a="t">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
</f></op_UnaryNegation>
		<op_UnaryPlus public="1" set="method" static="1"><f a="t">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
</f></op_UnaryPlus>
		<TotalSeconds public="1" get="accessor" set="null"><x path="Float"/></TotalSeconds>
		<TotalMinutes public="1" get="accessor" set="null"><x path="Float"/></TotalMinutes>
		<TotalMilliseconds public="1" get="accessor" set="null"><x path="Float"/></TotalMilliseconds>
		<TotalHours public="1" get="accessor" set="null"><x path="Float"/></TotalHours>
		<TotalDays public="1" get="accessor" set="null"><x path="Float"/></TotalDays>
		<Ticks public="1" get="accessor" set="null"><x path="haxe.Int64"/></Ticks>
		<Seconds public="1" get="accessor" set="null"><x path="Int"/></Seconds>
		<Minutes public="1" get="accessor" set="null"><x path="Int"/></Minutes>
		<Milliseconds public="1" get="accessor" set="null"><x path="Int"/></Milliseconds>
		<Hours public="1" get="accessor" set="null"><x path="Int"/></Hours>
		<Days public="1" get="accessor" set="null"><x path="Int"/></Days>
		<get_Days final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Days>
		<get_Hours final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Hours>
		<get_Milliseconds final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Milliseconds>
		<get_Minutes final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Minutes>
		<get_Seconds final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Seconds>
		<get_Ticks final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_Ticks>
		<get_TotalDays final="1" public="1" set="method"><f a=""><x path="Float"/></f></get_TotalDays>
		<get_TotalHours final="1" public="1" set="method"><f a=""><x path="Float"/></f></get_TotalHours>
		<get_TotalMilliseconds final="1" public="1" set="method"><f a=""><x path="Float"/></f></get_TotalMilliseconds>
		<get_TotalMinutes final="1" public="1" set="method"><f a=""><x path="Float"/></f></get_TotalMinutes>
		<get_TotalSeconds final="1" public="1" set="method"><f a=""><x path="Float"/></f></get_TotalSeconds>
		<Add final="1" public="1" set="method"><f a="ts">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
</f></Add>
		<CompareTo final="1" public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads><CompareTo final="1" public="1" set="method"><f a="value">
	<c path="cs.system.TimeSpan"/>
	<x path="Int"/>
</f></CompareTo></overloads>
		</CompareTo>
		<Duration final="1" public="1" set="method"><f a=""><c path="cs.system.TimeSpan"/></f></Duration>
		<Negate final="1" public="1" set="method"><f a=""><c path="cs.system.TimeSpan"/></f></Negate>
		<Subtract final="1" public="1" set="method"><f a="ts">
	<c path="cs.system.TimeSpan"/>
	<c path="cs.system.TimeSpan"/>
</f></Subtract>
		<ToString public="1" set="method" override="1"><f a=""><c path="String"/></f></ToString>
		<new final="1" public="1" set="method">
			<f a="ticks">
				<x path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="days:hours:minutes:seconds:milliseconds">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="days:hours:minutes:seconds">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="hours:minutes:seconds">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.TimeSpan"</e></m>
		</meta>
	</class>
	<class path="cs.system.TimeZone" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.TimeZone" extern="1" abstract="1">
		<CurrentTimeZone public="1" get="accessor" set="null" static="1"><c path="cs.system.TimeZone"/></CurrentTimeZone>
		<get_CurrentTimeZone public="1" set="method" static="1"><f a=""><c path="cs.system.TimeZone"/></f></get_CurrentTimeZone>
		<IsDaylightSavingTime public="1" set="method" static="1"><f a="time:daylightTimes">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.globalization.DaylightTime"/>
	<x path="Bool"/>
</f></IsDaylightSavingTime>
		<_IsDaylightSavingTime public="1" set="method" static="1">
			<f a="time:daylightTimes">
				<c path="cs.system.DateTime"/>
				<c path="cs.system.globalization.DaylightTime"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsDaylightSavingTime"</e></m></meta>
		</_IsDaylightSavingTime>
		<StandardName public="1" get="accessor" set="null"><c path="String"/></StandardName>
		<DaylightName public="1" get="accessor" set="null"><c path="String"/></DaylightName>
		<get_DaylightName abstract="1" public="1" set="method"><f a=""><c path="String"/></f></get_DaylightName>
		<get_StandardName abstract="1" public="1" set="method"><f a=""><c path="String"/></f></get_StandardName>
		<GetDaylightChanges abstract="1" public="1" set="method"><f a="year">
	<x path="Int"/>
	<c path="cs.system.globalization.DaylightTime"/>
</f></GetDaylightChanges>
		<GetUtcOffset abstract="1" public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.TimeSpan"/>
</f></GetUtcOffset>
		<IsDaylightSavingTime public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<x path="Bool"/>
</f></IsDaylightSavingTime>
		<ToLocalTime public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
</f></ToLocalTime>
		<ToUniversalTime public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
</f></ToUniversalTime>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.TimeZone"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.ICustomAttributeProvider" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ICustomAttributeProvider" extern="1" interface="1">
		<GetCustomAttributes public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.ICustomAttributeProvider"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._MemberInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._MemberInfo" extern="1" interface="1">
		<ReflectedType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ReflectedType>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<MemberType public="1" get="accessor" set="null"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<DeclaringType public="1" get="accessor" set="null"><c path="cs.system.Type"/></DeclaringType>
		<GetCustomAttributes public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<get_DeclaringType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_MemberType public="1" set="method"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_ReflectedType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._MemberInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.MemberInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.MemberInfo" extern="1" abstract="1">
		<implements path="cs.system.reflection.ICustomAttributeProvider"/>
		<implements path="cs.system.runtime.interopservices._MemberInfo"/>
		<MetadataToken public="1" get="accessor" set="null"><x path="Int"/></MetadataToken>
		<Module public="1" get="accessor" set="null"><c path="cs.system.reflection.Module"/></Module>
		<ReflectedType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ReflectedType>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<MemberType public="1" get="accessor" set="null"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<DeclaringType public="1" get="accessor" set="null"><c path="cs.system.Type"/></DeclaringType>
		<get_DeclaringType abstract="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_MemberType abstract="1" public="1" set="method"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_Name abstract="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_ReflectedType abstract="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<get_Module public="1" set="method"><f a=""><c path="cs.system.reflection.Module"/></f></get_Module>
		<IsDefined abstract="1" public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<GetCustomAttributes abstract="1" public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes abstract="1" public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<get_MetadataToken public="1" set="method"><f a=""><x path="Int"/></f></get_MetadataToken>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.MemberInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.IReflect" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.IReflect" extern="1" interface="1">
		<UnderlyingSystemType public="1" get="accessor" set="null"><c path="cs.system.Type"/></UnderlyingSystemType>
		<get_UnderlyingSystemType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_UnderlyingSystemType>
		<GetField public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.FieldInfo"/>
</f></GetField>
		<GetFields public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c>
</f></GetFields>
		<GetMember public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMember>
		<GetMembers public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMembers>
		<GetMethod public="1" set="method">
			<f a="name:bindingAttr">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.MethodInfo"/>
			</f>
			<overloads><GetMethod public="1" set="method"><f a="name:bindingAttr:binder:types:modifiers">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod></overloads>
		</GetMethod>
		<GetMethods public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c>
</f></GetMethods>
		<GetProperties public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.PropertyInfo"/></c>
</f></GetProperties>
		<GetProperty public="1" set="method">
			<f a="name:bindingAttr">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.PropertyInfo"/>
			</f>
			<overloads><GetProperty public="1" set="method"><f a="name:bindingAttr:binder:returnType:types:modifiers">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty></overloads>
		</GetProperty>
		<InvokeMember public="1" set="method"><f a="name:invokeAttr:binder:target:args:modifiers:culture:namedParameters">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<d/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<d/>
</f></InvokeMember>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.IReflect"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._Type" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._Type" extern="1" interface="1">
		<UnderlyingSystemType public="1" get="accessor" set="null"><c path="cs.system.Type"/></UnderlyingSystemType>
		<TypeInitializer public="1" get="accessor" set="null"><c path="cs.system.reflection.ConstructorInfo"/></TypeInitializer>
		<TypeHandle public="1" get="accessor" set="null"><c path="cs.system.RuntimeTypeHandle"/></TypeHandle>
		<ReflectedType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ReflectedType>
		<Namespace public="1" get="accessor" set="null"><c path="String"/></Namespace>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<Module public="1" get="accessor" set="null"><c path="cs.system.reflection.Module"/></Module>
		<MemberType public="1" get="accessor" set="null"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<IsValueType public="1" get="accessor" set="null"><x path="Bool"/></IsValueType>
		<IsUnicodeClass public="1" get="accessor" set="null"><x path="Bool"/></IsUnicodeClass>
		<IsSpecialName public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialName>
		<IsSerializable public="1" get="accessor" set="null"><x path="Bool"/></IsSerializable>
		<IsSealed public="1" get="accessor" set="null"><x path="Bool"/></IsSealed>
		<IsPublic public="1" get="accessor" set="null"><x path="Bool"/></IsPublic>
		<IsPrimitive public="1" get="accessor" set="null"><x path="Bool"/></IsPrimitive>
		<IsPointer public="1" get="accessor" set="null"><x path="Bool"/></IsPointer>
		<IsNotPublic public="1" get="accessor" set="null"><x path="Bool"/></IsNotPublic>
		<IsNestedPublic public="1" get="accessor" set="null"><x path="Bool"/></IsNestedPublic>
		<IsNestedPrivate public="1" get="accessor" set="null"><x path="Bool"/></IsNestedPrivate>
		<IsNestedFamORAssem public="1" get="accessor" set="null"><x path="Bool"/></IsNestedFamORAssem>
		<IsNestedFamily public="1" get="accessor" set="null"><x path="Bool"/></IsNestedFamily>
		<IsNestedFamANDAssem public="1" get="accessor" set="null"><x path="Bool"/></IsNestedFamANDAssem>
		<IsNestedAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsNestedAssembly>
		<IsMarshalByRef public="1" get="accessor" set="null"><x path="Bool"/></IsMarshalByRef>
		<IsLayoutSequential public="1" get="accessor" set="null"><x path="Bool"/></IsLayoutSequential>
		<IsInterface public="1" get="accessor" set="null"><x path="Bool"/></IsInterface>
		<IsImport public="1" get="accessor" set="null"><x path="Bool"/></IsImport>
		<IsExplicitLayout public="1" get="accessor" set="null"><x path="Bool"/></IsExplicitLayout>
		<IsEnum public="1" get="accessor" set="null"><x path="Bool"/></IsEnum>
		<IsContextful public="1" get="accessor" set="null"><x path="Bool"/></IsContextful>
		<IsCOMObject public="1" get="accessor" set="null"><x path="Bool"/></IsCOMObject>
		<IsClass public="1" get="accessor" set="null"><x path="Bool"/></IsClass>
		<IsByRef public="1" get="accessor" set="null"><x path="Bool"/></IsByRef>
		<IsAutoLayout public="1" get="accessor" set="null"><x path="Bool"/></IsAutoLayout>
		<IsAutoClass public="1" get="accessor" set="null"><x path="Bool"/></IsAutoClass>
		<IsArray public="1" get="accessor" set="null"><x path="Bool"/></IsArray>
		<IsAnsiClass public="1" get="accessor" set="null"><x path="Bool"/></IsAnsiClass>
		<IsAbstract public="1" get="accessor" set="null"><x path="Bool"/></IsAbstract>
		<HasElementType public="1" get="accessor" set="null"><x path="Bool"/></HasElementType>
		<GUID public="1" get="accessor" set="null"><c path="cs.system.Guid"/></GUID>
		<FullName public="1" get="accessor" set="null"><c path="String"/></FullName>
		<DeclaringType public="1" get="accessor" set="null"><c path="cs.system.Type"/></DeclaringType>
		<BaseType public="1" get="accessor" set="null"><c path="cs.system.Type"/></BaseType>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.TypeAttributes"/></Attributes>
		<AssemblyQualifiedName public="1" get="accessor" set="null"><c path="String"/></AssemblyQualifiedName>
		<Assembly public="1" get="accessor" set="null"><c path="cs.system.reflection.Assembly"/></Assembly>
		<FindInterfaces public="1" set="method"><f a="filter:filterCriteria">
	<x path="cs.system.reflection.TypeFilter"/>
	<d/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
</f></FindInterfaces>
		<FindMembers public="1" set="method"><f a="memberType:bindingAttr:filter:filterCriteria">
	<e path="cs.system.reflection.MemberTypes"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<x path="cs.system.reflection.MemberFilter"/>
	<d/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></FindMembers>
		<GetArrayRank public="1" set="method"><f a=""><x path="Int"/></f></GetArrayRank>
		<GetConstructor public="1" set="method">
			<f a="types">
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.system.reflection.ConstructorInfo"/>
			</f>
			<overloads>
				<GetConstructor public="1" set="method"><f a="bindingAttr:binder:callConvention:types:modifiers">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.ConstructorInfo"/>
</f></GetConstructor>
				<GetConstructor public="1" set="method"><f a="bindingAttr:binder:types:modifiers">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.ConstructorInfo"/>
</f></GetConstructor>
			</overloads>
		</GetConstructor>
		<GetConstructors public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ConstructorInfo"/></c></f>
			<overloads><GetConstructors public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ConstructorInfo"/></c>
</f></GetConstructors></overloads>
		</GetConstructors>
		<GetCustomAttributes public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetDefaultMembers public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c></f></GetDefaultMembers>
		<GetElementType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetElementType>
		<GetEvent public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.EventInfo"/>
			</f>
			<overloads><GetEvent public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.EventInfo"/>
</f></GetEvent></overloads>
		</GetEvent>
		<GetEvents public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.EventInfo"/></c></f>
			<overloads><GetEvents public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.EventInfo"/></c>
</f></GetEvents></overloads>
		</GetEvents>
		<GetField public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.FieldInfo"/>
			</f>
			<overloads><GetField public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.FieldInfo"/>
</f></GetField></overloads>
		</GetField>
		<GetFields public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c></f>
			<overloads><GetFields public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c>
</f></GetFields></overloads>
		</GetFields>
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<GetInterface public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.Type"/>
			</f>
			<overloads><GetInterface public="1" set="method"><f a="name:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetInterface></overloads>
		</GetInterface>
		<GetInterfaceMap public="1" set="method"><f a="interfaceType">
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.InterfaceMapping"/>
</f></GetInterfaceMap>
		<GetInterfaces public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetInterfaces>
		<GetMember public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
			</f>
			<overloads>
				<GetMember public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMember>
				<GetMember public="1" set="method"><f a="name:type:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.MemberTypes"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMember>
			</overloads>
		</GetMember>
		<GetMembers public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c></f>
			<overloads><GetMembers public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMembers></overloads>
		</GetMembers>
		<GetMethod public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.MethodInfo"/>
			</f>
			<overloads>
				<GetMethod public="1" set="method"><f a="name:bindingAttr:binder:callConvention:types:modifiers">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
				<GetMethod public="1" set="method"><f a="name:bindingAttr:binder:types:modifiers">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
				<GetMethod public="1" set="method"><f a="name:types:modifiers">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
				<GetMethod public="1" set="method"><f a="name:types">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
				<GetMethod public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
			</overloads>
		</GetMethod>
		<GetMethods public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c></f>
			<overloads><GetMethods public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c>
</f></GetMethods></overloads>
		</GetMethods>
		<GetNestedType public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.Type"/>
			</f>
			<overloads><GetNestedType public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.Type"/>
</f></GetNestedType></overloads>
		</GetNestedType>
		<GetNestedTypes public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f>
			<overloads><GetNestedTypes public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
</f></GetNestedTypes></overloads>
		</GetNestedTypes>
		<GetProperties public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.PropertyInfo"/></c></f>
			<overloads><GetProperties public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.PropertyInfo"/></c>
</f></GetProperties></overloads>
		</GetProperties>
		<GetProperty public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.PropertyInfo"/>
			</f>
			<overloads>
				<GetProperty public="1" set="method"><f a="name:bindingAttr:binder:returnType:types:modifiers">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty>
				<GetProperty public="1" set="method"><f a="name:returnType:types:modifiers">
	<c path="String"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty>
				<GetProperty public="1" set="method"><f a="name:returnType:types">
	<c path="String"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty>
				<GetProperty public="1" set="method"><f a="name:types">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty>
				<GetProperty public="1" set="method"><f a="name:returnType">
	<c path="String"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty>
				<GetProperty public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty>
			</overloads>
		</GetProperty>
		<GetType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<InvokeMember public="1" set="method">
			<f a="name:invokeAttr:binder:target:args">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<d/>
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<overloads>
				<InvokeMember public="1" set="method"><f a="name:invokeAttr:binder:target:args:modifiers:culture:namedParameters">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<d/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<d/>
</f></InvokeMember>
				<InvokeMember public="1" set="method"><f a="name:invokeAttr:binder:target:args:culture">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<d/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<d/>
</f></InvokeMember>
			</overloads>
		</InvokeMember>
		<IsAssignableFrom public="1" set="method"><f a="c">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsAssignableFrom>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<IsInstanceOfType public="1" set="method"><f a="o">
	<d/>
	<x path="Bool"/>
</f></IsInstanceOfType>
		<IsSubclassOf public="1" set="method"><f a="c">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsSubclassOf>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<get_Assembly public="1" set="method"><f a=""><c path="cs.system.reflection.Assembly"/></f></get_Assembly>
		<get_AssemblyQualifiedName public="1" set="method"><f a=""><c path="String"/></f></get_AssemblyQualifiedName>
		<get_Attributes public="1" set="method"><f a=""><e path="cs.system.reflection.TypeAttributes"/></f></get_Attributes>
		<get_BaseType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_BaseType>
		<get_DeclaringType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_FullName public="1" set="method"><f a=""><c path="String"/></f></get_FullName>
		<get_GUID public="1" set="method"><f a=""><c path="cs.system.Guid"/></f></get_GUID>
		<get_HasElementType public="1" set="method"><f a=""><x path="Bool"/></f></get_HasElementType>
		<get_IsAbstract public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAbstract>
		<get_IsAnsiClass public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAnsiClass>
		<get_IsArray public="1" set="method"><f a=""><x path="Bool"/></f></get_IsArray>
		<get_IsAutoClass public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAutoClass>
		<get_IsAutoLayout public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAutoLayout>
		<get_IsByRef public="1" set="method"><f a=""><x path="Bool"/></f></get_IsByRef>
		<get_IsClass public="1" set="method"><f a=""><x path="Bool"/></f></get_IsClass>
		<get_IsCOMObject public="1" set="method"><f a=""><x path="Bool"/></f></get_IsCOMObject>
		<get_IsContextful public="1" set="method"><f a=""><x path="Bool"/></f></get_IsContextful>
		<get_IsEnum public="1" set="method"><f a=""><x path="Bool"/></f></get_IsEnum>
		<get_IsExplicitLayout public="1" set="method"><f a=""><x path="Bool"/></f></get_IsExplicitLayout>
		<get_IsImport public="1" set="method"><f a=""><x path="Bool"/></f></get_IsImport>
		<get_IsInterface public="1" set="method"><f a=""><x path="Bool"/></f></get_IsInterface>
		<get_IsLayoutSequential public="1" set="method"><f a=""><x path="Bool"/></f></get_IsLayoutSequential>
		<get_IsMarshalByRef public="1" set="method"><f a=""><x path="Bool"/></f></get_IsMarshalByRef>
		<get_IsNestedAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNestedAssembly>
		<get_IsNestedFamANDAssem public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNestedFamANDAssem>
		<get_IsNestedFamily public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNestedFamily>
		<get_IsNestedFamORAssem public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNestedFamORAssem>
		<get_IsNestedPrivate public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNestedPrivate>
		<get_IsNestedPublic public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNestedPublic>
		<get_IsNotPublic public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNotPublic>
		<get_IsPointer public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPointer>
		<get_IsPrimitive public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPrimitive>
		<get_IsPublic public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPublic>
		<get_IsSealed public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSealed>
		<get_IsSerializable public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSerializable>
		<get_IsSpecialName public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialName>
		<get_IsUnicodeClass public="1" set="method"><f a=""><x path="Bool"/></f></get_IsUnicodeClass>
		<get_IsValueType public="1" set="method"><f a=""><x path="Bool"/></f></get_IsValueType>
		<get_MemberType public="1" set="method"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_Module public="1" set="method"><f a=""><c path="cs.system.reflection.Module"/></f></get_Module>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_Namespace public="1" set="method"><f a=""><c path="String"/></f></get_Namespace>
		<get_ReflectedType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<get_TypeHandle public="1" set="method"><f a=""><c path="cs.system.RuntimeTypeHandle"/></f></get_TypeHandle>
		<get_TypeInitializer public="1" set="method"><f a=""><c path="cs.system.reflection.ConstructorInfo"/></f></get_TypeInitializer>
		<get_UnderlyingSystemType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_UnderlyingSystemType>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._Type"</e></m>
		</meta>
	</class>
	<class path="cs.system.Type" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Type" extern="1" abstract="1">
		<extends path="cs.system.reflection.MemberInfo"/>
		<implements path="cs.system.reflection.IReflect"/>
		<implements path="cs.system.runtime.interopservices._Type"/>
		<DefaultBinder public="1" get="accessor" set="null" static="1"><c path="cs.system.reflection.Binder"/></DefaultBinder>
		<Missing public="1" set="null" static="1">
			<d/>
			<meta><m n=":readOnly"/></meta>
		</Missing>
		<FilterNameIgnoreCase public="1" set="null" static="1">
			<x path="cs.system.reflection.MemberFilter"/>
			<meta><m n=":readOnly"/></meta>
		</FilterNameIgnoreCase>
		<FilterName public="1" set="null" static="1">
			<x path="cs.system.reflection.MemberFilter"/>
			<meta><m n=":readOnly"/></meta>
		</FilterName>
		<FilterAttribute public="1" set="null" static="1">
			<x path="cs.system.reflection.MemberFilter"/>
			<meta><m n=":readOnly"/></meta>
		</FilterAttribute>
		<EmptyTypes public="1" set="null" static="1">
			<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
			<meta><m n=":readOnly"/></meta>
		</EmptyTypes>
		<Delimiter public="1" set="null" static="1">
			<t path="cs.types.Char16"/>
			<meta><m n=":readOnly"/></meta>
		</Delimiter>
		<get_DefaultBinder public="1" set="method" static="1"><f a=""><c path="cs.system.reflection.Binder"/></f></get_DefaultBinder>
		<GetType public="1" set="method" static="1">
			<f a="typeName">
				<c path="String"/>
				<c path="cs.system.Type"/>
			</f>
			<overloads>
				<GetType public="1" set="method"><f a="typeName:throwOnError:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetType>
				<GetType public="1" set="method"><f a="typeName:throwOnError">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetType>
			</overloads>
		</GetType>
		<_GetType public="1" set="method" static="1">
			<f a="typeName">
				<c path="String"/>
				<c path="cs.system.Type"/>
			</f>
			<meta><m n=":native"><e>"GetType"</e></m></meta>
			<overloads>
				<GetType public="1" set="method">
					<f a="typeName:throwOnError:ignoreCase">
						<c path="String"/>
						<x path="Bool"/>
						<x path="Bool"/>
						<c path="cs.system.Type"/>
					</f>
					<meta><m n=":native"><e>"GetType"</e></m></meta>
				</GetType>
				<GetType public="1" set="method">
					<f a="typeName:throwOnError">
						<c path="String"/>
						<x path="Bool"/>
						<c path="cs.system.Type"/>
					</f>
					<meta><m n=":native"><e>"GetType"</e></m></meta>
				</GetType>
			</overloads>
		</_GetType>
		<GetTypeArray public="1" set="method" static="1"><f a="args">
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
</f></GetTypeArray>
		<GetTypeCode public="1" set="method" static="1"><f a="type">
	<c path="cs.system.Type"/>
	<e path="cs.system.TypeCode"/>
</f></GetTypeCode>
		<GetTypeFromCLSID public="1" set="method" static="1">
			<f a="clsid">
				<c path="cs.system.Guid"/>
				<c path="cs.system.Type"/>
			</f>
			<overloads>
				<GetTypeFromCLSID public="1" set="method"><f a="clsid:server:throwOnError">
	<c path="cs.system.Guid"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetTypeFromCLSID>
				<GetTypeFromCLSID public="1" set="method"><f a="clsid:server">
	<c path="cs.system.Guid"/>
	<c path="String"/>
	<c path="cs.system.Type"/>
</f></GetTypeFromCLSID>
				<GetTypeFromCLSID public="1" set="method"><f a="clsid:throwOnError">
	<c path="cs.system.Guid"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetTypeFromCLSID>
			</overloads>
		</GetTypeFromCLSID>
		<GetTypeFromHandle public="1" set="method" static="1"><f a="handle">
	<c path="cs.system.RuntimeTypeHandle"/>
	<c path="cs.system.Type"/>
</f></GetTypeFromHandle>
		<GetTypeFromProgID public="1" set="method" static="1">
			<f a="progID">
				<c path="String"/>
				<c path="cs.system.Type"/>
			</f>
			<overloads>
				<GetTypeFromProgID public="1" set="method"><f a="progID:server:throwOnError">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetTypeFromProgID>
				<GetTypeFromProgID public="1" set="method"><f a="progID:server">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.Type"/>
</f></GetTypeFromProgID>
				<GetTypeFromProgID public="1" set="method"><f a="progID:throwOnError">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetTypeFromProgID>
			</overloads>
		</GetTypeFromProgID>
		<GetTypeHandle public="1" set="method" static="1"><f a="o">
	<d/>
	<c path="cs.system.RuntimeTypeHandle"/>
</f></GetTypeHandle>
		<ReflectionOnlyGetType public="1" set="method" static="1"><f a="typeName:throwIfNotFound:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></ReflectionOnlyGetType>
		<StructLayoutAttribute public="1" get="accessor" set="null"><c path="cs.system.runtime.interopservices.StructLayoutAttribute"/></StructLayoutAttribute>
		<DeclaringMethod public="1" get="accessor" set="null"><c path="cs.system.reflection.MethodBase"/></DeclaringMethod>
		<GenericParameterAttributes public="1" get="accessor" set="null"><e path="cs.system.reflection.GenericParameterAttributes"/></GenericParameterAttributes>
		<GenericParameterPosition public="1" get="accessor" set="null"><x path="Int"/></GenericParameterPosition>
		<IsVisible public="1" get="accessor" set="null"><x path="Bool"/></IsVisible>
		<IsNested public="1" get="accessor" set="null"><x path="Bool"/></IsNested>
		<IsGenericParameter public="1" get="accessor" set="null"><x path="Bool"/></IsGenericParameter>
		<IsGenericType public="1" get="accessor" set="null"><x path="Bool"/></IsGenericType>
		<IsGenericTypeDefinition public="1" get="accessor" set="null"><x path="Bool"/></IsGenericTypeDefinition>
		<ContainsGenericParameters public="1" get="accessor" set="null"><x path="Bool"/></ContainsGenericParameters>
		<UnderlyingSystemType public="1" get="accessor" set="null"><c path="cs.system.Type"/></UnderlyingSystemType>
		<TypeInitializer public="1" get="accessor" set="null"><c path="cs.system.reflection.ConstructorInfo"/></TypeInitializer>
		<TypeHandle public="1" get="accessor" set="null"><c path="cs.system.RuntimeTypeHandle"/></TypeHandle>
		<ReflectedType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></ReflectedType>
		<Namespace public="1" get="accessor" set="null"><c path="String"/></Namespace>
		<Module public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.Module"/></Module>
		<MemberType public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<IsValueType public="1" get="accessor" set="null"><x path="Bool"/></IsValueType>
		<IsUnicodeClass public="1" get="accessor" set="null"><x path="Bool"/></IsUnicodeClass>
		<IsSpecialName public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialName>
		<IsSerializable public="1" get="accessor" set="null"><x path="Bool"/></IsSerializable>
		<IsSealed public="1" get="accessor" set="null"><x path="Bool"/></IsSealed>
		<IsPublic public="1" get="accessor" set="null"><x path="Bool"/></IsPublic>
		<IsPrimitive public="1" get="accessor" set="null"><x path="Bool"/></IsPrimitive>
		<IsPointer public="1" get="accessor" set="null"><x path="Bool"/></IsPointer>
		<IsNotPublic public="1" get="accessor" set="null"><x path="Bool"/></IsNotPublic>
		<IsNestedPublic public="1" get="accessor" set="null"><x path="Bool"/></IsNestedPublic>
		<IsNestedPrivate public="1" get="accessor" set="null"><x path="Bool"/></IsNestedPrivate>
		<IsNestedFamORAssem public="1" get="accessor" set="null"><x path="Bool"/></IsNestedFamORAssem>
		<IsNestedFamily public="1" get="accessor" set="null"><x path="Bool"/></IsNestedFamily>
		<IsNestedFamANDAssem public="1" get="accessor" set="null"><x path="Bool"/></IsNestedFamANDAssem>
		<IsNestedAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsNestedAssembly>
		<IsMarshalByRef public="1" get="accessor" set="null"><x path="Bool"/></IsMarshalByRef>
		<IsLayoutSequential public="1" get="accessor" set="null"><x path="Bool"/></IsLayoutSequential>
		<IsInterface public="1" get="accessor" set="null"><x path="Bool"/></IsInterface>
		<IsImport public="1" get="accessor" set="null"><x path="Bool"/></IsImport>
		<IsExplicitLayout public="1" get="accessor" set="null"><x path="Bool"/></IsExplicitLayout>
		<IsEnum public="1" get="accessor" set="null"><x path="Bool"/></IsEnum>
		<IsContextful public="1" get="accessor" set="null"><x path="Bool"/></IsContextful>
		<IsCOMObject public="1" get="accessor" set="null"><x path="Bool"/></IsCOMObject>
		<IsClass public="1" get="accessor" set="null"><x path="Bool"/></IsClass>
		<IsByRef public="1" get="accessor" set="null"><x path="Bool"/></IsByRef>
		<IsAutoLayout public="1" get="accessor" set="null"><x path="Bool"/></IsAutoLayout>
		<IsAutoClass public="1" get="accessor" set="null"><x path="Bool"/></IsAutoClass>
		<IsArray public="1" get="accessor" set="null"><x path="Bool"/></IsArray>
		<IsAnsiClass public="1" get="accessor" set="null"><x path="Bool"/></IsAnsiClass>
		<IsAbstract public="1" get="accessor" set="null"><x path="Bool"/></IsAbstract>
		<HasElementType public="1" get="accessor" set="null"><x path="Bool"/></HasElementType>
		<GUID public="1" get="accessor" set="null"><c path="cs.system.Guid"/></GUID>
		<FullName public="1" get="accessor" set="null"><c path="String"/></FullName>
		<DeclaringType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></DeclaringType>
		<BaseType public="1" get="accessor" set="null"><c path="cs.system.Type"/></BaseType>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.TypeAttributes"/></Attributes>
		<AssemblyQualifiedName public="1" get="accessor" set="null"><c path="String"/></AssemblyQualifiedName>
		<Assembly public="1" get="accessor" set="null"><c path="cs.system.reflection.Assembly"/></Assembly>
		<get_Assembly abstract="1" public="1" set="method"><f a=""><c path="cs.system.reflection.Assembly"/></f></get_Assembly>
		<get_AssemblyQualifiedName abstract="1" public="1" set="method"><f a=""><c path="String"/></f></get_AssemblyQualifiedName>
		<get_Attributes final="1" public="1" set="method"><f a=""><e path="cs.system.reflection.TypeAttributes"/></f></get_Attributes>
		<get_BaseType abstract="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_BaseType>
		<get_DeclaringType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_FullName abstract="1" public="1" set="method"><f a=""><c path="String"/></f></get_FullName>
		<get_GUID abstract="1" public="1" set="method"><f a=""><c path="cs.system.Guid"/></f></get_GUID>
		<get_HasElementType final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_HasElementType>
		<get_IsAbstract final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAbstract>
		<get_IsAnsiClass final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAnsiClass>
		<get_IsArray final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsArray>
		<get_IsAutoClass final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAutoClass>
		<get_IsAutoLayout final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAutoLayout>
		<get_IsByRef final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsByRef>
		<get_IsClass final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsClass>
		<get_IsCOMObject final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsCOMObject>
		<get_IsContextful final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsContextful>
		<get_IsEnum final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsEnum>
		<get_IsExplicitLayout final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsExplicitLayout>
		<get_IsImport final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsImport>
		<get_IsInterface final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsInterface>
		<get_IsLayoutSequential final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsLayoutSequential>
		<get_IsMarshalByRef final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsMarshalByRef>
		<get_IsNestedAssembly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNestedAssembly>
		<get_IsNestedFamANDAssem final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNestedFamANDAssem>
		<get_IsNestedFamily final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNestedFamily>
		<get_IsNestedFamORAssem final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNestedFamORAssem>
		<get_IsNestedPrivate final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNestedPrivate>
		<get_IsNestedPublic final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNestedPublic>
		<get_IsNotPublic final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNotPublic>
		<get_IsPointer final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPointer>
		<get_IsPrimitive final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPrimitive>
		<get_IsPublic final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPublic>
		<get_IsSealed final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSealed>
		<get_IsSerializable final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSerializable>
		<get_IsSpecialName final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialName>
		<get_IsUnicodeClass final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsUnicodeClass>
		<get_IsValueType final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsValueType>
		<get_MemberType public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_Module abstract="1" public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.Module"/></f></get_Module>
		<get_Namespace abstract="1" public="1" set="method"><f a=""><c path="String"/></f></get_Namespace>
		<get_ReflectedType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<get_TypeHandle public="1" set="method"><f a=""><c path="cs.system.RuntimeTypeHandle"/></f></get_TypeHandle>
		<get_TypeInitializer final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.ConstructorInfo"/></f></get_TypeInitializer>
		<get_UnderlyingSystemType abstract="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_UnderlyingSystemType>
		<GetType final="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<IsSubclassOf public="1" set="method"><f a="c">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsSubclassOf>
		<FindInterfaces public="1" set="method"><f a="filter:filterCriteria">
	<x path="cs.system.reflection.TypeFilter"/>
	<d/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
</f></FindInterfaces>
		<GetInterface final="1" public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.Type"/>
			</f>
			<overloads><GetInterface abstract="1" public="1" set="method"><f a="name:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetInterface></overloads>
		</GetInterface>
		<GetInterfaceMap public="1" set="method"><f a="interfaceType">
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.InterfaceMapping"/>
</f></GetInterfaceMap>
		<GetInterfaces abstract="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetInterfaces>
		<IsAssignableFrom public="1" set="method"><f a="c">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsAssignableFrom>
		<IsInstanceOfType public="1" set="method"><f a="o">
	<d/>
	<x path="Bool"/>
</f></IsInstanceOfType>
		<GetArrayRank public="1" set="method"><f a=""><x path="Int"/></f></GetArrayRank>
		<GetElementType abstract="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetElementType>
		<GetEvent final="1" public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.EventInfo"/>
			</f>
			<overloads><GetEvent abstract="1" public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.EventInfo"/>
</f></GetEvent></overloads>
		</GetEvent>
		<GetEvents public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.EventInfo"/></c></f>
			<overloads><GetEvents abstract="1" public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.EventInfo"/></c>
</f></GetEvents></overloads>
		</GetEvents>
		<GetField final="1" public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.FieldInfo"/>
			</f>
			<overloads><GetField abstract="1" public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.FieldInfo"/>
</f></GetField></overloads>
		</GetField>
		<GetFields final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c></f>
			<overloads><GetFields abstract="1" public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c>
</f></GetFields></overloads>
		</GetFields>
		<GetMember final="1" public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
			</f>
			<overloads>
				<GetMember public="1" set="method"><f a="name:type:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.MemberTypes"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMember>
				<GetMember public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMember>
			</overloads>
		</GetMember>
		<GetMembers final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c></f>
			<overloads><GetMembers abstract="1" public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMembers></overloads>
		</GetMembers>
		<GetMethod final="1" public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.MethodInfo"/>
			</f>
			<overloads>
				<GetMethod final="1" public="1" set="method"><f a="name:bindingAttr:binder:callConvention:types:modifiers">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
				<GetMethod final="1" public="1" set="method"><f a="name:bindingAttr:binder:types:modifiers">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
				<GetMethod final="1" public="1" set="method"><f a="name:types:modifiers">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
				<GetMethod final="1" public="1" set="method"><f a="name:types">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
				<GetMethod final="1" public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
			</overloads>
		</GetMethod>
		<GetMethodImpl abstract="1" set="method">
			<f a="name:bindingAttr:binder:callConvention:types:modifiers">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.MethodInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetMethodImpl>
		<GetMethods final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c></f>
			<overloads><GetMethods abstract="1" public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c>
</f></GetMethods></overloads>
		</GetMethods>
		<GetNestedType final="1" public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.Type"/>
			</f>
			<overloads><GetNestedType abstract="1" public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.Type"/>
</f></GetNestedType></overloads>
		</GetNestedType>
		<GetNestedTypes final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f>
			<overloads><GetNestedTypes abstract="1" public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
</f></GetNestedTypes></overloads>
		</GetNestedTypes>
		<GetProperties final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.PropertyInfo"/></c></f>
			<overloads><GetProperties abstract="1" public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.PropertyInfo"/></c>
</f></GetProperties></overloads>
		</GetProperties>
		<GetProperty final="1" public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.PropertyInfo"/>
			</f>
			<overloads>
				<GetProperty final="1" public="1" set="method"><f a="name:bindingAttr:binder:returnType:types:modifiers">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty>
				<GetProperty final="1" public="1" set="method"><f a="name:returnType:types:modifiers">
	<c path="String"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty>
				<GetProperty final="1" public="1" set="method"><f a="name:returnType:types">
	<c path="String"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty>
				<GetProperty final="1" public="1" set="method"><f a="name:types">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty>
				<GetProperty final="1" public="1" set="method"><f a="name:returnType">
	<c path="String"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty>
				<GetProperty final="1" public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></GetProperty>
			</overloads>
		</GetProperty>
		<GetPropertyImpl abstract="1" set="method">
			<f a="name:bindingAttr:binder:returnType:types:modifiers">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<c path="cs.system.Type"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.PropertyInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetPropertyImpl>
		<GetConstructorImpl abstract="1" set="method">
			<f a="bindingAttr:binder:callConvention:types:modifiers">
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.ConstructorInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetConstructorImpl>
		<GetAttributeFlagsImpl abstract="1" set="method">
			<f a=""><e path="cs.system.reflection.TypeAttributes"/></f>
			<meta><m n=":protected"/></meta>
		</GetAttributeFlagsImpl>
		<HasElementTypeImpl abstract="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</HasElementTypeImpl>
		<IsArrayImpl abstract="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsArrayImpl>
		<IsByRefImpl abstract="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsByRefImpl>
		<IsCOMObjectImpl abstract="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsCOMObjectImpl>
		<IsPointerImpl abstract="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsPointerImpl>
		<IsPrimitiveImpl abstract="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsPrimitiveImpl>
		<IsValueTypeImpl set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsValueTypeImpl>
		<IsContextfulImpl set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsContextfulImpl>
		<IsMarshalByRefImpl set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsMarshalByRefImpl>
		<GetConstructor final="1" public="1" set="method">
			<f a="types">
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.system.reflection.ConstructorInfo"/>
			</f>
			<overloads>
				<GetConstructor final="1" public="1" set="method"><f a="bindingAttr:binder:callConvention:types:modifiers">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.ConstructorInfo"/>
</f></GetConstructor>
				<GetConstructor final="1" public="1" set="method"><f a="bindingAttr:binder:types:modifiers">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.ConstructorInfo"/>
</f></GetConstructor>
			</overloads>
		</GetConstructor>
		<GetConstructors final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ConstructorInfo"/></c></f>
			<overloads><GetConstructors abstract="1" public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ConstructorInfo"/></c>
</f></GetConstructors></overloads>
		</GetConstructors>
		<GetDefaultMembers public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c></f></GetDefaultMembers>
		<FindMembers public="1" set="method"><f a="memberType:bindingAttr:filter:filterCriteria">
	<e path="cs.system.reflection.MemberTypes"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<x path="cs.system.reflection.MemberFilter"/>
	<d/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></FindMembers>
		<InvokeMember final="1" public="1" set="method">
			<f a="name:invokeAttr:binder:target:args">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<d/>
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<overloads>
				<InvokeMember abstract="1" public="1" set="method"><f a="name:invokeAttr:binder:target:args:modifiers:culture:namedParameters">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<d/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<d/>
</f></InvokeMember>
				<InvokeMember final="1" public="1" set="method"><f a="name:invokeAttr:binder:target:args:culture">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<d/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<d/>
</f></InvokeMember>
			</overloads>
		</InvokeMember>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<GetGenericArguments public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetGenericArguments>
		<get_ContainsGenericParameters public="1" set="method"><f a=""><x path="Bool"/></f></get_ContainsGenericParameters>
		<get_IsGenericTypeDefinition public="1" set="method"><f a=""><x path="Bool"/></f></get_IsGenericTypeDefinition>
		<GetGenericTypeDefinition public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetGenericTypeDefinition>
		<get_IsGenericType public="1" set="method"><f a=""><x path="Bool"/></f></get_IsGenericType>
		<MakeGenericType public="1" set="method"><f a="typeArguments">
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.Type"/>
</f></MakeGenericType>
		<get_IsGenericParameter public="1" set="method"><f a=""><x path="Bool"/></f></get_IsGenericParameter>
		<get_IsNested final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNested>
		<get_IsVisible final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsVisible>
		<get_GenericParameterPosition public="1" set="method"><f a=""><x path="Int"/></f></get_GenericParameterPosition>
		<get_GenericParameterAttributes public="1" set="method"><f a=""><e path="cs.system.reflection.GenericParameterAttributes"/></f></get_GenericParameterAttributes>
		<GetGenericParameterConstraints public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetGenericParameterConstraints>
		<get_DeclaringMethod public="1" set="method"><f a=""><c path="cs.system.reflection.MethodBase"/></f></get_DeclaringMethod>
		<MakeArrayType public="1" set="method">
			<f a=""><c path="cs.system.Type"/></f>
			<overloads><MakeArrayType public="1" set="method"><f a="rank">
	<x path="Int"/>
	<c path="cs.system.Type"/>
</f></MakeArrayType></overloads>
		</MakeArrayType>
		<MakeByRefType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></MakeByRefType>
		<MakePointerType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></MakePointerType>
		<get_StructLayoutAttribute public="1" set="method"><f a=""><c path="cs.system.runtime.interopservices.StructLayoutAttribute"/></f></get_StructLayoutAttribute>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Type"</e></m>
		</meta>
	</class>
	<enum path="cs.system.TypeCode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.TypeCode">
		<Empty><meta><m n=":csNative"><e>0</e></m></meta></Empty>
		<Object><meta><m n=":csNative"><e>1</e></m></meta></Object>
		<DBNull><meta><m n=":csNative"><e>2</e></m></meta></DBNull>
		<Boolean><meta><m n=":csNative"><e>3</e></m></meta></Boolean>
		<Char><meta><m n=":csNative"><e>4</e></m></meta></Char>
		<SByte><meta><m n=":csNative"><e>5</e></m></meta></SByte>
		<Byte><meta><m n=":csNative"><e>6</e></m></meta></Byte>
		<Int16><meta><m n=":csNative"><e>7</e></m></meta></Int16>
		<UInt16><meta><m n=":csNative"><e>8</e></m></meta></UInt16>
		<Int32><meta><m n=":csNative"><e>9</e></m></meta></Int32>
		<UInt32><meta><m n=":csNative"><e>10</e></m></meta></UInt32>
		<Int64><meta><m n=":csNative"><e>11</e></m></meta></Int64>
		<UInt64><meta><m n=":csNative"><e>12</e></m></meta></UInt64>
		<Single><meta><m n=":csNative"><e>13</e></m></meta></Single>
		<Double><meta><m n=":csNative"><e>14</e></m></meta></Double>
		<Decimal><meta><m n=":csNative"><e>15</e></m></meta></Decimal>
		<DateTime><meta><m n=":csNative"><e>16</e></m></meta></DateTime>
		<String><meta><m n=":csNative"><e>18</e></m></meta></String>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.TypeCode"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.TypedReference" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.TypedReference" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<GetTargetType public="1" set="method" static="1"><f a="value">
	<c path="cs.system.TypedReference"/>
	<c path="cs.system.Type"/>
</f></GetTargetType>
		<MakeTypedReference public="1" set="method" static="1"><f a="target:flds">
	<d/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c>
	<c path="cs.system.TypedReference"/>
</f></MakeTypedReference>
		<SetTypedReference public="1" set="method" static="1"><f a="target:value">
	<c path="cs.system.TypedReference"/>
	<d/>
	<x path="Void"/>
</f></SetTypedReference>
		<TargetTypeToken public="1" set="method" static="1"><f a="value">
	<c path="cs.system.TypedReference"/>
	<c path="cs.system.RuntimeTypeHandle"/>
</f></TargetTypeToken>
		<ToObject public="1" set="method" static="1"><f a="value">
	<c path="cs.system.TypedReference"/>
	<d/>
</f></ToObject>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.TypedReference"</e></m>
		</meta>
	</class>
	<class path="cs.system.UInt32" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.UInt32" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IConvertible"/>
		<implements path="cs.system.IFormattable"/>
		<implements path="cs.system.IComparable_1"><x path="UInt"/></implements>
		<implements path="cs.system.IEquatable_1"><x path="UInt"/></implements>
		<MinValue public="1" set="null" static="1">
			<x path="UInt"/>
			<meta><m n=":readOnly"/></meta>
		</MinValue>
		<MaxValue public="1" set="null" static="1">
			<x path="UInt"/>
			<meta><m n=":readOnly"/></meta>
		</MaxValue>
		<Parse public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<x path="UInt"/>
			</f>
			<overloads>
				<Parse public="1" set="method"><f a="s:style">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<x path="UInt"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<x path="UInt"/>
</f></Parse>
				<Parse public="1" set="method"><f a="s:style:provider">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<c path="cs.system.IFormatProvider"/>
	<x path="UInt"/>
</f></Parse>
			</overloads>
		</Parse>
		<TryParse public="1" set="method" static="1">
			<f a="s:result">
				<c path="String"/>
				<t path="cs.Out"><x path="UInt"/></t>
				<x path="Bool"/>
			</f>
			<overloads><TryParse public="1" set="method"><f a="s:style:provider:result">
	<c path="String"/>
	<e path="cs.system.globalization.NumberStyles"/>
	<c path="cs.system.IFormatProvider"/>
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Bool"/>
</f></TryParse></overloads>
		</TryParse>
		<CompareTo final="1" public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads><CompareTo final="1" public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Int"/>
</f></CompareTo></overloads>
		</CompareTo>
		<ToString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<overloads>
				<ToString final="1" public="1" set="method"><f a="format:provider">
	<c path="String"/>
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="format">
	<c path="String"/>
	<c path="String"/>
</f></ToString>
				<ToString final="1" public="1" set="method"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
</f></ToString>
			</overloads>
		</ToString>
		<GetTypeCode final="1" public="1" set="method"><f a=""><e path="cs.system.TypeCode"/></f></GetTypeCode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.UInt32"</e></m>
		</meta>
	</class>
	<class path="cs.system.UIntPtr" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.UIntPtr" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<Size public="1" get="accessor" set="null" static="1"><x path="Int"/></Size>
		<Zero public="1" set="null" static="1">
			<c path="cs.system.UIntPtr"/>
			<meta><m n=":readOnly"/></meta>
		</Zero>
		<get_Size public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_Size>
		<op_Equality public="1" set="method" static="1"><f a="value1:value2">
	<c path="cs.system.UIntPtr"/>
	<c path="cs.system.UIntPtr"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="value1:value2">
	<c path="cs.system.UIntPtr"/>
	<c path="cs.system.UIntPtr"/>
	<x path="Bool"/>
</f></op_Inequality>
		<op_Explicit public="1" set="method" static="1">
			<f a="value">
				<t path="cs.types.UInt64"/>
				<c path="cs.system.UIntPtr"/>
			</f>
			<overloads><op_Explicit public="1" set="method"><f a="value">
	<x path="UInt"/>
	<c path="cs.system.UIntPtr"/>
</f></op_Explicit></overloads>
		</op_Explicit>
		<ToUInt32 final="1" public="1" set="method"><f a=""><x path="UInt"/></f></ToUInt32>
		<ToUInt64 final="1" public="1" set="method"><f a=""><t path="cs.types.UInt64"/></f></ToUInt64>
		<ToString public="1" set="method" override="1"><f a=""><c path="String"/></f></ToString>
		<new final="1" public="1" set="method">
			<f a="value">
				<t path="cs.types.UInt64"/>
				<x path="Void"/>
			</f>
			<overloads><new final="1" public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.UIntPtr"</e></m>
		</meta>
	</class>
	<class path="cs.system.UnhandledExceptionEventArgs" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.UnhandledExceptionEventArgs" extern="1">
		<extends path="cs.system.EventArgs"/>
		<IsTerminating public="1" get="accessor" set="null"><x path="Bool"/></IsTerminating>
		<ExceptionObject public="1" get="accessor" set="null"><d/></ExceptionObject>
		<get_ExceptionObject final="1" public="1" set="method"><f a=""><d/></f></get_ExceptionObject>
		<get_IsTerminating final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsTerminating>
		<new final="1" public="1" set="method"><f a="exception:isTerminating">
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.UnhandledExceptionEventArgs"</e></m>
		</meta>
	</class>
	<class path="cs.system.Delegate_UnhandledExceptionEventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.UnhandledExceptionEventHandler" module="cs.system.UnhandledExceptionEventHandler" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.UnhandledExceptionEventHandler"/>
	<x path="cs.system.UnhandledExceptionEventHandler"/>
	<x path="cs.system.UnhandledExceptionEventHandler"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.UnhandledExceptionEventHandler"/>
	<x path="cs.system.UnhandledExceptionEventHandler"/>
	<x path="cs.system.UnhandledExceptionEventHandler"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="sender:e">
	<d/>
	<c path="cs.system.UnhandledExceptionEventArgs"/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="sender:e:callback:object">
	<d/>
	<c path="cs.system.UnhandledExceptionEventArgs"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.UnhandledExceptionEventHandler"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.UnhandledExceptionEventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.UnhandledExceptionEventHandler">
		<from><icast field="FromHaxeFunction"><f a=":">
	<d/>
	<c path="cs.system.UnhandledExceptionEventArgs"/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.Delegate_UnhandledExceptionEventHandler"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system._UnhandledExceptionEventHandler.UnhandledExceptionEventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.UnhandledExceptionEventHandler" private="1" module="cs.system.UnhandledExceptionEventHandler" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.UnhandledExceptionEventArgs"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.UnhandledExceptionEventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.UnhandledExceptionEventArgs"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.UnhandledExceptionEventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_UnhandledExceptionEventHandler"/>
	<c path="cs.system.Delegate_UnhandledExceptionEventHandler"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.UnhandledExceptionEventHandler"/>
			<x path="cs.system.UnhandledExceptionEventHandler"/>
			<x path="cs.system.UnhandledExceptionEventHandler"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.UnhandledExceptionEventHandler"/>
			<x path="cs.system.UnhandledExceptionEventHandler"/>
			<x path="cs.system.UnhandledExceptionEventHandler"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system._UnhandledExceptionEventHandler.UnhandledExceptionEventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.UnhandledExceptionEventHandler" private="1" module="cs.system.UnhandledExceptionEventHandler" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.UnhandledExceptionEventArgs"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.UnhandledExceptionEventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.UnhandledExceptionEventArgs"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.UnhandledExceptionEventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.Delegate_UnhandledExceptionEventHandler"/>
	<c path="cs.system.Delegate_UnhandledExceptionEventHandler"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.UnhandledExceptionEventHandler"/>
				<x path="cs.system.UnhandledExceptionEventHandler"/>
				<x path="cs.system.UnhandledExceptionEventHandler"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.UnhandledExceptionEventHandler"/>
				<x path="cs.system.UnhandledExceptionEventHandler"/>
				<x path="cs.system.UnhandledExceptionEventHandler"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.Uri_UriScheme" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.Uri" module="cs.system.Uri" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<defaultPort public="1"><x path="Int"/></defaultPort>
		<delimiter public="1"><c path="String"/></delimiter>
		<scheme public="1"><c path="String"/></scheme>
		<new final="1" public="1" set="method"><f a="s:d:p">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Uri.UriScheme"</e></m>
		</meta>
	</class>
	<class path="cs.system.Uri" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.Uri" extern="1">
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<UriSchemeNetTcp public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</UriSchemeNetTcp>
		<UriSchemeNetPipe public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</UriSchemeNetPipe>
		<UriSchemeNntp public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</UriSchemeNntp>
		<UriSchemeNews public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</UriSchemeNews>
		<UriSchemeMailto public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</UriSchemeMailto>
		<UriSchemeHttps public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</UriSchemeHttps>
		<UriSchemeHttp public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</UriSchemeHttp>
		<UriSchemeGopher public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</UriSchemeGopher>
		<UriSchemeFtp public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</UriSchemeFtp>
		<UriSchemeFile public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</UriSchemeFile>
		<SchemeDelimiter public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</SchemeDelimiter>
		<CheckHostName public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<e path="cs.system.UriHostNameType"/>
</f></CheckHostName>
		<CheckSchemeName public="1" set="method" static="1"><f a="schemeName">
	<c path="String"/>
	<x path="Bool"/>
</f></CheckSchemeName>
		<FromHex public="1" set="method" static="1"><f a="digit">
	<t path="cs.types.Char16"/>
	<x path="Int"/>
</f></FromHex>
		<HexEscape public="1" set="method" static="1"><f a="character">
	<t path="cs.types.Char16"/>
	<c path="String"/>
</f></HexEscape>
		<HexUnescape public="1" set="method" static="1"><f a="pattern:index">
	<c path="String"/>
	<t path="cs.Ref"><x path="Int"/></t>
	<t path="cs.types.Char16"/>
</f></HexUnescape>
		<IsHexDigit public="1" set="method" static="1"><f a="digit">
	<t path="cs.types.Char16"/>
	<x path="Bool"/>
</f></IsHexDigit>
		<IsHexEncoding public="1" set="method" static="1"><f a="pattern:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsHexEncoding>
		<EscapeString set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":protected"/></meta>
		</EscapeString>
		<IsExcludedCharacter set="method" static="1">
			<f a="ch">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</IsExcludedCharacter>
		<Compare public="1" set="method" static="1"><f a="uri1:uri2:partsToCompare:compareFormat:comparisonType">
	<c path="cs.system.Uri"/>
	<c path="cs.system.Uri"/>
	<e path="cs.system.UriComponents"/>
	<e path="cs.system.UriFormat"/>
	<e path="cs.system.StringComparison"/>
	<x path="Int"/>
</f></Compare>
		<EscapeDataString public="1" set="method" static="1"><f a="stringToEscape">
	<c path="String"/>
	<c path="String"/>
</f></EscapeDataString>
		<EscapeUriString public="1" set="method" static="1"><f a="stringToEscape">
	<c path="String"/>
	<c path="String"/>
</f></EscapeUriString>
		<IsWellFormedUriString public="1" set="method" static="1"><f a="uriString:uriKind">
	<c path="String"/>
	<e path="cs.system.UriKind"/>
	<x path="Bool"/>
</f></IsWellFormedUriString>
		<TryCreate public="1" set="method" static="1">
			<f a="uriString:uriKind:result">
				<c path="String"/>
				<e path="cs.system.UriKind"/>
				<t path="cs.Out"><c path="cs.system.Uri"/></t>
				<x path="Bool"/>
			</f>
			<overloads>
				<TryCreate public="1" set="method"><f a="baseUri:relativeUri:result">
	<c path="cs.system.Uri"/>
	<c path="cs.system.Uri"/>
	<t path="cs.Out"><c path="cs.system.Uri"/></t>
	<x path="Bool"/>
</f></TryCreate>
				<TryCreate public="1" set="method"><f a="baseUri:relativeUri:result">
	<c path="cs.system.Uri"/>
	<c path="String"/>
	<t path="cs.Out"><c path="cs.system.Uri"/></t>
	<x path="Bool"/>
</f></TryCreate>
			</overloads>
		</TryCreate>
		<UnescapeDataString public="1" set="method" static="1"><f a="stringToUnescape">
	<c path="String"/>
	<c path="String"/>
</f></UnescapeDataString>
		<op_Equality public="1" set="method" static="1"><f a="u1:u2">
	<c path="cs.system.Uri"/>
	<c path="cs.system.Uri"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="u1:u2">
	<c path="cs.system.Uri"/>
	<c path="cs.system.Uri"/>
	<x path="Bool"/>
</f></op_Inequality>
		<OriginalString public="1" get="accessor" set="null"><c path="String"/></OriginalString>
		<IsAbsoluteUri public="1" get="accessor" set="null"><x path="Bool"/></IsAbsoluteUri>
		<DnsSafeHost public="1" get="accessor" set="null"><c path="String"/></DnsSafeHost>
		<UserInfo public="1" get="accessor" set="null"><c path="String"/></UserInfo>
		<UserEscaped public="1" get="accessor" set="null"><x path="Bool"/></UserEscaped>
		<Segments public="1" get="accessor" set="null"><c path="cs.NativeArray"><c path="String"/></c></Segments>
		<Scheme public="1" get="accessor" set="null"><c path="String"/></Scheme>
		<Query public="1" get="accessor" set="null"><c path="String"/></Query>
		<Port public="1" get="accessor" set="null"><x path="Int"/></Port>
		<PathAndQuery public="1" get="accessor" set="null"><c path="String"/></PathAndQuery>
		<LocalPath public="1" get="accessor" set="null"><c path="String"/></LocalPath>
		<IsUnc public="1" get="accessor" set="null"><x path="Bool"/></IsUnc>
		<IsLoopback public="1" get="accessor" set="null"><x path="Bool"/></IsLoopback>
		<IsFile public="1" get="accessor" set="null"><x path="Bool"/></IsFile>
		<IsDefaultPort public="1" get="accessor" set="null"><x path="Bool"/></IsDefaultPort>
		<HostNameType public="1" get="accessor" set="null"><e path="cs.system.UriHostNameType"/></HostNameType>
		<Host public="1" get="accessor" set="null"><c path="String"/></Host>
		<Fragment public="1" get="accessor" set="null"><c path="String"/></Fragment>
		<Authority public="1" get="accessor" set="null"><c path="String"/></Authority>
		<AbsoluteUri public="1" get="accessor" set="null"><c path="String"/></AbsoluteUri>
		<AbsolutePath public="1" get="accessor" set="null"><c path="String"/></AbsolutePath>
		<get_AbsolutePath final="1" public="1" set="method"><f a=""><c path="String"/></f></get_AbsolutePath>
		<get_AbsoluteUri final="1" public="1" set="method"><f a=""><c path="String"/></f></get_AbsoluteUri>
		<get_Authority final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Authority>
		<get_Fragment final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Fragment>
		<get_Host final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Host>
		<get_HostNameType final="1" public="1" set="method"><f a=""><e path="cs.system.UriHostNameType"/></f></get_HostNameType>
		<get_IsDefaultPort final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsDefaultPort>
		<get_IsFile final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFile>
		<get_IsLoopback final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsLoopback>
		<get_IsUnc final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsUnc>
		<get_LocalPath final="1" public="1" set="method"><f a=""><c path="String"/></f></get_LocalPath>
		<get_PathAndQuery final="1" public="1" set="method"><f a=""><c path="String"/></f></get_PathAndQuery>
		<get_Port final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Port>
		<get_Query final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Query>
		<get_Scheme final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Scheme>
		<get_Segments final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></get_Segments>
		<get_UserEscaped final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_UserEscaped>
		<get_UserInfo final="1" public="1" set="method"><f a=""><c path="String"/></f></get_UserInfo>
		<get_DnsSafeHost final="1" public="1" set="method"><f a=""><c path="String"/></f></get_DnsSafeHost>
		<get_IsAbsoluteUri final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAbsoluteUri>
		<get_OriginalString final="1" public="1" set="method"><f a=""><c path="String"/></f></get_OriginalString>
		<Canonicalize set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</Canonicalize>
		<CheckSecurity set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</CheckSecurity>
		<GetLeftPart final="1" public="1" set="method"><f a="part">
	<e path="cs.system.UriPartial"/>
	<c path="String"/>
</f></GetLeftPart>
		<MakeRelativeUri final="1" public="1" set="method"><f a="uri">
	<c path="cs.system.Uri"/>
	<c path="cs.system.Uri"/>
</f></MakeRelativeUri>
		<MakeRelative final="1" public="1" set="method"><f a="toUri">
	<c path="cs.system.Uri"/>
	<c path="String"/>
</f></MakeRelative>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<GetObjectData final="1" public="1" set="method">
			<f a="info:context">
				<c path="cs.system.runtime.serialization.SerializationInfo"/>
				<c path="cs.system.runtime.serialization.StreamingContext"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</GetObjectData>
		<Escape set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</Escape>
		<Parse set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</Parse>
		<Unescape set="method">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":protected"/></meta>
		</Unescape>
		<IsBadFileSystemCharacter set="method">
			<f a="ch">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</IsBadFileSystemCharacter>
		<IsReservedCharacter set="method">
			<f a="ch">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</IsReservedCharacter>
		<GetComponents final="1" public="1" set="method"><f a="components:format">
	<e path="cs.system.UriComponents"/>
	<e path="cs.system.UriFormat"/>
	<c path="String"/>
</f></GetComponents>
		<IsBaseOf final="1" public="1" set="method"><f a="uri">
	<c path="cs.system.Uri"/>
	<x path="Bool"/>
</f></IsBaseOf>
		<IsWellFormedOriginalString final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsWellFormedOriginalString>
		<new final="1" public="1" set="method">
			<f a="uriString">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="baseUri:relativeUri:dontEscape">
	<c path="cs.system.Uri"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="baseUri:relativeUri">
	<c path="cs.system.Uri"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="uriString:dontEscape">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="baseUri:relativeUri">
	<c path="cs.system.Uri"/>
	<c path="cs.system.Uri"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="uriString:uriKind">
	<c path="String"/>
	<e path="cs.system.UriKind"/>
	<x path="Void"/>
</f></new>
				<new final="1" set="method">
					<f a="serializationInfo:streamingContext">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Uri"</e></m>
		</meta>
	</class>
	<enum path="cs.system.UriComponents" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.UriComponents">
		<SerializationInfoString><meta><m n=":csNative"><e>-2147483648</e></m></meta></SerializationInfoString>
		<Scheme><meta><m n=":csNative"><e>1</e></m></meta></Scheme>
		<UserInfo><meta><m n=":csNative"><e>2</e></m></meta></UserInfo>
		<Host><meta><m n=":csNative"><e>4</e></m></meta></Host>
		<Port><meta><m n=":csNative"><e>8</e></m></meta></Port>
		<SchemeAndServer><meta><m n=":csNative"><e>13</e></m></meta></SchemeAndServer>
		<Path><meta><m n=":csNative"><e>16</e></m></meta></Path>
		<Query><meta><m n=":csNative"><e>32</e></m></meta></Query>
		<PathAndQuery><meta><m n=":csNative"><e>48</e></m></meta></PathAndQuery>
		<HttpRequestUrl><meta><m n=":csNative"><e>61</e></m></meta></HttpRequestUrl>
		<Fragment><meta><m n=":csNative"><e>64</e></m></meta></Fragment>
		<AbsoluteUri><meta><m n=":csNative"><e>127</e></m></meta></AbsoluteUri>
		<StrongPort><meta><m n=":csNative"><e>128</e></m></meta></StrongPort>
		<HostAndPort><meta><m n=":csNative"><e>132</e></m></meta></HostAndPort>
		<StrongAuthority><meta><m n=":csNative"><e>134</e></m></meta></StrongAuthority>
		<KeepDelimiter><meta><m n=":csNative"><e>1073741824</e></m></meta></KeepDelimiter>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.UriComponents"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.UriFormat" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.UriFormat">
		<UriEscaped><meta><m n=":csNative"><e>1</e></m></meta></UriEscaped>
		<Unescaped><meta><m n=":csNative"><e>2</e></m></meta></Unescaped>
		<SafeUnescaped><meta><m n=":csNative"><e>3</e></m></meta></SafeUnescaped>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.UriFormat"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.UriHostNameType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.UriHostNameType">
		<Unknown><meta><m n=":csNative"><e>0</e></m></meta></Unknown>
		<Basic><meta><m n=":csNative"><e>1</e></m></meta></Basic>
		<Dns><meta><m n=":csNative"><e>2</e></m></meta></Dns>
		<IPv4><meta><m n=":csNative"><e>3</e></m></meta></IPv4>
		<IPv6><meta><m n=":csNative"><e>4</e></m></meta></IPv6>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.UriHostNameType"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.UriKind" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.UriKind">
		<RelativeOrAbsolute><meta><m n=":csNative"><e>0</e></m></meta></RelativeOrAbsolute>
		<Absolute><meta><m n=":csNative"><e>1</e></m></meta></Absolute>
		<Relative><meta><m n=":csNative"><e>2</e></m></meta></Relative>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.UriKind"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.UriPartial" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.UriPartial">
		<Scheme><meta><m n=":csNative"><e>0</e></m></meta></Scheme>
		<Authority><meta><m n=":csNative"><e>1</e></m></meta></Authority>
		<Path><meta><m n=":csNative"><e>2</e></m></meta></Path>
		<Query><meta><m n=":csNative"><e>3</e></m></meta></Query>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.UriPartial"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.Version" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.Version" extern="1" final="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.IComparable"/>
		<implements path="cs.system.IComparable_1"><c path="cs.system.Version"/></implements>
		<implements path="cs.system.IEquatable_1"><c path="cs.system.Version"/></implements>
		<op_Equality public="1" set="method" static="1"><f a="v1:v2">
	<c path="cs.system.Version"/>
	<c path="cs.system.Version"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="v1:v2">
	<c path="cs.system.Version"/>
	<c path="cs.system.Version"/>
	<x path="Bool"/>
</f></op_Inequality>
		<op_GreaterThan public="1" set="method" static="1"><f a="v1:v2">
	<c path="cs.system.Version"/>
	<c path="cs.system.Version"/>
	<x path="Bool"/>
</f></op_GreaterThan>
		<op_GreaterThanOrEqual public="1" set="method" static="1"><f a="v1:v2">
	<c path="cs.system.Version"/>
	<c path="cs.system.Version"/>
	<x path="Bool"/>
</f></op_GreaterThanOrEqual>
		<op_LessThan public="1" set="method" static="1"><f a="v1:v2">
	<c path="cs.system.Version"/>
	<c path="cs.system.Version"/>
	<x path="Bool"/>
</f></op_LessThan>
		<op_LessThanOrEqual public="1" set="method" static="1"><f a="v1:v2">
	<c path="cs.system.Version"/>
	<c path="cs.system.Version"/>
	<x path="Bool"/>
</f></op_LessThanOrEqual>
		<MinorRevision public="1" get="accessor" set="null"><t path="cs.types.Int16"/></MinorRevision>
		<MajorRevision public="1" get="accessor" set="null"><t path="cs.types.Int16"/></MajorRevision>
		<Revision public="1" get="accessor" set="null"><x path="Int"/></Revision>
		<Minor public="1" get="accessor" set="null"><x path="Int"/></Minor>
		<Major public="1" get="accessor" set="null"><x path="Int"/></Major>
		<Build public="1" get="accessor" set="null"><x path="Int"/></Build>
		<get_Build final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Build>
		<get_Major final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Major>
		<get_Minor final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Minor>
		<get_Revision final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Revision>
		<get_MajorRevision final="1" public="1" set="method"><f a=""><t path="cs.types.Int16"/></f></get_MajorRevision>
		<get_MinorRevision final="1" public="1" set="method"><f a=""><t path="cs.types.Int16"/></f></get_MinorRevision>
		<Clone final="1" public="1" set="method"><f a=""><d/></f></Clone>
		<CompareTo final="1" public="1" set="method">
			<f a="version">
				<d/>
				<x path="Int"/>
			</f>
			<overloads><CompareTo final="1" public="1" set="method"><f a="value">
	<c path="cs.system.Version"/>
	<x path="Int"/>
</f></CompareTo></overloads>
		</CompareTo>
		<ToString public="1" set="method">
			<f a=""><c path="String"/></f>
			<overloads><ToString final="1" public="1" set="method"><f a="fieldCount">
	<x path="Int"/>
	<c path="String"/>
</f></ToString></overloads>
		</ToString>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="major:minor:build:revision">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="major:minor:build">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="major:minor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="version">
	<c path="String"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Version"</e></m>
		</meta>
	</class>
	<class path="cs.system.WeakReference" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.WeakReference" extern="1">
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<TrackResurrection public="1" get="accessor" set="null"><x path="Bool"/></TrackResurrection>
		<Target public="1" get="accessor" set="accessor"><d/></Target>
		<IsAlive public="1" get="accessor" set="null"><x path="Bool"/></IsAlive>
		<get_IsAlive public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAlive>
		<get_Target public="1" set="method"><f a=""><d/></f></get_Target>
		<set_Target public="1" set="method"><f a="value">
	<d/>
	<d/>
</f></set_Target>
		<get_TrackResurrection public="1" set="method"><f a=""><x path="Bool"/></f></get_TrackResurrection>
		<GetObjectData public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<new final="1" public="1" set="method">
			<f a="target">
				<d/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" set="method">
					<f a="info:context">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" public="1" set="method"><f a="target:trackResurrection">
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.WeakReference"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_ListWrapper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1">
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<implements path="cs.system.collections.IList"/>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<IsFixedSize public="1" get="accessor" set="null"><x path="Bool"/></IsFixedSize>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<m_InnerList><c path="cs.system.collections.IList"/></m_InnerList>
		<get_Item public="1" set="method"><f a="index">
	<x path="Int"/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<get_Count public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_IsSynchronized public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_SyncRoot public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<get_IsFixedSize public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<get_IsReadOnly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<Add public="1" set="method"><f a="value">
	<d/>
	<x path="Int"/>
</f></Add>
		<Clear public="1" set="method"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></Contains>
		<IndexOf public="1" set="method"><f a="value">
	<d/>
	<x path="Int"/>
</f></IndexOf>
		<Insert public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></Insert>
		<Remove public="1" set="method"><f a="value">
	<d/>
	<x path="Void"/>
</f></Remove>
		<RemoveAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveAt>
		<CopyTo public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<GetEnumerator public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<new final="1" public="1" set="method"><f a="innerList">
	<c path="cs.system.collections.IList"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.ListWrapper"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_FixedSizeListWrapper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1">
		<extends path="cs.system.collections.ArrayList_ListWrapper"/>
		<IsFixedSize public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsFixedSize>
		<ErrorMessage get="null" set="null"><c path="String"/></ErrorMessage>
		<get_ErrorMessage set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":protected"/></meta>
		</get_ErrorMessage>
		<get_IsFixedSize public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<Add public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Int"/>
</f></Add>
		<Clear public="1" set="method" override="1"><f a=""><x path="Void"/></f></Clear>
		<Insert public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></Insert>
		<Remove public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Void"/>
</f></Remove>
		<RemoveAt public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveAt>
		<new final="1" public="1" set="method"><f a="innerList">
	<c path="cs.system.collections.IList"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.FixedSizeListWrapper"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_ReadOnlyListWrapper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1" final="1">
		<extends path="cs.system.collections.ArrayList_FixedSizeListWrapper"/>
		<IsReadOnly public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsReadOnly>
		<ErrorMessage get="null" set="null" override="1"><c path="String"/></ErrorMessage>
		<get_ErrorMessage set="method" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":protected"/></meta>
		</get_ErrorMessage>
		<get_IsReadOnly public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_Item public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<new final="1" public="1" set="method"><f a="innerList">
	<c path="cs.system.collections.IList"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.ReadOnlyListWrapper"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_SynchronizedListWrapper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1" final="1">
		<extends path="cs.system.collections.ArrayList_ListWrapper"/>
		<IsReadOnly public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsReadOnly>
		<IsFixedSize public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsFixedSize>
		<SyncRoot public="1" get="accessor" set="null" override="1"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsSynchronized>
		<Count public="1" get="accessor" set="null" override="1"><x path="Int"/></Count>
		<get_Count public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_Count>
		<get_IsSynchronized public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_SyncRoot public="1" set="method" override="1"><f a=""><d/></f></get_SyncRoot>
		<get_IsFixedSize public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<get_IsReadOnly public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_Item public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<Add public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Int"/>
</f></Add>
		<Clear public="1" set="method" override="1"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></Contains>
		<IndexOf public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Int"/>
</f></IndexOf>
		<Insert public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></Insert>
		<Remove public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Void"/>
</f></Remove>
		<RemoveAt public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveAt>
		<CopyTo public="1" set="method" override="1"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<GetEnumerator public="1" set="method" override="1"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<new final="1" public="1" set="method"><f a="innerList">
	<c path="cs.system.collections.IList"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.SynchronizedListWrapper"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" extern="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<implements path="cs.system.collections.IList"/>
		<Adapter public="1" set="method" static="1"><f a="list">
	<c path="cs.system.collections.IList"/>
	<c path="cs.system.collections.ArrayList"/>
</f></Adapter>
		<Synchronized public="1" set="method" static="1">
			<f a="list">
				<c path="cs.system.collections.ArrayList"/>
				<c path="cs.system.collections.ArrayList"/>
			</f>
			<overloads><Synchronized public="1" set="method"><f a="list">
	<c path="cs.system.collections.IList"/>
	<c path="cs.system.collections.IList"/>
</f></Synchronized></overloads>
		</Synchronized>
		<ReadOnly public="1" set="method" static="1">
			<f a="list">
				<c path="cs.system.collections.ArrayList"/>
				<c path="cs.system.collections.ArrayList"/>
			</f>
			<overloads><ReadOnly public="1" set="method"><f a="list">
	<c path="cs.system.collections.IList"/>
	<c path="cs.system.collections.IList"/>
</f></ReadOnly></overloads>
		</ReadOnly>
		<FixedSize public="1" set="method" static="1">
			<f a="list">
				<c path="cs.system.collections.ArrayList"/>
				<c path="cs.system.collections.ArrayList"/>
			</f>
			<overloads><FixedSize public="1" set="method"><f a="list">
	<c path="cs.system.collections.IList"/>
	<c path="cs.system.collections.IList"/>
</f></FixedSize></overloads>
		</FixedSize>
		<Repeat public="1" set="method" static="1"><f a="value:count">
	<d/>
	<x path="Int"/>
	<c path="cs.system.collections.ArrayList"/>
</f></Repeat>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<IsFixedSize public="1" get="accessor" set="null"><x path="Bool"/></IsFixedSize>
		<Capacity public="1" get="accessor" set="accessor"><x path="Int"/></Capacity>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<get_Item public="1" set="method"><f a="index">
	<x path="Int"/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<get_Count public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_Capacity public="1" set="method"><f a=""><x path="Int"/></f></get_Capacity>
		<set_Capacity public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_Capacity>
		<get_IsFixedSize public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<get_IsReadOnly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_IsSynchronized public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_SyncRoot public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<Add public="1" set="method"><f a="value">
	<d/>
	<x path="Int"/>
</f></Add>
		<Clear public="1" set="method"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method"><f a="item">
	<d/>
	<x path="Bool"/>
</f></Contains>
		<IndexOf public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<IndexOf public="1" set="method"><f a="value:startIndex:count">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="value:startIndex">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
			</overloads>
		</IndexOf>
		<LastIndexOf public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<LastIndexOf public="1" set="method"><f a="value:startIndex:count">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="value:startIndex">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
			</overloads>
		</LastIndexOf>
		<Insert public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></Insert>
		<InsertRange public="1" set="method"><f a="index:c">
	<x path="Int"/>
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></InsertRange>
		<Remove public="1" set="method"><f a="obj">
	<d/>
	<x path="Void"/>
</f></Remove>
		<RemoveAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveAt>
		<RemoveRange public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveRange>
		<Reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><Reverse public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Reverse></overloads>
		</Reverse>
		<CopyTo public="1" set="method">
			<f a="array">
				<c path="cs.system.Array"/>
				<x path="Void"/>
			</f>
			<overloads>
				<CopyTo public="1" set="method"><f a="index:array:arrayIndex:count">
	<x path="Int"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
				<CopyTo public="1" set="method"><f a="array:arrayIndex">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
			</overloads>
		</CopyTo>
		<GetEnumerator public="1" set="method">
			<f a=""><c path="cs.system.collections.IEnumerator"/></f>
			<overloads><GetEnumerator public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IEnumerator"/>
</f></GetEnumerator></overloads>
		</GetEnumerator>
		<AddRange public="1" set="method"><f a="c">
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></AddRange>
		<BinarySearch public="1" set="method">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<BinarySearch public="1" set="method"><f a="index:count:value:comparer">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Int"/>
</f></BinarySearch>
				<BinarySearch public="1" set="method"><f a="value:comparer">
	<d/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Int"/>
</f></BinarySearch>
			</overloads>
		</BinarySearch>
		<GetRange public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.ArrayList"/>
</f></GetRange>
		<SetRange public="1" set="method"><f a="index:c">
	<x path="Int"/>
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></SetRange>
		<TrimToSize public="1" set="method"><f a=""><x path="Void"/></f></TrimToSize>
		<Sort public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<Sort public="1" set="method"><f a="index:count:comparer">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="comparer">
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
			</overloads>
		</Sort>
		<ToArray public="1" set="method">
			<f a=""><c path="cs.NativeArray"><d/></c></f>
			<overloads><ToArray public="1" set="method"><f a="type">
	<c path="cs.system.Type"/>
	<c path="cs.system.Array"/>
</f></ToArray></overloads>
		</ToArray>
		<Clone public="1" set="method"><f a=""><d/></f></Clone>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="capacity">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="c">
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_ArrayListWrapper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1">
		<extends path="cs.system.collections.ArrayList"/>
		<SyncRoot public="1" get="accessor" set="null" override="1"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsSynchronized>
		<IsReadOnly public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsReadOnly>
		<IsFixedSize public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsFixedSize>
		<Capacity public="1" get="accessor" set="accessor" override="1"><x path="Int"/></Capacity>
		<Count public="1" get="accessor" set="null" override="1"><x path="Int"/></Count>
		<m_InnerArrayList><c path="cs.system.collections.ArrayList"/></m_InnerArrayList>
		<get_Item public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<get_Count public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_Count>
		<get_Capacity public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_Capacity>
		<set_Capacity public="1" set="method" override="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_Capacity>
		<get_IsFixedSize public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<get_IsReadOnly public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_IsSynchronized public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_SyncRoot public="1" set="method" override="1"><f a=""><d/></f></get_SyncRoot>
		<Add public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Int"/>
</f></Add>
		<Clear public="1" set="method" override="1"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></Contains>
		<IndexOf public="1" set="method" override="1">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<IndexOf public="1" set="method"><f a="value:startIndex:count">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="value:startIndex">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
			</overloads>
		</IndexOf>
		<LastIndexOf public="1" set="method" override="1">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<LastIndexOf public="1" set="method"><f a="value:startIndex:count">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="value:startIndex">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
			</overloads>
		</LastIndexOf>
		<Insert public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></Insert>
		<InsertRange public="1" set="method" override="1"><f a="index:c">
	<x path="Int"/>
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></InsertRange>
		<Remove public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Void"/>
</f></Remove>
		<RemoveAt public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveAt>
		<RemoveRange public="1" set="method" override="1"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveRange>
		<Reverse public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<overloads><Reverse public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Reverse></overloads>
		</Reverse>
		<SetRange public="1" set="method" override="1"><f a="index:c">
	<x path="Int"/>
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></SetRange>
		<CopyTo public="1" set="method" override="1">
			<f a="array">
				<c path="cs.system.Array"/>
				<x path="Void"/>
			</f>
			<overloads>
				<CopyTo public="1" set="method"><f a="index:array:arrayIndex:count">
	<x path="Int"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
				<CopyTo public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
			</overloads>
		</CopyTo>
		<GetEnumerator public="1" set="method" override="1">
			<f a=""><c path="cs.system.collections.IEnumerator"/></f>
			<overloads><GetEnumerator public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IEnumerator"/>
</f></GetEnumerator></overloads>
		</GetEnumerator>
		<AddRange public="1" set="method" override="1"><f a="c">
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></AddRange>
		<BinarySearch public="1" set="method" override="1">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<BinarySearch public="1" set="method"><f a="index:count:value:comparer">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Int"/>
</f></BinarySearch>
				<BinarySearch public="1" set="method"><f a="value:comparer">
	<d/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Int"/>
</f></BinarySearch>
			</overloads>
		</BinarySearch>
		<Clone public="1" set="method" override="1"><f a=""><d/></f></Clone>
		<GetRange public="1" set="method" override="1"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.ArrayList"/>
</f></GetRange>
		<TrimToSize public="1" set="method" override="1"><f a=""><x path="Void"/></f></TrimToSize>
		<Sort public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<overloads>
				<Sort public="1" set="method"><f a="index:count:comparer">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="comparer">
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
			</overloads>
		</Sort>
		<ToArray public="1" set="method" override="1">
			<f a=""><c path="cs.NativeArray"><d/></c></f>
			<overloads><ToArray public="1" set="method"><f a="elementType">
	<c path="cs.system.Type"/>
	<c path="cs.system.Array"/>
</f></ToArray></overloads>
		</ToArray>
		<new final="1" public="1" set="method"><f a="innerArrayList">
	<c path="cs.system.collections.ArrayList"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.ArrayListWrapper"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_RangedArrayList" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1" final="1">
		<extends path="cs.system.collections.ArrayList_ArrayListWrapper"/>
		<Capacity public="1" get="accessor" set="accessor" override="1"><x path="Int"/></Capacity>
		<Count public="1" get="accessor" set="null" override="1"><x path="Int"/></Count>
		<IsSynchronized public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsSynchronized>
		<get_IsSynchronized public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_Item public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<get_Count public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_Count>
		<get_Capacity public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_Capacity>
		<set_Capacity public="1" set="method" override="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_Capacity>
		<Add public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Int"/>
</f></Add>
		<Clear public="1" set="method" override="1"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></Contains>
		<IndexOf public="1" set="method" override="1">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<IndexOf public="1" set="method"><f a="value:startIndex:count">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="value:startIndex">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
			</overloads>
		</IndexOf>
		<LastIndexOf public="1" set="method" override="1">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<LastIndexOf public="1" set="method"><f a="value:startIndex:count">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="value:startIndex">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
			</overloads>
		</LastIndexOf>
		<Insert public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></Insert>
		<InsertRange public="1" set="method" override="1"><f a="index:c">
	<x path="Int"/>
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></InsertRange>
		<Remove public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Void"/>
</f></Remove>
		<RemoveAt public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveAt>
		<RemoveRange public="1" set="method" override="1"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveRange>
		<Reverse public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<overloads><Reverse public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Reverse></overloads>
		</Reverse>
		<SetRange public="1" set="method" override="1"><f a="index:c">
	<x path="Int"/>
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></SetRange>
		<CopyTo public="1" set="method" override="1">
			<f a="array">
				<c path="cs.system.Array"/>
				<x path="Void"/>
			</f>
			<overloads>
				<CopyTo public="1" set="method"><f a="index:array:arrayIndex:count">
	<x path="Int"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
				<CopyTo public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
			</overloads>
		</CopyTo>
		<GetEnumerator public="1" set="method" override="1">
			<f a=""><c path="cs.system.collections.IEnumerator"/></f>
			<overloads><GetEnumerator public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IEnumerator"/>
</f></GetEnumerator></overloads>
		</GetEnumerator>
		<AddRange public="1" set="method" override="1"><f a="c">
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></AddRange>
		<BinarySearch public="1" set="method" override="1">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<BinarySearch public="1" set="method"><f a="index:count:value:comparer">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Int"/>
</f></BinarySearch>
				<BinarySearch public="1" set="method"><f a="value:comparer">
	<d/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Int"/>
</f></BinarySearch>
			</overloads>
		</BinarySearch>
		<Clone public="1" set="method" override="1"><f a=""><d/></f></Clone>
		<GetRange public="1" set="method" override="1"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.ArrayList"/>
</f></GetRange>
		<TrimToSize public="1" set="method" override="1"><f a=""><x path="Void"/></f></TrimToSize>
		<Sort public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<overloads>
				<Sort public="1" set="method"><f a="index:count:comparer">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="comparer">
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
			</overloads>
		</Sort>
		<ToArray public="1" set="method" override="1">
			<f a=""><c path="cs.NativeArray"><d/></c></f>
			<overloads><ToArray public="1" set="method"><f a="elementType">
	<c path="cs.system.Type"/>
	<c path="cs.system.Array"/>
</f></ToArray></overloads>
		</ToArray>
		<new final="1" public="1" set="method"><f a="innerList:index:count">
	<c path="cs.system.collections.ArrayList"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.RangedArrayList"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_FixedSizeArrayListWrapper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1">
		<extends path="cs.system.collections.ArrayList_ArrayListWrapper"/>
		<IsFixedSize public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsFixedSize>
		<Capacity public="1" get="accessor" set="accessor" override="1"><x path="Int"/></Capacity>
		<ErrorMessage get="null" set="null"><c path="String"/></ErrorMessage>
		<get_ErrorMessage set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":protected"/></meta>
		</get_ErrorMessage>
		<get_Capacity public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_Capacity>
		<set_Capacity public="1" set="method" override="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_Capacity>
		<get_IsFixedSize public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<Add public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Int"/>
</f></Add>
		<AddRange public="1" set="method" override="1"><f a="c">
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></AddRange>
		<Clear public="1" set="method" override="1"><f a=""><x path="Void"/></f></Clear>
		<Insert public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></Insert>
		<InsertRange public="1" set="method" override="1"><f a="index:c">
	<x path="Int"/>
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></InsertRange>
		<Remove public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Void"/>
</f></Remove>
		<RemoveAt public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveAt>
		<RemoveRange public="1" set="method" override="1"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveRange>
		<TrimToSize public="1" set="method" override="1"><f a=""><x path="Void"/></f></TrimToSize>
		<new final="1" public="1" set="method"><f a="innerList">
	<c path="cs.system.collections.ArrayList"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.FixedSizeArrayListWrapper"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_ReadOnlyArrayListWrapper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1" final="1">
		<extends path="cs.system.collections.ArrayList_FixedSizeArrayListWrapper"/>
		<IsReadOnly public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsReadOnly>
		<ErrorMessage get="null" set="null" override="1"><c path="String"/></ErrorMessage>
		<get_ErrorMessage set="method" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":protected"/></meta>
		</get_ErrorMessage>
		<get_IsReadOnly public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_Item public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<Reverse public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<overloads><Reverse public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Reverse></overloads>
		</Reverse>
		<SetRange public="1" set="method" override="1"><f a="index:c">
	<x path="Int"/>
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></SetRange>
		<Sort public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<overloads>
				<Sort public="1" set="method"><f a="index:count:comparer">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="comparer">
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
			</overloads>
		</Sort>
		<new final="1" public="1" set="method"><f a="innerArrayList">
	<c path="cs.system.collections.ArrayList"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.ReadOnlyArrayListWrapper"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_SynchronizedArrayListWrapper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1" final="1">
		<extends path="cs.system.collections.ArrayList_ArrayListWrapper"/>
		<SyncRoot public="1" get="accessor" set="null" override="1"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsSynchronized>
		<IsReadOnly public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsReadOnly>
		<IsFixedSize public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsFixedSize>
		<Capacity public="1" get="accessor" set="accessor" override="1"><x path="Int"/></Capacity>
		<Count public="1" get="accessor" set="null" override="1"><x path="Int"/></Count>
		<get_Item public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<get_Count public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_Count>
		<get_Capacity public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_Capacity>
		<set_Capacity public="1" set="method" override="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_Capacity>
		<get_IsFixedSize public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<get_IsReadOnly public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_IsSynchronized public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_SyncRoot public="1" set="method" override="1"><f a=""><d/></f></get_SyncRoot>
		<Add public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Int"/>
</f></Add>
		<Clear public="1" set="method" override="1"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></Contains>
		<IndexOf public="1" set="method" override="1">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<IndexOf public="1" set="method"><f a="value:startIndex:count">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="value:startIndex">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
			</overloads>
		</IndexOf>
		<LastIndexOf public="1" set="method" override="1">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<LastIndexOf public="1" set="method"><f a="value:startIndex:count">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="value:startIndex">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
			</overloads>
		</LastIndexOf>
		<Insert public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></Insert>
		<InsertRange public="1" set="method" override="1"><f a="index:c">
	<x path="Int"/>
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></InsertRange>
		<Remove public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Void"/>
</f></Remove>
		<RemoveAt public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveAt>
		<RemoveRange public="1" set="method" override="1"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveRange>
		<Reverse public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<overloads><Reverse public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Reverse></overloads>
		</Reverse>
		<CopyTo public="1" set="method" override="1">
			<f a="array">
				<c path="cs.system.Array"/>
				<x path="Void"/>
			</f>
			<overloads>
				<CopyTo public="1" set="method"><f a="index:array:arrayIndex:count">
	<x path="Int"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
				<CopyTo public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
			</overloads>
		</CopyTo>
		<GetEnumerator public="1" set="method" override="1">
			<f a=""><c path="cs.system.collections.IEnumerator"/></f>
			<overloads><GetEnumerator public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IEnumerator"/>
</f></GetEnumerator></overloads>
		</GetEnumerator>
		<AddRange public="1" set="method" override="1"><f a="c">
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></AddRange>
		<BinarySearch public="1" set="method" override="1">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<BinarySearch public="1" set="method"><f a="index:count:value:comparer">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Int"/>
</f></BinarySearch>
				<BinarySearch public="1" set="method"><f a="value:comparer">
	<d/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Int"/>
</f></BinarySearch>
			</overloads>
		</BinarySearch>
		<Clone public="1" set="method" override="1"><f a=""><d/></f></Clone>
		<GetRange public="1" set="method" override="1"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.ArrayList"/>
</f></GetRange>
		<TrimToSize public="1" set="method" override="1"><f a=""><x path="Void"/></f></TrimToSize>
		<Sort public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<overloads>
				<Sort public="1" set="method"><f a="index:count:comparer">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="comparer">
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
			</overloads>
		</Sort>
		<ToArray public="1" set="method" override="1">
			<f a=""><c path="cs.NativeArray"><d/></c></f>
			<overloads><ToArray public="1" set="method"><f a="elementType">
	<c path="cs.system.Type"/>
	<c path="cs.system.Array"/>
</f></ToArray></overloads>
		</ToArray>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.SynchronizedArrayListWrapper"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_ArrayListAdapter_EnumeratorWithRange" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1" final="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.collections.IEnumerator"/>
		<Current public="1" get="accessor" set="null"><d/></Current>
		<Clone final="1" public="1" set="method"><f a=""><d/></f></Clone>
		<get_Current final="1" public="1" set="method"><f a=""><d/></f></get_Current>
		<MoveNext final="1" public="1" set="method"><f a=""><x path="Bool"/></f></MoveNext>
		<Reset final="1" public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<new final="1" public="1" set="method"><f a="enumerator:index:count">
	<c path="cs.system.collections.IEnumerator"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.ArrayListAdapter.EnumeratorWithRange"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_ArrayListAdapter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1" final="1">
		<extends path="cs.system.collections.ArrayList"/>
		<IsSynchronized public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsSynchronized>
		<SyncRoot public="1" get="accessor" set="null" override="1"><d/></SyncRoot>
		<IsReadOnly public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsReadOnly>
		<IsFixedSize public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsFixedSize>
		<Capacity public="1" get="accessor" set="accessor" override="1"><x path="Int"/></Capacity>
		<Count public="1" get="accessor" set="null" override="1"><x path="Int"/></Count>
		<get_Item public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<get_Count public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_Count>
		<get_Capacity public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_Capacity>
		<set_Capacity public="1" set="method" override="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_Capacity>
		<get_IsFixedSize public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<get_IsReadOnly public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_SyncRoot public="1" set="method" override="1"><f a=""><d/></f></get_SyncRoot>
		<Add public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Int"/>
</f></Add>
		<Clear public="1" set="method" override="1"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></Contains>
		<IndexOf public="1" set="method" override="1">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<IndexOf public="1" set="method"><f a="value:startIndex:count">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="value:startIndex">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
			</overloads>
		</IndexOf>
		<LastIndexOf public="1" set="method" override="1">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<LastIndexOf public="1" set="method"><f a="value:startIndex:count">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="value:startIndex">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
			</overloads>
		</LastIndexOf>
		<Insert public="1" set="method" override="1"><f a="index:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></Insert>
		<InsertRange public="1" set="method" override="1"><f a="index:c">
	<x path="Int"/>
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></InsertRange>
		<Remove public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Void"/>
</f></Remove>
		<RemoveAt public="1" set="method" override="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveAt>
		<RemoveRange public="1" set="method" override="1"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveRange>
		<Reverse public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<overloads><Reverse public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Reverse></overloads>
		</Reverse>
		<SetRange public="1" set="method" override="1"><f a="index:c">
	<x path="Int"/>
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></SetRange>
		<CopyTo public="1" set="method" override="1">
			<f a="array">
				<c path="cs.system.Array"/>
				<x path="Void"/>
			</f>
			<overloads>
				<CopyTo public="1" set="method"><f a="index:array:arrayIndex:count">
	<x path="Int"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
				<CopyTo public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
			</overloads>
		</CopyTo>
		<get_IsSynchronized public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<GetEnumerator public="1" set="method" override="1">
			<f a=""><c path="cs.system.collections.IEnumerator"/></f>
			<overloads><GetEnumerator public="1" set="method"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IEnumerator"/>
</f></GetEnumerator></overloads>
		</GetEnumerator>
		<AddRange public="1" set="method" override="1"><f a="c">
	<c path="cs.system.collections.ICollection"/>
	<x path="Void"/>
</f></AddRange>
		<BinarySearch public="1" set="method" override="1">
			<f a="value">
				<d/>
				<x path="Int"/>
			</f>
			<overloads>
				<BinarySearch public="1" set="method"><f a="index:count:value:comparer">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Int"/>
</f></BinarySearch>
				<BinarySearch public="1" set="method"><f a="value:comparer">
	<d/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Int"/>
</f></BinarySearch>
			</overloads>
		</BinarySearch>
		<Clone public="1" set="method" override="1"><f a=""><d/></f></Clone>
		<GetRange public="1" set="method" override="1"><f a="index:count">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.ArrayList"/>
</f></GetRange>
		<TrimToSize public="1" set="method" override="1"><f a=""><x path="Void"/></f></TrimToSize>
		<Sort public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<overloads>
				<Sort public="1" set="method"><f a="index:count:comparer">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
				<Sort public="1" set="method"><f a="comparer">
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></Sort>
			</overloads>
		</Sort>
		<ToArray public="1" set="method" override="1">
			<f a=""><c path="cs.NativeArray"><d/></c></f>
			<overloads><ToArray public="1" set="method"><f a="elementType">
	<c path="cs.system.Type"/>
	<c path="cs.system.Array"/>
</f></ToArray></overloads>
		</ToArray>
		<new final="1" public="1" set="method"><f a="adaptee">
	<c path="cs.system.collections.IList"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.ArrayListAdapter"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_SimpleEnumerator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1" final="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.collections.IEnumerator"/>
		<Current public="1" get="accessor" set="null"><d/></Current>
		<Clone final="1" public="1" set="method"><f a=""><d/></f></Clone>
		<MoveNext final="1" public="1" set="method"><f a=""><x path="Bool"/></f></MoveNext>
		<get_Current final="1" public="1" set="method"><f a=""><d/></f></get_Current>
		<Reset final="1" public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<new final="1" public="1" set="method"><f a="list">
	<c path="cs.system.collections.ArrayList"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.SimpleEnumerator"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.ArrayList_ArrayListEnumerator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ArrayList" module="cs.system.collections.ArrayList" extern="1" final="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.collections.IEnumerator"/>
		<Current public="1" get="accessor" set="null"><d/></Current>
		<Clone final="1" public="1" set="method"><f a=""><d/></f></Clone>
		<get_Current final="1" public="1" set="method"><f a=""><d/></f></get_Current>
		<MoveNext final="1" public="1" set="method"><f a=""><x path="Bool"/></f></MoveNext>
		<Reset final="1" public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<new final="1" public="1" set="method">
			<f a="list">
				<c path="cs.system.collections.ArrayList"/>
				<x path="Void"/>
			</f>
			<overloads><new final="1" public="1" set="method"><f a="list:index:count">
	<c path="cs.system.collections.ArrayList"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ArrayList.ArrayListEnumerator"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.DictionaryEntry" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.DictionaryEntry" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<Value public="1" get="accessor" set="accessor"><d/></Value>
		<Key public="1" get="accessor" set="accessor"><d/></Key>
		<get_Key final="1" public="1" set="method"><f a=""><d/></f></get_Key>
		<set_Key final="1" public="1" set="method"><f a="value">
	<d/>
	<d/>
</f></set_Key>
		<get_Value final="1" public="1" set="method"><f a=""><d/></f></get_Value>
		<set_Value final="1" public="1" set="method"><f a="value">
	<d/>
	<d/>
</f></set_Value>
		<new final="1" public="1" set="method"><f a="key:value">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.DictionaryEntry"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.IDictionary" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.IDictionary" extern="1" interface="1">
		<extends path="cs.system.collections.ICollection"/>
		<extends path="cs.system.collections.IEnumerable"/>
		<extends path="ArrayAccess"><d/></extends>
		<Values public="1" get="accessor" set="null"><c path="cs.system.collections.ICollection"/></Values>
		<Keys public="1" get="accessor" set="null"><c path="cs.system.collections.ICollection"/></Keys>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<IsFixedSize public="1" get="accessor" set="null"><x path="Bool"/></IsFixedSize>
		<get_IsFixedSize public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<get_IsReadOnly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_Item public="1" set="method"><f a="key">
	<d/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method"><f a="key:value">
	<d/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<get_Keys public="1" set="method"><f a=""><c path="cs.system.collections.ICollection"/></f></get_Keys>
		<get_Values public="1" set="method"><f a=""><c path="cs.system.collections.ICollection"/></f></get_Values>
		<Add public="1" set="method"><f a="key:value">
	<d/>
	<d/>
	<x path="Void"/>
</f></Add>
		<Clear public="1" set="method"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method"><f a="key">
	<d/>
	<x path="Bool"/>
</f></Contains>
		<GetEnumerator public="1" set="method"><f a=""><c path="cs.system.collections.IDictionaryEnumerator"/></f></GetEnumerator>
		<Remove public="1" set="method"><f a="key">
	<d/>
	<x path="Void"/>
</f></Remove>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.IDictionary"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.serialization.IDeserializationCallback" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.serialization.IDeserializationCallback" extern="1" interface="1">
		<OnDeserialization public="1" set="method"><f a="sender">
	<d/>
	<x path="Void"/>
</f></OnDeserialization>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Serialization.IDeserializationCallback"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.Hashtable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.Hashtable" extern="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IDictionary"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<implements path="cs.system.runtime.serialization.IDeserializationCallback"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<Synchronized public="1" set="method" static="1"><f a="table">
	<c path="cs.system.collections.Hashtable"/>
	<c path="cs.system.collections.Hashtable"/>
</f></Synchronized>
		<Values public="1" get="accessor" set="null"><c path="cs.system.collections.ICollection"/></Values>
		<Keys public="1" get="accessor" set="null"><c path="cs.system.collections.ICollection"/></Keys>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<IsFixedSize public="1" get="accessor" set="null"><x path="Bool"/></IsFixedSize>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<EqualityComparer get="null" set="null"><c path="cs.system.collections.IEqualityComparer"/></EqualityComparer>
		<hcp get="null" set="null"><c path="cs.system.collections.IHashCodeProvider"/></hcp>
		<comparer get="null" set="null"><c path="cs.system.collections.IComparer"/></comparer>
		<set_comparer final="1" set="method">
			<f a="value">
				<c path="cs.system.collections.IComparer"/>
				<c path="cs.system.collections.IComparer"/>
			</f>
			<meta><m n=":protected"/></meta>
		</set_comparer>
		<get_comparer final="1" set="method">
			<f a=""><c path="cs.system.collections.IComparer"/></f>
			<meta><m n=":protected"/></meta>
		</get_comparer>
		<set_hcp final="1" set="method">
			<f a="value">
				<c path="cs.system.collections.IHashCodeProvider"/>
				<c path="cs.system.collections.IHashCodeProvider"/>
			</f>
			<meta><m n=":protected"/></meta>
		</set_hcp>
		<get_hcp final="1" set="method">
			<f a=""><c path="cs.system.collections.IHashCodeProvider"/></f>
			<meta><m n=":protected"/></meta>
		</get_hcp>
		<get_EqualityComparer final="1" set="method">
			<f a=""><c path="cs.system.collections.IEqualityComparer"/></f>
			<meta><m n=":protected"/></meta>
		</get_EqualityComparer>
		<get_Count public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_IsSynchronized public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_SyncRoot public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<get_IsFixedSize public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<get_IsReadOnly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_Keys public="1" set="method"><f a=""><c path="cs.system.collections.ICollection"/></f></get_Keys>
		<get_Values public="1" set="method"><f a=""><c path="cs.system.collections.ICollection"/></f></get_Values>
		<get_Item public="1" set="method"><f a="key">
	<d/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method"><f a="key:value">
	<d/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<CopyTo public="1" set="method"><f a="array:arrayIndex">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<Add public="1" set="method"><f a="key:value">
	<d/>
	<d/>
	<x path="Void"/>
</f></Add>
		<Clear public="1" set="method"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method"><f a="key">
	<d/>
	<x path="Bool"/>
</f></Contains>
		<GetEnumerator public="1" set="method">
			<f a=""><c path="cs.system.collections.IDictionaryEnumerator"/></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</GetEnumerator>
		<Remove public="1" set="method"><f a="key">
	<d/>
	<x path="Void"/>
</f></Remove>
		<ContainsKey public="1" set="method"><f a="key">
	<d/>
	<x path="Bool"/>
</f></ContainsKey>
		<ContainsValue public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></ContainsValue>
		<Clone public="1" set="method"><f a=""><d/></f></Clone>
		<GetObjectData public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<OnDeserialization public="1" set="method"><f a="sender">
	<d/>
	<x path="Void"/>
</f></OnDeserialization>
		<GetHash set="method">
			<f a="key">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetHash>
		<KeyEquals set="method">
			<f a="item:key">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</KeyEquals>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="capacity:loadFactor:equalityComparer">
	<x path="Int"/>
	<x path="Single"/>
	<c path="cs.system.collections.IEqualityComparer"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="capacity:equalityComparer">
	<x path="Int"/>
	<c path="cs.system.collections.IEqualityComparer"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="equalityComparer">
	<c path="cs.system.collections.IEqualityComparer"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="d:loadFactor:equalityComparer">
	<c path="cs.system.collections.IDictionary"/>
	<x path="Single"/>
	<c path="cs.system.collections.IEqualityComparer"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="d:equalityComparer">
	<c path="cs.system.collections.IDictionary"/>
	<c path="cs.system.collections.IEqualityComparer"/>
	<x path="Void"/>
</f></new>
				<new final="1" set="method">
					<f a="info:context">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" public="1" set="method"><f a="hcp:comparer">
	<c path="cs.system.collections.IHashCodeProvider"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="d:hcp:comparer">
	<c path="cs.system.collections.IDictionary"/>
	<c path="cs.system.collections.IHashCodeProvider"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="d">
	<c path="cs.system.collections.IDictionary"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="d:loadFactor">
	<c path="cs.system.collections.IDictionary"/>
	<x path="Single"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="d:loadFactor:hcp:comparer">
	<c path="cs.system.collections.IDictionary"/>
	<x path="Single"/>
	<c path="cs.system.collections.IHashCodeProvider"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="capacity:hcp:comparer">
	<x path="Int"/>
	<c path="cs.system.collections.IHashCodeProvider"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="capacity">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="capacity:loadFactor">
	<x path="Int"/>
	<x path="Single"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="capacity:loadFactor:hcp:comparer">
	<x path="Int"/>
	<x path="Single"/>
	<c path="cs.system.collections.IHashCodeProvider"/>
	<c path="cs.system.collections.IComparer"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Hashtable"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.Hashtable_SyncHashtable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.Hashtable" module="cs.system.collections.Hashtable" extern="1">
		<extends path="cs.system.collections.Hashtable"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<Values public="1" get="accessor" set="null" override="1"><c path="cs.system.collections.ICollection"/></Values>
		<Keys public="1" get="accessor" set="null" override="1"><c path="cs.system.collections.ICollection"/></Keys>
		<IsReadOnly public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsReadOnly>
		<IsFixedSize public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsFixedSize>
		<SyncRoot public="1" get="accessor" set="null" override="1"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsSynchronized>
		<Count public="1" get="accessor" set="null" override="1"><x path="Int"/></Count>
		<GetObjectData public="1" set="method" override="1"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<get_Count public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_Count>
		<get_IsSynchronized public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_SyncRoot public="1" set="method" override="1"><f a=""><d/></f></get_SyncRoot>
		<get_IsFixedSize public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsFixedSize>
		<get_IsReadOnly public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_Keys public="1" set="method" override="1"><f a=""><c path="cs.system.collections.ICollection"/></f></get_Keys>
		<get_Values public="1" set="method" override="1"><f a=""><c path="cs.system.collections.ICollection"/></f></get_Values>
		<get_Item public="1" set="method" override="1"><f a="key">
	<d/>
	<d/>
</f></get_Item>
		<set_Item public="1" set="method" override="1"><f a="key:value">
	<d/>
	<d/>
	<x path="Void"/>
</f></set_Item>
		<CopyTo public="1" set="method" override="1"><f a="array:arrayIndex">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<Add public="1" set="method" override="1"><f a="key:value">
	<d/>
	<d/>
	<x path="Void"/>
</f></Add>
		<Clear public="1" set="method" override="1"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method" override="1"><f a="key">
	<d/>
	<x path="Bool"/>
</f></Contains>
		<GetEnumerator public="1" set="method" override="1">
			<f a=""><c path="cs.system.collections.IDictionaryEnumerator"/></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</GetEnumerator>
		<Remove public="1" set="method" override="1"><f a="key">
	<d/>
	<x path="Void"/>
</f></Remove>
		<ContainsKey public="1" set="method" override="1"><f a="key">
	<d/>
	<x path="Bool"/>
</f></ContainsKey>
		<ContainsValue public="1" set="method" override="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></ContainsValue>
		<Clone public="1" set="method" override="1"><f a=""><d/></f></Clone>
		<new final="1" public="1" set="method"><f a="host">
	<c path="cs.system.collections.Hashtable"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Hashtable.SyncHashtable"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.Hashtable_HashValues" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.Hashtable" module="cs.system.collections.Hashtable" extern="1">
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<get_Count public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_IsSynchronized public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_SyncRoot public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<CopyTo public="1" set="method"><f a="array:arrayIndex">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<GetEnumerator public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<new final="1" public="1" set="method"><f a="host">
	<c path="cs.system.collections.Hashtable"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Hashtable.HashValues"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.Hashtable_HashKeys" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.Hashtable" module="cs.system.collections.Hashtable" extern="1">
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<get_Count public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_IsSynchronized public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_SyncRoot public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<CopyTo public="1" set="method"><f a="array:arrayIndex">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<GetEnumerator public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<new final="1" public="1" set="method"><f a="host">
	<c path="cs.system.collections.Hashtable"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Hashtable.HashKeys"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.IDictionaryEnumerator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.IDictionaryEnumerator" extern="1" interface="1">
		<extends path="cs.system.collections.IEnumerator"/>
		<Value public="1" get="accessor" set="null"><d/></Value>
		<Key public="1" get="accessor" set="null"><d/></Key>
		<Entry public="1" get="accessor" set="null"><c path="cs.system.collections.DictionaryEntry"/></Entry>
		<get_Entry public="1" set="method"><f a=""><c path="cs.system.collections.DictionaryEntry"/></f></get_Entry>
		<get_Key public="1" set="method"><f a=""><d/></f></get_Key>
		<get_Value public="1" set="method"><f a=""><d/></f></get_Value>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.IDictionaryEnumerator"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.Hashtable_Enumerator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.Hashtable" module="cs.system.collections.Hashtable" extern="1" final="1">
		<implements path="cs.system.collections.IDictionaryEnumerator"/>
		<implements path="cs.system.collections.IEnumerator"/>
		<Current public="1" get="accessor" set="null"><d/></Current>
		<Value public="1" get="accessor" set="null"><d/></Value>
		<Key public="1" get="accessor" set="null"><d/></Key>
		<Entry public="1" get="accessor" set="null"><c path="cs.system.collections.DictionaryEntry"/></Entry>
		<Reset final="1" public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<MoveNext final="1" public="1" set="method"><f a=""><x path="Bool"/></f></MoveNext>
		<get_Entry final="1" public="1" set="method"><f a=""><c path="cs.system.collections.DictionaryEntry"/></f></get_Entry>
		<get_Key final="1" public="1" set="method"><f a=""><d/></f></get_Key>
		<get_Value final="1" public="1" set="method"><f a=""><d/></f></get_Value>
		<get_Current final="1" public="1" set="method"><f a=""><d/></f></get_Current>
		<new final="1" public="1" set="method">
			<f a="host:mode">
				<c path="cs.system.collections.Hashtable"/>
				<e path="cs.system.collections.Hashtable_EnumeratorMode"/>
				<x path="Void"/>
			</f>
			<overloads><new final="1" public="1" set="method"><f a="host">
	<c path="cs.system.collections.Hashtable"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Hashtable.Enumerator"</e></m>
		</meta>
	</class>
	<enum path="cs.system.collections.Hashtable_EnumeratorMode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.Hashtable" module="cs.system.collections.Hashtable">
		<KEY_MODE><meta><m n=":csNative"><e>0</e></m></meta></KEY_MODE>
		<VALUE_MODE><meta><m n=":csNative"><e>1</e></m></meta></VALUE_MODE>
		<ENTRY_MODE><meta><m n=":csNative"><e>2</e></m></meta></ENTRY_MODE>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Collections.Hashtable.EnumeratorMode"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.runtime.serialization.IObjectReference" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.serialization.IObjectReference" extern="1" interface="1">
		<GetRealObject public="1" set="method"><f a="context">
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<d/>
</f></GetRealObject>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Serialization.IObjectReference"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.Hashtable_KeyMarker" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.Hashtable" module="cs.system.collections.Hashtable" extern="1">
		<implements path="cs.system.runtime.serialization.IObjectReference"/>
		<Removed public="1" set="null" static="1">
			<c path="cs.system.collections.Hashtable_KeyMarker"/>
			<meta><m n=":readOnly"/></meta>
		</Removed>
		<GetRealObject final="1" public="1" set="method"><f a="context">
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<d/>
</f></GetRealObject>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Hashtable.KeyMarker"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.Hashtable_Slot" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.Hashtable" module="cs.system.collections.Hashtable" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Hashtable.Slot"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.IComparer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.IComparer" extern="1" interface="1">
		<Compare public="1" set="method"><f a="x:y">
	<d/>
	<d/>
	<x path="Int"/>
</f></Compare>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.IComparer"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.IEqualityComparer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.IEqualityComparer" extern="1" interface="1"><meta>
	<m n=":nativeGen"/>
	<m n=":abstract"/>
	<m n=":libType"/>
	<m n=":csNative"/>
	<m n=":native"><e>"System.Collections.IEqualityComparer"</e></m>
</meta></class>
	<class path="cs.system.collections.IHashCodeProvider" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.IHashCodeProvider" extern="1" interface="1"><meta>
	<m n=":nativeGen"/>
	<m n=":abstract"/>
	<m n=":libType"/>
	<m n=":csNative"/>
	<m n=":native"><e>"System.Collections.IHashCodeProvider"</e></m>
</meta></class>
	<class path="cs.system.collections.ReadOnlyCollectionBase" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.ReadOnlyCollectionBase" extern="1" abstract="1">
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<InnerList get="null" set="null"><c path="cs.system.collections.ArrayList"/></InnerList>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<get_Count public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<GetEnumerator public="1" set="method">
			<f a=""><c path="cs.system.collections.IEnumerator"/></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</GetEnumerator>
		<get_InnerList final="1" set="method">
			<f a=""><c path="cs.system.collections.ArrayList"/></f>
			<meta><m n=":protected"/></meta>
		</get_InnerList>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ReadOnlyCollectionBase"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.generic.ICollection_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.generic.ICollection_1" extern="1" interface="1">
		<extends path="cs.system.collections.generic.IEnumerable_1"><c path="cs.system.collections.generic.ICollection_1.T0"/></extends>
		<extends path="cs.system.collections.IEnumerable"/>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<get_Count public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_IsReadOnly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<Add public="1" set="method"><f a="item">
	<c path="cs.system.collections.generic.ICollection_1.T0"/>
	<x path="Void"/>
</f></Add>
		<Clear public="1" set="method"><f a=""><x path="Void"/></f></Clear>
		<Contains public="1" set="method"><f a="item">
	<c path="cs.system.collections.generic.ICollection_1.T0"/>
	<x path="Bool"/>
</f></Contains>
		<CopyTo public="1" set="method"><f a="array:arrayIndex">
	<c path="cs.NativeArray"><c path="cs.system.collections.generic.ICollection_1.T0"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<Remove public="1" set="method"><f a="item">
	<c path="cs.system.collections.generic.ICollection_1.T0"/>
	<x path="Bool"/>
</f></Remove>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Generic.ICollection`1"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.generic.IComparer_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.generic.IComparer_1" extern="1" interface="1">
		<Compare public="1" set="method"><f a="x:y">
	<c path="cs.system.collections.generic.IComparer_1.T0"/>
	<c path="cs.system.collections.generic.IComparer_1.T0"/>
	<x path="Int"/>
</f></Compare>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Generic.IComparer`1"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.generic.IList_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.generic.IList_1" extern="1" interface="1">
		<extends path="cs.system.collections.generic.ICollection_1"><c path="cs.system.collections.generic.IList_1.T0"/></extends>
		<extends path="cs.system.collections.generic.IEnumerable_1"><c path="cs.system.collections.generic.IList_1.T0"/></extends>
		<extends path="cs.system.collections.IEnumerable"/>
		<extends path="ArrayAccess"><c path="cs.system.collections.generic.IList_1.T0"/></extends>
		<IndexOf public="1" set="method"><f a="item">
	<c path="cs.system.collections.generic.IList_1.T0"/>
	<x path="Int"/>
</f></IndexOf>
		<Insert public="1" set="method"><f a="index:item">
	<x path="Int"/>
	<c path="cs.system.collections.generic.IList_1.T0"/>
	<x path="Void"/>
</f></Insert>
		<RemoveAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveAt>
		<get_Item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="cs.system.collections.generic.IList_1.T0"/>
</f></get_Item>
		<set_Item public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<c path="cs.system.collections.generic.IList_1.T0"/>
	<x path="Void"/>
</f></set_Item>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Generic.IList`1"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.objectmodel.ReadOnlyCollection_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.collections.objectmodel.ReadOnlyCollection_1" extern="1">
		<implements path="cs.system.collections.generic.ICollection_1"><c path="cs.system.collections.objectmodel.ReadOnlyCollection_1.T0"/></implements>
		<implements path="cs.system.collections.generic.IList_1"><c path="cs.system.collections.objectmodel.ReadOnlyCollection_1.T0"/></implements>
		<implements path="cs.system.collections.generic.IEnumerable_1"><c path="cs.system.collections.objectmodel.ReadOnlyCollection_1.T0"/></implements>
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<implements path="cs.system.collections.IList"/>
		<Items get="null" set="null"><c path="cs.system.collections.generic.IList_1"><c path="cs.system.collections.objectmodel.ReadOnlyCollection_1.T0"/></c></Items>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<Contains final="1" public="1" set="method">
			<f a="value">
				<c path="cs.system.collections.objectmodel.ReadOnlyCollection_1.T0"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</Contains>
		<CopyTo final="1" public="1" set="method">
			<f a="array:index">
				<c path="cs.NativeArray"><c path="cs.system.collections.objectmodel.ReadOnlyCollection_1.T0"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</CopyTo>
		<GetEnumerator final="1" public="1" set="method">
			<f a=""><c path="cs.system.collections.generic.IEnumerator_1"><c path="cs.system.collections.objectmodel.ReadOnlyCollection_1.T0"/></c></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</GetEnumerator>
		<IndexOf final="1" public="1" set="method">
			<f a="value">
				<c path="cs.system.collections.objectmodel.ReadOnlyCollection_1.T0"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</IndexOf>
		<get_Count final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_Items final="1" set="method">
			<f a=""><c path="cs.system.collections.generic.IList_1"><c path="cs.system.collections.objectmodel.ReadOnlyCollection_1.T0"/></c></f>
			<meta><m n=":protected"/></meta>
		</get_Items>
		<get_Item final="1" public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="cs.system.collections.objectmodel.ReadOnlyCollection_1.T0"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</get_Item>
		<new final="1" public="1" set="method"><f a="list">
	<c path="cs.system.collections.generic.IList_1"><c path="cs.system.collections.objectmodel.ReadOnlyCollection_1.T0"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.ObjectModel.ReadOnlyCollection`1"</e></m>
		</meta>
	</class>
	<class path="cs.system.collections.specialized.StringDictionary" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.collections.specialized.StringDictionary" extern="1">
		<implements path="cs.system.collections.IEnumerable"/>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<Values public="1" get="accessor" set="null"><c path="cs.system.collections.ICollection"/></Values>
		<Keys public="1" get="accessor" set="null"><c path="cs.system.collections.ICollection"/></Keys>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<get_Count public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_IsSynchronized public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_Item public="1" set="method"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></get_Item>
		<set_Item public="1" set="method"><f a="key:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></set_Item>
		<get_Keys public="1" set="method"><f a=""><c path="cs.system.collections.ICollection"/></f></get_Keys>
		<get_Values public="1" set="method"><f a=""><c path="cs.system.collections.ICollection"/></f></get_Values>
		<get_SyncRoot public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<Add public="1" set="method"><f a="key:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></Add>
		<Clear public="1" set="method"><f a=""><x path="Void"/></f></Clear>
		<ContainsKey public="1" set="method"><f a="key">
	<c path="String"/>
	<x path="Bool"/>
</f></ContainsKey>
		<ContainsValue public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Bool"/>
</f></ContainsValue>
		<CopyTo public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<GetEnumerator public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<Remove public="1" set="method"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></Remove>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Collections.Specialized.StringDictionary"</e></m>
		</meta>
	</class>
	<class path="cs.system.componentmodel.IComponent" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.componentmodel.IComponent" extern="1" interface="1">
		<extends path="cs.system.IDisposable"/>
		<Disposed>
			<x path="cs.system.EventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</Disposed>
		<Site public="1" get="accessor" set="accessor"><c path="cs.system.componentmodel.ISite"/></Site>
		<add_Disposed public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></add_Disposed>
		<remove_Disposed public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></remove_Disposed>
		<get_Site public="1" set="method"><f a=""><c path="cs.system.componentmodel.ISite"/></f></get_Site>
		<set_Site public="1" set="method"><f a="value">
	<c path="cs.system.componentmodel.ISite"/>
	<c path="cs.system.componentmodel.ISite"/>
</f></set_Site>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ComponentModel.IComponent"</e></m>
		</meta>
	</class>
	<class path="cs.system.componentmodel.Component" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.componentmodel.Component" extern="1">
		<extends path="cs.system.MarshalByRefObject"/>
		<implements path="cs.system.IDisposable"/>
		<implements path="cs.system.componentmodel.IComponent"/>
		<Disposed>
			<x path="cs.system.EventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</Disposed>
		<Events get="null" set="null"><c path="cs.system.componentmodel.EventHandlerList"/></Events>
		<DesignMode get="null" set="null"><x path="Bool"/></DesignMode>
		<Container public="1" get="accessor" set="null"><c path="cs.system.componentmodel.IContainer"/></Container>
		<Site public="1" get="accessor" set="accessor"><c path="cs.system.componentmodel.ISite"/></Site>
		<CanRaiseEvents get="null" set="null"><x path="Bool"/></CanRaiseEvents>
		<add_Disposed final="1" public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></add_Disposed>
		<remove_Disposed final="1" public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></remove_Disposed>
		<get_CanRaiseEvents set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</get_CanRaiseEvents>
		<get_Site public="1" set="method"><f a=""><c path="cs.system.componentmodel.ISite"/></f></get_Site>
		<set_Site public="1" set="method"><f a="value">
	<c path="cs.system.componentmodel.ISite"/>
	<c path="cs.system.componentmodel.ISite"/>
</f></set_Site>
		<get_Container final="1" public="1" set="method"><f a=""><c path="cs.system.componentmodel.IContainer"/></f></get_Container>
		<get_DesignMode final="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</get_DesignMode>
		<get_Events final="1" set="method">
			<f a=""><c path="cs.system.componentmodel.EventHandlerList"/></f>
			<meta><m n=":protected"/></meta>
		</get_Events>
		<Dispose final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><Dispose set="method">
	<f a="release_all">
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":protected"/></meta>
</Dispose></overloads>
		</Dispose>
		<GetService set="method">
			<f a="service">
				<c path="cs.system.Type"/>
				<d/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetService>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ComponentModel.Component"</e></m>
		</meta>
	</class>
	<class path="cs.system.componentmodel.ComponentCollection" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.componentmodel.ComponentCollection" extern="1">
		<extends path="cs.system.collections.ReadOnlyCollectionBase"/>
		<get_Item public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="cs.system.componentmodel.IComponent"/>
			</f>
			<overloads><get_Item public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.componentmodel.IComponent"/>
</f></get_Item></overloads>
		</get_Item>
		<CopyTo final="1" public="1" set="method"><f a="array:index">
	<c path="cs.NativeArray"><c path="cs.system.componentmodel.IComponent"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<new final="1" public="1" set="method"><f a="components">
	<c path="cs.NativeArray"><c path="cs.system.componentmodel.IComponent"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ComponentModel.ComponentCollection"</e></m>
		</meta>
	</class>
	<class path="cs.system.componentmodel.EventHandlerList" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.componentmodel.EventHandlerList" extern="1" final="1">
		<implements path="cs.system.IDisposable"/>
		<get_Item final="1" public="1" set="method"><f a="key">
	<d/>
	<c path="cs.system.Delegate"/>
</f></get_Item>
		<set_Item final="1" public="1" set="method"><f a="key:value">
	<d/>
	<c path="cs.system.Delegate"/>
	<x path="Void"/>
</f></set_Item>
		<AddHandler final="1" public="1" set="method"><f a="key:value">
	<d/>
	<c path="cs.system.Delegate"/>
	<x path="Void"/>
</f></AddHandler>
		<AddHandlers final="1" public="1" set="method"><f a="listToAddFrom">
	<c path="cs.system.componentmodel.EventHandlerList"/>
	<x path="Void"/>
</f></AddHandlers>
		<RemoveHandler final="1" public="1" set="method"><f a="key:value">
	<d/>
	<c path="cs.system.Delegate"/>
	<x path="Void"/>
</f></RemoveHandler>
		<Dispose final="1" public="1" set="method"><f a=""><x path="Void"/></f></Dispose>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ComponentModel.EventHandlerList"</e></m>
		</meta>
	</class>
	<class path="cs.system.componentmodel.IContainer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.componentmodel.IContainer" extern="1" interface="1">
		<extends path="cs.system.IDisposable"/>
		<Components public="1" get="accessor" set="null"><c path="cs.system.componentmodel.ComponentCollection"/></Components>
		<get_Components public="1" set="method"><f a=""><c path="cs.system.componentmodel.ComponentCollection"/></f></get_Components>
		<Add public="1" set="method">
			<f a="component">
				<c path="cs.system.componentmodel.IComponent"/>
				<x path="Void"/>
			</f>
			<overloads><Add public="1" set="method"><f a="component:name">
	<c path="cs.system.componentmodel.IComponent"/>
	<c path="String"/>
	<x path="Void"/>
</f></Add></overloads>
		</Add>
		<Remove public="1" set="method"><f a="component">
	<c path="cs.system.componentmodel.IComponent"/>
	<x path="Void"/>
</f></Remove>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ComponentModel.IContainer"</e></m>
		</meta>
	</class>
	<class path="cs.system.componentmodel.ISite" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.componentmodel.ISite" extern="1" interface="1">
		<extends path="cs.system.IServiceProvider"/>
		<Name public="1" get="accessor" set="accessor"><c path="String"/></Name>
		<DesignMode public="1" get="accessor" set="null"><x path="Bool"/></DesignMode>
		<Container public="1" get="accessor" set="null"><c path="cs.system.componentmodel.IContainer"/></Container>
		<Component public="1" get="accessor" set="null"><c path="cs.system.componentmodel.IComponent"/></Component>
		<get_Component public="1" set="method"><f a=""><c path="cs.system.componentmodel.IComponent"/></f></get_Component>
		<get_Container public="1" set="method"><f a=""><c path="cs.system.componentmodel.IContainer"/></f></get_Container>
		<get_DesignMode public="1" set="method"><f a=""><x path="Bool"/></f></get_DesignMode>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<set_Name public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Name>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ComponentModel.ISite"</e></m>
		</meta>
	</class>
	<class path="cs.system.componentmodel.ISynchronizeInvoke" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.componentmodel.ISynchronizeInvoke" extern="1" interface="1">
		<InvokeRequired public="1" get="accessor" set="null"><x path="Bool"/></InvokeRequired>
		<get_InvokeRequired public="1" set="method"><f a=""><x path="Bool"/></f></get_InvokeRequired>
		<BeginInvoke public="1" set="method"><f a="method:args">
	<c path="cs.system.Delegate"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<d/>
</f></EndInvoke>
		<Invoke public="1" set="method"><f a="method:args">
	<c path="cs.system.Delegate"/>
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.ComponentModel.ISynchronizeInvoke"</e></m>
		</meta>
	</class>
	<enum path="cs.system.configuration.assemblies.AssemblyHashAlgorithm" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.configuration.assemblies.AssemblyHashAlgorithm">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<MD5><meta><m n=":csNative"><e>32771</e></m></meta></MD5>
		<SHA1><meta><m n=":csNative"><e>32772</e></m></meta></SHA1>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Configuration.Assemblies.AssemblyHashAlgorithm"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.configuration.assemblies.AssemblyVersionCompatibility" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.configuration.assemblies.AssemblyVersionCompatibility">
		<SameMachine><meta><m n=":csNative"><e>1</e></m></meta></SameMachine>
		<SameProcess><meta><m n=":csNative"><e>2</e></m></meta></SameProcess>
		<SameDomain><meta><m n=":csNative"><e>3</e></m></meta></SameDomain>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Configuration.Assemblies.AssemblyVersionCompatibility"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.diagnostics.DataReceivedEventArgs" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.DataReceivedEventArgs" extern="1">
		<extends path="cs.system.EventArgs"/>
		<Data public="1" get="accessor" set="null"><c path="String"/></Data>
		<get_Data final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Data>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.DataReceivedEventArgs"</e></m>
		</meta>
	</class>
	<class path="cs.system.diagnostics.Delegate_DataReceivedEventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.DataReceivedEventHandler" module="cs.system.diagnostics.DataReceivedEventHandler" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
	<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
	<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
	<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
	<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="sender:e">
	<d/>
	<c path="cs.system.diagnostics.DataReceivedEventArgs"/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="sender:e:callback:object">
	<d/>
	<c path="cs.system.diagnostics.DataReceivedEventArgs"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.DataReceivedEventHandler"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.diagnostics.DataReceivedEventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.DataReceivedEventHandler">
		<from><icast field="FromHaxeFunction"><f a=":">
	<d/>
	<c path="cs.system.diagnostics.DataReceivedEventArgs"/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.diagnostics.Delegate_DataReceivedEventHandler"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.diagnostics._DataReceivedEventHandler.DataReceivedEventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.DataReceivedEventHandler" private="1" module="cs.system.diagnostics.DataReceivedEventHandler" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.diagnostics.DataReceivedEventArgs"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.diagnostics.DataReceivedEventArgs"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.diagnostics.Delegate_DataReceivedEventHandler"/>
	<c path="cs.system.diagnostics.Delegate_DataReceivedEventHandler"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
			<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
			<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
			<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
			<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.diagnostics._DataReceivedEventHandler.DataReceivedEventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.DataReceivedEventHandler" private="1" module="cs.system.diagnostics.DataReceivedEventHandler" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.diagnostics.DataReceivedEventArgs"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.diagnostics.DataReceivedEventArgs"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.diagnostics.Delegate_DataReceivedEventHandler"/>
	<c path="cs.system.diagnostics.Delegate_DataReceivedEventHandler"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
				<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
				<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
				<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
				<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.diagnostics.FileVersionInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.FileVersionInfo" extern="1" final="1">
		<GetVersionInfo public="1" set="method" static="1"><f a="fileName">
	<c path="String"/>
	<c path="cs.system.diagnostics.FileVersionInfo"/>
</f></GetVersionInfo>
		<SpecialBuild public="1" get="accessor" set="null"><c path="String"/></SpecialBuild>
		<ProductVersion public="1" get="accessor" set="null"><c path="String"/></ProductVersion>
		<ProductPrivatePart public="1" get="accessor" set="null"><x path="Int"/></ProductPrivatePart>
		<ProductName public="1" get="accessor" set="null"><c path="String"/></ProductName>
		<ProductMinorPart public="1" get="accessor" set="null"><x path="Int"/></ProductMinorPart>
		<ProductMajorPart public="1" get="accessor" set="null"><x path="Int"/></ProductMajorPart>
		<ProductBuildPart public="1" get="accessor" set="null"><x path="Int"/></ProductBuildPart>
		<PrivateBuild public="1" get="accessor" set="null"><c path="String"/></PrivateBuild>
		<OriginalFilename public="1" get="accessor" set="null"><c path="String"/></OriginalFilename>
		<LegalTrademarks public="1" get="accessor" set="null"><c path="String"/></LegalTrademarks>
		<LegalCopyright public="1" get="accessor" set="null"><c path="String"/></LegalCopyright>
		<Language public="1" get="accessor" set="null"><c path="String"/></Language>
		<IsSpecialBuild public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialBuild>
		<IsPrivateBuild public="1" get="accessor" set="null"><x path="Bool"/></IsPrivateBuild>
		<IsPreRelease public="1" get="accessor" set="null"><x path="Bool"/></IsPreRelease>
		<IsPatched public="1" get="accessor" set="null"><x path="Bool"/></IsPatched>
		<IsDebug public="1" get="accessor" set="null"><x path="Bool"/></IsDebug>
		<InternalName public="1" get="accessor" set="null"><c path="String"/></InternalName>
		<FileVersion public="1" get="accessor" set="null"><c path="String"/></FileVersion>
		<FilePrivatePart public="1" get="accessor" set="null"><x path="Int"/></FilePrivatePart>
		<FileName public="1" get="accessor" set="null"><c path="String"/></FileName>
		<FileMinorPart public="1" get="accessor" set="null"><x path="Int"/></FileMinorPart>
		<FileMajorPart public="1" get="accessor" set="null"><x path="Int"/></FileMajorPart>
		<FileDescription public="1" get="accessor" set="null"><c path="String"/></FileDescription>
		<FileBuildPart public="1" get="accessor" set="null"><x path="Int"/></FileBuildPart>
		<CompanyName public="1" get="accessor" set="null"><c path="String"/></CompanyName>
		<Comments public="1" get="accessor" set="null"><c path="String"/></Comments>
		<get_Comments final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Comments>
		<get_CompanyName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_CompanyName>
		<get_FileBuildPart final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_FileBuildPart>
		<get_FileDescription final="1" public="1" set="method"><f a=""><c path="String"/></f></get_FileDescription>
		<get_FileMajorPart final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_FileMajorPart>
		<get_FileMinorPart final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_FileMinorPart>
		<get_FileName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_FileName>
		<get_FilePrivatePart final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_FilePrivatePart>
		<get_FileVersion final="1" public="1" set="method"><f a=""><c path="String"/></f></get_FileVersion>
		<get_InternalName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_InternalName>
		<get_IsDebug final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsDebug>
		<get_IsPatched final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPatched>
		<get_IsPreRelease final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPreRelease>
		<get_IsPrivateBuild final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPrivateBuild>
		<get_IsSpecialBuild final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialBuild>
		<get_Language final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Language>
		<get_LegalCopyright final="1" public="1" set="method"><f a=""><c path="String"/></f></get_LegalCopyright>
		<get_LegalTrademarks final="1" public="1" set="method"><f a=""><c path="String"/></f></get_LegalTrademarks>
		<get_OriginalFilename final="1" public="1" set="method"><f a=""><c path="String"/></f></get_OriginalFilename>
		<get_PrivateBuild final="1" public="1" set="method"><f a=""><c path="String"/></f></get_PrivateBuild>
		<get_ProductBuildPart final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_ProductBuildPart>
		<get_ProductMajorPart final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_ProductMajorPart>
		<get_ProductMinorPart final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_ProductMinorPart>
		<get_ProductName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ProductName>
		<get_ProductPrivatePart final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_ProductPrivatePart>
		<get_ProductVersion final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ProductVersion>
		<get_SpecialBuild final="1" public="1" set="method"><f a=""><c path="String"/></f></get_SpecialBuild>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.FileVersionInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.threading.WaitHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.WaitHandle" extern="1" abstract="1">
		<extends path="cs.system.MarshalByRefObject"/>
		<implements path="cs.system.IDisposable"/>
		<InvalidHandle set="null" static="1">
			<c path="cs.system.IntPtr"/>
			<meta><m n=":readOnly"/></meta>
		</InvalidHandle>
		<WaitTimeout public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":readOnly"/></meta>
		</WaitTimeout>
		<WaitAll public="1" set="method" static="1">
			<f a="waitHandles">
				<c path="cs.NativeArray"><c path="cs.system.threading.WaitHandle"/></c>
				<x path="Bool"/>
			</f>
			<overloads>
				<WaitAll public="1" set="method"><f a="waitHandles:timeout">
	<c path="cs.NativeArray"><c path="cs.system.threading.WaitHandle"/></c>
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
</f></WaitAll>
				<WaitAll public="1" set="method"><f a="waitHandles:millisecondsTimeout">
	<c path="cs.NativeArray"><c path="cs.system.threading.WaitHandle"/></c>
	<x path="Int"/>
	<x path="Bool"/>
</f></WaitAll>
				<WaitAll public="1" set="method"><f a="waitHandles:timeout:exitContext">
	<c path="cs.NativeArray"><c path="cs.system.threading.WaitHandle"/></c>
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></WaitAll>
				<WaitAll public="1" set="method"><f a="waitHandles:millisecondsTimeout:exitContext">
	<c path="cs.NativeArray"><c path="cs.system.threading.WaitHandle"/></c>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></WaitAll>
			</overloads>
		</WaitAll>
		<WaitAny public="1" set="method" static="1">
			<f a="waitHandles">
				<c path="cs.NativeArray"><c path="cs.system.threading.WaitHandle"/></c>
				<x path="Int"/>
			</f>
			<overloads>
				<WaitAny public="1" set="method"><f a="waitHandles:timeout:exitContext">
	<c path="cs.NativeArray"><c path="cs.system.threading.WaitHandle"/></c>
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></WaitAny>
				<WaitAny public="1" set="method"><f a="waitHandles:millisecondsTimeout">
	<c path="cs.NativeArray"><c path="cs.system.threading.WaitHandle"/></c>
	<x path="Int"/>
	<x path="Int"/>
</f></WaitAny>
				<WaitAny public="1" set="method"><f a="waitHandles:timeout">
	<c path="cs.NativeArray"><c path="cs.system.threading.WaitHandle"/></c>
	<c path="cs.system.TimeSpan"/>
	<x path="Int"/>
</f></WaitAny>
				<WaitAny public="1" set="method"><f a="waitHandles:millisecondsTimeout:exitContext">
	<c path="cs.NativeArray"><c path="cs.system.threading.WaitHandle"/></c>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></WaitAny>
			</overloads>
		</WaitAny>
		<SignalAndWait public="1" set="method" static="1">
			<f a="toSignal:toWaitOn">
				<c path="cs.system.threading.WaitHandle"/>
				<c path="cs.system.threading.WaitHandle"/>
				<x path="Bool"/>
			</f>
			<overloads>
				<SignalAndWait public="1" set="method"><f a="toSignal:toWaitOn:timeout:exitContext">
	<c path="cs.system.threading.WaitHandle"/>
	<c path="cs.system.threading.WaitHandle"/>
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></SignalAndWait>
				<SignalAndWait public="1" set="method"><f a="toSignal:toWaitOn:millisecondsTimeout:exitContext">
	<c path="cs.system.threading.WaitHandle"/>
	<c path="cs.system.threading.WaitHandle"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></SignalAndWait>
			</overloads>
		</SignalAndWait>
		<SafeWaitHandle public="1" get="accessor" set="accessor"><c path="microsoft.win32.safehandles.SafeWaitHandle"/></SafeWaitHandle>
		<Handle public="1" get="accessor" set="accessor"><c path="cs.system.IntPtr"/></Handle>
		<Close public="1" set="method"><f a=""><x path="Void"/></f></Close>
		<get_Handle public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_Handle>
		<set_Handle public="1" set="method"><f a="value">
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
</f></set_Handle>
		<Dispose set="method">
			<f a="explicitDisposing">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
				<m n=":protected"/>
			</meta>
		</Dispose>
		<get_SafeWaitHandle final="1" public="1" set="method"><f a=""><c path="microsoft.win32.safehandles.SafeWaitHandle"/></f></get_SafeWaitHandle>
		<set_SafeWaitHandle final="1" public="1" set="method"><f a="value">
	<c path="microsoft.win32.safehandles.SafeWaitHandle"/>
	<c path="microsoft.win32.safehandles.SafeWaitHandle"/>
</f></set_SafeWaitHandle>
		<WaitOne public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<overloads>
				<WaitOne public="1" set="method"><f a="timeout:exitContext">
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></WaitOne>
				<WaitOne public="1" set="method"><f a="timeout">
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
</f></WaitOne>
				<WaitOne public="1" set="method"><f a="millisecondsTimeout">
	<x path="Int"/>
	<x path="Bool"/>
</f></WaitOne>
				<WaitOne public="1" set="method"><f a="millisecondsTimeout:exitContext">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></WaitOne>
			</overloads>
		</WaitOne>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.WaitHandle"</e></m>
		</meta>
	</class>
	<class path="cs.system.diagnostics.Process_ProcessWaitHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.Process" module="cs.system.diagnostics.Process" extern="1">
		<extends path="cs.system.threading.WaitHandle"/>
		<new final="1" public="1" set="method"><f a="handle">
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.Process.ProcessWaitHandle"</e></m>
		</meta>
	</class>
	<class path="cs.system.diagnostics.Process_Delegate_AsyncReadHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.Process" module="cs.system.diagnostics.Process" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
	<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
	<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
	<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
	<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a=""><x path="Void"/></f></Invoke>
		<BeginInvoke public="1" set="method"><f a="callback:object">
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.Process.AsyncReadHandler"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.diagnostics.Process_AsyncReadHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.Process" module="cs.system.diagnostics.Process">
		<from><icast field="FromHaxeFunction"><f a=""><x path="Void"/></f></icast></from>
		<this><c path="cs.system.diagnostics.Process_Delegate_AsyncReadHandler"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.diagnostics._Process.Process_AsyncReadHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.Process" private="1" module="cs.system.diagnostics.Process" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=""><x path="Void"/></f>
			<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=""><x path="Void"/></f>
			<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.diagnostics.Process_Delegate_AsyncReadHandler"/>
	<c path="cs.system.diagnostics.Process_Delegate_AsyncReadHandler"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
			<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
			<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
			<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
			<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.diagnostics._Process.Process_AsyncReadHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.Process" private="1" module="cs.system.diagnostics.Process" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=""><x path="Void"/></f>
				<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=""><x path="Void"/></f>
				<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.diagnostics.Process_Delegate_AsyncReadHandler"/>
	<c path="cs.system.diagnostics.Process_Delegate_AsyncReadHandler"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
				<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
				<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
				<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
				<x path="cs.system.diagnostics.Process_AsyncReadHandler"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.diagnostics.Process_ProcessAsyncReader" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.Process" module="cs.system.diagnostics.Process" extern="1" final="1">
		<WaitHandle public="1" get="accessor" set="null"><c path="cs.system.threading.WaitHandle"/></WaitHandle>
		<IsCompleted public="1" get="accessor" set="null"><x path="Bool"/></IsCompleted>
		<ReadHandler public="1"><x path="cs.system.diagnostics.Process_AsyncReadHandler"/></ReadHandler>
		<EndCalled public="1"><x path="Int"/></EndCalled>
		<ares public="1"><d/></ares>
		<operation public="1"><x path="Int"/></operation>
		<completed_sync public="1"><x path="Bool"/></completed_sync>
		<total public="1"><x path="Int"/></total>
		<acc_socket public="1"><d/></acc_socket>
		<ReuseSocket public="1"><x path="Bool"/></ReuseSocket>
		<Buffers public="1"><d/></Buffers>
		<port public="1"><x path="Int"/></port>
		<Addresses public="1"><c path="cs.NativeArray"><d/></c></Addresses>
		<AcceptSocket public="1"><d/></AcceptSocket>
		<SockFlags public="1"><x path="Int"/></SockFlags>
		<Size public="1"><x path="Int"/></Size>
		<Offset public="1"><x path="Int"/></Offset>
		<EndPoint public="1"><d/></EndPoint>
		<delayedException public="1"><c path="cs.system.Exception"/></delayedException>
		<wait_handle public="1"><c path="cs.system.threading.ManualResetEvent"/></wait_handle>
		<callback public="1"><x path="cs.system.AsyncCallback"/></callback>
		<state public="1"><d/></state>
		<handle public="1"><c path="cs.system.IntPtr"/></handle>
		<Sock public="1"><d/></Sock>
		<AddInput final="1" public="1" set="method"><f a=""><x path="Void"/></f></AddInput>
		<get_IsCompleted final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsCompleted>
		<get_WaitHandle final="1" public="1" set="method"><f a=""><c path="cs.system.threading.WaitHandle"/></f></get_WaitHandle>
		<Close final="1" public="1" set="method"><f a=""><x path="Void"/></f></Close>
		<new final="1" public="1" set="method"><f a="process:handle:err_out">
	<c path="cs.system.diagnostics.Process"/>
	<c path="cs.system.IntPtr"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.Process.ProcessAsyncReader"</e></m>
		</meta>
	</class>
	<enum path="cs.system.diagnostics.Process_AsyncModes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.Process" module="cs.system.diagnostics.Process">
		<NoneYet><meta><m n=":csNative"><e>0</e></m></meta></NoneYet>
		<SyncOutput><meta><m n=":csNative"><e>1</e></m></meta></SyncOutput>
		<SyncError><meta><m n=":csNative"><e>2</e></m></meta></SyncError>
		<AsyncOutput><meta><m n=":csNative"><e>4</e></m></meta></AsyncOutput>
		<AsyncError><meta><m n=":csNative"><e>8</e></m></meta></AsyncError>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Diagnostics.Process.AsyncModes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.diagnostics.Process_ProcInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.Process" module="cs.system.diagnostics.Process" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<LoadUserProfile public="1"><x path="Bool"/></LoadUserProfile>
		<Password public="1"><c path="cs.system.IntPtr"/></Password>
		<Domain public="1"><c path="String"/></Domain>
		<UserName public="1"><c path="String"/></UserName>
		<envValues public="1"><c path="cs.NativeArray"><c path="String"/></c></envValues>
		<envKeys public="1"><c path="cs.NativeArray"><c path="String"/></c></envKeys>
		<tid public="1"><x path="Int"/></tid>
		<pid public="1"><x path="Int"/></pid>
		<thread_handle public="1"><c path="cs.system.IntPtr"/></thread_handle>
		<process_handle public="1"><c path="cs.system.IntPtr"/></process_handle>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.Process.ProcInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.diagnostics.Process" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.Process" extern="1">
		<extends path="cs.system.componentmodel.Component"/>
		<EnterDebugMode public="1" set="method" static="1"><f a=""><x path="Void"/></f></EnterDebugMode>
		<GetCurrentProcess public="1" set="method" static="1"><f a=""><c path="cs.system.diagnostics.Process"/></f></GetCurrentProcess>
		<GetProcessById public="1" set="method" static="1">
			<f a="processId">
				<x path="Int"/>
				<c path="cs.system.diagnostics.Process"/>
			</f>
			<overloads><GetProcessById public="1" set="method"><f a="processId:machineName">
	<x path="Int"/>
	<c path="String"/>
	<c path="cs.system.diagnostics.Process"/>
</f></GetProcessById></overloads>
		</GetProcessById>
		<GetProcesses public="1" set="method" static="1">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.diagnostics.Process"/></c></f>
			<overloads><GetProcesses public="1" set="method"><f a="machineName">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="cs.system.diagnostics.Process"/></c>
</f></GetProcesses></overloads>
		</GetProcesses>
		<GetProcessesByName public="1" set="method" static="1">
			<f a="processName">
				<c path="String"/>
				<c path="cs.NativeArray"><c path="cs.system.diagnostics.Process"/></c>
			</f>
			<overloads><GetProcessesByName public="1" set="method"><f a="processName:machineName">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><c path="cs.system.diagnostics.Process"/></c>
</f></GetProcessesByName></overloads>
		</GetProcessesByName>
		<LeaveDebugMode public="1" set="method" static="1"><f a=""><x path="Void"/></f></LeaveDebugMode>
		<Start public="1" set="method" static="1">
			<f a="startInfo">
				<c path="cs.system.diagnostics.ProcessStartInfo"/>
				<c path="cs.system.diagnostics.Process"/>
			</f>
			<overloads>
				<Start public="1" set="method"><f a="fileName:arguments:username:password:domain">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.security.SecureString"/>
	<c path="String"/>
	<c path="cs.system.diagnostics.Process"/>
</f></Start>
				<Start public="1" set="method"><f a="fileName:username:password:domain">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.security.SecureString"/>
	<c path="String"/>
	<c path="cs.system.diagnostics.Process"/>
</f></Start>
				<Start public="1" set="method"><f a="fileName:arguments">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.diagnostics.Process"/>
</f></Start>
				<Start public="1" set="method"><f a="fileName">
	<c path="String"/>
	<c path="cs.system.diagnostics.Process"/>
</f></Start>
			</overloads>
		</Start>
		<_Start public="1" set="method" static="1">
			<f a="startInfo">
				<c path="cs.system.diagnostics.ProcessStartInfo"/>
				<c path="cs.system.diagnostics.Process"/>
			</f>
			<meta><m n=":native"><e>"Start"</e></m></meta>
			<overloads>
				<Start public="1" set="method">
					<f a="fileName:arguments:username:password:domain">
						<c path="String"/>
						<c path="String"/>
						<c path="String"/>
						<c path="cs.system.security.SecureString"/>
						<c path="String"/>
						<c path="cs.system.diagnostics.Process"/>
					</f>
					<meta><m n=":native"><e>"Start"</e></m></meta>
				</Start>
				<Start public="1" set="method">
					<f a="fileName:username:password:domain">
						<c path="String"/>
						<c path="String"/>
						<c path="cs.system.security.SecureString"/>
						<c path="String"/>
						<c path="cs.system.diagnostics.Process"/>
					</f>
					<meta><m n=":native"><e>"Start"</e></m></meta>
				</Start>
				<Start public="1" set="method">
					<f a="fileName:arguments">
						<c path="String"/>
						<c path="String"/>
						<c path="cs.system.diagnostics.Process"/>
					</f>
					<meta><m n=":native"><e>"Start"</e></m></meta>
				</Start>
				<Start public="1" set="method">
					<f a="fileName">
						<c path="String"/>
						<c path="cs.system.diagnostics.Process"/>
					</f>
					<meta><m n=":native"><e>"Start"</e></m></meta>
				</Start>
			</overloads>
		</_Start>
		<Exited>
			<x path="cs.system.EventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</Exited>
		<ErrorDataReceived>
			<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</ErrorDataReceived>
		<OutputDataReceived>
			<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</OutputDataReceived>
		<WorkingSet64 public="1" get="accessor" set="null"><x path="haxe.Int64"/></WorkingSet64>
		<VirtualMemorySize64 public="1" get="accessor" set="null"><x path="haxe.Int64"/></VirtualMemorySize64>
		<PrivateMemorySize64 public="1" get="accessor" set="null"><x path="haxe.Int64"/></PrivateMemorySize64>
		<WorkingSet public="1" get="accessor" set="null"><x path="Int"/></WorkingSet>
		<VirtualMemorySize public="1" get="accessor" set="null"><x path="Int"/></VirtualMemorySize>
		<UserProcessorTime public="1" get="accessor" set="null"><c path="cs.system.TimeSpan"/></UserProcessorTime>
		<TotalProcessorTime public="1" get="accessor" set="null"><c path="cs.system.TimeSpan"/></TotalProcessorTime>
		<Threads public="1" get="accessor" set="null"><c path="cs.system.diagnostics.ProcessThreadCollection"/></Threads>
		<SynchronizingObject public="1" get="accessor" set="accessor"><c path="cs.system.componentmodel.ISynchronizeInvoke"/></SynchronizingObject>
		<StartTime public="1" get="accessor" set="null"><c path="cs.system.DateTime"/></StartTime>
		<StartInfo public="1" get="accessor" set="accessor"><c path="cs.system.diagnostics.ProcessStartInfo"/></StartInfo>
		<StandardOutput public="1" get="accessor" set="null"><c path="cs.system.io.StreamReader"/></StandardOutput>
		<StandardInput public="1" get="accessor" set="null"><c path="cs.system.io.StreamWriter"/></StandardInput>
		<StandardError public="1" get="accessor" set="null"><c path="cs.system.io.StreamReader"/></StandardError>
		<Responding public="1" get="accessor" set="null"><x path="Bool"/></Responding>
		<ProcessorAffinity public="1" get="accessor" set="accessor"><c path="cs.system.IntPtr"/></ProcessorAffinity>
		<ProcessName public="1" get="accessor" set="null"><c path="String"/></ProcessName>
		<PrivilegedProcessorTime public="1" get="accessor" set="null"><c path="cs.system.TimeSpan"/></PrivilegedProcessorTime>
		<SessionId public="1" get="accessor" set="null"><x path="Int"/></SessionId>
		<PrivateMemorySize public="1" get="accessor" set="null"><x path="Int"/></PrivateMemorySize>
		<PriorityClass public="1" get="accessor" set="accessor"><e path="cs.system.diagnostics.ProcessPriorityClass"/></PriorityClass>
		<PriorityBoostEnabled public="1" get="accessor" set="accessor"><x path="Bool"/></PriorityBoostEnabled>
		<PeakWorkingSet64 public="1" get="accessor" set="null"><x path="haxe.Int64"/></PeakWorkingSet64>
		<PeakVirtualMemorySize64 public="1" get="accessor" set="null"><x path="haxe.Int64"/></PeakVirtualMemorySize64>
		<PeakPagedMemorySize64 public="1" get="accessor" set="null"><x path="haxe.Int64"/></PeakPagedMemorySize64>
		<PagedSystemMemorySize64 public="1" get="accessor" set="null"><x path="haxe.Int64"/></PagedSystemMemorySize64>
		<PagedMemorySize64 public="1" get="accessor" set="null"><x path="haxe.Int64"/></PagedMemorySize64>
		<NonpagedSystemMemorySize64 public="1" get="accessor" set="null"><x path="haxe.Int64"/></NonpagedSystemMemorySize64>
		<PeakWorkingSet public="1" get="accessor" set="null"><x path="Int"/></PeakWorkingSet>
		<PeakVirtualMemorySize public="1" get="accessor" set="null"><x path="Int"/></PeakVirtualMemorySize>
		<PeakPagedMemorySize public="1" get="accessor" set="null"><x path="Int"/></PeakPagedMemorySize>
		<PagedSystemMemorySize public="1" get="accessor" set="null"><x path="Int"/></PagedSystemMemorySize>
		<PagedMemorySize public="1" get="accessor" set="null"><x path="Int"/></PagedMemorySize>
		<NonpagedSystemMemorySize public="1" get="accessor" set="null"><x path="Int"/></NonpagedSystemMemorySize>
		<Modules public="1" get="accessor" set="null"><c path="cs.system.diagnostics.ProcessModuleCollection"/></Modules>
		<MinWorkingSet public="1" get="accessor" set="accessor"><c path="cs.system.IntPtr"/></MinWorkingSet>
		<MaxWorkingSet public="1" get="accessor" set="accessor"><c path="cs.system.IntPtr"/></MaxWorkingSet>
		<MainWindowTitle public="1" get="accessor" set="null"><c path="String"/></MainWindowTitle>
		<MainWindowHandle public="1" get="accessor" set="null"><c path="cs.system.IntPtr"/></MainWindowHandle>
		<MainModule public="1" get="accessor" set="null"><c path="cs.system.diagnostics.ProcessModule"/></MainModule>
		<MachineName public="1" get="accessor" set="null"><c path="String"/></MachineName>
		<Id public="1" get="accessor" set="null"><x path="Int"/></Id>
		<HasExited public="1" get="accessor" set="null"><x path="Bool"/></HasExited>
		<HandleCount public="1" get="accessor" set="null"><x path="Int"/></HandleCount>
		<Handle public="1" get="accessor" set="null"><c path="cs.system.IntPtr"/></Handle>
		<ExitTime public="1" get="accessor" set="null"><c path="cs.system.DateTime"/></ExitTime>
		<ExitCode public="1" get="accessor" set="null"><x path="Int"/></ExitCode>
		<EnableRaisingEvents public="1" get="accessor" set="accessor"><x path="Bool"/></EnableRaisingEvents>
		<BasePriority public="1" get="accessor" set="null"><x path="Int"/></BasePriority>
		<add_OutputDataReceived final="1" public="1" set="method"><f a="value">
	<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
	<x path="Void"/>
</f></add_OutputDataReceived>
		<remove_OutputDataReceived final="1" public="1" set="method"><f a="value">
	<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
	<x path="Void"/>
</f></remove_OutputDataReceived>
		<add_ErrorDataReceived final="1" public="1" set="method"><f a="value">
	<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
	<x path="Void"/>
</f></add_ErrorDataReceived>
		<remove_ErrorDataReceived final="1" public="1" set="method"><f a="value">
	<x path="cs.system.diagnostics.DataReceivedEventHandler"/>
	<x path="Void"/>
</f></remove_ErrorDataReceived>
		<add_Exited final="1" public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></add_Exited>
		<remove_Exited final="1" public="1" set="method"><f a="value">
	<x path="cs.system.EventHandler"/>
	<x path="Void"/>
</f></remove_Exited>
		<get_BasePriority final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_BasePriority>
		<get_EnableRaisingEvents final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_EnableRaisingEvents>
		<set_EnableRaisingEvents final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_EnableRaisingEvents>
		<get_ExitCode final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_ExitCode>
		<get_ExitTime final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_ExitTime>
		<get_Handle final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_Handle>
		<get_HandleCount final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_HandleCount>
		<get_HasExited final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_HasExited>
		<get_Id final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Id>
		<get_MachineName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_MachineName>
		<get_MainModule final="1" public="1" set="method"><f a=""><c path="cs.system.diagnostics.ProcessModule"/></f></get_MainModule>
		<get_MainWindowHandle final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_MainWindowHandle>
		<get_MainWindowTitle final="1" public="1" set="method"><f a=""><c path="String"/></f></get_MainWindowTitle>
		<get_MaxWorkingSet final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_MaxWorkingSet>
		<set_MaxWorkingSet final="1" public="1" set="method"><f a="value">
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
</f></set_MaxWorkingSet>
		<get_MinWorkingSet final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_MinWorkingSet>
		<set_MinWorkingSet final="1" public="1" set="method"><f a="value">
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
</f></set_MinWorkingSet>
		<get_Modules final="1" public="1" set="method"><f a=""><c path="cs.system.diagnostics.ProcessModuleCollection"/></f></get_Modules>
		<get_NonpagedSystemMemorySize final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_NonpagedSystemMemorySize>
		<get_PagedMemorySize final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_PagedMemorySize>
		<get_PagedSystemMemorySize final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_PagedSystemMemorySize>
		<get_PeakPagedMemorySize final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_PeakPagedMemorySize>
		<get_PeakVirtualMemorySize final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_PeakVirtualMemorySize>
		<get_PeakWorkingSet final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_PeakWorkingSet>
		<get_NonpagedSystemMemorySize64 final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_NonpagedSystemMemorySize64>
		<get_PagedMemorySize64 final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_PagedMemorySize64>
		<get_PagedSystemMemorySize64 final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_PagedSystemMemorySize64>
		<get_PeakPagedMemorySize64 final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_PeakPagedMemorySize64>
		<get_PeakVirtualMemorySize64 final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_PeakVirtualMemorySize64>
		<get_PeakWorkingSet64 final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_PeakWorkingSet64>
		<get_PriorityBoostEnabled final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_PriorityBoostEnabled>
		<set_PriorityBoostEnabled final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_PriorityBoostEnabled>
		<get_PriorityClass final="1" public="1" set="method"><f a=""><e path="cs.system.diagnostics.ProcessPriorityClass"/></f></get_PriorityClass>
		<set_PriorityClass final="1" public="1" set="method"><f a="value">
	<e path="cs.system.diagnostics.ProcessPriorityClass"/>
	<e path="cs.system.diagnostics.ProcessPriorityClass"/>
</f></set_PriorityClass>
		<get_PrivateMemorySize final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_PrivateMemorySize>
		<get_SessionId final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_SessionId>
		<get_PrivilegedProcessorTime final="1" public="1" set="method"><f a=""><c path="cs.system.TimeSpan"/></f></get_PrivilegedProcessorTime>
		<get_ProcessName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ProcessName>
		<get_ProcessorAffinity final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_ProcessorAffinity>
		<set_ProcessorAffinity final="1" public="1" set="method"><f a="value">
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
</f></set_ProcessorAffinity>
		<get_Responding final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_Responding>
		<get_StandardError final="1" public="1" set="method"><f a=""><c path="cs.system.io.StreamReader"/></f></get_StandardError>
		<get_StandardInput final="1" public="1" set="method"><f a=""><c path="cs.system.io.StreamWriter"/></f></get_StandardInput>
		<get_StandardOutput final="1" public="1" set="method"><f a=""><c path="cs.system.io.StreamReader"/></f></get_StandardOutput>
		<get_StartInfo final="1" public="1" set="method"><f a=""><c path="cs.system.diagnostics.ProcessStartInfo"/></f></get_StartInfo>
		<set_StartInfo final="1" public="1" set="method"><f a="value">
	<c path="cs.system.diagnostics.ProcessStartInfo"/>
	<c path="cs.system.diagnostics.ProcessStartInfo"/>
</f></set_StartInfo>
		<get_StartTime final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_StartTime>
		<get_SynchronizingObject final="1" public="1" set="method"><f a=""><c path="cs.system.componentmodel.ISynchronizeInvoke"/></f></get_SynchronizingObject>
		<set_SynchronizingObject final="1" public="1" set="method"><f a="value">
	<c path="cs.system.componentmodel.ISynchronizeInvoke"/>
	<c path="cs.system.componentmodel.ISynchronizeInvoke"/>
</f></set_SynchronizingObject>
		<get_Threads final="1" public="1" set="method"><f a=""><c path="cs.system.diagnostics.ProcessThreadCollection"/></f></get_Threads>
		<get_TotalProcessorTime final="1" public="1" set="method"><f a=""><c path="cs.system.TimeSpan"/></f></get_TotalProcessorTime>
		<get_UserProcessorTime final="1" public="1" set="method"><f a=""><c path="cs.system.TimeSpan"/></f></get_UserProcessorTime>
		<get_VirtualMemorySize final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_VirtualMemorySize>
		<get_WorkingSet final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_WorkingSet>
		<get_PrivateMemorySize64 final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_PrivateMemorySize64>
		<get_VirtualMemorySize64 final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_VirtualMemorySize64>
		<get_WorkingSet64 final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_WorkingSet64>
		<Close final="1" public="1" set="method"><f a=""><x path="Void"/></f></Close>
		<CloseMainWindow final="1" public="1" set="method"><f a=""><x path="Bool"/></f></CloseMainWindow>
		<Kill final="1" public="1" set="method"><f a=""><x path="Void"/></f></Kill>
		<Refresh final="1" public="1" set="method"><f a=""><x path="Void"/></f></Refresh>
		<Start final="1" public="1" set="method"><f a=""><x path="Bool"/></f></Start>
		<ToString public="1" set="method" override="1"><f a=""><c path="String"/></f></ToString>
		<WaitForExit final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><WaitForExit final="1" public="1" set="method"><f a="milliseconds">
	<x path="Int"/>
	<x path="Bool"/>
</f></WaitForExit></overloads>
		</WaitForExit>
		<WaitForInputIdle final="1" public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<overloads><WaitForInputIdle final="1" public="1" set="method"><f a="milliseconds">
	<x path="Int"/>
	<x path="Bool"/>
</f></WaitForInputIdle></overloads>
		</WaitForInputIdle>
		<BeginOutputReadLine final="1" public="1" set="method"><f a=""><x path="Void"/></f></BeginOutputReadLine>
		<CancelOutputRead final="1" public="1" set="method"><f a=""><x path="Void"/></f></CancelOutputRead>
		<BeginErrorReadLine final="1" public="1" set="method"><f a=""><x path="Void"/></f></BeginErrorReadLine>
		<CancelErrorRead final="1" public="1" set="method"><f a=""><x path="Void"/></f></CancelErrorRead>
		<Dispose set="method" override="1">
			<f a="disposing">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</Dispose>
		<OnExited final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</OnExited>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.Process"</e></m>
		</meta>
	</class>
	<class path="cs.system.diagnostics.ProcessModule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.ProcessModule" extern="1">
		<extends path="cs.system.componentmodel.Component"/>
		<ModuleName public="1" get="accessor" set="null"><c path="String"/></ModuleName>
		<ModuleMemorySize public="1" get="accessor" set="null"><x path="Int"/></ModuleMemorySize>
		<FileVersionInfo public="1" get="accessor" set="null"><c path="cs.system.diagnostics.FileVersionInfo"/></FileVersionInfo>
		<FileName public="1" get="accessor" set="null"><c path="String"/></FileName>
		<EntryPointAddress public="1" get="accessor" set="null"><c path="cs.system.IntPtr"/></EntryPointAddress>
		<BaseAddress public="1" get="accessor" set="null"><c path="cs.system.IntPtr"/></BaseAddress>
		<get_BaseAddress final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_BaseAddress>
		<get_EntryPointAddress final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_EntryPointAddress>
		<get_FileName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_FileName>
		<get_FileVersionInfo final="1" public="1" set="method"><f a=""><c path="cs.system.diagnostics.FileVersionInfo"/></f></get_FileVersionInfo>
		<get_ModuleMemorySize final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_ModuleMemorySize>
		<get_ModuleName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ModuleName>
		<ToString public="1" set="method" override="1"><f a=""><c path="String"/></f></ToString>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.ProcessModule"</e></m>
		</meta>
	</class>
	<class path="cs.system.diagnostics.ProcessModuleCollection" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.ProcessModuleCollection" extern="1">
		<extends path="cs.system.collections.ReadOnlyCollectionBase"/>
		<get_Item final="1" public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="cs.system.diagnostics.ProcessModule"/>
</f></get_Item>
		<Contains final="1" public="1" set="method"><f a="module">
	<c path="cs.system.diagnostics.ProcessModule"/>
	<x path="Bool"/>
</f></Contains>
		<CopyTo final="1" public="1" set="method"><f a="array:index">
	<c path="cs.NativeArray"><c path="cs.system.diagnostics.ProcessModule"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<IndexOf final="1" public="1" set="method"><f a="module">
	<c path="cs.system.diagnostics.ProcessModule"/>
	<x path="Int"/>
</f></IndexOf>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
			<overloads><new final="1" public="1" set="method"><f a="processModules">
	<c path="cs.NativeArray"><c path="cs.system.diagnostics.ProcessModule"/></c>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.ProcessModuleCollection"</e></m>
		</meta>
	</class>
	<enum path="cs.system.diagnostics.ProcessPriorityClass" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.ProcessPriorityClass">
		<Normal><meta><m n=":csNative"><e>32</e></m></meta></Normal>
		<Idle><meta><m n=":csNative"><e>64</e></m></meta></Idle>
		<High><meta><m n=":csNative"><e>128</e></m></meta></High>
		<RealTime><meta><m n=":csNative"><e>256</e></m></meta></RealTime>
		<BelowNormal><meta><m n=":csNative"><e>16384</e></m></meta></BelowNormal>
		<AboveNormal><meta><m n=":csNative"><e>32768</e></m></meta></AboveNormal>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Diagnostics.ProcessPriorityClass"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.diagnostics.ProcessStartInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.ProcessStartInfo" extern="1" final="1">
		<Password public="1" get="accessor" set="accessor"><c path="cs.system.security.SecureString"/></Password>
		<Domain public="1" get="accessor" set="accessor"><c path="String"/></Domain>
		<UserName public="1" get="accessor" set="accessor"><c path="String"/></UserName>
		<LoadUserProfile public="1" get="accessor" set="accessor"><x path="Bool"/></LoadUserProfile>
		<WorkingDirectory public="1" get="accessor" set="accessor"><c path="String"/></WorkingDirectory>
		<WindowStyle public="1" get="accessor" set="accessor"><e path="cs.system.diagnostics.ProcessWindowStyle"/></WindowStyle>
		<Verbs public="1" get="accessor" set="null"><c path="cs.NativeArray"><c path="String"/></c></Verbs>
		<Verb public="1" get="accessor" set="accessor"><c path="String"/></Verb>
		<UseShellExecute public="1" get="accessor" set="accessor"><x path="Bool"/></UseShellExecute>
		<StandardOutputEncoding public="1" get="accessor" set="accessor"><c path="cs.system.text.Encoding"/></StandardOutputEncoding>
		<StandardErrorEncoding public="1" get="accessor" set="accessor"><c path="cs.system.text.Encoding"/></StandardErrorEncoding>
		<RedirectStandardOutput public="1" get="accessor" set="accessor"><x path="Bool"/></RedirectStandardOutput>
		<RedirectStandardInput public="1" get="accessor" set="accessor"><x path="Bool"/></RedirectStandardInput>
		<RedirectStandardError public="1" get="accessor" set="accessor"><x path="Bool"/></RedirectStandardError>
		<FileName public="1" get="accessor" set="accessor"><c path="String"/></FileName>
		<ErrorDialogParentHandle public="1" get="accessor" set="accessor"><c path="cs.system.IntPtr"/></ErrorDialogParentHandle>
		<ErrorDialog public="1" get="accessor" set="accessor"><x path="Bool"/></ErrorDialog>
		<EnvironmentVariables public="1" get="accessor" set="null"><c path="cs.system.collections.specialized.StringDictionary"/></EnvironmentVariables>
		<CreateNoWindow public="1" get="accessor" set="accessor"><x path="Bool"/></CreateNoWindow>
		<Arguments public="1" get="accessor" set="accessor"><c path="String"/></Arguments>
		<get_Arguments final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Arguments>
		<set_Arguments final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Arguments>
		<get_CreateNoWindow final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_CreateNoWindow>
		<set_CreateNoWindow final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_CreateNoWindow>
		<get_EnvironmentVariables final="1" public="1" set="method"><f a=""><c path="cs.system.collections.specialized.StringDictionary"/></f></get_EnvironmentVariables>
		<get_ErrorDialog final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_ErrorDialog>
		<set_ErrorDialog final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ErrorDialog>
		<get_ErrorDialogParentHandle final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_ErrorDialogParentHandle>
		<set_ErrorDialogParentHandle final="1" public="1" set="method"><f a="value">
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
</f></set_ErrorDialogParentHandle>
		<get_FileName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_FileName>
		<set_FileName final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_FileName>
		<get_RedirectStandardError final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_RedirectStandardError>
		<set_RedirectStandardError final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RedirectStandardError>
		<get_RedirectStandardInput final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_RedirectStandardInput>
		<set_RedirectStandardInput final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RedirectStandardInput>
		<get_RedirectStandardOutput final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_RedirectStandardOutput>
		<set_RedirectStandardOutput final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RedirectStandardOutput>
		<get_StandardErrorEncoding final="1" public="1" set="method"><f a=""><c path="cs.system.text.Encoding"/></f></get_StandardErrorEncoding>
		<set_StandardErrorEncoding final="1" public="1" set="method"><f a="value">
	<c path="cs.system.text.Encoding"/>
	<c path="cs.system.text.Encoding"/>
</f></set_StandardErrorEncoding>
		<get_StandardOutputEncoding final="1" public="1" set="method"><f a=""><c path="cs.system.text.Encoding"/></f></get_StandardOutputEncoding>
		<set_StandardOutputEncoding final="1" public="1" set="method"><f a="value">
	<c path="cs.system.text.Encoding"/>
	<c path="cs.system.text.Encoding"/>
</f></set_StandardOutputEncoding>
		<get_UseShellExecute final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_UseShellExecute>
		<set_UseShellExecute final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_UseShellExecute>
		<get_Verb final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Verb>
		<set_Verb final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Verb>
		<get_Verbs final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></get_Verbs>
		<get_WindowStyle final="1" public="1" set="method"><f a=""><e path="cs.system.diagnostics.ProcessWindowStyle"/></f></get_WindowStyle>
		<set_WindowStyle final="1" public="1" set="method"><f a="value">
	<e path="cs.system.diagnostics.ProcessWindowStyle"/>
	<e path="cs.system.diagnostics.ProcessWindowStyle"/>
</f></set_WindowStyle>
		<get_WorkingDirectory final="1" public="1" set="method"><f a=""><c path="String"/></f></get_WorkingDirectory>
		<set_WorkingDirectory final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_WorkingDirectory>
		<get_LoadUserProfile final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_LoadUserProfile>
		<set_LoadUserProfile final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_LoadUserProfile>
		<get_UserName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_UserName>
		<set_UserName final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_UserName>
		<get_Domain final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Domain>
		<set_Domain final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Domain>
		<get_Password final="1" public="1" set="method"><f a=""><c path="cs.system.security.SecureString"/></f></get_Password>
		<set_Password final="1" public="1" set="method"><f a="value">
	<c path="cs.system.security.SecureString"/>
	<c path="cs.system.security.SecureString"/>
</f></set_Password>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="filename:arguments">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="filename">
	<c path="String"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.ProcessStartInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.diagnostics.ProcessThread" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.ProcessThread" extern="1">
		<extends path="cs.system.componentmodel.Component"/>
		<WaitReason public="1" get="accessor" set="null"><e path="cs.system.diagnostics.ThreadWaitReason"/></WaitReason>
		<UserProcessorTime public="1" get="accessor" set="null"><c path="cs.system.TimeSpan"/></UserProcessorTime>
		<TotalProcessorTime public="1" get="accessor" set="null"><c path="cs.system.TimeSpan"/></TotalProcessorTime>
		<ThreadState public="1" get="accessor" set="null"><e path="cs.system.diagnostics.ThreadState"/></ThreadState>
		<StartTime public="1" get="accessor" set="null"><c path="cs.system.DateTime"/></StartTime>
		<StartAddress public="1" get="accessor" set="null"><c path="cs.system.IntPtr"/></StartAddress>
		<ProcessorAffinity public="1" get="null" set="accessor"><c path="cs.system.IntPtr"/></ProcessorAffinity>
		<PrivilegedProcessorTime public="1" get="accessor" set="null"><c path="cs.system.TimeSpan"/></PrivilegedProcessorTime>
		<PriorityLevel public="1" get="accessor" set="accessor"><e path="cs.system.diagnostics.ThreadPriorityLevel"/></PriorityLevel>
		<PriorityBoostEnabled public="1" get="accessor" set="accessor"><x path="Bool"/></PriorityBoostEnabled>
		<IdealProcessor public="1" get="null" set="accessor"><x path="Int"/></IdealProcessor>
		<Id public="1" get="accessor" set="null"><x path="Int"/></Id>
		<CurrentPriority public="1" get="accessor" set="null"><x path="Int"/></CurrentPriority>
		<BasePriority public="1" get="accessor" set="null"><x path="Int"/></BasePriority>
		<get_BasePriority final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_BasePriority>
		<get_CurrentPriority final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_CurrentPriority>
		<get_Id final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Id>
		<set_IdealProcessor final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_IdealProcessor>
		<get_PriorityBoostEnabled final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_PriorityBoostEnabled>
		<set_PriorityBoostEnabled final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_PriorityBoostEnabled>
		<get_PriorityLevel final="1" public="1" set="method"><f a=""><e path="cs.system.diagnostics.ThreadPriorityLevel"/></f></get_PriorityLevel>
		<set_PriorityLevel final="1" public="1" set="method"><f a="value">
	<e path="cs.system.diagnostics.ThreadPriorityLevel"/>
	<e path="cs.system.diagnostics.ThreadPriorityLevel"/>
</f></set_PriorityLevel>
		<get_PrivilegedProcessorTime final="1" public="1" set="method"><f a=""><c path="cs.system.TimeSpan"/></f></get_PrivilegedProcessorTime>
		<set_ProcessorAffinity final="1" public="1" set="method"><f a="value">
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
</f></set_ProcessorAffinity>
		<get_StartAddress final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_StartAddress>
		<get_StartTime final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_StartTime>
		<get_ThreadState final="1" public="1" set="method"><f a=""><e path="cs.system.diagnostics.ThreadState"/></f></get_ThreadState>
		<get_TotalProcessorTime final="1" public="1" set="method"><f a=""><c path="cs.system.TimeSpan"/></f></get_TotalProcessorTime>
		<get_UserProcessorTime final="1" public="1" set="method"><f a=""><c path="cs.system.TimeSpan"/></f></get_UserProcessorTime>
		<get_WaitReason final="1" public="1" set="method"><f a=""><e path="cs.system.diagnostics.ThreadWaitReason"/></f></get_WaitReason>
		<ResetIdealProcessor final="1" public="1" set="method"><f a=""><x path="Void"/></f></ResetIdealProcessor>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.ProcessThread"</e></m>
		</meta>
	</class>
	<class path="cs.system.diagnostics.ProcessThreadCollection" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.ProcessThreadCollection" extern="1">
		<extends path="cs.system.collections.ReadOnlyCollectionBase"/>
		<get_Item final="1" public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="cs.system.diagnostics.ProcessThread"/>
</f></get_Item>
		<Add final="1" public="1" set="method"><f a="thread">
	<c path="cs.system.diagnostics.ProcessThread"/>
	<x path="Int"/>
</f></Add>
		<Contains final="1" public="1" set="method"><f a="thread">
	<c path="cs.system.diagnostics.ProcessThread"/>
	<x path="Bool"/>
</f></Contains>
		<CopyTo final="1" public="1" set="method"><f a="array:index">
	<c path="cs.NativeArray"><c path="cs.system.diagnostics.ProcessThread"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<IndexOf final="1" public="1" set="method"><f a="thread">
	<c path="cs.system.diagnostics.ProcessThread"/>
	<x path="Int"/>
</f></IndexOf>
		<Insert final="1" public="1" set="method"><f a="index:thread">
	<x path="Int"/>
	<c path="cs.system.diagnostics.ProcessThread"/>
	<x path="Void"/>
</f></Insert>
		<Remove final="1" public="1" set="method"><f a="thread">
	<c path="cs.system.diagnostics.ProcessThread"/>
	<x path="Void"/>
</f></Remove>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
			<overloads><new final="1" public="1" set="method"><f a="processThreads">
	<c path="cs.NativeArray"><c path="cs.system.diagnostics.ProcessThread"/></c>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.ProcessThreadCollection"</e></m>
		</meta>
	</class>
	<enum path="cs.system.diagnostics.ProcessWindowStyle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.ProcessWindowStyle">
		<Normal><meta><m n=":csNative"><e>0</e></m></meta></Normal>
		<Hidden><meta><m n=":csNative"><e>1</e></m></meta></Hidden>
		<Minimized><meta><m n=":csNative"><e>2</e></m></meta></Minimized>
		<Maximized><meta><m n=":csNative"><e>3</e></m></meta></Maximized>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Diagnostics.ProcessWindowStyle"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.diagnostics.StackFrame" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.diagnostics.StackFrame" extern="1">
		<OFFSET_UNKNOWN public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":readOnly"/></meta>
		</OFFSET_UNKNOWN>
		<GetFileLineNumber public="1" set="method"><f a=""><x path="Int"/></f></GetFileLineNumber>
		<GetFileColumnNumber public="1" set="method"><f a=""><x path="Int"/></f></GetFileColumnNumber>
		<GetFileName public="1" set="method"><f a=""><c path="String"/></f></GetFileName>
		<GetILOffset public="1" set="method"><f a=""><x path="Int"/></f></GetILOffset>
		<GetMethod public="1" set="method"><f a=""><c path="cs.system.reflection.MethodBase"/></f></GetMethod>
		<GetNativeOffset public="1" set="method"><f a=""><x path="Int"/></f></GetNativeOffset>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="fileName:lineNumber:colNumber">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="fileName:lineNumber">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="skipFrames:fNeedFileInfo">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="skipFrames">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="fNeedFileInfo">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.StackFrame"</e></m>
		</meta>
	</class>
	<class path="cs.system.diagnostics.StackTrace" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.diagnostics.StackTrace" extern="1">
		<METHODS_TO_SKIP public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":readOnly"/></meta>
		</METHODS_TO_SKIP>
		<FrameCount public="1" get="accessor" set="null"><x path="Int"/></FrameCount>
		<get_FrameCount public="1" set="method"><f a=""><x path="Int"/></f></get_FrameCount>
		<GetFrame public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="cs.system.diagnostics.StackFrame"/>
</f></GetFrame>
		<GetFrames public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.diagnostics.StackFrame"/></c></f></GetFrames>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="targetThread:needFileInfo">
	<c path="cs.system.threading.Thread"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="frame">
	<c path="cs.system.diagnostics.StackFrame"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="e:skipFrames:fNeedFileInfo">
	<c path="cs.system.Exception"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="e:skipFrames">
	<c path="cs.system.Exception"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="e:fNeedFileInfo">
	<c path="cs.system.Exception"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="e">
	<c path="cs.system.Exception"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="skipFrames:fNeedFileInfo">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="skipFrames">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="fNeedFileInfo">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.StackTrace"</e></m>
		</meta>
	</class>
	<enum path="cs.system.diagnostics.ThreadPriorityLevel" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.ThreadPriorityLevel">
		<Idle><meta><m n=":csNative"><e>-15</e></m></meta></Idle>
		<Lowest><meta><m n=":csNative"><e>-2</e></m></meta></Lowest>
		<BelowNormal><meta><m n=":csNative"><e>-1</e></m></meta></BelowNormal>
		<Normal><meta><m n=":csNative"><e>0</e></m></meta></Normal>
		<AboveNormal><meta><m n=":csNative"><e>1</e></m></meta></AboveNormal>
		<Highest><meta><m n=":csNative"><e>2</e></m></meta></Highest>
		<TimeCritical><meta><m n=":csNative"><e>15</e></m></meta></TimeCritical>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Diagnostics.ThreadPriorityLevel"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.diagnostics.ThreadState" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.ThreadState">
		<Initialized><meta><m n=":csNative"><e>0</e></m></meta></Initialized>
		<Ready><meta><m n=":csNative"><e>1</e></m></meta></Ready>
		<Running><meta><m n=":csNative"><e>2</e></m></meta></Running>
		<Standby><meta><m n=":csNative"><e>3</e></m></meta></Standby>
		<Terminated><meta><m n=":csNative"><e>4</e></m></meta></Terminated>
		<Wait><meta><m n=":csNative"><e>5</e></m></meta></Wait>
		<Transition><meta><m n=":csNative"><e>6</e></m></meta></Transition>
		<Unknown><meta><m n=":csNative"><e>7</e></m></meta></Unknown>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Diagnostics.ThreadState"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.diagnostics.ThreadWaitReason" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.diagnostics.ThreadWaitReason">
		<Executive><meta><m n=":csNative"><e>0</e></m></meta></Executive>
		<FreePage><meta><m n=":csNative"><e>1</e></m></meta></FreePage>
		<PageIn><meta><m n=":csNative"><e>2</e></m></meta></PageIn>
		<SystemAllocation><meta><m n=":csNative"><e>3</e></m></meta></SystemAllocation>
		<ExecutionDelay><meta><m n=":csNative"><e>4</e></m></meta></ExecutionDelay>
		<Suspended><meta><m n=":csNative"><e>5</e></m></meta></Suspended>
		<UserRequest><meta><m n=":csNative"><e>6</e></m></meta></UserRequest>
		<EventPairHigh><meta><m n=":csNative"><e>7</e></m></meta></EventPairHigh>
		<EventPairLow><meta><m n=":csNative"><e>8</e></m></meta></EventPairLow>
		<LpcReceive><meta><m n=":csNative"><e>9</e></m></meta></LpcReceive>
		<LpcReply><meta><m n=":csNative"><e>10</e></m></meta></LpcReply>
		<VirtualMemory><meta><m n=":csNative"><e>11</e></m></meta></VirtualMemory>
		<PageOut><meta><m n=":csNative"><e>12</e></m></meta></PageOut>
		<Unknown><meta><m n=":csNative"><e>13</e></m></meta></Unknown>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Diagnostics.ThreadWaitReason"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.diagnostics.symbolstore.ISymbolDocumentWriter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.diagnostics.symbolstore.ISymbolDocumentWriter" extern="1" interface="1">
		<SetCheckSum public="1" set="method"><f a="algorithmId:checkSum">
	<c path="cs.system.Guid"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetCheckSum>
		<SetSource public="1" set="method"><f a="source">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetSource>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.SymbolStore.ISymbolDocumentWriter"</e></m>
		</meta>
	</class>
	<class path="cs.system.diagnostics.symbolstore.ISymbolWriter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.diagnostics.symbolstore.ISymbolWriter" extern="1" interface="1">
		<Close public="1" set="method"><f a=""><x path="Void"/></f></Close>
		<CloseMethod public="1" set="method"><f a=""><x path="Void"/></f></CloseMethod>
		<CloseNamespace public="1" set="method"><f a=""><x path="Void"/></f></CloseNamespace>
		<CloseScope public="1" set="method"><f a="endOffset">
	<x path="Int"/>
	<x path="Void"/>
</f></CloseScope>
		<DefineDocument public="1" set="method"><f a="url:language:languageVendor:documentType">
	<c path="String"/>
	<c path="cs.system.Guid"/>
	<c path="cs.system.Guid"/>
	<c path="cs.system.Guid"/>
	<c path="cs.system.diagnostics.symbolstore.ISymbolDocumentWriter"/>
</f></DefineDocument>
		<DefineField public="1" set="method"><f a="parent:name:attributes:signature:addrKind:addr1:addr2:addr3">
	<c path="cs.system.diagnostics.symbolstore.SymbolToken"/>
	<c path="String"/>
	<e path="cs.system.reflection.FieldAttributes"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<e path="cs.system.diagnostics.symbolstore.SymAddressKind"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></DefineField>
		<DefineGlobalVariable public="1" set="method"><f a="name:attributes:signature:addrKind:addr1:addr2:addr3">
	<c path="String"/>
	<e path="cs.system.reflection.FieldAttributes"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<e path="cs.system.diagnostics.symbolstore.SymAddressKind"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></DefineGlobalVariable>
		<DefineLocalVariable public="1" set="method"><f a="name:attributes:signature:addrKind:addr1:addr2:addr3:startOffset:endOffset">
	<c path="String"/>
	<e path="cs.system.reflection.FieldAttributes"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<e path="cs.system.diagnostics.symbolstore.SymAddressKind"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></DefineLocalVariable>
		<DefineParameter public="1" set="method"><f a="name:attributes:sequence:addrKind:addr1:addr2:addr3">
	<c path="String"/>
	<e path="cs.system.reflection.ParameterAttributes"/>
	<x path="Int"/>
	<e path="cs.system.diagnostics.symbolstore.SymAddressKind"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></DefineParameter>
		<DefineSequencePoints public="1" set="method"><f a="document:offsets:lines:columns:endLines:endColumns">
	<c path="cs.system.diagnostics.symbolstore.ISymbolDocumentWriter"/>
	<c path="cs.NativeArray"><x path="Int"/></c>
	<c path="cs.NativeArray"><x path="Int"/></c>
	<c path="cs.NativeArray"><x path="Int"/></c>
	<c path="cs.NativeArray"><x path="Int"/></c>
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Void"/>
</f></DefineSequencePoints>
		<Initialize public="1" set="method"><f a="emitter:filename:fFullBuild">
	<c path="cs.system.IntPtr"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></Initialize>
		<OpenMethod public="1" set="method"><f a="method">
	<c path="cs.system.diagnostics.symbolstore.SymbolToken"/>
	<x path="Void"/>
</f></OpenMethod>
		<OpenNamespace public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></OpenNamespace>
		<OpenScope public="1" set="method"><f a="startOffset">
	<x path="Int"/>
	<x path="Int"/>
</f></OpenScope>
		<SetMethodSourceRange public="1" set="method"><f a="startDoc:startLine:startColumn:endDoc:endLine:endColumn">
	<c path="cs.system.diagnostics.symbolstore.ISymbolDocumentWriter"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.diagnostics.symbolstore.ISymbolDocumentWriter"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></SetMethodSourceRange>
		<SetScopeRange public="1" set="method"><f a="scopeID:startOffset:endOffset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></SetScopeRange>
		<SetSymAttribute public="1" set="method"><f a="parent:name:data">
	<c path="cs.system.diagnostics.symbolstore.SymbolToken"/>
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetSymAttribute>
		<SetUnderlyingWriter public="1" set="method"><f a="underlyingWriter">
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></SetUnderlyingWriter>
		<SetUserEntryPoint public="1" set="method"><f a="entryMethod">
	<c path="cs.system.diagnostics.symbolstore.SymbolToken"/>
	<x path="Void"/>
</f></SetUserEntryPoint>
		<UsingNamespace public="1" set="method"><f a="fullName">
	<c path="String"/>
	<x path="Void"/>
</f></UsingNamespace>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.SymbolStore.ISymbolWriter"</e></m>
		</meta>
	</class>
	<enum path="cs.system.diagnostics.symbolstore.SymAddressKind" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.diagnostics.symbolstore.SymAddressKind">
		<ILOffset><meta><m n=":csNative"><e>1</e></m></meta></ILOffset>
		<NativeRVA><meta><m n=":csNative"><e>2</e></m></meta></NativeRVA>
		<NativeRegister><meta><m n=":csNative"><e>3</e></m></meta></NativeRegister>
		<NativeRegisterRelative><meta><m n=":csNative"><e>4</e></m></meta></NativeRegisterRelative>
		<NativeOffset><meta><m n=":csNative"><e>5</e></m></meta></NativeOffset>
		<NativeRegisterRegister><meta><m n=":csNative"><e>6</e></m></meta></NativeRegisterRegister>
		<NativeRegisterStack><meta><m n=":csNative"><e>7</e></m></meta></NativeRegisterStack>
		<NativeStackRegister><meta><m n=":csNative"><e>8</e></m></meta></NativeStackRegister>
		<BitField><meta><m n=":csNative"><e>9</e></m></meta></BitField>
		<NativeSectionOffset><meta><m n=":csNative"><e>10</e></m></meta></NativeSectionOffset>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Diagnostics.SymbolStore.SymAddressKind"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.diagnostics.symbolstore.SymbolToken" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.diagnostics.symbolstore.SymbolToken" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.diagnostics.symbolstore.SymbolToken"/>
	<c path="cs.system.diagnostics.symbolstore.SymbolToken"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.diagnostics.symbolstore.SymbolToken"/>
	<c path="cs.system.diagnostics.symbolstore.SymbolToken"/>
	<x path="Bool"/>
</f></op_Inequality>
		<GetToken final="1" public="1" set="method"><f a=""><x path="Int"/></f></GetToken>
		<new final="1" public="1" set="method"><f a="val">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Diagnostics.SymbolStore.SymbolToken"</e></m>
		</meta>
	</class>
	<class path="cs.system.globalization.Calendar" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.Calendar" extern="1" abstract="1">
		<implements path="cs.system.ICloneable"/>
		<CurrentEra public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":readOnly"/></meta>
		</CurrentEra>
		<ReadOnly public="1" set="method" static="1"><f a="calendar">
	<c path="cs.system.globalization.Calendar"/>
	<c path="cs.system.globalization.Calendar"/>
</f></ReadOnly>
		<TwoDigitYearMax public="1" get="accessor" set="accessor"><x path="Int"/></TwoDigitYearMax>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<MinSupportedDateTime public="1" get="accessor" set="null"><c path="cs.system.DateTime"/></MinSupportedDateTime>
		<MaxSupportedDateTime public="1" get="accessor" set="null"><c path="cs.system.DateTime"/></MaxSupportedDateTime>
		<AlgorithmType public="1" get="accessor" set="null"><e path="cs.system.globalization.CalendarAlgorithmType"/></AlgorithmType>
		<Eras public="1" get="accessor" set="null"><c path="cs.NativeArray"><x path="Int"/></c></Eras>
		<get_Eras abstract="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><x path="Int"/></c></f></get_Eras>
		<get_AlgorithmType public="1" set="method"><f a=""><e path="cs.system.globalization.CalendarAlgorithmType"/></f></get_AlgorithmType>
		<get_MaxSupportedDateTime public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_MaxSupportedDateTime>
		<get_MinSupportedDateTime public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_MinSupportedDateTime>
		<Clone public="1" set="method"><f a=""><d/></f></Clone>
		<GetLeapMonth public="1" set="method">
			<f a="year">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<overloads><GetLeapMonth public="1" set="method"><f a="year:era">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></GetLeapMonth></overloads>
		</GetLeapMonth>
		<get_IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_TwoDigitYearMax public="1" set="method"><f a=""><x path="Int"/></f></get_TwoDigitYearMax>
		<set_TwoDigitYearMax public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_TwoDigitYearMax>
		<AddDays public="1" set="method"><f a="time:days">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
	<c path="cs.system.DateTime"/>
</f></AddDays>
		<AddHours public="1" set="method"><f a="time:hours">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
	<c path="cs.system.DateTime"/>
</f></AddHours>
		<AddMilliseconds public="1" set="method"><f a="time:milliseconds">
	<c path="cs.system.DateTime"/>
	<x path="Float"/>
	<c path="cs.system.DateTime"/>
</f></AddMilliseconds>
		<AddMinutes public="1" set="method"><f a="time:minutes">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
	<c path="cs.system.DateTime"/>
</f></AddMinutes>
		<AddMonths abstract="1" public="1" set="method"><f a="time:months">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
	<c path="cs.system.DateTime"/>
</f></AddMonths>
		<AddSeconds public="1" set="method"><f a="time:seconds">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
	<c path="cs.system.DateTime"/>
</f></AddSeconds>
		<AddWeeks public="1" set="method"><f a="time:weeks">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
	<c path="cs.system.DateTime"/>
</f></AddWeeks>
		<AddYears abstract="1" public="1" set="method"><f a="time:years">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
	<c path="cs.system.DateTime"/>
</f></AddYears>
		<GetDayOfMonth abstract="1" public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
</f></GetDayOfMonth>
		<GetDayOfWeek abstract="1" public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<e path="cs.system.DayOfWeek"/>
</f></GetDayOfWeek>
		<GetDayOfYear abstract="1" public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
</f></GetDayOfYear>
		<GetDaysInMonth public="1" set="method">
			<f a="year:month">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<overloads><GetDaysInMonth abstract="1" public="1" set="method"><f a="year:month:era">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></GetDaysInMonth></overloads>
		</GetDaysInMonth>
		<GetDaysInYear public="1" set="method">
			<f a="year">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<overloads><GetDaysInYear abstract="1" public="1" set="method"><f a="year:era">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></GetDaysInYear></overloads>
		</GetDaysInYear>
		<GetEra abstract="1" public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
</f></GetEra>
		<GetHour public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
</f></GetHour>
		<GetMilliseconds public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<x path="Float"/>
</f></GetMilliseconds>
		<GetMinute public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
</f></GetMinute>
		<GetMonth abstract="1" public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
</f></GetMonth>
		<GetMonthsInYear public="1" set="method">
			<f a="year">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<overloads><GetMonthsInYear abstract="1" public="1" set="method"><f a="year:era">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></GetMonthsInYear></overloads>
		</GetMonthsInYear>
		<GetSecond public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
</f></GetSecond>
		<GetWeekOfYear public="1" set="method"><f a="time:rule:firstDayOfWeek">
	<c path="cs.system.DateTime"/>
	<e path="cs.system.globalization.CalendarWeekRule"/>
	<e path="cs.system.DayOfWeek"/>
	<x path="Int"/>
</f></GetWeekOfYear>
		<GetYear abstract="1" public="1" set="method"><f a="time">
	<c path="cs.system.DateTime"/>
	<x path="Int"/>
</f></GetYear>
		<IsLeapDay public="1" set="method">
			<f a="year:month:day">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><IsLeapDay abstract="1" public="1" set="method"><f a="year:month:day:era">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsLeapDay></overloads>
		</IsLeapDay>
		<IsLeapMonth public="1" set="method">
			<f a="year:month">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><IsLeapMonth abstract="1" public="1" set="method"><f a="year:month:era">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsLeapMonth></overloads>
		</IsLeapMonth>
		<IsLeapYear public="1" set="method">
			<f a="year">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><IsLeapYear abstract="1" public="1" set="method"><f a="year:era">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></IsLeapYear></overloads>
		</IsLeapYear>
		<ToDateTime public="1" set="method">
			<f a="year:month:day:hour:minute:second:millisecond">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cs.system.DateTime"/>
			</f>
			<overloads><ToDateTime abstract="1" public="1" set="method"><f a="year:month:day:hour:minute:second:millisecond:era">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime></overloads>
		</ToDateTime>
		<ToFourDigitYear public="1" set="method"><f a="year">
	<x path="Int"/>
	<x path="Int"/>
</f></ToFourDigitYear>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Globalization.Calendar"</e></m>
		</meta>
	</class>
	<enum path="cs.system.globalization.CalendarAlgorithmType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.CalendarAlgorithmType">
		<Unknown><meta><m n=":csNative"><e>0</e></m></meta></Unknown>
		<SolarCalendar><meta><m n=":csNative"><e>1</e></m></meta></SolarCalendar>
		<LunarCalendar><meta><m n=":csNative"><e>2</e></m></meta></LunarCalendar>
		<LunisolarCalendar><meta><m n=":csNative"><e>3</e></m></meta></LunisolarCalendar>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Globalization.CalendarAlgorithmType"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.globalization.CalendarWeekRule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.CalendarWeekRule">
		<FirstDay><meta><m n=":csNative"><e>0</e></m></meta></FirstDay>
		<FirstFullWeek><meta><m n=":csNative"><e>1</e></m></meta></FirstFullWeek>
		<FirstFourDayWeek><meta><m n=":csNative"><e>2</e></m></meta></FirstFourDayWeek>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Globalization.CalendarWeekRule"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.globalization.CompareInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.CompareInfo" extern="1">
		<implements path="cs.system.runtime.serialization.IDeserializationCallback"/>
		<GetCompareInfo public="1" set="method" static="1">
			<f a="culture">
				<x path="Int"/>
				<c path="cs.system.globalization.CompareInfo"/>
			</f>
			<overloads>
				<GetCompareInfo public="1" set="method"><f a="name:assembly">
	<c path="String"/>
	<c path="cs.system.reflection.Assembly"/>
	<c path="cs.system.globalization.CompareInfo"/>
</f></GetCompareInfo>
				<GetCompareInfo public="1" set="method"><f a="culture:assembly">
	<x path="Int"/>
	<c path="cs.system.reflection.Assembly"/>
	<c path="cs.system.globalization.CompareInfo"/>
</f></GetCompareInfo>
				<GetCompareInfo public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.globalization.CompareInfo"/>
</f></GetCompareInfo>
			</overloads>
		</GetCompareInfo>
		<IsSortable public="1" set="method" static="1">
			<f a="ch">
				<t path="cs.types.Char16"/>
				<x path="Bool"/>
			</f>
			<overloads><IsSortable public="1" set="method"><f a="text">
	<c path="String"/>
	<x path="Bool"/>
</f></IsSortable></overloads>
		</IsSortable>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<LCID public="1" get="accessor" set="null"><x path="Int"/></LCID>
		<Compare public="1" set="method">
			<f a="string1:string2">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<overloads>
				<Compare public="1" set="method"><f a="string1:offset1:length1:string2:offset2:length2:options">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></Compare>
				<Compare public="1" set="method"><f a="string1:offset1:length1:string2:offset2:length2">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Compare>
				<Compare public="1" set="method"><f a="string1:offset1:string2:offset2:options">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></Compare>
				<Compare public="1" set="method"><f a="string1:offset1:string2:offset2">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Compare>
				<Compare public="1" set="method"><f a="string1:string2:options">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></Compare>
			</overloads>
		</Compare>
		<GetSortKey public="1" set="method">
			<f a="source">
				<c path="String"/>
				<c path="cs.system.globalization.SortKey"/>
			</f>
			<overloads><GetSortKey public="1" set="method"><f a="source:options">
	<c path="String"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<c path="cs.system.globalization.SortKey"/>
</f></GetSortKey></overloads>
		</GetSortKey>
		<IndexOf public="1" set="method">
			<f a="source:value">
				<c path="String"/>
				<t path="cs.types.Char16"/>
				<x path="Int"/>
			</f>
			<overloads>
				<IndexOf public="1" set="method"><f a="source:value:startIndex:count:options">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="source:value:startIndex:count:options">
	<c path="String"/>
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="source:value:startIndex:count">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="source:value:startIndex:options">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="source:value:startIndex:count">
	<c path="String"/>
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="source:value:startIndex:options">
	<c path="String"/>
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="source:value:startIndex">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="source:value:options">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="source:value:startIndex">
	<c path="String"/>
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="source:value:options">
	<c path="String"/>
	<t path="cs.types.Char16"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></IndexOf>
				<IndexOf public="1" set="method"><f a="source:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
</f></IndexOf>
			</overloads>
		</IndexOf>
		<IsPrefix public="1" set="method">
			<f a="source:prefix">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<overloads><IsPrefix public="1" set="method"><f a="source:prefix:options">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Bool"/>
</f></IsPrefix></overloads>
		</IsPrefix>
		<IsSuffix public="1" set="method">
			<f a="source:suffix">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<overloads><IsSuffix public="1" set="method"><f a="source:suffix:options">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Bool"/>
</f></IsSuffix></overloads>
		</IsSuffix>
		<LastIndexOf public="1" set="method">
			<f a="source:value">
				<c path="String"/>
				<t path="cs.types.Char16"/>
				<x path="Int"/>
			</f>
			<overloads>
				<LastIndexOf public="1" set="method"><f a="source:value:startIndex:count:options">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="source:value:startIndex:count:options">
	<c path="String"/>
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="source:value:startIndex:count">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="source:value:startIndex:options">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="source:value:startIndex:count">
	<c path="String"/>
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="source:value:startIndex:options">
	<c path="String"/>
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="source:value:startIndex">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="source:value:options">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="source:value:startIndex">
	<c path="String"/>
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="source:value:options">
	<c path="String"/>
	<t path="cs.types.Char16"/>
	<e path="cs.system.globalization.CompareOptions"/>
	<x path="Int"/>
</f></LastIndexOf>
				<LastIndexOf public="1" set="method"><f a="source:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
</f></LastIndexOf>
			</overloads>
		</LastIndexOf>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<get_LCID final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_LCID>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Globalization.CompareInfo"</e></m>
		</meta>
	</class>
	<enum path="cs.system.globalization.CompareOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.CompareOptions">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<IgnoreCase><meta><m n=":csNative"><e>1</e></m></meta></IgnoreCase>
		<IgnoreNonSpace><meta><m n=":csNative"><e>2</e></m></meta></IgnoreNonSpace>
		<IgnoreSymbols><meta><m n=":csNative"><e>4</e></m></meta></IgnoreSymbols>
		<IgnoreKanaType><meta><m n=":csNative"><e>8</e></m></meta></IgnoreKanaType>
		<IgnoreWidth><meta><m n=":csNative"><e>16</e></m></meta></IgnoreWidth>
		<OrdinalIgnoreCase><meta><m n=":csNative"><e>268435456</e></m></meta></OrdinalIgnoreCase>
		<StringSort><meta><m n=":csNative"><e>536870912</e></m></meta></StringSort>
		<Ordinal><meta><m n=":csNative"><e>1073741824</e></m></meta></Ordinal>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Globalization.CompareOptions"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.globalization.CultureInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.CultureInfo" extern="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.IFormatProvider"/>
		<InstalledUICulture public="1" get="accessor" set="null" static="1"><c path="cs.system.globalization.CultureInfo"/></InstalledUICulture>
		<CurrentUICulture public="1" get="accessor" set="null" static="1"><c path="cs.system.globalization.CultureInfo"/></CurrentUICulture>
		<CurrentCulture public="1" get="accessor" set="null" static="1"><c path="cs.system.globalization.CultureInfo"/></CurrentCulture>
		<InvariantCulture public="1" get="accessor" set="null" static="1"><c path="cs.system.globalization.CultureInfo"/></InvariantCulture>
		<get_InvariantCulture public="1" set="method" static="1"><f a=""><c path="cs.system.globalization.CultureInfo"/></f></get_InvariantCulture>
		<CreateSpecificCulture public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<c path="cs.system.globalization.CultureInfo"/>
</f></CreateSpecificCulture>
		<get_CurrentCulture public="1" set="method" static="1"><f a=""><c path="cs.system.globalization.CultureInfo"/></f></get_CurrentCulture>
		<get_CurrentUICulture public="1" set="method" static="1"><f a=""><c path="cs.system.globalization.CultureInfo"/></f></get_CurrentUICulture>
		<GetCultures public="1" set="method" static="1"><f a="types">
	<e path="cs.system.globalization.CultureTypes"/>
	<c path="cs.NativeArray"><c path="cs.system.globalization.CultureInfo"/></c>
</f></GetCultures>
		<ReadOnly public="1" set="method" static="1"><f a="ci">
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.system.globalization.CultureInfo"/>
</f></ReadOnly>
		<get_InstalledUICulture public="1" set="method" static="1"><f a=""><c path="cs.system.globalization.CultureInfo"/></f></get_InstalledUICulture>
		<GetCultureInfo public="1" set="method" static="1">
			<f a="culture">
				<x path="Int"/>
				<c path="cs.system.globalization.CultureInfo"/>
			</f>
			<overloads>
				<GetCultureInfo public="1" set="method"><f a="name:altName">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.globalization.CultureInfo"/>
</f></GetCultureInfo>
				<GetCultureInfo public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.globalization.CultureInfo"/>
</f></GetCultureInfo>
			</overloads>
		</GetCultureInfo>
		<GetCultureInfoByIetfLanguageTag public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<c path="cs.system.globalization.CultureInfo"/>
</f></GetCultureInfoByIetfLanguageTag>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<EnglishName public="1" get="accessor" set="null"><c path="String"/></EnglishName>
		<DisplayName public="1" get="accessor" set="null"><c path="String"/></DisplayName>
		<DateTimeFormat public="1" get="accessor" set="accessor"><c path="cs.system.globalization.DateTimeFormatInfo"/></DateTimeFormat>
		<NumberFormat public="1" get="accessor" set="accessor"><c path="cs.system.globalization.NumberFormatInfo"/></NumberFormat>
		<IsNeutralCulture public="1" get="accessor" set="null"><x path="Bool"/></IsNeutralCulture>
		<CompareInfo public="1" get="accessor" set="null"><c path="cs.system.globalization.CompareInfo"/></CompareInfo>
		<UseUserOverride public="1" get="accessor" set="null"><x path="Bool"/></UseUserOverride>
		<TwoLetterISOLanguageName public="1" get="accessor" set="null"><c path="String"/></TwoLetterISOLanguageName>
		<ThreeLetterWindowsLanguageName public="1" get="accessor" set="null"><c path="String"/></ThreeLetterWindowsLanguageName>
		<ThreeLetterISOLanguageName public="1" get="accessor" set="null"><c path="String"/></ThreeLetterISOLanguageName>
		<TextInfo public="1" get="accessor" set="null"><c path="cs.system.globalization.TextInfo"/></TextInfo>
		<Parent public="1" get="accessor" set="null"><c path="cs.system.globalization.CultureInfo"/></Parent>
		<OptionalCalendars public="1" get="accessor" set="null"><c path="cs.NativeArray"><c path="cs.system.globalization.Calendar"/></c></OptionalCalendars>
		<Calendar public="1" get="accessor" set="null"><c path="cs.system.globalization.Calendar"/></Calendar>
		<NativeName public="1" get="accessor" set="null"><c path="String"/></NativeName>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<LCID public="1" get="accessor" set="null"><x path="Int"/></LCID>
		<KeyboardLayoutId public="1" get="accessor" set="null"><x path="Int"/></KeyboardLayoutId>
		<IetfLanguageTag public="1" get="accessor" set="null"><c path="String"/></IetfLanguageTag>
		<CultureTypes public="1" get="accessor" set="null"><e path="cs.system.globalization.CultureTypes"/></CultureTypes>
		<get_CultureTypes final="1" public="1" set="method"><f a=""><e path="cs.system.globalization.CultureTypes"/></f></get_CultureTypes>
		<GetConsoleFallbackUICulture final="1" public="1" set="method"><f a=""><c path="cs.system.globalization.CultureInfo"/></f></GetConsoleFallbackUICulture>
		<get_IetfLanguageTag final="1" public="1" set="method"><f a=""><c path="String"/></f></get_IetfLanguageTag>
		<get_KeyboardLayoutId public="1" set="method"><f a=""><x path="Int"/></f></get_KeyboardLayoutId>
		<get_LCID public="1" set="method"><f a=""><x path="Int"/></f></get_LCID>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_NativeName public="1" set="method"><f a=""><c path="String"/></f></get_NativeName>
		<get_Calendar public="1" set="method"><f a=""><c path="cs.system.globalization.Calendar"/></f></get_Calendar>
		<get_OptionalCalendars public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.globalization.Calendar"/></c></f></get_OptionalCalendars>
		<get_Parent public="1" set="method"><f a=""><c path="cs.system.globalization.CultureInfo"/></f></get_Parent>
		<get_TextInfo public="1" set="method"><f a=""><c path="cs.system.globalization.TextInfo"/></f></get_TextInfo>
		<get_ThreeLetterISOLanguageName public="1" set="method"><f a=""><c path="String"/></f></get_ThreeLetterISOLanguageName>
		<get_ThreeLetterWindowsLanguageName public="1" set="method"><f a=""><c path="String"/></f></get_ThreeLetterWindowsLanguageName>
		<get_TwoLetterISOLanguageName public="1" set="method"><f a=""><c path="String"/></f></get_TwoLetterISOLanguageName>
		<get_UseUserOverride final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_UseUserOverride>
		<ClearCachedData final="1" public="1" set="method"><f a=""><x path="Void"/></f></ClearCachedData>
		<Clone public="1" set="method"><f a=""><d/></f></Clone>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<get_CompareInfo public="1" set="method"><f a=""><c path="cs.system.globalization.CompareInfo"/></f></get_CompareInfo>
		<get_IsNeutralCulture public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNeutralCulture>
		<get_NumberFormat public="1" set="method"><f a=""><c path="cs.system.globalization.NumberFormatInfo"/></f></get_NumberFormat>
		<set_NumberFormat public="1" set="method"><f a="value">
	<c path="cs.system.globalization.NumberFormatInfo"/>
	<c path="cs.system.globalization.NumberFormatInfo"/>
</f></set_NumberFormat>
		<get_DateTimeFormat public="1" set="method"><f a=""><c path="cs.system.globalization.DateTimeFormatInfo"/></f></get_DateTimeFormat>
		<set_DateTimeFormat public="1" set="method"><f a="value">
	<c path="cs.system.globalization.DateTimeFormatInfo"/>
	<c path="cs.system.globalization.DateTimeFormatInfo"/>
</f></set_DateTimeFormat>
		<get_DisplayName public="1" set="method"><f a=""><c path="String"/></f></get_DisplayName>
		<get_EnglishName public="1" set="method"><f a=""><c path="String"/></f></get_EnglishName>
		<get_IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<GetFormat public="1" set="method"><f a="formatType">
	<c path="cs.system.Type"/>
	<d/>
</f></GetFormat>
		<new final="1" public="1" set="method">
			<f a="culture">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="name:useUserOverride">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="culture:useUserOverride">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Globalization.CultureInfo"</e></m>
		</meta>
	</class>
	<enum path="cs.system.globalization.CultureTypes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.CultureTypes">
		<NeutralCultures><meta><m n=":csNative"><e>1</e></m></meta></NeutralCultures>
		<SpecificCultures><meta><m n=":csNative"><e>2</e></m></meta></SpecificCultures>
		<InstalledWin32Cultures><meta><m n=":csNative"><e>4</e></m></meta></InstalledWin32Cultures>
		<AllCultures><meta><m n=":csNative"><e>7</e></m></meta></AllCultures>
		<UserCustomCulture><meta><m n=":csNative"><e>8</e></m></meta></UserCustomCulture>
		<ReplacementCultures><meta><m n=":csNative"><e>16</e></m></meta></ReplacementCultures>
		<WindowsOnlyCultures><meta><m n=":csNative"><e>32</e></m></meta></WindowsOnlyCultures>
		<FrameworkCultures><meta><m n=":csNative"><e>64</e></m></meta></FrameworkCultures>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Globalization.CultureTypes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.globalization.DateTimeFormatInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.DateTimeFormatInfo" extern="1" final="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.IFormatProvider"/>
		<InvariantInfo public="1" get="accessor" set="null" static="1"><c path="cs.system.globalization.DateTimeFormatInfo"/></InvariantInfo>
		<CurrentInfo public="1" get="accessor" set="null" static="1"><c path="cs.system.globalization.DateTimeFormatInfo"/></CurrentInfo>
		<GetInstance public="1" set="method" static="1"><f a="provider">
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.system.globalization.DateTimeFormatInfo"/>
</f></GetInstance>
		<ReadOnly public="1" set="method" static="1"><f a="dtfi">
	<c path="cs.system.globalization.DateTimeFormatInfo"/>
	<c path="cs.system.globalization.DateTimeFormatInfo"/>
</f></ReadOnly>
		<get_CurrentInfo public="1" set="method" static="1"><f a=""><c path="cs.system.globalization.DateTimeFormatInfo"/></f></get_CurrentInfo>
		<get_InvariantInfo public="1" set="method" static="1"><f a=""><c path="cs.system.globalization.DateTimeFormatInfo"/></f></get_InvariantInfo>
		<ShortestDayNames public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><c path="String"/></c></ShortestDayNames>
		<NativeCalendarName public="1" get="accessor" set="null"><c path="String"/></NativeCalendarName>
		<MonthGenitiveNames public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><c path="String"/></c></MonthGenitiveNames>
		<AbbreviatedMonthGenitiveNames public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><c path="String"/></c></AbbreviatedMonthGenitiveNames>
		<UniversalSortableDateTimePattern public="1" get="accessor" set="null"><c path="String"/></UniversalSortableDateTimePattern>
		<SortableDateTimePattern public="1" get="accessor" set="null"><c path="String"/></SortableDateTimePattern>
		<RFC1123Pattern public="1" get="accessor" set="null"><c path="String"/></RFC1123Pattern>
		<CalendarWeekRule public="1" get="accessor" set="accessor"><e path="cs.system.globalization.CalendarWeekRule"/></CalendarWeekRule>
		<Calendar public="1" get="accessor" set="accessor"><c path="cs.system.globalization.Calendar"/></Calendar>
		<FirstDayOfWeek public="1" get="accessor" set="accessor"><e path="cs.system.DayOfWeek"/></FirstDayOfWeek>
		<FullDateTimePattern public="1" get="accessor" set="accessor"><c path="String"/></FullDateTimePattern>
		<YearMonthPattern public="1" get="accessor" set="accessor"><c path="String"/></YearMonthPattern>
		<MonthDayPattern public="1" get="accessor" set="accessor"><c path="String"/></MonthDayPattern>
		<LongTimePattern public="1" get="accessor" set="accessor"><c path="String"/></LongTimePattern>
		<ShortTimePattern public="1" get="accessor" set="accessor"><c path="String"/></ShortTimePattern>
		<ShortDatePattern public="1" get="accessor" set="accessor"><c path="String"/></ShortDatePattern>
		<LongDatePattern public="1" get="accessor" set="accessor"><c path="String"/></LongDatePattern>
		<TimeSeparator public="1" get="accessor" set="accessor"><c path="String"/></TimeSeparator>
		<DateSeparator public="1" get="accessor" set="accessor"><c path="String"/></DateSeparator>
		<PMDesignator public="1" get="accessor" set="accessor"><c path="String"/></PMDesignator>
		<AMDesignator public="1" get="accessor" set="accessor"><c path="String"/></AMDesignator>
		<MonthNames public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><c path="String"/></c></MonthNames>
		<DayNames public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><c path="String"/></c></DayNames>
		<AbbreviatedMonthNames public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><c path="String"/></c></AbbreviatedMonthNames>
		<AbbreviatedDayNames public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><c path="String"/></c></AbbreviatedDayNames>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<get_IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<Clone final="1" public="1" set="method"><f a=""><d/></f></Clone>
		<GetFormat final="1" public="1" set="method"><f a="formatType">
	<c path="cs.system.Type"/>
	<d/>
</f></GetFormat>
		<GetAbbreviatedEraName final="1" public="1" set="method"><f a="era">
	<x path="Int"/>
	<c path="String"/>
</f></GetAbbreviatedEraName>
		<GetAbbreviatedMonthName final="1" public="1" set="method"><f a="month">
	<x path="Int"/>
	<c path="String"/>
</f></GetAbbreviatedMonthName>
		<GetEra final="1" public="1" set="method"><f a="eraName">
	<c path="String"/>
	<x path="Int"/>
</f></GetEra>
		<GetEraName final="1" public="1" set="method"><f a="era">
	<x path="Int"/>
	<c path="String"/>
</f></GetEraName>
		<GetMonthName final="1" public="1" set="method"><f a="month">
	<x path="Int"/>
	<c path="String"/>
</f></GetMonthName>
		<get_AbbreviatedDayNames final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></get_AbbreviatedDayNames>
		<set_AbbreviatedDayNames final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></set_AbbreviatedDayNames>
		<get_AbbreviatedMonthNames final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></get_AbbreviatedMonthNames>
		<set_AbbreviatedMonthNames final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></set_AbbreviatedMonthNames>
		<get_DayNames final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></get_DayNames>
		<set_DayNames final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></set_DayNames>
		<get_MonthNames final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></get_MonthNames>
		<set_MonthNames final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></set_MonthNames>
		<get_AMDesignator final="1" public="1" set="method"><f a=""><c path="String"/></f></get_AMDesignator>
		<set_AMDesignator final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_AMDesignator>
		<get_PMDesignator final="1" public="1" set="method"><f a=""><c path="String"/></f></get_PMDesignator>
		<set_PMDesignator final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_PMDesignator>
		<get_DateSeparator final="1" public="1" set="method"><f a=""><c path="String"/></f></get_DateSeparator>
		<set_DateSeparator final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_DateSeparator>
		<get_TimeSeparator final="1" public="1" set="method"><f a=""><c path="String"/></f></get_TimeSeparator>
		<set_TimeSeparator final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_TimeSeparator>
		<get_LongDatePattern final="1" public="1" set="method"><f a=""><c path="String"/></f></get_LongDatePattern>
		<set_LongDatePattern final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_LongDatePattern>
		<get_ShortDatePattern final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ShortDatePattern>
		<set_ShortDatePattern final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ShortDatePattern>
		<get_ShortTimePattern final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ShortTimePattern>
		<set_ShortTimePattern final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ShortTimePattern>
		<get_LongTimePattern final="1" public="1" set="method"><f a=""><c path="String"/></f></get_LongTimePattern>
		<set_LongTimePattern final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_LongTimePattern>
		<get_MonthDayPattern final="1" public="1" set="method"><f a=""><c path="String"/></f></get_MonthDayPattern>
		<set_MonthDayPattern final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_MonthDayPattern>
		<get_YearMonthPattern final="1" public="1" set="method"><f a=""><c path="String"/></f></get_YearMonthPattern>
		<set_YearMonthPattern final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_YearMonthPattern>
		<get_FullDateTimePattern final="1" public="1" set="method"><f a=""><c path="String"/></f></get_FullDateTimePattern>
		<set_FullDateTimePattern final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_FullDateTimePattern>
		<get_FirstDayOfWeek final="1" public="1" set="method"><f a=""><e path="cs.system.DayOfWeek"/></f></get_FirstDayOfWeek>
		<set_FirstDayOfWeek final="1" public="1" set="method"><f a="value">
	<e path="cs.system.DayOfWeek"/>
	<e path="cs.system.DayOfWeek"/>
</f></set_FirstDayOfWeek>
		<get_Calendar final="1" public="1" set="method"><f a=""><c path="cs.system.globalization.Calendar"/></f></get_Calendar>
		<set_Calendar final="1" public="1" set="method"><f a="value">
	<c path="cs.system.globalization.Calendar"/>
	<c path="cs.system.globalization.Calendar"/>
</f></set_Calendar>
		<get_CalendarWeekRule final="1" public="1" set="method"><f a=""><e path="cs.system.globalization.CalendarWeekRule"/></f></get_CalendarWeekRule>
		<set_CalendarWeekRule final="1" public="1" set="method"><f a="value">
	<e path="cs.system.globalization.CalendarWeekRule"/>
	<e path="cs.system.globalization.CalendarWeekRule"/>
</f></set_CalendarWeekRule>
		<get_RFC1123Pattern final="1" public="1" set="method"><f a=""><c path="String"/></f></get_RFC1123Pattern>
		<get_SortableDateTimePattern final="1" public="1" set="method"><f a=""><c path="String"/></f></get_SortableDateTimePattern>
		<get_UniversalSortableDateTimePattern final="1" public="1" set="method"><f a=""><c path="String"/></f></get_UniversalSortableDateTimePattern>
		<GetAllDateTimePatterns final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="String"/></c></f>
			<overloads><GetAllDateTimePatterns final="1" public="1" set="method"><f a="format">
	<t path="cs.types.Char16"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetAllDateTimePatterns></overloads>
		</GetAllDateTimePatterns>
		<GetDayName final="1" public="1" set="method"><f a="dayofweek">
	<e path="cs.system.DayOfWeek"/>
	<c path="String"/>
</f></GetDayName>
		<GetAbbreviatedDayName final="1" public="1" set="method"><f a="dayofweek">
	<e path="cs.system.DayOfWeek"/>
	<c path="String"/>
</f></GetAbbreviatedDayName>
		<get_AbbreviatedMonthGenitiveNames final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></get_AbbreviatedMonthGenitiveNames>
		<set_AbbreviatedMonthGenitiveNames final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></set_AbbreviatedMonthGenitiveNames>
		<get_MonthGenitiveNames final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></get_MonthGenitiveNames>
		<set_MonthGenitiveNames final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></set_MonthGenitiveNames>
		<get_NativeCalendarName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_NativeCalendarName>
		<get_ShortestDayNames final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></get_ShortestDayNames>
		<set_ShortestDayNames final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></set_ShortestDayNames>
		<GetShortestDayName final="1" public="1" set="method"><f a="dayOfWeek">
	<e path="cs.system.DayOfWeek"/>
	<c path="String"/>
</f></GetShortestDayName>
		<SetAllDateTimePatterns final="1" public="1" set="method"><f a="patterns:format">
	<c path="cs.NativeArray"><c path="String"/></c>
	<t path="cs.types.Char16"/>
	<x path="Void"/>
</f></SetAllDateTimePatterns>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Globalization.DateTimeFormatInfo"</e></m>
		</meta>
	</class>
	<enum path="cs.system.globalization.DateTimeStyles" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.DateTimeStyles">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<AllowLeadingWhite><meta><m n=":csNative"><e>1</e></m></meta></AllowLeadingWhite>
		<AllowTrailingWhite><meta><m n=":csNative"><e>2</e></m></meta></AllowTrailingWhite>
		<AllowInnerWhite><meta><m n=":csNative"><e>4</e></m></meta></AllowInnerWhite>
		<AllowWhiteSpaces><meta><m n=":csNative"><e>7</e></m></meta></AllowWhiteSpaces>
		<NoCurrentDateDefault><meta><m n=":csNative"><e>8</e></m></meta></NoCurrentDateDefault>
		<AdjustToUniversal><meta><m n=":csNative"><e>16</e></m></meta></AdjustToUniversal>
		<AssumeLocal><meta><m n=":csNative"><e>32</e></m></meta></AssumeLocal>
		<AssumeUniversal><meta><m n=":csNative"><e>64</e></m></meta></AssumeUniversal>
		<RoundtripKind><meta><m n=":csNative"><e>128</e></m></meta></RoundtripKind>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Globalization.DateTimeStyles"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.globalization.DaylightTime" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.DaylightTime" extern="1">
		<Delta public="1" get="accessor" set="null"><c path="cs.system.TimeSpan"/></Delta>
		<End public="1" get="accessor" set="null"><c path="cs.system.DateTime"/></End>
		<Start public="1" get="accessor" set="null"><c path="cs.system.DateTime"/></Start>
		<get_Start final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_Start>
		<get_End final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_End>
		<get_Delta final="1" public="1" set="method"><f a=""><c path="cs.system.TimeSpan"/></f></get_Delta>
		<new final="1" public="1" set="method"><f a="start:end:delta">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
	<c path="cs.system.TimeSpan"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Globalization.DaylightTime"</e></m>
		</meta>
	</class>
	<enum path="cs.system.globalization.DigitShapes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.DigitShapes">
		<Context><meta><m n=":csNative"><e>0</e></m></meta></Context>
		<None><meta><m n=":csNative"><e>1</e></m></meta></None>
		<NativeNational><meta><m n=":csNative"><e>2</e></m></meta></NativeNational>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Globalization.DigitShapes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.globalization.NumberFormatInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.NumberFormatInfo" extern="1" final="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.IFormatProvider"/>
		<InvariantInfo public="1" get="accessor" set="null" static="1"><c path="cs.system.globalization.NumberFormatInfo"/></InvariantInfo>
		<CurrentInfo public="1" get="accessor" set="null" static="1"><c path="cs.system.globalization.NumberFormatInfo"/></CurrentInfo>
		<get_CurrentInfo public="1" set="method" static="1"><f a=""><c path="cs.system.globalization.NumberFormatInfo"/></f></get_CurrentInfo>
		<get_InvariantInfo public="1" set="method" static="1"><f a=""><c path="cs.system.globalization.NumberFormatInfo"/></f></get_InvariantInfo>
		<ReadOnly public="1" set="method" static="1"><f a="nfi">
	<c path="cs.system.globalization.NumberFormatInfo"/>
	<c path="cs.system.globalization.NumberFormatInfo"/>
</f></ReadOnly>
		<GetInstance public="1" set="method" static="1"><f a="formatProvider">
	<c path="cs.system.IFormatProvider"/>
	<c path="cs.system.globalization.NumberFormatInfo"/>
</f></GetInstance>
		<PositiveSign public="1" get="accessor" set="accessor"><c path="String"/></PositiveSign>
		<PositiveInfinitySymbol public="1" get="accessor" set="accessor"><c path="String"/></PositiveInfinitySymbol>
		<PerMilleSymbol public="1" get="accessor" set="accessor"><c path="String"/></PerMilleSymbol>
		<PercentSymbol public="1" get="accessor" set="accessor"><c path="String"/></PercentSymbol>
		<PercentPositivePattern public="1" get="accessor" set="accessor"><x path="Int"/></PercentPositivePattern>
		<PercentNegativePattern public="1" get="accessor" set="accessor"><x path="Int"/></PercentNegativePattern>
		<PercentGroupSizes public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><x path="Int"/></c></PercentGroupSizes>
		<PercentGroupSeparator public="1" get="accessor" set="accessor"><c path="String"/></PercentGroupSeparator>
		<PercentDecimalSeparator public="1" get="accessor" set="accessor"><c path="String"/></PercentDecimalSeparator>
		<PercentDecimalDigits public="1" get="accessor" set="accessor"><x path="Int"/></PercentDecimalDigits>
		<NumberNegativePattern public="1" get="accessor" set="accessor"><x path="Int"/></NumberNegativePattern>
		<NumberGroupSizes public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><x path="Int"/></c></NumberGroupSizes>
		<NumberGroupSeparator public="1" get="accessor" set="accessor"><c path="String"/></NumberGroupSeparator>
		<NumberDecimalSeparator public="1" get="accessor" set="accessor"><c path="String"/></NumberDecimalSeparator>
		<NumberDecimalDigits public="1" get="accessor" set="accessor"><x path="Int"/></NumberDecimalDigits>
		<NegativeSign public="1" get="accessor" set="accessor"><c path="String"/></NegativeSign>
		<NegativeInfinitySymbol public="1" get="accessor" set="accessor"><c path="String"/></NegativeInfinitySymbol>
		<DigitSubstitution public="1" get="accessor" set="accessor"><e path="cs.system.globalization.DigitShapes"/></DigitSubstitution>
		<NativeDigits public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><c path="String"/></c></NativeDigits>
		<NaNSymbol public="1" get="accessor" set="accessor"><c path="String"/></NaNSymbol>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<CurrencySymbol public="1" get="accessor" set="accessor"><c path="String"/></CurrencySymbol>
		<CurrencyPositivePattern public="1" get="accessor" set="accessor"><x path="Int"/></CurrencyPositivePattern>
		<CurrencyNegativePattern public="1" get="accessor" set="accessor"><x path="Int"/></CurrencyNegativePattern>
		<CurrencyGroupSizes public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><x path="Int"/></c></CurrencyGroupSizes>
		<CurrencyGroupSeparator public="1" get="accessor" set="accessor"><c path="String"/></CurrencyGroupSeparator>
		<CurrencyDecimalSeparator public="1" get="accessor" set="accessor"><c path="String"/></CurrencyDecimalSeparator>
		<CurrencyDecimalDigits public="1" get="accessor" set="accessor"><x path="Int"/></CurrencyDecimalDigits>
		<get_CurrencyDecimalDigits final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_CurrencyDecimalDigits>
		<set_CurrencyDecimalDigits final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_CurrencyDecimalDigits>
		<get_CurrencyDecimalSeparator final="1" public="1" set="method"><f a=""><c path="String"/></f></get_CurrencyDecimalSeparator>
		<set_CurrencyDecimalSeparator final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_CurrencyDecimalSeparator>
		<get_CurrencyGroupSeparator final="1" public="1" set="method"><f a=""><c path="String"/></f></get_CurrencyGroupSeparator>
		<set_CurrencyGroupSeparator final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_CurrencyGroupSeparator>
		<get_CurrencyGroupSizes final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><x path="Int"/></c></f></get_CurrencyGroupSizes>
		<set_CurrencyGroupSizes final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<c path="cs.NativeArray"><x path="Int"/></c>
</f></set_CurrencyGroupSizes>
		<get_CurrencyNegativePattern final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_CurrencyNegativePattern>
		<set_CurrencyNegativePattern final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_CurrencyNegativePattern>
		<get_CurrencyPositivePattern final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_CurrencyPositivePattern>
		<set_CurrencyPositivePattern final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_CurrencyPositivePattern>
		<get_CurrencySymbol final="1" public="1" set="method"><f a=""><c path="String"/></f></get_CurrencySymbol>
		<set_CurrencySymbol final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_CurrencySymbol>
		<get_IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_NaNSymbol final="1" public="1" set="method"><f a=""><c path="String"/></f></get_NaNSymbol>
		<set_NaNSymbol final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_NaNSymbol>
		<get_NativeDigits final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></get_NativeDigits>
		<set_NativeDigits final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></set_NativeDigits>
		<get_DigitSubstitution final="1" public="1" set="method"><f a=""><e path="cs.system.globalization.DigitShapes"/></f></get_DigitSubstitution>
		<set_DigitSubstitution final="1" public="1" set="method"><f a="value">
	<e path="cs.system.globalization.DigitShapes"/>
	<e path="cs.system.globalization.DigitShapes"/>
</f></set_DigitSubstitution>
		<get_NegativeInfinitySymbol final="1" public="1" set="method"><f a=""><c path="String"/></f></get_NegativeInfinitySymbol>
		<set_NegativeInfinitySymbol final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_NegativeInfinitySymbol>
		<get_NegativeSign final="1" public="1" set="method"><f a=""><c path="String"/></f></get_NegativeSign>
		<set_NegativeSign final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_NegativeSign>
		<get_NumberDecimalDigits final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_NumberDecimalDigits>
		<set_NumberDecimalDigits final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_NumberDecimalDigits>
		<get_NumberDecimalSeparator final="1" public="1" set="method"><f a=""><c path="String"/></f></get_NumberDecimalSeparator>
		<set_NumberDecimalSeparator final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_NumberDecimalSeparator>
		<get_NumberGroupSeparator final="1" public="1" set="method"><f a=""><c path="String"/></f></get_NumberGroupSeparator>
		<set_NumberGroupSeparator final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_NumberGroupSeparator>
		<get_NumberGroupSizes final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><x path="Int"/></c></f></get_NumberGroupSizes>
		<set_NumberGroupSizes final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<c path="cs.NativeArray"><x path="Int"/></c>
</f></set_NumberGroupSizes>
		<get_NumberNegativePattern final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_NumberNegativePattern>
		<set_NumberNegativePattern final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_NumberNegativePattern>
		<get_PercentDecimalDigits final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_PercentDecimalDigits>
		<set_PercentDecimalDigits final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_PercentDecimalDigits>
		<get_PercentDecimalSeparator final="1" public="1" set="method"><f a=""><c path="String"/></f></get_PercentDecimalSeparator>
		<set_PercentDecimalSeparator final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_PercentDecimalSeparator>
		<get_PercentGroupSeparator final="1" public="1" set="method"><f a=""><c path="String"/></f></get_PercentGroupSeparator>
		<set_PercentGroupSeparator final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_PercentGroupSeparator>
		<get_PercentGroupSizes final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><x path="Int"/></c></f></get_PercentGroupSizes>
		<set_PercentGroupSizes final="1" public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<c path="cs.NativeArray"><x path="Int"/></c>
</f></set_PercentGroupSizes>
		<get_PercentNegativePattern final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_PercentNegativePattern>
		<set_PercentNegativePattern final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_PercentNegativePattern>
		<get_PercentPositivePattern final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_PercentPositivePattern>
		<set_PercentPositivePattern final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_PercentPositivePattern>
		<get_PercentSymbol final="1" public="1" set="method"><f a=""><c path="String"/></f></get_PercentSymbol>
		<set_PercentSymbol final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_PercentSymbol>
		<get_PerMilleSymbol final="1" public="1" set="method"><f a=""><c path="String"/></f></get_PerMilleSymbol>
		<set_PerMilleSymbol final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_PerMilleSymbol>
		<get_PositiveInfinitySymbol final="1" public="1" set="method"><f a=""><c path="String"/></f></get_PositiveInfinitySymbol>
		<set_PositiveInfinitySymbol final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_PositiveInfinitySymbol>
		<get_PositiveSign final="1" public="1" set="method"><f a=""><c path="String"/></f></get_PositiveSign>
		<set_PositiveSign final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_PositiveSign>
		<GetFormat final="1" public="1" set="method"><f a="formatType">
	<c path="cs.system.Type"/>
	<d/>
</f></GetFormat>
		<Clone final="1" public="1" set="method"><f a=""><d/></f></Clone>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Globalization.NumberFormatInfo"</e></m>
		</meta>
	</class>
	<enum path="cs.system.globalization.NumberStyles" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.NumberStyles">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<AllowLeadingWhite><meta><m n=":csNative"><e>1</e></m></meta></AllowLeadingWhite>
		<AllowTrailingWhite><meta><m n=":csNative"><e>2</e></m></meta></AllowTrailingWhite>
		<AllowLeadingSign><meta><m n=":csNative"><e>4</e></m></meta></AllowLeadingSign>
		<Integer><meta><m n=":csNative"><e>7</e></m></meta></Integer>
		<AllowTrailingSign><meta><m n=":csNative"><e>8</e></m></meta></AllowTrailingSign>
		<AllowParentheses><meta><m n=":csNative"><e>16</e></m></meta></AllowParentheses>
		<AllowDecimalPoint><meta><m n=":csNative"><e>32</e></m></meta></AllowDecimalPoint>
		<AllowThousands><meta><m n=":csNative"><e>64</e></m></meta></AllowThousands>
		<Number><meta><m n=":csNative"><e>111</e></m></meta></Number>
		<AllowExponent><meta><m n=":csNative"><e>128</e></m></meta></AllowExponent>
		<Float><meta><m n=":csNative"><e>167</e></m></meta></Float>
		<AllowCurrencySymbol><meta><m n=":csNative"><e>256</e></m></meta></AllowCurrencySymbol>
		<Currency><meta><m n=":csNative"><e>383</e></m></meta></Currency>
		<Any><meta><m n=":csNative"><e>511</e></m></meta></Any>
		<AllowHexSpecifier><meta><m n=":csNative"><e>512</e></m></meta></AllowHexSpecifier>
		<HexNumber><meta><m n=":csNative"><e>515</e></m></meta></HexNumber>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Globalization.NumberStyles"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.globalization.SortKey" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.SortKey" extern="1">
		<Compare public="1" set="method" static="1"><f a="sortkey1:sortkey2">
	<c path="cs.system.globalization.SortKey"/>
	<c path="cs.system.globalization.SortKey"/>
	<x path="Int"/>
</f></Compare>
		<KeyData public="1" get="accessor" set="null"><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></KeyData>
		<OriginalString public="1" get="accessor" set="null"><c path="String"/></OriginalString>
		<get_OriginalString public="1" set="method"><f a=""><c path="String"/></f></get_OriginalString>
		<get_KeyData public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></get_KeyData>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Globalization.SortKey"</e></m>
		</meta>
	</class>
	<class path="cs.system.globalization.TextInfo_Data" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.TextInfo" module="cs.system.globalization.TextInfo" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<list_sep public="1"><t path="cs.types.UInt8"/></list_sep>
		<oem public="1"><x path="Int"/></oem>
		<mac public="1"><x path="Int"/></mac>
		<ebcdic public="1"><x path="Int"/></ebcdic>
		<ansi public="1"><x path="Int"/></ansi>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Globalization.TextInfo.Data"</e></m>
		</meta>
	</class>
	<class path="cs.system.globalization.TextInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.TextInfo" extern="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.runtime.serialization.IDeserializationCallback"/>
		<ReadOnly public="1" set="method" static="1"><f a="textInfo">
	<c path="cs.system.globalization.TextInfo"/>
	<c path="cs.system.globalization.TextInfo"/>
</f></ReadOnly>
		<IsRightToLeft public="1" get="accessor" set="null"><x path="Bool"/></IsRightToLeft>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<CultureName public="1" get="accessor" set="null"><c path="String"/></CultureName>
		<OEMCodePage public="1" get="accessor" set="null"><x path="Int"/></OEMCodePage>
		<MacCodePage public="1" get="accessor" set="null"><x path="Int"/></MacCodePage>
		<ListSeparator public="1" get="accessor" set="accessor"><c path="String"/></ListSeparator>
		<LCID public="1" get="accessor" set="null"><x path="Int"/></LCID>
		<EBCDICCodePage public="1" get="accessor" set="null"><x path="Int"/></EBCDICCodePage>
		<ANSICodePage public="1" get="accessor" set="null"><x path="Int"/></ANSICodePage>
		<get_ANSICodePage public="1" set="method"><f a=""><x path="Int"/></f></get_ANSICodePage>
		<get_EBCDICCodePage public="1" set="method"><f a=""><x path="Int"/></f></get_EBCDICCodePage>
		<get_LCID final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_LCID>
		<get_ListSeparator public="1" set="method"><f a=""><c path="String"/></f></get_ListSeparator>
		<set_ListSeparator public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_ListSeparator>
		<get_MacCodePage public="1" set="method"><f a=""><x path="Int"/></f></get_MacCodePage>
		<get_OEMCodePage public="1" set="method"><f a=""><x path="Int"/></f></get_OEMCodePage>
		<get_CultureName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_CultureName>
		<get_IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_IsRightToLeft final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsRightToLeft>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<ToTitleCase final="1" public="1" set="method"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></ToTitleCase>
		<ToLower public="1" set="method">
			<f a="c">
				<t path="cs.types.Char16"/>
				<t path="cs.types.Char16"/>
			</f>
			<overloads><ToLower public="1" set="method"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></ToLower></overloads>
		</ToLower>
		<ToUpper public="1" set="method">
			<f a="c">
				<t path="cs.types.Char16"/>
				<t path="cs.types.Char16"/>
			</f>
			<overloads><ToUpper public="1" set="method"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></ToUpper></overloads>
		</ToUpper>
		<Clone public="1" set="method"><f a=""><d/></f></Clone>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Globalization.TextInfo"</e></m>
		</meta>
	</class>
	<enum path="cs.system.globalization.UnicodeCategory" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.globalization.UnicodeCategory">
		<UppercaseLetter><meta><m n=":csNative"><e>0</e></m></meta></UppercaseLetter>
		<LowercaseLetter><meta><m n=":csNative"><e>1</e></m></meta></LowercaseLetter>
		<TitlecaseLetter><meta><m n=":csNative"><e>2</e></m></meta></TitlecaseLetter>
		<ModifierLetter><meta><m n=":csNative"><e>3</e></m></meta></ModifierLetter>
		<OtherLetter><meta><m n=":csNative"><e>4</e></m></meta></OtherLetter>
		<NonSpacingMark><meta><m n=":csNative"><e>5</e></m></meta></NonSpacingMark>
		<SpacingCombiningMark><meta><m n=":csNative"><e>6</e></m></meta></SpacingCombiningMark>
		<EnclosingMark><meta><m n=":csNative"><e>7</e></m></meta></EnclosingMark>
		<DecimalDigitNumber><meta><m n=":csNative"><e>8</e></m></meta></DecimalDigitNumber>
		<LetterNumber><meta><m n=":csNative"><e>9</e></m></meta></LetterNumber>
		<OtherNumber><meta><m n=":csNative"><e>10</e></m></meta></OtherNumber>
		<SpaceSeparator><meta><m n=":csNative"><e>11</e></m></meta></SpaceSeparator>
		<LineSeparator><meta><m n=":csNative"><e>12</e></m></meta></LineSeparator>
		<ParagraphSeparator><meta><m n=":csNative"><e>13</e></m></meta></ParagraphSeparator>
		<Control><meta><m n=":csNative"><e>14</e></m></meta></Control>
		<Format><meta><m n=":csNative"><e>15</e></m></meta></Format>
		<Surrogate><meta><m n=":csNative"><e>16</e></m></meta></Surrogate>
		<PrivateUse><meta><m n=":csNative"><e>17</e></m></meta></PrivateUse>
		<ConnectorPunctuation><meta><m n=":csNative"><e>18</e></m></meta></ConnectorPunctuation>
		<DashPunctuation><meta><m n=":csNative"><e>19</e></m></meta></DashPunctuation>
		<OpenPunctuation><meta><m n=":csNative"><e>20</e></m></meta></OpenPunctuation>
		<ClosePunctuation><meta><m n=":csNative"><e>21</e></m></meta></ClosePunctuation>
		<InitialQuotePunctuation><meta><m n=":csNative"><e>22</e></m></meta></InitialQuotePunctuation>
		<FinalQuotePunctuation><meta><m n=":csNative"><e>23</e></m></meta></FinalQuotePunctuation>
		<OtherPunctuation><meta><m n=":csNative"><e>24</e></m></meta></OtherPunctuation>
		<MathSymbol><meta><m n=":csNative"><e>25</e></m></meta></MathSymbol>
		<CurrencySymbol><meta><m n=":csNative"><e>26</e></m></meta></CurrencySymbol>
		<ModifierSymbol><meta><m n=":csNative"><e>27</e></m></meta></ModifierSymbol>
		<OtherSymbol><meta><m n=":csNative"><e>28</e></m></meta></OtherSymbol>
		<OtherNotAssigned><meta><m n=":csNative"><e>29</e></m></meta></OtherNotAssigned>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Globalization.UnicodeCategory"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.io.Directory" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.Directory" extern="1" final="1">
		<CreateDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="cs.system.io.DirectoryInfo"/>
			</f>
			<overloads><CreateDirectory public="1" set="method"><f a="path:directorySecurity">
	<c path="String"/>
	<c path="cs.system.security.accesscontrol.DirectorySecurity"/>
	<c path="cs.system.io.DirectoryInfo"/>
</f></CreateDirectory></overloads>
		</CreateDirectory>
		<Delete public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><Delete public="1" set="method"><f a="path:recursive">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></Delete></overloads>
		</Delete>
		<Exists public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></Exists>
		<GetLastAccessTime public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetLastAccessTime>
		<GetLastAccessTimeUtc public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetLastAccessTimeUtc>
		<GetLastWriteTime public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetLastWriteTime>
		<GetLastWriteTimeUtc public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetLastWriteTimeUtc>
		<GetCreationTime public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetCreationTime>
		<GetCreationTimeUtc public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetCreationTimeUtc>
		<GetCurrentDirectory public="1" set="method" static="1"><f a=""><c path="String"/></f></GetCurrentDirectory>
		<GetDirectories public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="cs.NativeArray"><c path="String"/></c>
			</f>
			<overloads>
				<GetDirectories public="1" set="method"><f a="path:searchPattern:searchOption">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.io.SearchOption"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetDirectories>
				<GetDirectories public="1" set="method"><f a="path:searchPattern">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetDirectories>
			</overloads>
		</GetDirectories>
		<GetDirectoryRoot public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></GetDirectoryRoot>
		<GetFiles public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="cs.NativeArray"><c path="String"/></c>
			</f>
			<overloads>
				<GetFiles public="1" set="method"><f a="path:searchPattern:searchOption">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.io.SearchOption"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetFiles>
				<GetFiles public="1" set="method"><f a="path:searchPattern">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetFiles>
			</overloads>
		</GetFiles>
		<GetFileSystemEntries public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="cs.NativeArray"><c path="String"/></c>
			</f>
			<overloads><GetFileSystemEntries public="1" set="method"><f a="path:searchPattern">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></GetFileSystemEntries></overloads>
		</GetFileSystemEntries>
		<GetLogicalDrives public="1" set="method" static="1"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></GetLogicalDrives>
		<GetParent public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.io.DirectoryInfo"/>
</f></GetParent>
		<Move public="1" set="method" static="1"><f a="sourceDirName:destDirName">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></Move>
		<SetAccessControl public="1" set="method" static="1"><f a="path:directorySecurity">
	<c path="String"/>
	<c path="cs.system.security.accesscontrol.DirectorySecurity"/>
	<x path="Void"/>
</f></SetAccessControl>
		<SetCreationTime public="1" set="method" static="1"><f a="path:creationTime">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></SetCreationTime>
		<SetCreationTimeUtc public="1" set="method" static="1"><f a="path:creationTimeUtc">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></SetCreationTimeUtc>
		<SetCurrentDirectory public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></SetCurrentDirectory>
		<SetLastAccessTime public="1" set="method" static="1"><f a="path:lastAccessTime">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></SetLastAccessTime>
		<SetLastAccessTimeUtc public="1" set="method" static="1"><f a="path:lastAccessTimeUtc">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></SetLastAccessTimeUtc>
		<SetLastWriteTime public="1" set="method" static="1"><f a="path:lastWriteTime">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></SetLastWriteTime>
		<SetLastWriteTimeUtc public="1" set="method" static="1"><f a="path:lastWriteTimeUtc">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></SetLastWriteTimeUtc>
		<GetAccessControl public="1" set="method" static="1">
			<f a="path:includeSections">
				<c path="String"/>
				<e path="cs.system.security.accesscontrol.AccessControlSections"/>
				<c path="cs.system.security.accesscontrol.DirectorySecurity"/>
			</f>
			<overloads><GetAccessControl public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="cs.system.security.accesscontrol.DirectorySecurity"/>
</f></GetAccessControl></overloads>
		</GetAccessControl>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.Directory"</e></m>
		</meta>
	</class>
	<class path="cs.system.io.FileSystemInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileSystemInfo" extern="1" abstract="1">
		<extends path="cs.system.MarshalByRefObject"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<LastWriteTimeUtc public="1" get="accessor" set="accessor"><c path="cs.system.DateTime"/></LastWriteTimeUtc>
		<LastWriteTime public="1" get="accessor" set="accessor"><c path="cs.system.DateTime"/></LastWriteTime>
		<LastAccessTimeUtc public="1" get="accessor" set="accessor"><c path="cs.system.DateTime"/></LastAccessTimeUtc>
		<LastAccessTime public="1" get="accessor" set="accessor"><c path="cs.system.DateTime"/></LastAccessTime>
		<CreationTimeUtc public="1" get="accessor" set="accessor"><c path="cs.system.DateTime"/></CreationTimeUtc>
		<CreationTime public="1" get="accessor" set="accessor"><c path="cs.system.DateTime"/></CreationTime>
		<Attributes public="1" get="accessor" set="accessor"><e path="cs.system.io.FileAttributes"/></Attributes>
		<Extension public="1" get="accessor" set="null"><c path="String"/></Extension>
		<FullName public="1" get="accessor" set="null"><c path="String"/></FullName>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<Exists public="1" get="accessor" set="null"><x path="Bool"/></Exists>
		<OriginalPath><c path="String"/></OriginalPath>
		<FullPath><c path="String"/></FullPath>
		<GetObjectData public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<get_Exists abstract="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_Exists>
		<get_Name abstract="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_FullName public="1" set="method"><f a=""><c path="String"/></f></get_FullName>
		<get_Extension final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Extension>
		<get_Attributes final="1" public="1" set="method"><f a=""><e path="cs.system.io.FileAttributes"/></f></get_Attributes>
		<set_Attributes final="1" public="1" set="method"><f a="value">
	<e path="cs.system.io.FileAttributes"/>
	<e path="cs.system.io.FileAttributes"/>
</f></set_Attributes>
		<get_CreationTime final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_CreationTime>
		<set_CreationTime final="1" public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
</f></set_CreationTime>
		<get_CreationTimeUtc final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_CreationTimeUtc>
		<set_CreationTimeUtc final="1" public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
</f></set_CreationTimeUtc>
		<get_LastAccessTime final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_LastAccessTime>
		<set_LastAccessTime final="1" public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
</f></set_LastAccessTime>
		<get_LastAccessTimeUtc final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_LastAccessTimeUtc>
		<set_LastAccessTimeUtc final="1" public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
</f></set_LastAccessTimeUtc>
		<get_LastWriteTime final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_LastWriteTime>
		<set_LastWriteTime final="1" public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
</f></set_LastWriteTime>
		<get_LastWriteTimeUtc final="1" public="1" set="method"><f a=""><c path="cs.system.DateTime"/></f></get_LastWriteTimeUtc>
		<set_LastWriteTimeUtc final="1" public="1" set="method"><f a="value">
	<c path="cs.system.DateTime"/>
	<c path="cs.system.DateTime"/>
</f></set_LastWriteTimeUtc>
		<Delete abstract="1" public="1" set="method"><f a=""><x path="Void"/></f></Delete>
		<Refresh final="1" public="1" set="method"><f a=""><x path="Void"/></f></Refresh>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
			<overloads><new final="1" set="method">
	<f a="info:context">
		<c path="cs.system.runtime.serialization.SerializationInfo"/>
		<c path="cs.system.runtime.serialization.StreamingContext"/>
		<x path="Void"/>
	</f>
	<meta><m n=":protected"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.FileSystemInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.io.DirectoryInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.DirectoryInfo" extern="1" final="1">
		<extends path="cs.system.io.FileSystemInfo"/>
		<Root public="1" get="accessor" set="null"><c path="cs.system.io.DirectoryInfo"/></Root>
		<Parent public="1" get="accessor" set="null"><c path="cs.system.io.DirectoryInfo"/></Parent>
		<Name public="1" get="accessor" set="null" override="1"><c path="String"/></Name>
		<Exists public="1" get="accessor" set="null" override="1"><x path="Bool"/></Exists>
		<get_Exists public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_Exists>
		<get_Name public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Name>
		<get_Parent final="1" public="1" set="method"><f a=""><c path="cs.system.io.DirectoryInfo"/></f></get_Parent>
		<get_Root final="1" public="1" set="method"><f a=""><c path="cs.system.io.DirectoryInfo"/></f></get_Root>
		<Create final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><Create final="1" public="1" set="method"><f a="directorySecurity">
	<c path="cs.system.security.accesscontrol.DirectorySecurity"/>
	<x path="Void"/>
</f></Create></overloads>
		</Create>
		<CreateSubdirectory final="1" public="1" set="method">
			<f a="path">
				<c path="String"/>
				<c path="cs.system.io.DirectoryInfo"/>
			</f>
			<overloads><CreateSubdirectory final="1" public="1" set="method"><f a="path:directorySecurity">
	<c path="String"/>
	<c path="cs.system.security.accesscontrol.DirectorySecurity"/>
	<c path="cs.system.io.DirectoryInfo"/>
</f></CreateSubdirectory></overloads>
		</CreateSubdirectory>
		<GetFiles final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.io.FileInfo"/></c></f>
			<overloads>
				<GetFiles final="1" public="1" set="method"><f a="searchPattern:searchOption">
	<c path="String"/>
	<e path="cs.system.io.SearchOption"/>
	<c path="cs.NativeArray"><c path="cs.system.io.FileInfo"/></c>
</f></GetFiles>
				<GetFiles final="1" public="1" set="method"><f a="searchPattern">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="cs.system.io.FileInfo"/></c>
</f></GetFiles>
			</overloads>
		</GetFiles>
		<GetDirectories final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.io.DirectoryInfo"/></c></f>
			<overloads>
				<GetDirectories final="1" public="1" set="method"><f a="searchPattern:searchOption">
	<c path="String"/>
	<e path="cs.system.io.SearchOption"/>
	<c path="cs.NativeArray"><c path="cs.system.io.DirectoryInfo"/></c>
</f></GetDirectories>
				<GetDirectories final="1" public="1" set="method"><f a="searchPattern">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="cs.system.io.DirectoryInfo"/></c>
</f></GetDirectories>
			</overloads>
		</GetDirectories>
		<GetFileSystemInfos final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.io.FileSystemInfo"/></c></f>
			<overloads><GetFileSystemInfos final="1" public="1" set="method"><f a="searchPattern">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="cs.system.io.FileSystemInfo"/></c>
</f></GetFileSystemInfos></overloads>
		</GetFileSystemInfos>
		<Delete public="1" set="method" override="1">
			<f a=""><x path="Void"/></f>
			<overloads><Delete final="1" public="1" set="method"><f a="recursive">
	<x path="Bool"/>
	<x path="Void"/>
</f></Delete></overloads>
		</Delete>
		<MoveTo final="1" public="1" set="method"><f a="destDirName">
	<c path="String"/>
	<x path="Void"/>
</f></MoveTo>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<GetAccessControl final="1" public="1" set="method">
			<f a=""><c path="cs.system.security.accesscontrol.DirectorySecurity"/></f>
			<overloads><GetAccessControl final="1" public="1" set="method"><f a="includeSections">
	<e path="cs.system.security.accesscontrol.AccessControlSections"/>
	<c path="cs.system.security.accesscontrol.DirectorySecurity"/>
</f></GetAccessControl></overloads>
		</GetAccessControl>
		<SetAccessControl final="1" public="1" set="method"><f a="directorySecurity">
	<c path="cs.system.security.accesscontrol.DirectorySecurity"/>
	<x path="Void"/>
</f></SetAccessControl>
		<new final="1" public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.DirectoryInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.io.File" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.File" extern="1" final="1">
		<AppendAllText public="1" set="method" static="1">
			<f a="path:contents">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><AppendAllText public="1" set="method"><f a="path:contents:encoding">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.text.Encoding"/>
	<x path="Void"/>
</f></AppendAllText></overloads>
		</AppendAllText>
		<AppendText public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.io.StreamWriter"/>
</f></AppendText>
		<Copy public="1" set="method" static="1">
			<f a="sourceFileName:destFileName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><Copy public="1" set="method"><f a="sourceFileName:destFileName:overwrite">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></Copy></overloads>
		</Copy>
		<Create public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="cs.system.io.FileStream"/>
			</f>
			<overloads>
				<Create public="1" set="method"><f a="path:bufferSize:options:fileSecurity">
	<c path="String"/>
	<x path="Int"/>
	<e path="cs.system.io.FileOptions"/>
	<c path="cs.system.security.accesscontrol.FileSecurity"/>
	<c path="cs.system.io.FileStream"/>
</f></Create>
				<Create public="1" set="method"><f a="path:bufferSize:options">
	<c path="String"/>
	<x path="Int"/>
	<e path="cs.system.io.FileOptions"/>
	<c path="cs.system.io.FileStream"/>
</f></Create>
				<Create public="1" set="method"><f a="path:bufferSize">
	<c path="String"/>
	<x path="Int"/>
	<c path="cs.system.io.FileStream"/>
</f></Create>
			</overloads>
		</Create>
		<CreateText public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.io.StreamWriter"/>
</f></CreateText>
		<Delete public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></Delete>
		<Exists public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></Exists>
		<GetAccessControl public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="cs.system.security.accesscontrol.FileSecurity"/>
			</f>
			<overloads><GetAccessControl public="1" set="method"><f a="path:includeSections">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.AccessControlSections"/>
	<c path="cs.system.security.accesscontrol.FileSecurity"/>
</f></GetAccessControl></overloads>
		</GetAccessControl>
		<GetAttributes public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<e path="cs.system.io.FileAttributes"/>
</f></GetAttributes>
		<GetCreationTime public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetCreationTime>
		<GetCreationTimeUtc public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetCreationTimeUtc>
		<GetLastAccessTime public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetLastAccessTime>
		<GetLastAccessTimeUtc public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetLastAccessTimeUtc>
		<GetLastWriteTime public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetLastWriteTime>
		<GetLastWriteTimeUtc public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetLastWriteTimeUtc>
		<Move public="1" set="method" static="1"><f a="sourceFileName:destFileName">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></Move>
		<Open public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<e path="cs.system.io.FileMode"/>
				<c path="cs.system.io.FileStream"/>
			</f>
			<overloads>
				<Open public="1" set="method"><f a="path:mode:access:share">
	<c path="String"/>
	<e path="cs.system.io.FileMode"/>
	<e path="cs.system.io.FileAccess"/>
	<e path="cs.system.io.FileShare"/>
	<c path="cs.system.io.FileStream"/>
</f></Open>
				<Open public="1" set="method"><f a="path:mode:access">
	<c path="String"/>
	<e path="cs.system.io.FileMode"/>
	<e path="cs.system.io.FileAccess"/>
	<c path="cs.system.io.FileStream"/>
</f></Open>
			</overloads>
		</Open>
		<OpenRead public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.io.FileStream"/>
</f></OpenRead>
		<OpenText public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.io.StreamReader"/>
</f></OpenText>
		<OpenWrite public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.system.io.FileStream"/>
</f></OpenWrite>
		<Replace public="1" set="method" static="1">
			<f a="sourceFileName:destinationFileName:destinationBackupFileName">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><Replace public="1" set="method"><f a="sourceFileName:destinationFileName:destinationBackupFileName:ignoreMetadataErrors">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></Replace></overloads>
		</Replace>
		<SetAccessControl public="1" set="method" static="1"><f a="path:fileSecurity">
	<c path="String"/>
	<c path="cs.system.security.accesscontrol.FileSecurity"/>
	<x path="Void"/>
</f></SetAccessControl>
		<SetAttributes public="1" set="method" static="1"><f a="path:fileAttributes">
	<c path="String"/>
	<e path="cs.system.io.FileAttributes"/>
	<x path="Void"/>
</f></SetAttributes>
		<SetCreationTime public="1" set="method" static="1"><f a="path:creationTime">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></SetCreationTime>
		<SetCreationTimeUtc public="1" set="method" static="1"><f a="path:creationTimeUtc">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></SetCreationTimeUtc>
		<SetLastAccessTime public="1" set="method" static="1"><f a="path:lastAccessTime">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></SetLastAccessTime>
		<SetLastAccessTimeUtc public="1" set="method" static="1"><f a="path:lastAccessTimeUtc">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></SetLastAccessTimeUtc>
		<SetLastWriteTime public="1" set="method" static="1"><f a="path:lastWriteTime">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></SetLastWriteTime>
		<SetLastWriteTimeUtc public="1" set="method" static="1"><f a="path:lastWriteTimeUtc">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></SetLastWriteTimeUtc>
		<ReadAllBytes public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></ReadAllBytes>
		<ReadAllLines public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="cs.NativeArray"><c path="String"/></c>
			</f>
			<overloads><ReadAllLines public="1" set="method"><f a="path:encoding">
	<c path="String"/>
	<c path="cs.system.text.Encoding"/>
	<c path="cs.NativeArray"><c path="String"/></c>
</f></ReadAllLines></overloads>
		</ReadAllLines>
		<ReadAllText public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<overloads><ReadAllText public="1" set="method"><f a="path:encoding">
	<c path="String"/>
	<c path="cs.system.text.Encoding"/>
	<c path="String"/>
</f></ReadAllText></overloads>
		</ReadAllText>
		<WriteAllBytes public="1" set="method" static="1"><f a="path:bytes">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></WriteAllBytes>
		<WriteAllLines public="1" set="method" static="1">
			<f a="path:contents">
				<c path="String"/>
				<c path="cs.NativeArray"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<overloads><WriteAllLines public="1" set="method"><f a="path:contents:encoding">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.system.text.Encoding"/>
	<x path="Void"/>
</f></WriteAllLines></overloads>
		</WriteAllLines>
		<WriteAllText public="1" set="method" static="1">
			<f a="path:contents">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><WriteAllText public="1" set="method"><f a="path:contents:encoding">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.text.Encoding"/>
	<x path="Void"/>
</f></WriteAllText></overloads>
		</WriteAllText>
		<Encrypt public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></Encrypt>
		<Decrypt public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></Decrypt>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.File"</e></m>
		</meta>
	</class>
	<enum path="cs.system.io.FileAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileAccess">
		<Read><meta><m n=":csNative"><e>1</e></m></meta></Read>
		<Write><meta><m n=":csNative"><e>2</e></m></meta></Write>
		<ReadWrite><meta><m n=":csNative"><e>3</e></m></meta></ReadWrite>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.IO.FileAccess"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.io.FileAttributes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileAttributes">
		<ReadOnly><meta><m n=":csNative"><e>1</e></m></meta></ReadOnly>
		<Hidden><meta><m n=":csNative"><e>2</e></m></meta></Hidden>
		<System><meta><m n=":csNative"><e>4</e></m></meta></System>
		<Directory><meta><m n=":csNative"><e>16</e></m></meta></Directory>
		<Archive><meta><m n=":csNative"><e>32</e></m></meta></Archive>
		<Device><meta><m n=":csNative"><e>64</e></m></meta></Device>
		<Normal><meta><m n=":csNative"><e>128</e></m></meta></Normal>
		<Temporary><meta><m n=":csNative"><e>256</e></m></meta></Temporary>
		<SparseFile><meta><m n=":csNative"><e>512</e></m></meta></SparseFile>
		<ReparsePoint><meta><m n=":csNative"><e>1024</e></m></meta></ReparsePoint>
		<Compressed><meta><m n=":csNative"><e>2048</e></m></meta></Compressed>
		<Offline><meta><m n=":csNative"><e>4096</e></m></meta></Offline>
		<NotContentIndexed><meta><m n=":csNative"><e>8192</e></m></meta></NotContentIndexed>
		<Encrypted><meta><m n=":csNative"><e>16384</e></m></meta></Encrypted>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.IO.FileAttributes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.io.FileInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileInfo" extern="1" final="1">
		<extends path="cs.system.io.FileSystemInfo"/>
		<Directory public="1" get="accessor" set="null"><c path="cs.system.io.DirectoryInfo"/></Directory>
		<DirectoryName public="1" get="accessor" set="null"><c path="String"/></DirectoryName>
		<Length public="1" get="accessor" set="null"><x path="haxe.Int64"/></Length>
		<IsReadOnly public="1" get="accessor" set="accessor"><x path="Bool"/></IsReadOnly>
		<Name public="1" get="accessor" set="null" override="1"><c path="String"/></Name>
		<Exists public="1" get="accessor" set="null" override="1"><x path="Bool"/></Exists>
		<get_Exists public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_Exists>
		<get_Name public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Name>
		<get_IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<set_IsReadOnly final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_IsReadOnly>
		<Encrypt final="1" public="1" set="method"><f a=""><x path="Void"/></f></Encrypt>
		<Decrypt final="1" public="1" set="method"><f a=""><x path="Void"/></f></Decrypt>
		<get_Length final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_Length>
		<get_DirectoryName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_DirectoryName>
		<get_Directory final="1" public="1" set="method"><f a=""><c path="cs.system.io.DirectoryInfo"/></f></get_Directory>
		<OpenText final="1" public="1" set="method"><f a=""><c path="cs.system.io.StreamReader"/></f></OpenText>
		<CreateText final="1" public="1" set="method"><f a=""><c path="cs.system.io.StreamWriter"/></f></CreateText>
		<AppendText final="1" public="1" set="method"><f a=""><c path="cs.system.io.StreamWriter"/></f></AppendText>
		<Create final="1" public="1" set="method"><f a=""><c path="cs.system.io.FileStream"/></f></Create>
		<OpenRead final="1" public="1" set="method"><f a=""><c path="cs.system.io.FileStream"/></f></OpenRead>
		<OpenWrite final="1" public="1" set="method"><f a=""><c path="cs.system.io.FileStream"/></f></OpenWrite>
		<Open final="1" public="1" set="method">
			<f a="mode">
				<e path="cs.system.io.FileMode"/>
				<c path="cs.system.io.FileStream"/>
			</f>
			<overloads>
				<Open final="1" public="1" set="method"><f a="mode:access:share">
	<e path="cs.system.io.FileMode"/>
	<e path="cs.system.io.FileAccess"/>
	<e path="cs.system.io.FileShare"/>
	<c path="cs.system.io.FileStream"/>
</f></Open>
				<Open final="1" public="1" set="method"><f a="mode:access">
	<e path="cs.system.io.FileMode"/>
	<e path="cs.system.io.FileAccess"/>
	<c path="cs.system.io.FileStream"/>
</f></Open>
			</overloads>
		</Open>
		<Delete public="1" set="method" override="1"><f a=""><x path="Void"/></f></Delete>
		<MoveTo final="1" public="1" set="method"><f a="destFileName">
	<c path="String"/>
	<x path="Void"/>
</f></MoveTo>
		<CopyTo final="1" public="1" set="method">
			<f a="destFileName">
				<c path="String"/>
				<c path="cs.system.io.FileInfo"/>
			</f>
			<overloads><CopyTo final="1" public="1" set="method"><f a="destFileName:overwrite">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.io.FileInfo"/>
</f></CopyTo></overloads>
		</CopyTo>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<GetAccessControl final="1" public="1" set="method">
			<f a=""><c path="cs.system.security.accesscontrol.FileSecurity"/></f>
			<overloads><GetAccessControl final="1" public="1" set="method"><f a="includeSections">
	<e path="cs.system.security.accesscontrol.AccessControlSections"/>
	<c path="cs.system.security.accesscontrol.FileSecurity"/>
</f></GetAccessControl></overloads>
		</GetAccessControl>
		<Replace final="1" public="1" set="method">
			<f a="destinationFileName:destinationBackupFileName">
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.io.FileInfo"/>
			</f>
			<overloads><Replace final="1" public="1" set="method"><f a="destinationFileName:destinationBackupFileName:ignoreMetadataErrors">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.io.FileInfo"/>
</f></Replace></overloads>
		</Replace>
		<SetAccessControl final="1" public="1" set="method"><f a="fileSecurity">
	<c path="cs.system.security.accesscontrol.FileSecurity"/>
	<x path="Void"/>
</f></SetAccessControl>
		<new final="1" public="1" set="method"><f a="fileName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.FileInfo"</e></m>
		</meta>
	</class>
	<enum path="cs.system.io.FileMode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileMode">
		<CreateNew><meta><m n=":csNative"><e>1</e></m></meta></CreateNew>
		<Create><meta><m n=":csNative"><e>2</e></m></meta></Create>
		<Open><meta><m n=":csNative"><e>3</e></m></meta></Open>
		<OpenOrCreate><meta><m n=":csNative"><e>4</e></m></meta></OpenOrCreate>
		<Truncate><meta><m n=":csNative"><e>5</e></m></meta></Truncate>
		<Append><meta><m n=":csNative"><e>6</e></m></meta></Append>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.IO.FileMode"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.io.FileOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileOptions">
		<WriteThrough><meta><m n=":csNative"><e>-2147483648</e></m></meta></WriteThrough>
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<Encrypted><meta><m n=":csNative"><e>16384</e></m></meta></Encrypted>
		<DeleteOnClose><meta><m n=":csNative"><e>67108864</e></m></meta></DeleteOnClose>
		<SequentialScan><meta><m n=":csNative"><e>134217728</e></m></meta></SequentialScan>
		<RandomAccess><meta><m n=":csNative"><e>268435456</e></m></meta></RandomAccess>
		<Asynchronous><meta><m n=":csNative"><e>1073741824</e></m></meta></Asynchronous>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.IO.FileOptions"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.io.FileShare" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileShare">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<Read><meta><m n=":csNative"><e>1</e></m></meta></Read>
		<Write><meta><m n=":csNative"><e>2</e></m></meta></Write>
		<ReadWrite><meta><m n=":csNative"><e>3</e></m></meta></ReadWrite>
		<Delete><meta><m n=":csNative"><e>4</e></m></meta></Delete>
		<Inheritable><meta><m n=":csNative"><e>16</e></m></meta></Inheritable>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.IO.FileShare"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.io.FileStream_Delegate_WriteDelegate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileStream" module="cs.system.io.FileStream" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.io.FileStream_WriteDelegate"/>
	<x path="cs.system.io.FileStream_WriteDelegate"/>
	<x path="cs.system.io.FileStream_WriteDelegate"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.io.FileStream_WriteDelegate"/>
	<x path="cs.system.io.FileStream_WriteDelegate"/>
	<x path="cs.system.io.FileStream_WriteDelegate"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="buffer:offset:count">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="buffer:offset:count:callback:object">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.FileStream.WriteDelegate"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.io.FileStream_WriteDelegate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileStream" module="cs.system.io.FileStream">
		<from><icast field="FromHaxeFunction"><f a="::">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.io.FileStream_Delegate_WriteDelegate"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.io._FileStream.FileStream_WriteDelegate_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileStream" private="1" module="cs.system.io.FileStream" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="::">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.io.FileStream_WriteDelegate"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="::">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.io.FileStream_WriteDelegate"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.io.FileStream_Delegate_WriteDelegate"/>
	<c path="cs.system.io.FileStream_Delegate_WriteDelegate"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.io.FileStream_WriteDelegate"/>
			<x path="cs.system.io.FileStream_WriteDelegate"/>
			<x path="cs.system.io.FileStream_WriteDelegate"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.io.FileStream_WriteDelegate"/>
			<x path="cs.system.io.FileStream_WriteDelegate"/>
			<x path="cs.system.io.FileStream_WriteDelegate"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.io._FileStream.FileStream_WriteDelegate_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileStream" private="1" module="cs.system.io.FileStream" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="::">
					<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.io.FileStream_WriteDelegate"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="::">
					<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.io.FileStream_WriteDelegate"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.io.FileStream_Delegate_WriteDelegate"/>
	<c path="cs.system.io.FileStream_Delegate_WriteDelegate"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.io.FileStream_WriteDelegate"/>
				<x path="cs.system.io.FileStream_WriteDelegate"/>
				<x path="cs.system.io.FileStream_WriteDelegate"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.io.FileStream_WriteDelegate"/>
				<x path="cs.system.io.FileStream_WriteDelegate"/>
				<x path="cs.system.io.FileStream_WriteDelegate"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.io.FileStream_Delegate_ReadDelegate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileStream" module="cs.system.io.FileStream" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.io.FileStream_ReadDelegate"/>
	<x path="cs.system.io.FileStream_ReadDelegate"/>
	<x path="cs.system.io.FileStream_ReadDelegate"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.io.FileStream_ReadDelegate"/>
	<x path="cs.system.io.FileStream_ReadDelegate"/>
	<x path="cs.system.io.FileStream_ReadDelegate"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="buffer:offset:count">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="buffer:offset:count:callback:object">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Int"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.FileStream.ReadDelegate"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.io.FileStream_ReadDelegate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileStream" module="cs.system.io.FileStream">
		<from><icast field="FromHaxeFunction"><f a="::">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></icast></from>
		<this><c path="cs.system.io.FileStream_Delegate_ReadDelegate"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.io._FileStream.FileStream_ReadDelegate_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileStream" private="1" module="cs.system.io.FileStream" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="::">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<x path="cs.system.io.FileStream_ReadDelegate"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="::">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<x path="cs.system.io.FileStream_ReadDelegate"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.io.FileStream_Delegate_ReadDelegate"/>
	<c path="cs.system.io.FileStream_Delegate_ReadDelegate"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.io.FileStream_ReadDelegate"/>
			<x path="cs.system.io.FileStream_ReadDelegate"/>
			<x path="cs.system.io.FileStream_ReadDelegate"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.io.FileStream_ReadDelegate"/>
			<x path="cs.system.io.FileStream_ReadDelegate"/>
			<x path="cs.system.io.FileStream_ReadDelegate"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.io._FileStream.FileStream_ReadDelegate_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileStream" private="1" module="cs.system.io.FileStream" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="::">
					<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="cs.system.io.FileStream_ReadDelegate"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="::">
					<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="cs.system.io.FileStream_ReadDelegate"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.io.FileStream_Delegate_ReadDelegate"/>
	<c path="cs.system.io.FileStream_Delegate_ReadDelegate"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.io.FileStream_ReadDelegate"/>
				<x path="cs.system.io.FileStream_ReadDelegate"/>
				<x path="cs.system.io.FileStream_ReadDelegate"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.io.FileStream_ReadDelegate"/>
				<x path="cs.system.io.FileStream_ReadDelegate"/>
				<x path="cs.system.io.FileStream_ReadDelegate"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.io.Stream" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.Stream" extern="1" abstract="1">
		<extends path="cs.system.MarshalByRefObject"/>
		<implements path="cs.system.IDisposable"/>
		<Null public="1" set="null" static="1">
			<c path="cs.system.io.Stream"/>
			<meta><m n=":readOnly"/></meta>
		</Null>
		<Synchronized public="1" set="method" static="1"><f a="stream">
	<c path="cs.system.io.Stream"/>
	<c path="cs.system.io.Stream"/>
</f></Synchronized>
		<WriteTimeout public="1" get="accessor" set="accessor"><x path="Int"/></WriteTimeout>
		<ReadTimeout public="1" get="accessor" set="accessor"><x path="Int"/></ReadTimeout>
		<Position public="1" get="accessor" set="accessor"><x path="haxe.Int64"/></Position>
		<Length public="1" get="accessor" set="null"><x path="haxe.Int64"/></Length>
		<CanTimeout public="1" get="accessor" set="null"><x path="Bool"/></CanTimeout>
		<CanWrite public="1" get="accessor" set="null"><x path="Bool"/></CanWrite>
		<CanSeek public="1" get="accessor" set="null"><x path="Bool"/></CanSeek>
		<CanRead public="1" get="accessor" set="null"><x path="Bool"/></CanRead>
		<get_CanRead abstract="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_CanRead>
		<get_CanSeek abstract="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_CanSeek>
		<get_CanWrite abstract="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_CanWrite>
		<get_CanTimeout public="1" set="method"><f a=""><x path="Bool"/></f></get_CanTimeout>
		<get_Length abstract="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_Length>
		<get_Position abstract="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_Position>
		<set_Position abstract="1" public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
</f></set_Position>
		<Dispose final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><Dispose set="method">
	<f a="disposing">
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":protected"/></meta>
</Dispose></overloads>
		</Dispose>
		<Close public="1" set="method"><f a=""><x path="Void"/></f></Close>
		<get_ReadTimeout public="1" set="method"><f a=""><x path="Int"/></f></get_ReadTimeout>
		<set_ReadTimeout public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_ReadTimeout>
		<get_WriteTimeout public="1" set="method"><f a=""><x path="Int"/></f></get_WriteTimeout>
		<set_WriteTimeout public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_WriteTimeout>
		<CreateWaitHandle set="method">
			<f a=""><c path="cs.system.threading.WaitHandle"/></f>
			<meta><m n=":protected"/></meta>
		</CreateWaitHandle>
		<Flush abstract="1" public="1" set="method"><f a=""><x path="Void"/></f></Flush>
		<Read abstract="1" public="1" set="method"><f a="buffer:offset:count">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Read>
		<ReadByte public="1" set="method"><f a=""><x path="Int"/></f></ReadByte>
		<Seek abstract="1" public="1" set="method"><f a="offset:origin">
	<x path="haxe.Int64"/>
	<e path="cs.system.io.SeekOrigin"/>
	<x path="haxe.Int64"/>
</f></Seek>
		<SetLength abstract="1" public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></SetLength>
		<Write abstract="1" public="1" set="method"><f a="buffer:offset:count">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Write>
		<WriteByte public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<x path="Void"/>
</f></WriteByte>
		<BeginRead public="1" set="method"><f a="buffer:offset:count:callback:state">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginRead>
		<BeginWrite public="1" set="method"><f a="buffer:offset:count:callback:state">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginWrite>
		<EndRead public="1" set="method"><f a="asyncResult">
	<c path="cs.system.IAsyncResult"/>
	<x path="Int"/>
</f></EndRead>
		<EndWrite public="1" set="method"><f a="asyncResult">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndWrite>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.Stream"</e></m>
		</meta>
	</class>
	<class path="cs.system.io.FileStream" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.FileStream" extern="1">
		<extends path="cs.system.io.Stream"/>
		<SafeFileHandle public="1" get="accessor" set="null"><c path="microsoft.win32.safehandles.SafeFileHandle"/></SafeFileHandle>
		<Handle public="1" get="accessor" set="null"><c path="cs.system.IntPtr"/></Handle>
		<Position public="1" get="accessor" set="accessor" override="1"><x path="haxe.Int64"/></Position>
		<Length public="1" get="accessor" set="null" override="1"><x path="haxe.Int64"/></Length>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<IsAsync public="1" get="accessor" set="null"><x path="Bool"/></IsAsync>
		<CanSeek public="1" get="accessor" set="null" override="1"><x path="Bool"/></CanSeek>
		<CanWrite public="1" get="accessor" set="null" override="1"><x path="Bool"/></CanWrite>
		<CanRead public="1" get="accessor" set="null" override="1"><x path="Bool"/></CanRead>
		<get_CanRead public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_CanRead>
		<get_CanWrite public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_CanWrite>
		<get_CanSeek public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_CanSeek>
		<get_IsAsync public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAsync>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_Length public="1" set="method" override="1"><f a=""><x path="haxe.Int64"/></f></get_Length>
		<get_Position public="1" set="method" override="1"><f a=""><x path="haxe.Int64"/></f></get_Position>
		<set_Position public="1" set="method" override="1"><f a="value">
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
</f></set_Position>
		<get_Handle public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_Handle>
		<get_SafeFileHandle public="1" set="method"><f a=""><c path="microsoft.win32.safehandles.SafeFileHandle"/></f></get_SafeFileHandle>
		<ReadByte public="1" set="method" override="1"><f a=""><x path="Int"/></f></ReadByte>
		<WriteByte public="1" set="method" override="1"><f a="value">
	<t path="cs.types.UInt8"/>
	<x path="Void"/>
</f></WriteByte>
		<Read public="1" set="method" override="1"><f a="array:offset:count">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Read>
		<BeginRead public="1" set="method" override="1"><f a="array:offset:numBytes:userCallback:stateObject">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginRead>
		<EndRead public="1" set="method" override="1"><f a="asyncResult">
	<c path="cs.system.IAsyncResult"/>
	<x path="Int"/>
</f></EndRead>
		<Write public="1" set="method" override="1"><f a="array:offset:count">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Write>
		<BeginWrite public="1" set="method" override="1"><f a="array:offset:numBytes:userCallback:stateObject">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginWrite>
		<EndWrite public="1" set="method" override="1"><f a="asyncResult">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndWrite>
		<Seek public="1" set="method" override="1"><f a="offset:origin">
	<x path="haxe.Int64"/>
	<e path="cs.system.io.SeekOrigin"/>
	<x path="haxe.Int64"/>
</f></Seek>
		<SetLength public="1" set="method" override="1"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></SetLength>
		<Flush public="1" set="method" override="1"><f a=""><x path="Void"/></f></Flush>
		<Lock public="1" set="method"><f a="position:length">
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></Lock>
		<Unlock public="1" set="method"><f a="position:length">
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></Unlock>
		<Dispose set="method" override="1">
			<f a="disposing">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</Dispose>
		<GetAccessControl final="1" public="1" set="method"><f a=""><c path="cs.system.security.accesscontrol.FileSecurity"/></f></GetAccessControl>
		<SetAccessControl final="1" public="1" set="method"><f a="fileSecurity">
	<c path="cs.system.security.accesscontrol.FileSecurity"/>
	<x path="Void"/>
</f></SetAccessControl>
		<new final="1" public="1" set="method">
			<f a="handle:access">
				<c path="cs.system.IntPtr"/>
				<e path="cs.system.io.FileAccess"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="path:mode:rights:share:bufferSize:options:fileSecurity">
	<c path="String"/>
	<e path="cs.system.io.FileMode"/>
	<e path="cs.system.security.accesscontrol.FileSystemRights"/>
	<e path="cs.system.io.FileShare"/>
	<x path="Int"/>
	<e path="cs.system.io.FileOptions"/>
	<c path="cs.system.security.accesscontrol.FileSecurity"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path:mode:rights:share:bufferSize:options">
	<c path="String"/>
	<e path="cs.system.io.FileMode"/>
	<e path="cs.system.security.accesscontrol.FileSystemRights"/>
	<e path="cs.system.io.FileShare"/>
	<x path="Int"/>
	<e path="cs.system.io.FileOptions"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="handle:access:bufferSize:isAsync">
	<c path="microsoft.win32.safehandles.SafeFileHandle"/>
	<e path="cs.system.io.FileAccess"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="handle:access:bufferSize">
	<c path="microsoft.win32.safehandles.SafeFileHandle"/>
	<e path="cs.system.io.FileAccess"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="handle:access">
	<c path="microsoft.win32.safehandles.SafeFileHandle"/>
	<e path="cs.system.io.FileAccess"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path:mode:access:share:bufferSize:options">
	<c path="String"/>
	<e path="cs.system.io.FileMode"/>
	<e path="cs.system.io.FileAccess"/>
	<e path="cs.system.io.FileShare"/>
	<x path="Int"/>
	<e path="cs.system.io.FileOptions"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path:mode:access:share:bufferSize:useAsync">
	<c path="String"/>
	<e path="cs.system.io.FileMode"/>
	<e path="cs.system.io.FileAccess"/>
	<e path="cs.system.io.FileShare"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path:mode:access:share:bufferSize">
	<c path="String"/>
	<e path="cs.system.io.FileMode"/>
	<e path="cs.system.io.FileAccess"/>
	<e path="cs.system.io.FileShare"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path:mode:access:share">
	<c path="String"/>
	<e path="cs.system.io.FileMode"/>
	<e path="cs.system.io.FileAccess"/>
	<e path="cs.system.io.FileShare"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path:mode:access">
	<c path="String"/>
	<e path="cs.system.io.FileMode"/>
	<e path="cs.system.io.FileAccess"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path:mode">
	<c path="String"/>
	<e path="cs.system.io.FileMode"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="handle:access:ownsHandle:bufferSize:isAsync">
	<c path="cs.system.IntPtr"/>
	<e path="cs.system.io.FileAccess"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="handle:access:ownsHandle:bufferSize">
	<c path="cs.system.IntPtr"/>
	<e path="cs.system.io.FileAccess"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="handle:access:ownsHandle">
	<c path="cs.system.IntPtr"/>
	<e path="cs.system.io.FileAccess"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.FileStream"</e></m>
		</meta>
	</class>
	<class path="cs.system.io.MemoryStream" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.MemoryStream" extern="1">
		<extends path="cs.system.io.Stream"/>
		<Position public="1" get="accessor" set="accessor" override="1"><x path="haxe.Int64"/></Position>
		<Length public="1" get="accessor" set="null" override="1"><x path="haxe.Int64"/></Length>
		<Capacity public="1" get="accessor" set="accessor"><x path="Int"/></Capacity>
		<CanWrite public="1" get="accessor" set="null" override="1"><x path="Bool"/></CanWrite>
		<CanSeek public="1" get="accessor" set="null" override="1"><x path="Bool"/></CanSeek>
		<CanRead public="1" get="accessor" set="null" override="1"><x path="Bool"/></CanRead>
		<get_CanRead public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_CanRead>
		<get_CanSeek public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_CanSeek>
		<get_CanWrite public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_CanWrite>
		<get_Capacity public="1" set="method"><f a=""><x path="Int"/></f></get_Capacity>
		<set_Capacity public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_Capacity>
		<get_Length public="1" set="method" override="1"><f a=""><x path="haxe.Int64"/></f></get_Length>
		<get_Position public="1" set="method" override="1"><f a=""><x path="haxe.Int64"/></f></get_Position>
		<set_Position public="1" set="method" override="1"><f a="value">
	<x path="haxe.Int64"/>
	<x path="haxe.Int64"/>
</f></set_Position>
		<Dispose set="method" override="1">
			<f a="disposing">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</Dispose>
		<Flush public="1" set="method" override="1"><f a=""><x path="Void"/></f></Flush>
		<GetBuffer public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetBuffer>
		<Read public="1" set="method" override="1"><f a="buffer:offset:count">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Read>
		<ReadByte public="1" set="method" override="1"><f a=""><x path="Int"/></f></ReadByte>
		<Seek public="1" set="method" override="1"><f a="offset:loc">
	<x path="haxe.Int64"/>
	<e path="cs.system.io.SeekOrigin"/>
	<x path="haxe.Int64"/>
</f></Seek>
		<SetLength public="1" set="method" override="1"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></SetLength>
		<ToArray public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></ToArray>
		<Write public="1" set="method" override="1"><f a="buffer:offset:count">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Write>
		<WriteByte public="1" set="method" override="1"><f a="value">
	<t path="cs.types.UInt8"/>
	<x path="Void"/>
</f></WriteByte>
		<WriteTo public="1" set="method"><f a="stream">
	<c path="cs.system.io.Stream"/>
	<x path="Void"/>
</f></WriteTo>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="buffer:index:count:writable:publiclyVisible">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="buffer:index:count:writable">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="buffer:index:count">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="buffer:writable">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="buffer">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="capacity">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.MemoryStream"</e></m>
		</meta>
	</class>
	<enum path="cs.system.io.SearchOption" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.SearchOption">
		<TopDirectoryOnly><meta><m n=":csNative"><e>0</e></m></meta></TopDirectoryOnly>
		<AllDirectories><meta><m n=":csNative"><e>1</e></m></meta></AllDirectories>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.IO.SearchOption"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.io.SeekOrigin" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.SeekOrigin">
		<Begin><meta><m n=":csNative"><e>0</e></m></meta></Begin>
		<Current><meta><m n=":csNative"><e>1</e></m></meta></Current>
		<End><meta><m n=":csNative"><e>2</e></m></meta></End>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.IO.SeekOrigin"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.io.TextReader" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.TextReader" extern="1" abstract="1">
		<extends path="cs.system.MarshalByRefObject"/>
		<implements path="cs.system.IDisposable"/>
		<Null public="1" set="null" static="1">
			<c path="cs.system.io.TextReader"/>
			<meta><m n=":readOnly"/></meta>
		</Null>
		<Synchronized public="1" set="method" static="1"><f a="reader">
	<c path="cs.system.io.TextReader"/>
	<c path="cs.system.io.TextReader"/>
</f></Synchronized>
		<Close public="1" set="method"><f a=""><x path="Void"/></f></Close>
		<Dispose final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><Dispose set="method">
	<f a="disposing">
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":protected"/></meta>
</Dispose></overloads>
		</Dispose>
		<Peek public="1" set="method"><f a=""><x path="Int"/></f></Peek>
		<Read public="1" set="method">
			<f a=""><x path="Int"/></f>
			<overloads><Read public="1" set="method"><f a="buffer:index:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Read></overloads>
		</Read>
		<ReadBlock public="1" set="method"><f a="buffer:index:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ReadBlock>
		<ReadLine public="1" set="method"><f a=""><c path="String"/></f></ReadLine>
		<ReadToEnd public="1" set="method"><f a=""><c path="String"/></f></ReadToEnd>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.TextReader"</e></m>
		</meta>
	</class>
	<class path="cs.system.io.StreamReader" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.StreamReader" extern="1">
		<extends path="cs.system.io.TextReader"/>
		<Null public="1" set="null" static="1">
			<c path="cs.system.io.StreamReader"/>
			<meta><m n=":readOnly"/></meta>
		</Null>
		<EndOfStream public="1" get="accessor" set="null"><x path="Bool"/></EndOfStream>
		<CurrentEncoding public="1" get="accessor" set="null"><c path="cs.system.text.Encoding"/></CurrentEncoding>
		<BaseStream public="1" get="accessor" set="null"><c path="cs.system.io.Stream"/></BaseStream>
		<get_BaseStream public="1" set="method"><f a=""><c path="cs.system.io.Stream"/></f></get_BaseStream>
		<get_CurrentEncoding public="1" set="method"><f a=""><c path="cs.system.text.Encoding"/></f></get_CurrentEncoding>
		<get_EndOfStream final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_EndOfStream>
		<Close public="1" set="method" override="1"><f a=""><x path="Void"/></f></Close>
		<Dispose set="method" override="1">
			<f a="disposing">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</Dispose>
		<DiscardBufferedData final="1" public="1" set="method"><f a=""><x path="Void"/></f></DiscardBufferedData>
		<Peek public="1" set="method" override="1"><f a=""><x path="Int"/></f></Peek>
		<Read public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<overloads><Read public="1" set="method"><f a="buffer:index:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Read></overloads>
		</Read>
		<ReadLine public="1" set="method" override="1"><f a=""><c path="String"/></f></ReadLine>
		<ReadToEnd public="1" set="method" override="1"><f a=""><c path="String"/></f></ReadToEnd>
		<new final="1" public="1" set="method">
			<f a="stream">
				<c path="cs.system.io.Stream"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="path:encoding:detectEncodingFromByteOrderMarks:bufferSize">
	<c path="String"/>
	<c path="cs.system.text.Encoding"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path:encoding:detectEncodingFromByteOrderMarks">
	<c path="String"/>
	<c path="cs.system.text.Encoding"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path:encoding">
	<c path="String"/>
	<c path="cs.system.text.Encoding"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path:detectEncodingFromByteOrderMarks">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="stream:encoding:detectEncodingFromByteOrderMarks:bufferSize">
	<c path="cs.system.io.Stream"/>
	<c path="cs.system.text.Encoding"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="stream:encoding:detectEncodingFromByteOrderMarks">
	<c path="cs.system.io.Stream"/>
	<c path="cs.system.text.Encoding"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="stream:encoding">
	<c path="cs.system.io.Stream"/>
	<c path="cs.system.text.Encoding"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="stream:detectEncodingFromByteOrderMarks">
	<c path="cs.system.io.Stream"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.StreamReader"</e></m>
		</meta>
	</class>
	<class path="cs.system.io.StreamReader_NullStreamReader" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.StreamReader" module="cs.system.io.StreamReader" extern="1">
		<extends path="cs.system.io.StreamReader"/>
		<CurrentEncoding public="1" get="accessor" set="null" override="1"><c path="cs.system.text.Encoding"/></CurrentEncoding>
		<BaseStream public="1" get="accessor" set="null" override="1"><c path="cs.system.io.Stream"/></BaseStream>
		<Peek public="1" set="method" override="1"><f a=""><x path="Int"/></f></Peek>
		<Read public="1" set="method" override="1">
			<f a=""><x path="Int"/></f>
			<overloads><Read public="1" set="method"><f a="buffer:index:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></Read></overloads>
		</Read>
		<ReadLine public="1" set="method" override="1"><f a=""><c path="String"/></f></ReadLine>
		<ReadToEnd public="1" set="method" override="1"><f a=""><c path="String"/></f></ReadToEnd>
		<get_BaseStream public="1" set="method" override="1"><f a=""><c path="cs.system.io.Stream"/></f></get_BaseStream>
		<get_CurrentEncoding public="1" set="method" override="1"><f a=""><c path="cs.system.text.Encoding"/></f></get_CurrentEncoding>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.StreamReader.NullStreamReader"</e></m>
		</meta>
	</class>
	<class path="cs.system.io.TextWriter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.TextWriter" extern="1" abstract="1">
		<extends path="cs.system.MarshalByRefObject"/>
		<implements path="cs.system.IDisposable"/>
		<Null public="1" set="null" static="1">
			<c path="cs.system.io.TextWriter"/>
			<meta><m n=":readOnly"/></meta>
		</Null>
		<Synchronized public="1" set="method" static="1"><f a="writer">
	<c path="cs.system.io.TextWriter"/>
	<c path="cs.system.io.TextWriter"/>
</f></Synchronized>
		<NewLine public="1" get="accessor" set="accessor"><c path="String"/></NewLine>
		<FormatProvider public="1" get="accessor" set="null"><c path="cs.system.IFormatProvider"/></FormatProvider>
		<Encoding public="1" get="accessor" set="null"><c path="cs.system.text.Encoding"/></Encoding>
		<CoreNewLine><c path="cs.NativeArray"><t path="cs.types.Char16"/></c></CoreNewLine>
		<get_Encoding abstract="1" public="1" set="method"><f a=""><c path="cs.system.text.Encoding"/></f></get_Encoding>
		<get_FormatProvider public="1" set="method"><f a=""><c path="cs.system.IFormatProvider"/></f></get_FormatProvider>
		<get_NewLine public="1" set="method"><f a=""><c path="String"/></f></get_NewLine>
		<set_NewLine public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_NewLine>
		<Close public="1" set="method"><f a=""><x path="Void"/></f></Close>
		<Dispose set="method">
			<f a="disposing">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
			<overloads><Dispose final="1" public="1" set="method"><f a=""><x path="Void"/></f></Dispose></overloads>
		</Dispose>
		<Flush public="1" set="method"><f a=""><x path="Void"/></f></Flush>
		<Write public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<overloads>
				<Write public="1" set="method"><f a="format:arg0:arg1:arg2">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="format:arg0:arg1">
	<c path="String"/>
	<d/>
	<d/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="buffer:index:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="format:arg">
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="format:arg0">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<d/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="buffer">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Void"/>
</f></Write>
			</overloads>
		</Write>
		<WriteLine public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<WriteLine public="1" set="method"><f a="format:arg0:arg1:arg2">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="format:arg0:arg1">
	<c path="String"/>
	<d/>
	<d/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="buffer:index:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="format:arg">
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="format:arg0">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<x path="Single"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<d/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="buffer">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Void"/>
</f></WriteLine>
				<WriteLine public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></WriteLine>
			</overloads>
		</WriteLine>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
			<overloads><new final="1" set="method">
	<f a="formatProvider">
		<c path="cs.system.IFormatProvider"/>
		<x path="Void"/>
	</f>
	<meta><m n=":protected"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.TextWriter"</e></m>
		</meta>
	</class>
	<class path="cs.system.io.StreamWriter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.StreamWriter" extern="1">
		<extends path="cs.system.io.TextWriter"/>
		<Null public="1" set="null" static="1">
			<c path="cs.system.io.StreamWriter"/>
			<meta><m n=":readOnly"/></meta>
		</Null>
		<Encoding public="1" get="accessor" set="null" override="1"><c path="cs.system.text.Encoding"/></Encoding>
		<BaseStream public="1" get="accessor" set="null"><c path="cs.system.io.Stream"/></BaseStream>
		<AutoFlush public="1" get="accessor" set="accessor"><x path="Bool"/></AutoFlush>
		<get_AutoFlush public="1" set="method"><f a=""><x path="Bool"/></f></get_AutoFlush>
		<set_AutoFlush public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_AutoFlush>
		<get_BaseStream public="1" set="method"><f a=""><c path="cs.system.io.Stream"/></f></get_BaseStream>
		<get_Encoding public="1" set="method" override="1"><f a=""><c path="cs.system.text.Encoding"/></f></get_Encoding>
		<Dispose set="method" override="1">
			<f a="disposing">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</Dispose>
		<Flush public="1" set="method" override="1"><f a=""><x path="Void"/></f></Flush>
		<Write public="1" set="method" override="1">
			<f a="buffer:index:count">
				<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<Write public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="buffer">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Void"/>
</f></Write>
			</overloads>
		</Write>
		<Close public="1" set="method" override="1"><f a=""><x path="Void"/></f></Close>
		<new final="1" public="1" set="method">
			<f a="stream">
				<c path="cs.system.io.Stream"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="path:append:encoding:bufferSize">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.text.Encoding"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path:append:encoding">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.text.Encoding"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path:append">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="stream:encoding:bufferSize">
	<c path="cs.system.io.Stream"/>
	<c path="cs.system.text.Encoding"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="stream:encoding">
	<c path="cs.system.io.Stream"/>
	<c path="cs.system.text.Encoding"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.StreamWriter"</e></m>
		</meta>
	</class>
	<class path="cs.system.io.TextReader_NullTextReader" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.TextReader" module="cs.system.io.TextReader" extern="1">
		<extends path="cs.system.io.TextReader"/>
		<ReadLine public="1" set="method" override="1"><f a=""><c path="String"/></f></ReadLine>
		<ReadToEnd public="1" set="method" override="1"><f a=""><c path="String"/></f></ReadToEnd>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.TextReader.NullTextReader"</e></m>
		</meta>
	</class>
	<class path="cs.system.io.TextWriter_NullTextWriter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.io.TextWriter" module="cs.system.io.TextWriter" extern="1" final="1">
		<extends path="cs.system.io.TextWriter"/>
		<Encoding public="1" get="accessor" set="null" override="1"><c path="cs.system.text.Encoding"/></Encoding>
		<get_Encoding public="1" set="method" override="1"><f a=""><c path="cs.system.text.Encoding"/></f></get_Encoding>
		<Write public="1" set="method" override="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads>
				<Write public="1" set="method"><f a="value:index:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Write>
				<Write public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<x path="Void"/>
</f></Write>
			</overloads>
		</Write>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.IO.TextWriter.NullTextWriter"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.Assembly_ResourceCloseHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.Assembly" module="cs.system.reflection.Assembly" extern="1">
		<OnClose final="1" public="1" set="method"><f a="sender:e">
	<d/>
	<c path="cs.system.EventArgs"/>
	<x path="Void"/>
</f></OnClose>
		<new final="1" public="1" set="method"><f a="module">
	<c path="cs.system.reflection.Module"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Assembly.ResourceCloseHandler"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.Assembly_ResolveEventHolder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.Assembly" module="cs.system.reflection.Assembly" extern="1">
		<ModuleResolve>
			<x path="cs.system.reflection.ModuleResolveEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</ModuleResolve>
		<add_ModuleResolve final="1" public="1" set="method"><f a="value">
	<x path="cs.system.reflection.ModuleResolveEventHandler"/>
	<x path="Void"/>
</f></add_ModuleResolve>
		<remove_ModuleResolve final="1" public="1" set="method"><f a="value">
	<x path="cs.system.reflection.ModuleResolveEventHandler"/>
	<x path="Void"/>
</f></remove_ModuleResolve>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Assembly.ResolveEventHolder"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._Assembly" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._Assembly" extern="1" interface="1">
		<ModuleResolve>
			<x path="cs.system.reflection.ModuleResolveEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</ModuleResolve>
		<GlobalAssemblyCache public="1" get="accessor" set="null"><x path="Bool"/></GlobalAssemblyCache>
		<Evidence public="1" get="accessor" set="null"><c path="cs.system.security.policy.Evidence"/></Evidence>
		<Location public="1" get="accessor" set="null"><c path="String"/></Location>
		<EntryPoint public="1" get="accessor" set="null"><c path="cs.system.reflection.MethodInfo"/></EntryPoint>
		<FullName public="1" get="accessor" set="null"><c path="String"/></FullName>
		<EscapedCodeBase public="1" get="accessor" set="null"><c path="String"/></EscapedCodeBase>
		<CodeBase public="1" get="accessor" set="null"><c path="String"/></CodeBase>
		<add_ModuleResolve public="1" set="method"><f a="value">
	<x path="cs.system.reflection.ModuleResolveEventHandler"/>
	<x path="Void"/>
</f></add_ModuleResolve>
		<remove_ModuleResolve public="1" set="method"><f a="value">
	<x path="cs.system.reflection.ModuleResolveEventHandler"/>
	<x path="Void"/>
</f></remove_ModuleResolve>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<GetType public="1" set="method">
			<f a=""><c path="cs.system.Type"/></f>
			<overloads>
				<GetType public="1" set="method"><f a="name:throwOnError:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetType>
				<GetType public="1" set="method"><f a="name:throwOnError">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetType>
				<GetType public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.Type"/>
</f></GetType>
			</overloads>
		</GetType>
		<get_CodeBase public="1" set="method"><f a=""><c path="String"/></f></get_CodeBase>
		<get_EscapedCodeBase public="1" set="method"><f a=""><c path="String"/></f></get_EscapedCodeBase>
		<GetName public="1" set="method">
			<f a=""><c path="cs.system.reflection.AssemblyName"/></f>
			<overloads><GetName public="1" set="method"><f a="copiedName">
	<x path="Bool"/>
	<c path="cs.system.reflection.AssemblyName"/>
</f></GetName></overloads>
		</GetName>
		<get_FullName public="1" set="method"><f a=""><c path="String"/></f></get_FullName>
		<get_EntryPoint public="1" set="method"><f a=""><c path="cs.system.reflection.MethodInfo"/></f></get_EntryPoint>
		<GetExportedTypes public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetExportedTypes>
		<GetTypes public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetTypes>
		<GetManifestResourceStream public="1" set="method">
			<f a="type:name">
				<c path="cs.system.Type"/>
				<c path="String"/>
				<c path="cs.system.io.Stream"/>
			</f>
			<overloads><GetManifestResourceStream public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.io.Stream"/>
</f></GetManifestResourceStream></overloads>
		</GetManifestResourceStream>
		<GetFile public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.io.FileStream"/>
</f></GetFile>
		<GetFiles public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.io.FileStream"/></c></f>
			<overloads><GetFiles public="1" set="method"><f a="getResourceModules">
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.io.FileStream"/></c>
</f></GetFiles></overloads>
		</GetFiles>
		<GetManifestResourceNames public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></GetManifestResourceNames>
		<GetManifestResourceInfo public="1" set="method"><f a="resourceName">
	<c path="String"/>
	<c path="cs.system.reflection.ManifestResourceInfo"/>
</f></GetManifestResourceInfo>
		<get_Location public="1" set="method"><f a=""><c path="String"/></f></get_Location>
		<get_Evidence public="1" set="method"><f a=""><c path="cs.system.security.policy.Evidence"/></f></get_Evidence>
		<GetCustomAttributes public="1" set="method">
			<f a="attributeType:inherit">
				<c path="cs.system.Type"/>
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="inherit">
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<GetObjectData public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<GetSatelliteAssembly public="1" set="method">
			<f a="culture">
				<c path="cs.system.globalization.CultureInfo"/>
				<c path="cs.system.reflection.Assembly"/>
			</f>
			<overloads><GetSatelliteAssembly public="1" set="method"><f a="culture:version">
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.system.Version"/>
	<c path="cs.system.reflection.Assembly"/>
</f></GetSatelliteAssembly></overloads>
		</GetSatelliteAssembly>
		<LoadModule public="1" set="method">
			<f a="moduleName:rawModule">
				<c path="String"/>
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<c path="cs.system.reflection.Module"/>
			</f>
			<overloads><LoadModule public="1" set="method"><f a="moduleName:rawModule:rawSymbolStore">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.reflection.Module"/>
</f></LoadModule></overloads>
		</LoadModule>
		<CreateInstance public="1" set="method">
			<f a="typeName">
				<c path="String"/>
				<d/>
			</f>
			<overloads>
				<CreateInstance public="1" set="method"><f a="typeName:ignoreCase:bindingAttr:binder:args:culture:activationAttributes">
	<c path="String"/>
	<x path="Bool"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></CreateInstance>
				<CreateInstance public="1" set="method"><f a="typeName:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<d/>
</f></CreateInstance>
			</overloads>
		</CreateInstance>
		<GetLoadedModules public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.Module"/></c></f>
			<overloads><GetLoadedModules public="1" set="method"><f a="getResourceModules">
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.Module"/></c>
</f></GetLoadedModules></overloads>
		</GetLoadedModules>
		<GetModules public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.Module"/></c></f>
			<overloads><GetModules public="1" set="method"><f a="getResourceModules">
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.Module"/></c>
</f></GetModules></overloads>
		</GetModules>
		<GetModule public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.reflection.Module"/>
</f></GetModule>
		<GetReferencedAssemblies public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.AssemblyName"/></c></f></GetReferencedAssemblies>
		<get_GlobalAssemblyCache public="1" set="method"><f a=""><x path="Bool"/></f></get_GlobalAssemblyCache>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._Assembly"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.Assembly" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.Assembly" extern="1">
		<implements path="cs.system.reflection.ICustomAttributeProvider"/>
		<implements path="cs.system.runtime.interopservices._Assembly"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<implements path="cs.system.security.IEvidenceFactory"/>
		<CreateQualifiedName public="1" set="method" static="1"><f a="assemblyName:typeName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></CreateQualifiedName>
		<GetAssembly public="1" set="method" static="1"><f a="type">
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.Assembly"/>
</f></GetAssembly>
		<GetEntryAssembly public="1" set="method" static="1"><f a=""><c path="cs.system.reflection.Assembly"/></f></GetEntryAssembly>
		<LoadFrom public="1" set="method" static="1">
			<f a="assemblyFile">
				<c path="String"/>
				<c path="cs.system.reflection.Assembly"/>
			</f>
			<overloads>
				<LoadFrom public="1" set="method"><f a="assemblyFile:securityEvidence:hashValue:hashAlgorithm">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<e path="cs.system.configuration.assemblies.AssemblyHashAlgorithm"/>
	<c path="cs.system.reflection.Assembly"/>
</f></LoadFrom>
				<LoadFrom public="1" set="method"><f a="assemblyFile:securityEvidence">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.Assembly"/>
</f></LoadFrom>
			</overloads>
		</LoadFrom>
		<LoadFile public="1" set="method" static="1">
			<f a="path:securityEvidence">
				<c path="String"/>
				<c path="cs.system.security.policy.Evidence"/>
				<c path="cs.system.reflection.Assembly"/>
			</f>
			<overloads><LoadFile public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="cs.system.reflection.Assembly"/>
</f></LoadFile></overloads>
		</LoadFile>
		<Load public="1" set="method" static="1">
			<f a="assemblyString">
				<c path="String"/>
				<c path="cs.system.reflection.Assembly"/>
			</f>
			<overloads>
				<Load public="1" set="method"><f a="rawAssembly:rawSymbolStore:securityEvidence">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load public="1" set="method"><f a="rawAssembly:rawSymbolStore">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load public="1" set="method"><f a="rawAssembly">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load public="1" set="method"><f a="assemblyRef:assemblySecurity">
	<c path="cs.system.reflection.AssemblyName"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load public="1" set="method"><f a="assemblyRef">
	<c path="cs.system.reflection.AssemblyName"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
				<Load public="1" set="method"><f a="assemblyString:assemblySecurity">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.Assembly"/>
</f></Load>
			</overloads>
		</Load>
		<ReflectionOnlyLoad public="1" set="method" static="1">
			<f a="rawAssembly">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<c path="cs.system.reflection.Assembly"/>
			</f>
			<overloads><ReflectionOnlyLoad public="1" set="method"><f a="assemblyString">
	<c path="String"/>
	<c path="cs.system.reflection.Assembly"/>
</f></ReflectionOnlyLoad></overloads>
		</ReflectionOnlyLoad>
		<ReflectionOnlyLoadFrom public="1" set="method" static="1"><f a="assemblyFile">
	<c path="String"/>
	<c path="cs.system.reflection.Assembly"/>
</f></ReflectionOnlyLoadFrom>
		<LoadWithPartialName public="1" set="method" static="1">
			<f a="partialName">
				<c path="String"/>
				<c path="cs.system.reflection.Assembly"/>
			</f>
			<overloads><LoadWithPartialName public="1" set="method"><f a="partialName:securityEvidence">
	<c path="String"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.reflection.Assembly"/>
</f></LoadWithPartialName></overloads>
		</LoadWithPartialName>
		<GetExecutingAssembly public="1" set="method" static="1"><f a=""><c path="cs.system.reflection.Assembly"/></f></GetExecutingAssembly>
		<GetCallingAssembly public="1" set="method" static="1"><f a=""><c path="cs.system.reflection.Assembly"/></f></GetCallingAssembly>
		<ModuleResolve>
			<x path="cs.system.reflection.ModuleResolveEventHandler"/>
			<meta>
				<m n=":event"/>
				<m n=":keep"/>
				<m n=":skipReflection"/>
			</meta>
		</ModuleResolve>
		<GlobalAssemblyCache public="1" get="accessor" set="null"><x path="Bool"/></GlobalAssemblyCache>
		<ManifestModule public="1" get="accessor" set="null"><c path="cs.system.reflection.Module"/></ManifestModule>
		<ReflectionOnly public="1" get="accessor" set="null"><x path="Bool"/></ReflectionOnly>
		<HostContext public="1" get="accessor" set="null"><x path="haxe.Int64"/></HostContext>
		<ImageRuntimeVersion public="1" get="accessor" set="null"><c path="String"/></ImageRuntimeVersion>
		<Location public="1" get="accessor" set="null"><c path="String"/></Location>
		<Evidence public="1" get="accessor" set="null"><c path="cs.system.security.policy.Evidence"/></Evidence>
		<EntryPoint public="1" get="accessor" set="null"><c path="cs.system.reflection.MethodInfo"/></EntryPoint>
		<FullName public="1" get="accessor" set="null"><c path="String"/></FullName>
		<EscapedCodeBase public="1" get="accessor" set="null"><c path="String"/></EscapedCodeBase>
		<CodeBase public="1" get="accessor" set="null"><c path="String"/></CodeBase>
		<add_ModuleResolve final="1" public="1" set="method"><f a="value">
	<x path="cs.system.reflection.ModuleResolveEventHandler"/>
	<x path="Void"/>
</f></add_ModuleResolve>
		<remove_ModuleResolve final="1" public="1" set="method"><f a="value">
	<x path="cs.system.reflection.ModuleResolveEventHandler"/>
	<x path="Void"/>
</f></remove_ModuleResolve>
		<get_CodeBase public="1" set="method"><f a=""><c path="String"/></f></get_CodeBase>
		<get_EscapedCodeBase public="1" set="method"><f a=""><c path="String"/></f></get_EscapedCodeBase>
		<get_FullName public="1" set="method"><f a=""><c path="String"/></f></get_FullName>
		<get_EntryPoint public="1" set="method"><f a=""><c path="cs.system.reflection.MethodInfo"/></f></get_EntryPoint>
		<get_Evidence public="1" set="method"><f a=""><c path="cs.system.security.policy.Evidence"/></f></get_Evidence>
		<get_Location public="1" set="method"><f a=""><c path="String"/></f></get_Location>
		<get_ImageRuntimeVersion public="1" set="method"><f a=""><c path="String"/></f></get_ImageRuntimeVersion>
		<GetObjectData public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<GetCustomAttributes public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetFiles public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.io.FileStream"/></c></f>
			<overloads><GetFiles public="1" set="method"><f a="getResourceModules">
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.io.FileStream"/></c>
</f></GetFiles></overloads>
		</GetFiles>
		<GetFile public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.io.FileStream"/>
</f></GetFile>
		<GetManifestResourceStream public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.io.Stream"/>
			</f>
			<overloads><GetManifestResourceStream public="1" set="method"><f a="type:name">
	<c path="cs.system.Type"/>
	<c path="String"/>
	<c path="cs.system.io.Stream"/>
</f></GetManifestResourceStream></overloads>
		</GetManifestResourceStream>
		<GetTypes public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetTypes>
		<GetExportedTypes public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetExportedTypes>
		<GetType public="1" set="method">
			<f a="name:throwOnError">
				<c path="String"/>
				<x path="Bool"/>
				<c path="cs.system.Type"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
			<overloads>
				<GetType final="1" public="1" set="method">
					<f a="name:throwOnError:ignoreCase">
						<c path="String"/>
						<x path="Bool"/>
						<x path="Bool"/>
						<c path="cs.system.Type"/>
					</f>
					<meta>
						<m n=":noCompletion"/>
						<m n=":skipReflection"/>
					</meta>
				</GetType>
				<GetType public="1" set="method">
					<f a="name">
						<c path="String"/>
						<c path="cs.system.Type"/>
					</f>
					<meta>
						<m n=":noCompletion"/>
						<m n=":skipReflection"/>
					</meta>
				</GetType>
			</overloads>
		</GetType>
		<GetName public="1" set="method">
			<f a="copiedName">
				<x path="Bool"/>
				<c path="cs.system.reflection.AssemblyName"/>
			</f>
			<overloads><GetName public="1" set="method"><f a=""><c path="cs.system.reflection.AssemblyName"/></f></GetName></overloads>
		</GetName>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<LoadModule final="1" public="1" set="method">
			<f a="moduleName:rawModule">
				<c path="String"/>
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<c path="cs.system.reflection.Module"/>
			</f>
			<overloads><LoadModule final="1" public="1" set="method"><f a="moduleName:rawModule:rawSymbolStore">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.reflection.Module"/>
</f></LoadModule></overloads>
		</LoadModule>
		<CreateInstance final="1" public="1" set="method">
			<f a="typeName">
				<c path="String"/>
				<d/>
			</f>
			<overloads>
				<CreateInstance final="1" public="1" set="method"><f a="typeName:ignoreCase:bindingAttr:binder:args:culture:activationAttributes">
	<c path="String"/>
	<x path="Bool"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></CreateInstance>
				<CreateInstance final="1" public="1" set="method"><f a="typeName:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<d/>
</f></CreateInstance>
			</overloads>
		</CreateInstance>
		<GetLoadedModules final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.Module"/></c></f>
			<overloads><GetLoadedModules final="1" public="1" set="method"><f a="getResourceModules">
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.Module"/></c>
</f></GetLoadedModules></overloads>
		</GetLoadedModules>
		<GetModules final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.Module"/></c></f>
			<overloads><GetModules final="1" public="1" set="method"><f a="getResourceModules">
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.Module"/></c>
</f></GetModules></overloads>
		</GetModules>
		<GetManifestResourceNames public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></GetManifestResourceNames>
		<GetManifestResourceInfo public="1" set="method"><f a="resourceName">
	<c path="String"/>
	<c path="cs.system.reflection.ManifestResourceInfo"/>
</f></GetManifestResourceInfo>
		<get_HostContext final="1" public="1" set="method"><f a=""><x path="haxe.Int64"/></f></get_HostContext>
		<get_ReflectionOnly public="1" set="method"><f a=""><x path="Bool"/></f></get_ReflectionOnly>
		<GetModule final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.reflection.Module"/>
</f></GetModule>
		<GetReferencedAssemblies final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.AssemblyName"/></c></f></GetReferencedAssemblies>
		<GetSatelliteAssembly final="1" public="1" set="method">
			<f a="culture">
				<c path="cs.system.globalization.CultureInfo"/>
				<c path="cs.system.reflection.Assembly"/>
			</f>
			<overloads><GetSatelliteAssembly final="1" public="1" set="method"><f a="culture:version">
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.system.Version"/>
	<c path="cs.system.reflection.Assembly"/>
</f></GetSatelliteAssembly></overloads>
		</GetSatelliteAssembly>
		<get_ManifestModule final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.Module"/></f></get_ManifestModule>
		<get_GlobalAssemblyCache final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_GlobalAssemblyCache>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Assembly"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._AssemblyName" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._AssemblyName" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._AssemblyName"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.AssemblyName" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.AssemblyName" extern="1" final="1">
		<implements path="cs.system.ICloneable"/>
		<implements path="cs.system.runtime.interopservices._AssemblyName"/>
		<implements path="cs.system.runtime.serialization.IDeserializationCallback"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<ReferenceMatchesDefinition public="1" set="method" static="1"><f a="reference:definition">
	<c path="cs.system.reflection.AssemblyName"/>
	<c path="cs.system.reflection.AssemblyName"/>
	<x path="Bool"/>
</f></ReferenceMatchesDefinition>
		<GetAssemblyName public="1" set="method" static="1"><f a="assemblyFile">
	<c path="String"/>
	<c path="cs.system.reflection.AssemblyName"/>
</f></GetAssemblyName>
		<VersionCompatibility public="1" get="accessor" set="accessor"><e path="cs.system.configuration.assemblies.AssemblyVersionCompatibility"/></VersionCompatibility>
		<Version public="1" get="accessor" set="accessor"><c path="cs.system.Version"/></Version>
		<KeyPair public="1" get="accessor" set="accessor"><c path="cs.system.reflection.StrongNameKeyPair"/></KeyPair>
		<HashAlgorithm public="1" get="accessor" set="accessor"><e path="cs.system.configuration.assemblies.AssemblyHashAlgorithm"/></HashAlgorithm>
		<FullName public="1" get="accessor" set="null"><c path="String"/></FullName>
		<Flags public="1" get="accessor" set="accessor"><e path="cs.system.reflection.AssemblyNameFlags"/></Flags>
		<CultureInfo public="1" get="accessor" set="accessor"><c path="cs.system.globalization.CultureInfo"/></CultureInfo>
		<EscapedCodeBase public="1" get="accessor" set="null"><c path="String"/></EscapedCodeBase>
		<CodeBase public="1" get="accessor" set="accessor"><c path="String"/></CodeBase>
		<Name public="1" get="accessor" set="accessor"><c path="String"/></Name>
		<ProcessorArchitecture public="1" get="accessor" set="accessor"><e path="cs.system.reflection.ProcessorArchitecture"/></ProcessorArchitecture>
		<get_ProcessorArchitecture final="1" public="1" set="method"><f a=""><e path="cs.system.reflection.ProcessorArchitecture"/></f></get_ProcessorArchitecture>
		<set_ProcessorArchitecture final="1" public="1" set="method"><f a="value">
	<e path="cs.system.reflection.ProcessorArchitecture"/>
	<e path="cs.system.reflection.ProcessorArchitecture"/>
</f></set_ProcessorArchitecture>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<set_Name final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Name>
		<get_CodeBase final="1" public="1" set="method"><f a=""><c path="String"/></f></get_CodeBase>
		<set_CodeBase final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_CodeBase>
		<get_EscapedCodeBase final="1" public="1" set="method"><f a=""><c path="String"/></f></get_EscapedCodeBase>
		<get_CultureInfo final="1" public="1" set="method"><f a=""><c path="cs.system.globalization.CultureInfo"/></f></get_CultureInfo>
		<set_CultureInfo final="1" public="1" set="method"><f a="value">
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.system.globalization.CultureInfo"/>
</f></set_CultureInfo>
		<get_Flags final="1" public="1" set="method"><f a=""><e path="cs.system.reflection.AssemblyNameFlags"/></f></get_Flags>
		<set_Flags final="1" public="1" set="method"><f a="value">
	<e path="cs.system.reflection.AssemblyNameFlags"/>
	<e path="cs.system.reflection.AssemblyNameFlags"/>
</f></set_Flags>
		<get_FullName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_FullName>
		<get_HashAlgorithm final="1" public="1" set="method"><f a=""><e path="cs.system.configuration.assemblies.AssemblyHashAlgorithm"/></f></get_HashAlgorithm>
		<set_HashAlgorithm final="1" public="1" set="method"><f a="value">
	<e path="cs.system.configuration.assemblies.AssemblyHashAlgorithm"/>
	<e path="cs.system.configuration.assemblies.AssemblyHashAlgorithm"/>
</f></set_HashAlgorithm>
		<get_KeyPair final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.StrongNameKeyPair"/></f></get_KeyPair>
		<set_KeyPair final="1" public="1" set="method"><f a="value">
	<c path="cs.system.reflection.StrongNameKeyPair"/>
	<c path="cs.system.reflection.StrongNameKeyPair"/>
</f></set_KeyPair>
		<get_Version final="1" public="1" set="method"><f a=""><c path="cs.system.Version"/></f></get_Version>
		<set_Version final="1" public="1" set="method"><f a="value">
	<c path="cs.system.Version"/>
	<c path="cs.system.Version"/>
</f></set_Version>
		<get_VersionCompatibility final="1" public="1" set="method"><f a=""><e path="cs.system.configuration.assemblies.AssemblyVersionCompatibility"/></f></get_VersionCompatibility>
		<set_VersionCompatibility final="1" public="1" set="method"><f a="value">
	<e path="cs.system.configuration.assemblies.AssemblyVersionCompatibility"/>
	<e path="cs.system.configuration.assemblies.AssemblyVersionCompatibility"/>
</f></set_VersionCompatibility>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<GetPublicKey final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetPublicKey>
		<GetPublicKeyToken final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetPublicKeyToken>
		<SetPublicKey final="1" public="1" set="method"><f a="publicKey">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetPublicKey>
		<SetPublicKeyToken final="1" public="1" set="method"><f a="publicKeyToken">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetPublicKeyToken>
		<GetObjectData final="1" public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<Clone final="1" public="1" set="method"><f a=""><d/></f></Clone>
		<OnDeserialization final="1" public="1" set="method"><f a="sender">
	<d/>
	<x path="Void"/>
</f></OnDeserialization>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><new final="1" public="1" set="method"><f a="assemblyName">
	<c path="String"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.AssemblyName"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.AssemblyNameFlags" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.AssemblyNameFlags">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<PublicKey><meta><m n=":csNative"><e>1</e></m></meta></PublicKey>
		<Retargetable><meta><m n=":csNative"><e>256</e></m></meta></Retargetable>
		<EnableJITcompileOptimizer><meta><m n=":csNative"><e>16384</e></m></meta></EnableJITcompileOptimizer>
		<EnableJITcompileTracking><meta><m n=":csNative"><e>32768</e></m></meta></EnableJITcompileTracking>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.AssemblyNameFlags"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.reflection.Binder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.Binder" extern="1" abstract="1">
		<BindToField abstract="1" public="1" set="method"><f a="bindingAttr:match:value:culture">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c>
	<d/>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.system.reflection.FieldInfo"/>
</f></BindToField>
		<BindToMethod abstract="1" public="1" set="method"><f a="bindingAttr:match:args:modifiers:culture:names:state">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodBase"/></c>
	<t path="cs.Ref"><c path="cs.NativeArray"><d/></c></t>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<t path="cs.Out"><d/></t>
	<c path="cs.system.reflection.MethodBase"/>
</f></BindToMethod>
		<ChangeType abstract="1" public="1" set="method"><f a="value:type:culture">
	<d/>
	<c path="cs.system.Type"/>
	<c path="cs.system.globalization.CultureInfo"/>
	<d/>
</f></ChangeType>
		<ReorderArgumentArray abstract="1" public="1" set="method"><f a="args:state">
	<t path="cs.Ref"><c path="cs.NativeArray"><d/></c></t>
	<d/>
	<x path="Void"/>
</f></ReorderArgumentArray>
		<SelectMethod abstract="1" public="1" set="method"><f a="bindingAttr:match:types:modifiers">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodBase"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.MethodBase"/>
</f></SelectMethod>
		<SelectProperty abstract="1" public="1" set="method"><f a="bindingAttr:match:returnType:indexes:modifiers">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.PropertyInfo"/></c>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></SelectProperty>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Binder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.Binder_Default" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.Binder" module="cs.system.reflection.Binder" extern="1" final="1">
		<extends path="cs.system.reflection.Binder"/>
		<BindToField public="1" set="method" override="1"><f a="bindingAttr:match:value:culture">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c>
	<d/>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.system.reflection.FieldInfo"/>
</f></BindToField>
		<BindToMethod public="1" set="method" override="1"><f a="bindingAttr:match:args:modifiers:culture:names:state">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodBase"/></c>
	<t path="cs.Ref"><c path="cs.NativeArray"><d/></c></t>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<t path="cs.Out"><d/></t>
	<c path="cs.system.reflection.MethodBase"/>
</f></BindToMethod>
		<ChangeType public="1" set="method" override="1"><f a="value:type:culture">
	<d/>
	<c path="cs.system.Type"/>
	<c path="cs.system.globalization.CultureInfo"/>
	<d/>
</f></ChangeType>
		<ReorderArgumentArray public="1" set="method" override="1"><f a="args:state">
	<t path="cs.Ref"><c path="cs.NativeArray"><d/></c></t>
	<d/>
	<x path="Void"/>
</f></ReorderArgumentArray>
		<SelectMethod public="1" set="method" override="1"><f a="bindingAttr:match:types:modifiers">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodBase"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.MethodBase"/>
</f></SelectMethod>
		<SelectProperty public="1" set="method" override="1"><f a="bindingAttr:match:returnType:indexes:modifiers">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.PropertyInfo"/></c>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.PropertyInfo"/>
</f></SelectProperty>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Binder.Default"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.BindingFlags" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.BindingFlags">
		<Default><meta><m n=":csNative"><e>0</e></m></meta></Default>
		<IgnoreCase><meta><m n=":csNative"><e>1</e></m></meta></IgnoreCase>
		<DeclaredOnly><meta><m n=":csNative"><e>2</e></m></meta></DeclaredOnly>
		<Instance><meta><m n=":csNative"><e>4</e></m></meta></Instance>
		<Static><meta><m n=":csNative"><e>8</e></m></meta></Static>
		<Public><meta><m n=":csNative"><e>16</e></m></meta></Public>
		<NonPublic><meta><m n=":csNative"><e>32</e></m></meta></NonPublic>
		<FlattenHierarchy><meta><m n=":csNative"><e>64</e></m></meta></FlattenHierarchy>
		<InvokeMethod><meta><m n=":csNative"><e>256</e></m></meta></InvokeMethod>
		<CreateInstance><meta><m n=":csNative"><e>512</e></m></meta></CreateInstance>
		<GetField><meta><m n=":csNative"><e>1024</e></m></meta></GetField>
		<SetField><meta><m n=":csNative"><e>2048</e></m></meta></SetField>
		<GetProperty><meta><m n=":csNative"><e>4096</e></m></meta></GetProperty>
		<SetProperty><meta><m n=":csNative"><e>8192</e></m></meta></SetProperty>
		<PutDispProperty><meta><m n=":csNative"><e>16384</e></m></meta></PutDispProperty>
		<PutRefDispProperty><meta><m n=":csNative"><e>32768</e></m></meta></PutRefDispProperty>
		<ExactBinding><meta><m n=":csNative"><e>65536</e></m></meta></ExactBinding>
		<SuppressChangeType><meta><m n=":csNative"><e>131072</e></m></meta></SuppressChangeType>
		<OptionalParamBinding><meta><m n=":csNative"><e>262144</e></m></meta></OptionalParamBinding>
		<IgnoreReturn><meta><m n=":csNative"><e>16777216</e></m></meta></IgnoreReturn>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.BindingFlags"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.reflection.CallingConventions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.CallingConventions">
		<Standard><meta><m n=":csNative"><e>1</e></m></meta></Standard>
		<VarArgs><meta><m n=":csNative"><e>2</e></m></meta></VarArgs>
		<Any><meta><m n=":csNative"><e>3</e></m></meta></Any>
		<HasThis><meta><m n=":csNative"><e>32</e></m></meta></HasThis>
		<ExplicitThis><meta><m n=":csNative"><e>64</e></m></meta></ExplicitThis>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.CallingConventions"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.runtime.interopservices._MethodBase" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._MethodBase" extern="1" interface="1">
		<ReflectedType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ReflectedType>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<MethodHandle public="1" get="accessor" set="null"><c path="cs.system.RuntimeMethodHandle"/></MethodHandle>
		<MemberType public="1" get="accessor" set="null"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<IsVirtual public="1" get="accessor" set="null"><x path="Bool"/></IsVirtual>
		<IsStatic public="1" get="accessor" set="null"><x path="Bool"/></IsStatic>
		<IsSpecialName public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialName>
		<IsPublic public="1" get="accessor" set="null"><x path="Bool"/></IsPublic>
		<IsPrivate public="1" get="accessor" set="null"><x path="Bool"/></IsPrivate>
		<IsHideBySig public="1" get="accessor" set="null"><x path="Bool"/></IsHideBySig>
		<IsFinal public="1" get="accessor" set="null"><x path="Bool"/></IsFinal>
		<IsFamilyOrAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsFamilyOrAssembly>
		<IsFamilyAndAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsFamilyAndAssembly>
		<IsFamily public="1" get="accessor" set="null"><x path="Bool"/></IsFamily>
		<IsConstructor public="1" get="accessor" set="null"><x path="Bool"/></IsConstructor>
		<IsAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsAssembly>
		<IsAbstract public="1" get="accessor" set="null"><x path="Bool"/></IsAbstract>
		<DeclaringType public="1" get="accessor" set="null"><c path="cs.system.Type"/></DeclaringType>
		<CallingConvention public="1" get="accessor" set="null"><e path="cs.system.reflection.CallingConventions"/></CallingConvention>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.MethodAttributes"/></Attributes>
		<GetCustomAttributes public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetMethodImplementationFlags public="1" set="method"><f a=""><e path="cs.system.reflection.MethodImplAttributes"/></f></GetMethodImplementationFlags>
		<GetParameters public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ParameterInfo"/></c></f></GetParameters>
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method">
			<f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
				<x path="UInt"/>
				<t path="cs.Ref"><c path="cs.system.Guid"/></t>
				<x path="UInt"/>
				<t path="cs.types.Int16"/>
				<c path="cs.system.IntPtr"/>
				<c path="cs.system.IntPtr"/>
				<c path="cs.system.IntPtr"/>
				<c path="cs.system.IntPtr"/>
				<x path="Void"/>
			</f>
			<overloads>
				<Invoke public="1" set="method"><f a="obj:invokeAttr:binder:parameters:culture">
	<d/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<d/>
</f></Invoke>
				<Invoke public="1" set="method"><f a="obj:parameters">
	<d/>
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></Invoke>
			</overloads>
		</Invoke>
		<GetType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<get_Attributes public="1" set="method"><f a=""><e path="cs.system.reflection.MethodAttributes"/></f></get_Attributes>
		<get_CallingConvention public="1" set="method"><f a=""><e path="cs.system.reflection.CallingConventions"/></f></get_CallingConvention>
		<get_DeclaringType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_IsAbstract public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAbstract>
		<get_IsAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAssembly>
		<get_IsConstructor public="1" set="method"><f a=""><x path="Bool"/></f></get_IsConstructor>
		<get_IsFamily public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamily>
		<get_IsFamilyAndAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamilyAndAssembly>
		<get_IsFamilyOrAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamilyOrAssembly>
		<get_IsFinal public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFinal>
		<get_IsHideBySig public="1" set="method"><f a=""><x path="Bool"/></f></get_IsHideBySig>
		<get_IsPrivate public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPrivate>
		<get_IsPublic public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPublic>
		<get_IsSpecialName public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialName>
		<get_IsStatic public="1" set="method"><f a=""><x path="Bool"/></f></get_IsStatic>
		<get_IsVirtual public="1" set="method"><f a=""><x path="Bool"/></f></get_IsVirtual>
		<get_MemberType public="1" set="method"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_MethodHandle public="1" set="method"><f a=""><c path="cs.system.RuntimeMethodHandle"/></f></get_MethodHandle>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_ReflectedType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._MethodBase"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.MethodBase" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.MethodBase" extern="1" abstract="1">
		<extends path="cs.system.reflection.MemberInfo"/>
		<implements path="cs.system.runtime.interopservices._MethodBase"/>
		<GetCurrentMethod public="1" set="method" static="1"><f a=""><c path="cs.system.reflection.MethodBase"/></f></GetCurrentMethod>
		<GetMethodFromHandle public="1" set="method" static="1">
			<f a="handle">
				<c path="cs.system.RuntimeMethodHandle"/>
				<c path="cs.system.reflection.MethodBase"/>
			</f>
			<overloads><GetMethodFromHandle public="1" set="method"><f a="handle:declaringType">
	<c path="cs.system.RuntimeMethodHandle"/>
	<c path="cs.system.RuntimeTypeHandle"/>
	<c path="cs.system.reflection.MethodBase"/>
</f></GetMethodFromHandle></overloads>
		</GetMethodFromHandle>
		<IsGenericMethod public="1" get="accessor" set="null"><x path="Bool"/></IsGenericMethod>
		<IsGenericMethodDefinition public="1" get="accessor" set="null"><x path="Bool"/></IsGenericMethodDefinition>
		<ContainsGenericParameters public="1" get="accessor" set="null"><x path="Bool"/></ContainsGenericParameters>
		<IsConstructor public="1" get="accessor" set="null"><x path="Bool"/></IsConstructor>
		<IsSpecialName public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialName>
		<IsAbstract public="1" get="accessor" set="null"><x path="Bool"/></IsAbstract>
		<IsHideBySig public="1" get="accessor" set="null"><x path="Bool"/></IsHideBySig>
		<IsVirtual public="1" get="accessor" set="null"><x path="Bool"/></IsVirtual>
		<IsFinal public="1" get="accessor" set="null"><x path="Bool"/></IsFinal>
		<IsStatic public="1" get="accessor" set="null"><x path="Bool"/></IsStatic>
		<IsFamilyOrAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsFamilyOrAssembly>
		<IsFamilyAndAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsFamilyAndAssembly>
		<IsAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsAssembly>
		<IsFamily public="1" get="accessor" set="null"><x path="Bool"/></IsFamily>
		<IsPrivate public="1" get="accessor" set="null"><x path="Bool"/></IsPrivate>
		<IsPublic public="1" get="accessor" set="null"><x path="Bool"/></IsPublic>
		<CallingConvention public="1" get="accessor" set="null"><e path="cs.system.reflection.CallingConventions"/></CallingConvention>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.MethodAttributes"/></Attributes>
		<MethodHandle public="1" get="accessor" set="null"><c path="cs.system.RuntimeMethodHandle"/></MethodHandle>
		<GetMethodImplementationFlags abstract="1" public="1" set="method"><f a=""><e path="cs.system.reflection.MethodImplAttributes"/></f></GetMethodImplementationFlags>
		<GetParameters abstract="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ParameterInfo"/></c></f></GetParameters>
		<Invoke final="1" public="1" set="method">
			<f a="obj:parameters">
				<d/>
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
			<overloads><Invoke abstract="1" public="1" set="method">
	<f a="obj:invokeAttr:binder:parameters:culture">
		<d/>
		<e path="cs.system.reflection.BindingFlags"/>
		<c path="cs.system.reflection.Binder"/>
		<c path="cs.NativeArray"><d/></c>
		<c path="cs.system.globalization.CultureInfo"/>
		<d/>
	</f>
	<meta>
		<m n=":noCompletion"/>
		<m n=":skipReflection"/>
	</meta>
</Invoke></overloads>
		</Invoke>
		<get_MethodHandle abstract="1" public="1" set="method"><f a=""><c path="cs.system.RuntimeMethodHandle"/></f></get_MethodHandle>
		<get_Attributes abstract="1" public="1" set="method"><f a=""><e path="cs.system.reflection.MethodAttributes"/></f></get_Attributes>
		<get_CallingConvention public="1" set="method"><f a=""><e path="cs.system.reflection.CallingConventions"/></f></get_CallingConvention>
		<get_IsPublic final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPublic>
		<get_IsPrivate final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPrivate>
		<get_IsFamily final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamily>
		<get_IsAssembly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAssembly>
		<get_IsFamilyAndAssembly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamilyAndAssembly>
		<get_IsFamilyOrAssembly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamilyOrAssembly>
		<get_IsStatic final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsStatic>
		<get_IsFinal final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFinal>
		<get_IsVirtual final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsVirtual>
		<get_IsHideBySig final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsHideBySig>
		<get_IsAbstract final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAbstract>
		<get_IsSpecialName final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialName>
		<get_IsConstructor final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsConstructor>
		<GetGenericArguments public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetGenericArguments>
		<get_ContainsGenericParameters public="1" set="method"><f a=""><x path="Bool"/></f></get_ContainsGenericParameters>
		<get_IsGenericMethodDefinition public="1" set="method"><f a=""><x path="Bool"/></f></get_IsGenericMethodDefinition>
		<get_IsGenericMethod public="1" set="method"><f a=""><x path="Bool"/></f></get_IsGenericMethod>
		<GetMethodBody public="1" set="method"><f a=""><c path="cs.system.reflection.MethodBody"/></f></GetMethodBody>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.MethodBase"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._ConstructorInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._ConstructorInfo" extern="1" interface="1">
		<ReflectedType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ReflectedType>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<MethodHandle public="1" get="accessor" set="null"><c path="cs.system.RuntimeMethodHandle"/></MethodHandle>
		<MemberType public="1" get="accessor" set="null"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<IsVirtual public="1" get="accessor" set="null"><x path="Bool"/></IsVirtual>
		<IsStatic public="1" get="accessor" set="null"><x path="Bool"/></IsStatic>
		<IsSpecialName public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialName>
		<IsPublic public="1" get="accessor" set="null"><x path="Bool"/></IsPublic>
		<IsPrivate public="1" get="accessor" set="null"><x path="Bool"/></IsPrivate>
		<IsHideBySig public="1" get="accessor" set="null"><x path="Bool"/></IsHideBySig>
		<IsFinal public="1" get="accessor" set="null"><x path="Bool"/></IsFinal>
		<IsFamilyOrAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsFamilyOrAssembly>
		<IsFamilyAndAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsFamilyAndAssembly>
		<IsFamily public="1" get="accessor" set="null"><x path="Bool"/></IsFamily>
		<IsConstructor public="1" get="accessor" set="null"><x path="Bool"/></IsConstructor>
		<IsAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsAssembly>
		<IsAbstract public="1" get="accessor" set="null"><x path="Bool"/></IsAbstract>
		<DeclaringType public="1" get="accessor" set="null"><c path="cs.system.Type"/></DeclaringType>
		<CallingConvention public="1" get="accessor" set="null"><e path="cs.system.reflection.CallingConventions"/></CallingConvention>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.MethodAttributes"/></Attributes>
		<GetCustomAttributes public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetMethodImplementationFlags public="1" set="method"><f a=""><e path="cs.system.reflection.MethodImplAttributes"/></f></GetMethodImplementationFlags>
		<GetParameters public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ParameterInfo"/></c></f></GetParameters>
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<GetType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<Invoke_5 public="1" set="method"><f a="parameters">
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></Invoke_5>
		<Invoke_3 public="1" set="method"><f a="obj:parameters">
	<d/>
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></Invoke_3>
		<Invoke_4 public="1" set="method"><f a="invokeAttr:binder:parameters:culture">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<d/>
</f></Invoke_4>
		<Invoke_2 public="1" set="method"><f a="obj:invokeAttr:binder:parameters:culture">
	<d/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<d/>
</f></Invoke_2>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<get_Attributes public="1" set="method"><f a=""><e path="cs.system.reflection.MethodAttributes"/></f></get_Attributes>
		<get_CallingConvention public="1" set="method"><f a=""><e path="cs.system.reflection.CallingConventions"/></f></get_CallingConvention>
		<get_DeclaringType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_IsAbstract public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAbstract>
		<get_IsAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAssembly>
		<get_IsConstructor public="1" set="method"><f a=""><x path="Bool"/></f></get_IsConstructor>
		<get_IsFamily public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamily>
		<get_IsFamilyAndAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamilyAndAssembly>
		<get_IsFamilyOrAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamilyOrAssembly>
		<get_IsFinal public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFinal>
		<get_IsHideBySig public="1" set="method"><f a=""><x path="Bool"/></f></get_IsHideBySig>
		<get_IsPrivate public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPrivate>
		<get_IsPublic public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPublic>
		<get_IsSpecialName public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialName>
		<get_IsStatic public="1" set="method"><f a=""><x path="Bool"/></f></get_IsStatic>
		<get_IsVirtual public="1" set="method"><f a=""><x path="Bool"/></f></get_IsVirtual>
		<get_MemberType public="1" set="method"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_MethodHandle public="1" set="method"><f a=""><c path="cs.system.RuntimeMethodHandle"/></f></get_MethodHandle>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_ReflectedType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._ConstructorInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.ConstructorInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ConstructorInfo" extern="1" abstract="1">
		<extends path="cs.system.reflection.MethodBase"/>
		<implements path="cs.system.runtime.interopservices._ConstructorInfo"/>
		<TypeConstructorName public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</TypeConstructorName>
		<ConstructorName public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":readOnly"/></meta>
		</ConstructorName>
		<MemberType public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<get_MemberType public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<Invoke final="1" public="1" set="method" override="1">
			<f a="parameters">
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
			<overloads><Invoke abstract="1" public="1" set="method">
	<f a="invokeAttr:binder:parameters:culture">
		<e path="cs.system.reflection.BindingFlags"/>
		<c path="cs.system.reflection.Binder"/>
		<c path="cs.NativeArray"><d/></c>
		<c path="cs.system.globalization.CultureInfo"/>
		<d/>
	</f>
	<meta>
		<m n=":noCompletion"/>
		<m n=":skipReflection"/>
	</meta>
</Invoke></overloads>
		</Invoke>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.ConstructorInfo"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.EventAttributes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventAttributes">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<SpecialName><meta><m n=":csNative"><e>512</e></m></meta></SpecialName>
		<ReservedMask><meta><m n=":csNative"><e>1024</e></m></meta></ReservedMask>
		<RTSpecialName><meta><m n=":csNative"><e>1024</e></m></meta></RTSpecialName>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.EventAttributes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.reflection.EventInfo_Delegate_StaticAddEvent_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" module="cs.system.reflection.EventInfo" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" params="T0" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="op_Addition.T0"/></x>
	<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="op_Addition.T0"/></x>
	<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="op_Addition.T0"/></x>
</f></op_Addition>
		<op_Subtraction public="1" params="T0" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="op_Subtraction.T0"/></x>
	<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="op_Subtraction.T0"/></x>
	<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="op_Subtraction.T0"/></x>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="dele">
	<c path="cs.system.reflection.EventInfo_Delegate_StaticAddEvent_1.T0"/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="dele:callback:object">
	<c path="cs.system.reflection.EventInfo_Delegate_StaticAddEvent_1.T0"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.EventInfo.StaticAddEvent`1"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.reflection.EventInfo_StaticAddEvent_1" params="T0" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" module="cs.system.reflection.EventInfo">
		<from><icast field="FromHaxeFunction"><f a="">
	<c path="FromHaxeFunction.T0"/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.reflection.EventInfo_Delegate_StaticAddEvent_1"><c path="cs.system.reflection.EventInfo_StaticAddEvent_1.T0"/></c></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.reflection._EventInfo.EventInfo_StaticAddEvent_1_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" private="1" module="cs.system.reflection.EventInfo" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="cs.system.reflection.EventInfo_StaticAddEvent_1.T0"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="cs.system.reflection.EventInfo_StaticAddEvent_1.T0"/></x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" params="T0" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="FromHaxeFunction.T0"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="FromHaxeFunction.T0"/></x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.reflection.EventInfo_Delegate_StaticAddEvent_1"><c path="cs.system.reflection.EventInfo_StaticAddEvent_1.T0"/></c>
	<c path="cs.system.reflection.EventInfo_Delegate_StaticAddEvent_1"><c path="cs.system.reflection.EventInfo_StaticAddEvent_1.T0"/></c>
</f></AsDelegate>
	<Add public="1" params="T0" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="Add.T0"/></x>
			<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="Add.T0"/></x>
			<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="Add.T0"/></x>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" params="T0" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="Remove.T0"/></x>
			<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="Remove.T0"/></x>
			<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="Remove.T0"/></x>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.reflection._EventInfo.EventInfo_StaticAddEvent_1_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" private="1" module="cs.system.reflection.EventInfo" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="cs.system.reflection.EventInfo_StaticAddEvent_1.T0"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="cs.system.reflection.EventInfo_StaticAddEvent_1.T0"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" params="T0" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="FromHaxeFunction.T0"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="FromHaxeFunction.T0"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.reflection.EventInfo_Delegate_StaticAddEvent_1"><c path="cs.system.reflection.EventInfo_StaticAddEvent_1.T0"/></c>
	<c path="cs.system.reflection.EventInfo_Delegate_StaticAddEvent_1"><c path="cs.system.reflection.EventInfo_StaticAddEvent_1.T0"/></c>
</f></AsDelegate>
		<Add public="1" params="T0" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="Add.T0"/></x>
				<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="Add.T0"/></x>
				<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="Add.T0"/></x>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" params="T0" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="Remove.T0"/></x>
				<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="Remove.T0"/></x>
				<x path="cs.system.reflection.EventInfo_StaticAddEvent_1"><c path="Remove.T0"/></x>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.reflection.EventInfo_Delegate_AddEvent_2" params="T0:T1" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" module="cs.system.reflection.EventInfo" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" params="T0:T1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.reflection.EventInfo_AddEvent_2">
		<c path="op_Addition.T0"/>
		<c path="op_Addition.T1"/>
	</x>
	<x path="cs.system.reflection.EventInfo_AddEvent_2">
		<c path="op_Addition.T0"/>
		<c path="op_Addition.T1"/>
	</x>
	<x path="cs.system.reflection.EventInfo_AddEvent_2">
		<c path="op_Addition.T0"/>
		<c path="op_Addition.T1"/>
	</x>
</f></op_Addition>
		<op_Subtraction public="1" params="T0:T1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.reflection.EventInfo_AddEvent_2">
		<c path="op_Subtraction.T0"/>
		<c path="op_Subtraction.T1"/>
	</x>
	<x path="cs.system.reflection.EventInfo_AddEvent_2">
		<c path="op_Subtraction.T0"/>
		<c path="op_Subtraction.T1"/>
	</x>
	<x path="cs.system.reflection.EventInfo_AddEvent_2">
		<c path="op_Subtraction.T0"/>
		<c path="op_Subtraction.T1"/>
	</x>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="_this:dele">
	<c path="cs.system.reflection.EventInfo_Delegate_AddEvent_2.T0"/>
	<c path="cs.system.reflection.EventInfo_Delegate_AddEvent_2.T1"/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="_this:dele:callback:object">
	<c path="cs.system.reflection.EventInfo_Delegate_AddEvent_2.T0"/>
	<c path="cs.system.reflection.EventInfo_Delegate_AddEvent_2.T1"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.EventInfo.AddEvent`2"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.reflection.EventInfo_AddEvent_2" params="T0:T1" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" module="cs.system.reflection.EventInfo">
		<from><icast field="FromHaxeFunction"><f a=":">
	<c path="FromHaxeFunction.T0"/>
	<c path="FromHaxeFunction.T1"/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.reflection.EventInfo_Delegate_AddEvent_2">
	<c path="cs.system.reflection.EventInfo_AddEvent_2.T0"/>
	<c path="cs.system.reflection.EventInfo_AddEvent_2.T1"/>
</c></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.reflection._EventInfo.EventInfo_AddEvent_2_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" private="1" module="cs.system.reflection.EventInfo" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<c path="cs.system.reflection.EventInfo_AddEvent_2.T0"/>
				<c path="cs.system.reflection.EventInfo_AddEvent_2.T1"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.reflection.EventInfo_AddEvent_2">
				<c path="cs.system.reflection.EventInfo_AddEvent_2.T0"/>
				<c path="cs.system.reflection.EventInfo_AddEvent_2.T1"/>
			</x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" params="T0:T1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<c path="FromHaxeFunction.T0"/>
				<c path="FromHaxeFunction.T1"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.reflection.EventInfo_AddEvent_2">
				<c path="FromHaxeFunction.T0"/>
				<c path="FromHaxeFunction.T1"/>
			</x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.reflection.EventInfo_Delegate_AddEvent_2">
		<c path="cs.system.reflection.EventInfo_AddEvent_2.T0"/>
		<c path="cs.system.reflection.EventInfo_AddEvent_2.T1"/>
	</c>
	<c path="cs.system.reflection.EventInfo_Delegate_AddEvent_2">
		<c path="cs.system.reflection.EventInfo_AddEvent_2.T0"/>
		<c path="cs.system.reflection.EventInfo_AddEvent_2.T1"/>
	</c>
</f></AsDelegate>
	<Add public="1" params="T0:T1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.reflection.EventInfo_AddEvent_2">
				<c path="Add.T0"/>
				<c path="Add.T1"/>
			</x>
			<x path="cs.system.reflection.EventInfo_AddEvent_2">
				<c path="Add.T0"/>
				<c path="Add.T1"/>
			</x>
			<x path="cs.system.reflection.EventInfo_AddEvent_2">
				<c path="Add.T0"/>
				<c path="Add.T1"/>
			</x>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" params="T0:T1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.reflection.EventInfo_AddEvent_2">
				<c path="Remove.T0"/>
				<c path="Remove.T1"/>
			</x>
			<x path="cs.system.reflection.EventInfo_AddEvent_2">
				<c path="Remove.T0"/>
				<c path="Remove.T1"/>
			</x>
			<x path="cs.system.reflection.EventInfo_AddEvent_2">
				<c path="Remove.T0"/>
				<c path="Remove.T1"/>
			</x>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.reflection._EventInfo.EventInfo_AddEvent_2_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" private="1" module="cs.system.reflection.EventInfo" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<c path="cs.system.reflection.EventInfo_AddEvent_2.T0"/>
					<c path="cs.system.reflection.EventInfo_AddEvent_2.T1"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.reflection.EventInfo_AddEvent_2">
					<c path="cs.system.reflection.EventInfo_AddEvent_2.T0"/>
					<c path="cs.system.reflection.EventInfo_AddEvent_2.T1"/>
				</x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" params="T0:T1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<c path="FromHaxeFunction.T0"/>
					<c path="FromHaxeFunction.T1"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.reflection.EventInfo_AddEvent_2">
					<c path="FromHaxeFunction.T0"/>
					<c path="FromHaxeFunction.T1"/>
				</x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.reflection.EventInfo_Delegate_AddEvent_2">
		<c path="cs.system.reflection.EventInfo_AddEvent_2.T0"/>
		<c path="cs.system.reflection.EventInfo_AddEvent_2.T1"/>
	</c>
	<c path="cs.system.reflection.EventInfo_Delegate_AddEvent_2">
		<c path="cs.system.reflection.EventInfo_AddEvent_2.T0"/>
		<c path="cs.system.reflection.EventInfo_AddEvent_2.T1"/>
	</c>
</f></AsDelegate>
		<Add public="1" params="T0:T1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.reflection.EventInfo_AddEvent_2">
					<c path="Add.T0"/>
					<c path="Add.T1"/>
				</x>
				<x path="cs.system.reflection.EventInfo_AddEvent_2">
					<c path="Add.T0"/>
					<c path="Add.T1"/>
				</x>
				<x path="cs.system.reflection.EventInfo_AddEvent_2">
					<c path="Add.T0"/>
					<c path="Add.T1"/>
				</x>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" params="T0:T1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.reflection.EventInfo_AddEvent_2">
					<c path="Remove.T0"/>
					<c path="Remove.T1"/>
				</x>
				<x path="cs.system.reflection.EventInfo_AddEvent_2">
					<c path="Remove.T0"/>
					<c path="Remove.T1"/>
				</x>
				<x path="cs.system.reflection.EventInfo_AddEvent_2">
					<c path="Remove.T0"/>
					<c path="Remove.T1"/>
				</x>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.reflection.EventInfo_Delegate_AddEventAdapter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" module="cs.system.reflection.EventInfo" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
	<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
	<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
	<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
	<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="_this:dele">
	<d/>
	<c path="cs.system.Delegate"/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="_this:dele:callback:object">
	<d/>
	<c path="cs.system.Delegate"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.EventInfo.AddEventAdapter"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.reflection.EventInfo_AddEventAdapter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" module="cs.system.reflection.EventInfo">
		<from><icast field="FromHaxeFunction"><f a=":">
	<d/>
	<c path="cs.system.Delegate"/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.reflection.EventInfo_Delegate_AddEventAdapter"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.reflection._EventInfo.EventInfo_AddEventAdapter_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" private="1" module="cs.system.reflection.EventInfo" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.Delegate"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.Delegate"/>
				<x path="Void"/>
			</f>
			<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.reflection.EventInfo_Delegate_AddEventAdapter"/>
	<c path="cs.system.reflection.EventInfo_Delegate_AddEventAdapter"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
			<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
			<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
			<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
			<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.reflection._EventInfo.EventInfo_AddEventAdapter_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" private="1" module="cs.system.reflection.EventInfo" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.Delegate"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.Delegate"/>
					<x path="Void"/>
				</f>
				<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.reflection.EventInfo_Delegate_AddEventAdapter"/>
	<c path="cs.system.reflection.EventInfo_Delegate_AddEventAdapter"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
				<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
				<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
				<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
				<x path="cs.system.reflection.EventInfo_AddEventAdapter"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.runtime.interopservices._EventInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._EventInfo" extern="1" interface="1">
		<ReflectedType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ReflectedType>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<MemberType public="1" get="accessor" set="null"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<IsSpecialName public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialName>
		<IsMulticast public="1" get="accessor" set="null"><x path="Bool"/></IsMulticast>
		<EventHandlerType public="1" get="accessor" set="null"><c path="cs.system.Type"/></EventHandlerType>
		<DeclaringType public="1" get="accessor" set="null"><c path="cs.system.Type"/></DeclaringType>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.EventAttributes"/></Attributes>
		<AddEventHandler public="1" set="method"><f a="target:handler">
	<d/>
	<c path="cs.system.Delegate"/>
	<x path="Void"/>
</f></AddEventHandler>
		<GetAddMethod public="1" set="method">
			<f a=""><c path="cs.system.reflection.MethodInfo"/></f>
			<overloads><GetAddMethod public="1" set="method"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetAddMethod></overloads>
		</GetAddMethod>
		<GetCustomAttributes public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<GetRaiseMethod public="1" set="method">
			<f a=""><c path="cs.system.reflection.MethodInfo"/></f>
			<overloads><GetRaiseMethod public="1" set="method"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetRaiseMethod></overloads>
		</GetRaiseMethod>
		<GetRemoveMethod public="1" set="method">
			<f a=""><c path="cs.system.reflection.MethodInfo"/></f>
			<overloads><GetRemoveMethod public="1" set="method"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetRemoveMethod></overloads>
		</GetRemoveMethod>
		<GetType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<RemoveEventHandler public="1" set="method"><f a="target:handler">
	<d/>
	<c path="cs.system.Delegate"/>
	<x path="Void"/>
</f></RemoveEventHandler>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<get_Attributes public="1" set="method"><f a=""><e path="cs.system.reflection.EventAttributes"/></f></get_Attributes>
		<get_DeclaringType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_EventHandlerType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_EventHandlerType>
		<get_IsMulticast public="1" set="method"><f a=""><x path="Bool"/></f></get_IsMulticast>
		<get_IsSpecialName public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialName>
		<get_MemberType public="1" set="method"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_ReflectedType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._EventInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.EventInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.EventInfo" extern="1" abstract="1">
		<extends path="cs.system.reflection.MemberInfo"/>
		<implements path="cs.system.runtime.interopservices._EventInfo"/>
		<MemberType public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<IsSpecialName public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialName>
		<IsMulticast public="1" get="accessor" set="null"><x path="Bool"/></IsMulticast>
		<EventHandlerType public="1" get="accessor" set="null"><c path="cs.system.Type"/></EventHandlerType>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.EventAttributes"/></Attributes>
		<get_Attributes abstract="1" public="1" set="method"><f a=""><e path="cs.system.reflection.EventAttributes"/></f></get_Attributes>
		<get_EventHandlerType final="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_EventHandlerType>
		<get_IsMulticast final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsMulticast>
		<get_IsSpecialName final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialName>
		<get_MemberType public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<AddEventHandler final="1" public="1" set="method"><f a="target:handler">
	<d/>
	<c path="cs.system.Delegate"/>
	<x path="Void"/>
</f></AddEventHandler>
		<GetAddMethod final="1" public="1" set="method">
			<f a=""><c path="cs.system.reflection.MethodInfo"/></f>
			<overloads><GetAddMethod abstract="1" public="1" set="method"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetAddMethod></overloads>
		</GetAddMethod>
		<GetRaiseMethod final="1" public="1" set="method">
			<f a=""><c path="cs.system.reflection.MethodInfo"/></f>
			<overloads><GetRaiseMethod abstract="1" public="1" set="method"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetRaiseMethod></overloads>
		</GetRaiseMethod>
		<GetRemoveMethod final="1" public="1" set="method">
			<f a=""><c path="cs.system.reflection.MethodInfo"/></f>
			<overloads><GetRemoveMethod abstract="1" public="1" set="method"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetRemoveMethod></overloads>
		</GetRemoveMethod>
		<GetOtherMethods public="1" set="method">
			<f a="nonPublic">
				<x path="Bool"/>
				<c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c>
			</f>
			<overloads><GetOtherMethods final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c></f></GetOtherMethods></overloads>
		</GetOtherMethods>
		<RemoveEventHandler final="1" public="1" set="method"><f a="target:handler">
	<d/>
	<c path="cs.system.Delegate"/>
	<x path="Void"/>
</f></RemoveEventHandler>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.EventInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.ExceptionHandlingClause" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ExceptionHandlingClause" extern="1" final="1">
		<TryOffset public="1" get="accessor" set="null"><x path="Int"/></TryOffset>
		<TryLength public="1" get="accessor" set="null"><x path="Int"/></TryLength>
		<HandlerOffset public="1" get="accessor" set="null"><x path="Int"/></HandlerOffset>
		<HandlerLength public="1" get="accessor" set="null"><x path="Int"/></HandlerLength>
		<Flags public="1" get="accessor" set="null"><e path="cs.system.reflection.ExceptionHandlingClauseOptions"/></Flags>
		<FilterOffset public="1" get="accessor" set="null"><x path="Int"/></FilterOffset>
		<CatchType public="1" get="accessor" set="null"><c path="cs.system.Type"/></CatchType>
		<get_CatchType final="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_CatchType>
		<get_FilterOffset final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_FilterOffset>
		<get_Flags final="1" public="1" set="method"><f a=""><e path="cs.system.reflection.ExceptionHandlingClauseOptions"/></f></get_Flags>
		<get_HandlerLength final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_HandlerLength>
		<get_HandlerOffset final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_HandlerOffset>
		<get_TryLength final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_TryLength>
		<get_TryOffset final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_TryOffset>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.ExceptionHandlingClause"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.ExceptionHandlingClauseOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ExceptionHandlingClauseOptions">
		<Clause><meta><m n=":csNative"><e>0</e></m></meta></Clause>
		<Filter><meta><m n=":csNative"><e>1</e></m></meta></Filter>
		<Finally><meta><m n=":csNative"><e>2</e></m></meta></Finally>
		<Fault><meta><m n=":csNative"><e>4</e></m></meta></Fault>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.ExceptionHandlingClauseOptions"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.reflection.FieldAttributes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.FieldAttributes">
		<PrivateScope><meta><m n=":csNative"><e>0</e></m></meta></PrivateScope>
		<Private><meta><m n=":csNative"><e>1</e></m></meta></Private>
		<FamANDAssem><meta><m n=":csNative"><e>2</e></m></meta></FamANDAssem>
		<Assembly><meta><m n=":csNative"><e>3</e></m></meta></Assembly>
		<Family><meta><m n=":csNative"><e>4</e></m></meta></Family>
		<FamORAssem><meta><m n=":csNative"><e>5</e></m></meta></FamORAssem>
		<Public><meta><m n=":csNative"><e>6</e></m></meta></Public>
		<FieldAccessMask><meta><m n=":csNative"><e>7</e></m></meta></FieldAccessMask>
		<Static><meta><m n=":csNative"><e>16</e></m></meta></Static>
		<InitOnly><meta><m n=":csNative"><e>32</e></m></meta></InitOnly>
		<Literal><meta><m n=":csNative"><e>64</e></m></meta></Literal>
		<NotSerialized><meta><m n=":csNative"><e>128</e></m></meta></NotSerialized>
		<HasFieldRVA><meta><m n=":csNative"><e>256</e></m></meta></HasFieldRVA>
		<SpecialName><meta><m n=":csNative"><e>512</e></m></meta></SpecialName>
		<RTSpecialName><meta><m n=":csNative"><e>1024</e></m></meta></RTSpecialName>
		<HasFieldMarshal><meta><m n=":csNative"><e>4096</e></m></meta></HasFieldMarshal>
		<PinvokeImpl><meta><m n=":csNative"><e>8192</e></m></meta></PinvokeImpl>
		<HasDefault><meta><m n=":csNative"><e>32768</e></m></meta></HasDefault>
		<ReservedMask><meta><m n=":csNative"><e>38144</e></m></meta></ReservedMask>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.FieldAttributes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.runtime.interopservices._FieldInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._FieldInfo" extern="1" interface="1">
		<ReflectedType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ReflectedType>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<MemberType public="1" get="accessor" set="null"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<IsStatic public="1" get="accessor" set="null"><x path="Bool"/></IsStatic>
		<IsSpecialName public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialName>
		<IsPublic public="1" get="accessor" set="null"><x path="Bool"/></IsPublic>
		<IsPrivate public="1" get="accessor" set="null"><x path="Bool"/></IsPrivate>
		<IsPinvokeImpl public="1" get="accessor" set="null"><x path="Bool"/></IsPinvokeImpl>
		<IsNotSerialized public="1" get="accessor" set="null"><x path="Bool"/></IsNotSerialized>
		<IsLiteral public="1" get="accessor" set="null"><x path="Bool"/></IsLiteral>
		<IsInitOnly public="1" get="accessor" set="null"><x path="Bool"/></IsInitOnly>
		<IsFamilyOrAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsFamilyOrAssembly>
		<IsFamilyAndAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsFamilyAndAssembly>
		<IsFamily public="1" get="accessor" set="null"><x path="Bool"/></IsFamily>
		<IsAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsAssembly>
		<FieldType public="1" get="accessor" set="null"><c path="cs.system.Type"/></FieldType>
		<FieldHandle public="1" get="accessor" set="null"><c path="cs.system.RuntimeFieldHandle"/></FieldHandle>
		<DeclaringType public="1" get="accessor" set="null"><c path="cs.system.Type"/></DeclaringType>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.FieldAttributes"/></Attributes>
		<GetCustomAttributes public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<GetValue public="1" set="method"><f a="obj">
	<d/>
	<d/>
</f></GetValue>
		<GetValueDirect public="1" set="method"><f a="obj">
	<c path="cs.system.TypedReference"/>
	<d/>
</f></GetValueDirect>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<SetValue public="1" set="method">
			<f a="obj:value">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<overloads><SetValue public="1" set="method"><f a="obj:value:invokeAttr:binder:culture">
	<d/>
	<d/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.system.globalization.CultureInfo"/>
	<x path="Void"/>
</f></SetValue></overloads>
		</SetValue>
		<SetValueDirect public="1" set="method"><f a="obj:value">
	<c path="cs.system.TypedReference"/>
	<d/>
	<x path="Void"/>
</f></SetValueDirect>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<get_Attributes public="1" set="method"><f a=""><e path="cs.system.reflection.FieldAttributes"/></f></get_Attributes>
		<get_DeclaringType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_FieldHandle public="1" set="method"><f a=""><c path="cs.system.RuntimeFieldHandle"/></f></get_FieldHandle>
		<get_FieldType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_FieldType>
		<get_IsAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAssembly>
		<get_IsFamily public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamily>
		<get_IsFamilyAndAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamilyAndAssembly>
		<get_IsFamilyOrAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamilyOrAssembly>
		<get_IsInitOnly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsInitOnly>
		<get_IsLiteral public="1" set="method"><f a=""><x path="Bool"/></f></get_IsLiteral>
		<get_IsNotSerialized public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNotSerialized>
		<get_IsPinvokeImpl public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPinvokeImpl>
		<get_IsPrivate public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPrivate>
		<get_IsPublic public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPublic>
		<get_IsSpecialName public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialName>
		<get_IsStatic public="1" set="method"><f a=""><x path="Bool"/></f></get_IsStatic>
		<get_MemberType public="1" set="method"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_ReflectedType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._FieldInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.FieldInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.FieldInfo" extern="1" abstract="1">
		<extends path="cs.system.reflection.MemberInfo"/>
		<implements path="cs.system.runtime.interopservices._FieldInfo"/>
		<GetFieldFromHandle public="1" set="method" static="1">
			<f a="handle">
				<c path="cs.system.RuntimeFieldHandle"/>
				<c path="cs.system.reflection.FieldInfo"/>
			</f>
			<overloads><GetFieldFromHandle public="1" set="method"><f a="handle:declaringType">
	<c path="cs.system.RuntimeFieldHandle"/>
	<c path="cs.system.RuntimeTypeHandle"/>
	<c path="cs.system.reflection.FieldInfo"/>
</f></GetFieldFromHandle></overloads>
		</GetFieldFromHandle>
		<IsNotSerialized public="1" get="accessor" set="null"><x path="Bool"/></IsNotSerialized>
		<IsSpecialName public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialName>
		<IsPinvokeImpl public="1" get="accessor" set="null"><x path="Bool"/></IsPinvokeImpl>
		<IsFamilyOrAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsFamilyOrAssembly>
		<IsFamilyAndAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsFamilyAndAssembly>
		<IsAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsAssembly>
		<IsFamily public="1" get="accessor" set="null"><x path="Bool"/></IsFamily>
		<IsPrivate public="1" get="accessor" set="null"><x path="Bool"/></IsPrivate>
		<IsPublic public="1" get="accessor" set="null"><x path="Bool"/></IsPublic>
		<IsInitOnly public="1" get="accessor" set="null"><x path="Bool"/></IsInitOnly>
		<IsStatic public="1" get="accessor" set="null"><x path="Bool"/></IsStatic>
		<IsLiteral public="1" get="accessor" set="null"><x path="Bool"/></IsLiteral>
		<MemberType public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<FieldType public="1" get="accessor" set="null"><c path="cs.system.Type"/></FieldType>
		<FieldHandle public="1" get="accessor" set="null"><c path="cs.system.RuntimeFieldHandle"/></FieldHandle>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.FieldAttributes"/></Attributes>
		<get_Attributes abstract="1" public="1" set="method"><f a=""><e path="cs.system.reflection.FieldAttributes"/></f></get_Attributes>
		<get_FieldHandle abstract="1" public="1" set="method"><f a=""><c path="cs.system.RuntimeFieldHandle"/></f></get_FieldHandle>
		<get_FieldType abstract="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_FieldType>
		<GetValue abstract="1" public="1" set="method"><f a="obj">
	<d/>
	<d/>
</f></GetValue>
		<get_MemberType public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_IsLiteral final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsLiteral>
		<get_IsStatic final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsStatic>
		<get_IsInitOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsInitOnly>
		<get_IsPublic final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPublic>
		<get_IsPrivate final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPrivate>
		<get_IsFamily final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamily>
		<get_IsAssembly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAssembly>
		<get_IsFamilyAndAssembly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamilyAndAssembly>
		<get_IsFamilyOrAssembly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamilyOrAssembly>
		<get_IsPinvokeImpl final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPinvokeImpl>
		<get_IsSpecialName final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialName>
		<get_IsNotSerialized final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsNotSerialized>
		<SetValue abstract="1" public="1" set="method">
			<f a="obj:value:invokeAttr:binder:culture">
				<d/>
				<d/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<c path="cs.system.globalization.CultureInfo"/>
				<x path="Void"/>
			</f>
			<overloads><SetValue final="1" public="1" set="method"><f a="obj:value">
	<d/>
	<d/>
	<x path="Void"/>
</f></SetValue></overloads>
		</SetValue>
		<GetValueDirect public="1" set="method"><f a="obj">
	<c path="cs.system.TypedReference"/>
	<d/>
</f></GetValueDirect>
		<SetValueDirect public="1" set="method"><f a="obj:value">
	<c path="cs.system.TypedReference"/>
	<d/>
	<x path="Void"/>
</f></SetValueDirect>
		<GetOptionalCustomModifiers public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetOptionalCustomModifiers>
		<GetRequiredCustomModifiers public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetRequiredCustomModifiers>
		<GetRawConstantValue public="1" set="method"><f a=""><d/></f></GetRawConstantValue>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.FieldInfo"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.GenericParameterAttributes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.GenericParameterAttributes">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<Covariant><meta><m n=":csNative"><e>1</e></m></meta></Covariant>
		<Contravariant><meta><m n=":csNative"><e>2</e></m></meta></Contravariant>
		<VarianceMask><meta><m n=":csNative"><e>3</e></m></meta></VarianceMask>
		<ReferenceTypeConstraint><meta><m n=":csNative"><e>4</e></m></meta></ReferenceTypeConstraint>
		<NotNullableValueTypeConstraint><meta><m n=":csNative"><e>8</e></m></meta></NotNullableValueTypeConstraint>
		<DefaultConstructorConstraint><meta><m n=":csNative"><e>16</e></m></meta></DefaultConstructorConstraint>
		<SpecialConstraintMask><meta><m n=":csNative"><e>28</e></m></meta></SpecialConstraintMask>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.GenericParameterAttributes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.reflection.ImageFileMachine" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ImageFileMachine">
		<I386><meta><m n=":csNative"><e>332</e></m></meta></I386>
		<IA64><meta><m n=":csNative"><e>512</e></m></meta></IA64>
		<AMD64><meta><m n=":csNative"><e>34404</e></m></meta></AMD64>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.ImageFileMachine"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.reflection.InterfaceMapping" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.InterfaceMapping" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<TargetType public="1"><c path="cs.system.Type"/></TargetType>
		<TargetMethods public="1"><c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c></TargetMethods>
		<InterfaceType public="1"><c path="cs.system.Type"/></InterfaceType>
		<InterfaceMethods public="1"><c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c></InterfaceMethods>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.InterfaceMapping"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.LocalVariableInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.LocalVariableInfo" extern="1">
		<LocalType public="1" get="accessor" set="null"><c path="cs.system.Type"/></LocalType>
		<LocalIndex public="1" get="accessor" set="null"><x path="Int"/></LocalIndex>
		<IsPinned public="1" get="accessor" set="null"><x path="Bool"/></IsPinned>
		<get_IsPinned public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPinned>
		<get_LocalIndex public="1" set="method"><f a=""><x path="Int"/></f></get_LocalIndex>
		<get_LocalType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_LocalType>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.LocalVariableInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.ManifestResourceInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ManifestResourceInfo" extern="1">
		<ResourceLocation public="1" get="accessor" set="null"><e path="cs.system.reflection.ResourceLocation"/></ResourceLocation>
		<ReferencedAssembly public="1" get="accessor" set="null"><c path="cs.system.reflection.Assembly"/></ReferencedAssembly>
		<FileName public="1" get="accessor" set="null"><c path="String"/></FileName>
		<get_FileName public="1" set="method"><f a=""><c path="String"/></f></get_FileName>
		<get_ReferencedAssembly public="1" set="method"><f a=""><c path="cs.system.reflection.Assembly"/></f></get_ReferencedAssembly>
		<get_ResourceLocation public="1" set="method"><f a=""><e path="cs.system.reflection.ResourceLocation"/></f></get_ResourceLocation>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.ManifestResourceInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.Delegate_MemberFilter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.MemberFilter" module="cs.system.reflection.MemberFilter" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.reflection.MemberFilter"/>
	<x path="cs.system.reflection.MemberFilter"/>
	<x path="cs.system.reflection.MemberFilter"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.reflection.MemberFilter"/>
	<x path="cs.system.reflection.MemberFilter"/>
	<x path="cs.system.reflection.MemberFilter"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="m:filterCriteria">
	<c path="cs.system.reflection.MemberInfo"/>
	<d/>
	<x path="Bool"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="m:filterCriteria:callback:object">
	<c path="cs.system.reflection.MemberInfo"/>
	<d/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Bool"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.MemberFilter"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.reflection.MemberFilter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.MemberFilter">
		<from><icast field="FromHaxeFunction"><f a=":">
	<c path="cs.system.reflection.MemberInfo"/>
	<d/>
	<x path="Bool"/>
</f></icast></from>
		<this><c path="cs.system.reflection.Delegate_MemberFilter"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.reflection._MemberFilter.MemberFilter_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.MemberFilter" private="1" module="cs.system.reflection.MemberFilter" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<c path="cs.system.reflection.MemberInfo"/>
				<d/>
				<x path="Bool"/>
			</f>
			<x path="cs.system.reflection.MemberFilter"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<c path="cs.system.reflection.MemberInfo"/>
				<d/>
				<x path="Bool"/>
			</f>
			<x path="cs.system.reflection.MemberFilter"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.reflection.Delegate_MemberFilter"/>
	<c path="cs.system.reflection.Delegate_MemberFilter"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.reflection.MemberFilter"/>
			<x path="cs.system.reflection.MemberFilter"/>
			<x path="cs.system.reflection.MemberFilter"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.reflection.MemberFilter"/>
			<x path="cs.system.reflection.MemberFilter"/>
			<x path="cs.system.reflection.MemberFilter"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.reflection._MemberFilter.MemberFilter_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.MemberFilter" private="1" module="cs.system.reflection.MemberFilter" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<c path="cs.system.reflection.MemberInfo"/>
					<d/>
					<x path="Bool"/>
				</f>
				<x path="cs.system.reflection.MemberFilter"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<c path="cs.system.reflection.MemberInfo"/>
					<d/>
					<x path="Bool"/>
				</f>
				<x path="cs.system.reflection.MemberFilter"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.reflection.Delegate_MemberFilter"/>
	<c path="cs.system.reflection.Delegate_MemberFilter"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.reflection.MemberFilter"/>
				<x path="cs.system.reflection.MemberFilter"/>
				<x path="cs.system.reflection.MemberFilter"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.reflection.MemberFilter"/>
				<x path="cs.system.reflection.MemberFilter"/>
				<x path="cs.system.reflection.MemberFilter"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<enum path="cs.system.reflection.MemberTypes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.MemberTypes">
		<Constructor><meta><m n=":csNative"><e>1</e></m></meta></Constructor>
		<Event><meta><m n=":csNative"><e>2</e></m></meta></Event>
		<Field><meta><m n=":csNative"><e>4</e></m></meta></Field>
		<Method><meta><m n=":csNative"><e>8</e></m></meta></Method>
		<Property><meta><m n=":csNative"><e>16</e></m></meta></Property>
		<TypeInfo><meta><m n=":csNative"><e>32</e></m></meta></TypeInfo>
		<Custom><meta><m n=":csNative"><e>64</e></m></meta></Custom>
		<NestedType><meta><m n=":csNative"><e>128</e></m></meta></NestedType>
		<All><meta><m n=":csNative"><e>191</e></m></meta></All>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.MemberTypes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.reflection.MethodAttributes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.MethodAttributes">
		<PrivateScope><meta><m n=":csNative"><e>0</e></m></meta></PrivateScope>
		<ReuseSlot><meta><m n=":csNative"><e>0</e></m></meta></ReuseSlot>
		<Private><meta><m n=":csNative"><e>1</e></m></meta></Private>
		<FamANDAssem><meta><m n=":csNative"><e>2</e></m></meta></FamANDAssem>
		<Assembly><meta><m n=":csNative"><e>3</e></m></meta></Assembly>
		<Family><meta><m n=":csNative"><e>4</e></m></meta></Family>
		<FamORAssem><meta><m n=":csNative"><e>5</e></m></meta></FamORAssem>
		<Public><meta><m n=":csNative"><e>6</e></m></meta></Public>
		<MemberAccessMask><meta><m n=":csNative"><e>7</e></m></meta></MemberAccessMask>
		<UnmanagedExport><meta><m n=":csNative"><e>8</e></m></meta></UnmanagedExport>
		<Static><meta><m n=":csNative"><e>16</e></m></meta></Static>
		<Final><meta><m n=":csNative"><e>32</e></m></meta></Final>
		<Virtual><meta><m n=":csNative"><e>64</e></m></meta></Virtual>
		<HideBySig><meta><m n=":csNative"><e>128</e></m></meta></HideBySig>
		<VtableLayoutMask><meta><m n=":csNative"><e>256</e></m></meta></VtableLayoutMask>
		<NewSlot><meta><m n=":csNative"><e>256</e></m></meta></NewSlot>
		<CheckAccessOnOverride><meta><m n=":csNative"><e>512</e></m></meta></CheckAccessOnOverride>
		<Abstract><meta><m n=":csNative"><e>1024</e></m></meta></Abstract>
		<SpecialName><meta><m n=":csNative"><e>2048</e></m></meta></SpecialName>
		<RTSpecialName><meta><m n=":csNative"><e>4096</e></m></meta></RTSpecialName>
		<PinvokeImpl><meta><m n=":csNative"><e>8192</e></m></meta></PinvokeImpl>
		<HasSecurity><meta><m n=":csNative"><e>16384</e></m></meta></HasSecurity>
		<RequireSecObject><meta><m n=":csNative"><e>32768</e></m></meta></RequireSecObject>
		<ReservedMask><meta><m n=":csNative"><e>53248</e></m></meta></ReservedMask>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.MethodAttributes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.reflection.MethodBody" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.MethodBody" extern="1" final="1">
		<MaxStackSize public="1" get="accessor" set="null"><x path="Int"/></MaxStackSize>
		<LocalSignatureMetadataToken public="1" get="accessor" set="null"><x path="Int"/></LocalSignatureMetadataToken>
		<InitLocals public="1" get="accessor" set="null"><x path="Bool"/></InitLocals>
		<LocalVariables public="1" get="accessor" set="null"><c path="cs.system.collections.generic.IList_1"><c path="cs.system.reflection.LocalVariableInfo"/></c></LocalVariables>
		<ExceptionHandlingClauses public="1" get="accessor" set="null"><c path="cs.system.collections.generic.IList_1"><c path="cs.system.reflection.ExceptionHandlingClause"/></c></ExceptionHandlingClauses>
		<get_ExceptionHandlingClauses final="1" public="1" set="method"><f a=""><c path="cs.system.collections.generic.IList_1"><c path="cs.system.reflection.ExceptionHandlingClause"/></c></f></get_ExceptionHandlingClauses>
		<get_LocalVariables final="1" public="1" set="method"><f a=""><c path="cs.system.collections.generic.IList_1"><c path="cs.system.reflection.LocalVariableInfo"/></c></f></get_LocalVariables>
		<get_InitLocals final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_InitLocals>
		<get_LocalSignatureMetadataToken final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_LocalSignatureMetadataToken>
		<get_MaxStackSize final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_MaxStackSize>
		<GetILAsByteArray final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetILAsByteArray>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.MethodBody"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.MethodImplAttributes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.MethodImplAttributes">
		<IL><meta><m n=":csNative"><e>0</e></m></meta></IL>
		<Managed><meta><m n=":csNative"><e>0</e></m></meta></Managed>
		<Native><meta><m n=":csNative"><e>1</e></m></meta></Native>
		<OPTIL><meta><m n=":csNative"><e>2</e></m></meta></OPTIL>
		<CodeTypeMask><meta><m n=":csNative"><e>3</e></m></meta></CodeTypeMask>
		<Runtime><meta><m n=":csNative"><e>3</e></m></meta></Runtime>
		<ManagedMask><meta><m n=":csNative"><e>4</e></m></meta></ManagedMask>
		<Unmanaged><meta><m n=":csNative"><e>4</e></m></meta></Unmanaged>
		<NoInlining><meta><m n=":csNative"><e>8</e></m></meta></NoInlining>
		<ForwardRef><meta><m n=":csNative"><e>16</e></m></meta></ForwardRef>
		<Synchronized><meta><m n=":csNative"><e>32</e></m></meta></Synchronized>
		<NoOptimization><meta><m n=":csNative"><e>64</e></m></meta></NoOptimization>
		<PreserveSig><meta><m n=":csNative"><e>128</e></m></meta></PreserveSig>
		<InternalCall><meta><m n=":csNative"><e>4096</e></m></meta></InternalCall>
		<MaxMethodImplVal><meta><m n=":csNative"><e>65535</e></m></meta></MaxMethodImplVal>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.MethodImplAttributes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.runtime.interopservices._MethodInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._MethodInfo" extern="1" interface="1">
		<ReturnTypeCustomAttributes public="1" get="accessor" set="null"><c path="cs.system.reflection.ICustomAttributeProvider"/></ReturnTypeCustomAttributes>
		<ReturnType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ReturnType>
		<ReflectedType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ReflectedType>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<MethodHandle public="1" get="accessor" set="null"><c path="cs.system.RuntimeMethodHandle"/></MethodHandle>
		<MemberType public="1" get="accessor" set="null"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<IsVirtual public="1" get="accessor" set="null"><x path="Bool"/></IsVirtual>
		<IsStatic public="1" get="accessor" set="null"><x path="Bool"/></IsStatic>
		<IsSpecialName public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialName>
		<IsPublic public="1" get="accessor" set="null"><x path="Bool"/></IsPublic>
		<IsPrivate public="1" get="accessor" set="null"><x path="Bool"/></IsPrivate>
		<IsHideBySig public="1" get="accessor" set="null"><x path="Bool"/></IsHideBySig>
		<IsFinal public="1" get="accessor" set="null"><x path="Bool"/></IsFinal>
		<IsFamilyOrAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsFamilyOrAssembly>
		<IsFamilyAndAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsFamilyAndAssembly>
		<IsFamily public="1" get="accessor" set="null"><x path="Bool"/></IsFamily>
		<IsConstructor public="1" get="accessor" set="null"><x path="Bool"/></IsConstructor>
		<IsAssembly public="1" get="accessor" set="null"><x path="Bool"/></IsAssembly>
		<IsAbstract public="1" get="accessor" set="null"><x path="Bool"/></IsAbstract>
		<DeclaringType public="1" get="accessor" set="null"><c path="cs.system.Type"/></DeclaringType>
		<CallingConvention public="1" get="accessor" set="null"><e path="cs.system.reflection.CallingConventions"/></CallingConvention>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.MethodAttributes"/></Attributes>
		<GetBaseDefinition public="1" set="method"><f a=""><c path="cs.system.reflection.MethodInfo"/></f></GetBaseDefinition>
		<GetCustomAttributes public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetMethodImplementationFlags public="1" set="method"><f a=""><e path="cs.system.reflection.MethodImplAttributes"/></f></GetMethodImplementationFlags>
		<GetParameters public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ParameterInfo"/></c></f></GetParameters>
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method">
			<f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
				<x path="UInt"/>
				<t path="cs.Ref"><c path="cs.system.Guid"/></t>
				<x path="UInt"/>
				<t path="cs.types.Int16"/>
				<c path="cs.system.IntPtr"/>
				<c path="cs.system.IntPtr"/>
				<c path="cs.system.IntPtr"/>
				<c path="cs.system.IntPtr"/>
				<x path="Void"/>
			</f>
			<overloads>
				<Invoke public="1" set="method"><f a="obj:invokeAttr:binder:parameters:culture">
	<d/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<d/>
</f></Invoke>
				<Invoke public="1" set="method"><f a="obj:parameters">
	<d/>
	<c path="cs.NativeArray"><d/></c>
	<d/>
</f></Invoke>
			</overloads>
		</Invoke>
		<GetType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<get_Attributes public="1" set="method"><f a=""><e path="cs.system.reflection.MethodAttributes"/></f></get_Attributes>
		<get_CallingConvention public="1" set="method"><f a=""><e path="cs.system.reflection.CallingConventions"/></f></get_CallingConvention>
		<get_DeclaringType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_IsAbstract public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAbstract>
		<get_IsAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAssembly>
		<get_IsConstructor public="1" set="method"><f a=""><x path="Bool"/></f></get_IsConstructor>
		<get_IsFamily public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamily>
		<get_IsFamilyAndAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamilyAndAssembly>
		<get_IsFamilyOrAssembly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFamilyOrAssembly>
		<get_IsFinal public="1" set="method"><f a=""><x path="Bool"/></f></get_IsFinal>
		<get_IsHideBySig public="1" set="method"><f a=""><x path="Bool"/></f></get_IsHideBySig>
		<get_IsPrivate public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPrivate>
		<get_IsPublic public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPublic>
		<get_IsSpecialName public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialName>
		<get_IsStatic public="1" set="method"><f a=""><x path="Bool"/></f></get_IsStatic>
		<get_IsVirtual public="1" set="method"><f a=""><x path="Bool"/></f></get_IsVirtual>
		<get_MemberType public="1" set="method"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_MethodHandle public="1" set="method"><f a=""><c path="cs.system.RuntimeMethodHandle"/></f></get_MethodHandle>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_ReflectedType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<get_ReturnType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ReturnType>
		<get_ReturnTypeCustomAttributes public="1" set="method"><f a=""><c path="cs.system.reflection.ICustomAttributeProvider"/></f></get_ReturnTypeCustomAttributes>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._MethodInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.MethodInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.MethodInfo" extern="1" abstract="1">
		<extends path="cs.system.reflection.MethodBase"/>
		<implements path="cs.system.runtime.interopservices._MethodInfo"/>
		<ReturnParameter public="1" get="accessor" set="null"><c path="cs.system.reflection.ParameterInfo"/></ReturnParameter>
		<ContainsGenericParameters public="1" get="accessor" set="null" override="1"><x path="Bool"/></ContainsGenericParameters>
		<IsGenericMethodDefinition public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsGenericMethodDefinition>
		<IsGenericMethod public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsGenericMethod>
		<ReturnTypeCustomAttributes public="1" get="accessor" set="null"><c path="cs.system.reflection.ICustomAttributeProvider"/></ReturnTypeCustomAttributes>
		<ReturnType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ReturnType>
		<MemberType public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<GetBaseDefinition abstract="1" public="1" set="method"><f a=""><c path="cs.system.reflection.MethodInfo"/></f></GetBaseDefinition>
		<get_MemberType public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_ReturnType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ReturnType>
		<get_ReturnTypeCustomAttributes abstract="1" public="1" set="method"><f a=""><c path="cs.system.reflection.ICustomAttributeProvider"/></f></get_ReturnTypeCustomAttributes>
		<GetGenericMethodDefinition public="1" set="method"><f a=""><c path="cs.system.reflection.MethodInfo"/></f></GetGenericMethodDefinition>
		<MakeGenericMethod public="1" set="method"><f a="typeArguments">
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></MakeGenericMethod>
		<GetGenericArguments public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetGenericArguments>
		<get_IsGenericMethod public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsGenericMethod>
		<get_IsGenericMethodDefinition public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsGenericMethodDefinition>
		<get_ContainsGenericParameters public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_ContainsGenericParameters>
		<get_ReturnParameter public="1" set="method"><f a=""><c path="cs.system.reflection.ParameterInfo"/></f></get_ReturnParameter>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.MethodInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._Module" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._Module" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._Module"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.Module" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.Module" extern="1">
		<implements path="cs.system.reflection.ICustomAttributeProvider"/>
		<implements path="cs.system.runtime.interopservices._Module"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<FilterTypeNameIgnoreCase public="1" set="null" static="1">
			<x path="cs.system.reflection.TypeFilter"/>
			<meta><m n=":readOnly"/></meta>
		</FilterTypeNameIgnoreCase>
		<FilterTypeName public="1" set="null" static="1">
			<x path="cs.system.reflection.TypeFilter"/>
			<meta><m n=":readOnly"/></meta>
		</FilterTypeName>
		<MetadataToken public="1" get="accessor" set="null"><x path="Int"/></MetadataToken>
		<FullyQualifiedName public="1" get="accessor" set="null"><c path="String"/></FullyQualifiedName>
		<ModuleVersionId public="1" get="accessor" set="null"><c path="cs.system.Guid"/></ModuleVersionId>
		<MDStreamVersion public="1" get="accessor" set="null"><x path="Int"/></MDStreamVersion>
		<ScopeName public="1" get="accessor" set="null"><c path="String"/></ScopeName>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<Assembly public="1" get="accessor" set="null"><c path="cs.system.reflection.Assembly"/></Assembly>
		<ModuleHandle public="1" get="accessor" set="null"><c path="cs.system.ModuleHandle"/></ModuleHandle>
		<get_ModuleHandle final="1" public="1" set="method"><f a=""><c path="cs.system.ModuleHandle"/></f></get_ModuleHandle>
		<GetField final="1" public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.FieldInfo"/>
			</f>
			<overloads><GetField public="1" set="method"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.FieldInfo"/>
</f></GetField></overloads>
		</GetField>
		<GetFields final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c></f>
			<overloads><GetFields public="1" set="method"><f a="bindingFlags">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c>
</f></GetFields></overloads>
		</GetFields>
		<GetMethod final="1" public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.MethodInfo"/>
			</f>
			<overloads>
				<GetMethod final="1" public="1" set="method"><f a="name:bindingAttr:binder:callConvention:types:modifiers">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
				<GetMethod final="1" public="1" set="method"><f a="name:types">
	<c path="String"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
			</overloads>
		</GetMethod>
		<GetMethods final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c></f>
			<overloads><GetMethods final="1" public="1" set="method"><f a="bindingFlags">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c>
</f></GetMethods></overloads>
		</GetMethods>
		<GetObjectData public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<GetType public="1" set="method">
			<f a="className">
				<c path="String"/>
				<c path="cs.system.Type"/>
			</f>
			<overloads>
				<GetType public="1" set="method"><f a="className:throwOnError:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetType>
				<GetType public="1" set="method"><f a="className:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetType>
			</overloads>
		</GetType>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<ResolveField final="1" public="1" set="method">
			<f a="metadataToken">
				<x path="Int"/>
				<c path="cs.system.reflection.FieldInfo"/>
			</f>
			<overloads><ResolveField final="1" public="1" set="method"><f a="metadataToken:genericTypeArguments:genericMethodArguments">
	<x path="Int"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.FieldInfo"/>
</f></ResolveField></overloads>
		</ResolveField>
		<ResolveMember final="1" public="1" set="method">
			<f a="metadataToken">
				<x path="Int"/>
				<c path="cs.system.reflection.MemberInfo"/>
			</f>
			<overloads><ResolveMember final="1" public="1" set="method"><f a="metadataToken:genericTypeArguments:genericMethodArguments">
	<x path="Int"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.MemberInfo"/>
</f></ResolveMember></overloads>
		</ResolveMember>
		<ResolveMethod final="1" public="1" set="method">
			<f a="metadataToken">
				<x path="Int"/>
				<c path="cs.system.reflection.MethodBase"/>
			</f>
			<overloads><ResolveMethod final="1" public="1" set="method"><f a="metadataToken:genericTypeArguments:genericMethodArguments">
	<x path="Int"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.MethodBase"/>
</f></ResolveMethod></overloads>
		</ResolveMethod>
		<ResolveType final="1" public="1" set="method">
			<f a="metadataToken">
				<x path="Int"/>
				<c path="cs.system.Type"/>
			</f>
			<overloads><ResolveType final="1" public="1" set="method"><f a="metadataToken:genericTypeArguments:genericMethodArguments">
	<x path="Int"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.Type"/>
</f></ResolveType></overloads>
		</ResolveType>
		<get_Assembly final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.Assembly"/></f></get_Assembly>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_ScopeName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_ScopeName>
		<get_MDStreamVersion final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_MDStreamVersion>
		<get_ModuleVersionId final="1" public="1" set="method"><f a=""><c path="cs.system.Guid"/></f></get_ModuleVersionId>
		<get_FullyQualifiedName public="1" set="method"><f a=""><c path="String"/></f></get_FullyQualifiedName>
		<IsResource final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsResource>
		<FindTypes public="1" set="method"><f a="filter:filterCriteria">
	<x path="cs.system.reflection.TypeFilter"/>
	<d/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
</f></FindTypes>
		<GetCustomAttributes public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<get_MetadataToken public="1" set="method"><f a=""><x path="Int"/></f></get_MetadataToken>
		<GetMethodImpl set="method">
			<f a="name:bindingAttr:binder:callConvention:types:modifiers">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.MethodInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetMethodImpl>
		<GetPEKind public="1" set="method"><f a="peKind:machine">
	<t path="cs.Out"><e path="cs.system.reflection.PortableExecutableKinds"/></t>
	<t path="cs.Out"><e path="cs.system.reflection.ImageFileMachine"/></t>
	<x path="Void"/>
</f></GetPEKind>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<ResolveString final="1" public="1" set="method"><f a="metadataToken">
	<x path="Int"/>
	<c path="String"/>
</f></ResolveString>
		<ResolveSignature final="1" public="1" set="method"><f a="metadataToken">
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></ResolveSignature>
		<GetSignerCertificate final="1" public="1" set="method"><f a=""><c path="cs.system.security.cryptography.x509certificates.X509Certificate"/></f></GetSignerCertificate>
		<GetTypes public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetTypes>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Module"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.Delegate_ModuleResolveEventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ModuleResolveEventHandler" module="cs.system.reflection.ModuleResolveEventHandler" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.reflection.ModuleResolveEventHandler"/>
	<x path="cs.system.reflection.ModuleResolveEventHandler"/>
	<x path="cs.system.reflection.ModuleResolveEventHandler"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.reflection.ModuleResolveEventHandler"/>
	<x path="cs.system.reflection.ModuleResolveEventHandler"/>
	<x path="cs.system.reflection.ModuleResolveEventHandler"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="sender:e">
	<d/>
	<c path="cs.system.ResolveEventArgs"/>
	<c path="cs.system.reflection.Module"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="sender:e:callback:object">
	<d/>
	<c path="cs.system.ResolveEventArgs"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<c path="cs.system.reflection.Module"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.ModuleResolveEventHandler"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.reflection.ModuleResolveEventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ModuleResolveEventHandler">
		<from><icast field="FromHaxeFunction"><f a=":">
	<d/>
	<c path="cs.system.ResolveEventArgs"/>
	<c path="cs.system.reflection.Module"/>
</f></icast></from>
		<this><c path="cs.system.reflection.Delegate_ModuleResolveEventHandler"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.reflection._ModuleResolveEventHandler.ModuleResolveEventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ModuleResolveEventHandler" private="1" module="cs.system.reflection.ModuleResolveEventHandler" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.ResolveEventArgs"/>
				<c path="cs.system.reflection.Module"/>
			</f>
			<x path="cs.system.reflection.ModuleResolveEventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<d/>
				<c path="cs.system.ResolveEventArgs"/>
				<c path="cs.system.reflection.Module"/>
			</f>
			<x path="cs.system.reflection.ModuleResolveEventHandler"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.reflection.Delegate_ModuleResolveEventHandler"/>
	<c path="cs.system.reflection.Delegate_ModuleResolveEventHandler"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.reflection.ModuleResolveEventHandler"/>
			<x path="cs.system.reflection.ModuleResolveEventHandler"/>
			<x path="cs.system.reflection.ModuleResolveEventHandler"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.reflection.ModuleResolveEventHandler"/>
			<x path="cs.system.reflection.ModuleResolveEventHandler"/>
			<x path="cs.system.reflection.ModuleResolveEventHandler"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.reflection._ModuleResolveEventHandler.ModuleResolveEventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ModuleResolveEventHandler" private="1" module="cs.system.reflection.ModuleResolveEventHandler" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.ResolveEventArgs"/>
					<c path="cs.system.reflection.Module"/>
				</f>
				<x path="cs.system.reflection.ModuleResolveEventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<d/>
					<c path="cs.system.ResolveEventArgs"/>
					<c path="cs.system.reflection.Module"/>
				</f>
				<x path="cs.system.reflection.ModuleResolveEventHandler"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.reflection.Delegate_ModuleResolveEventHandler"/>
	<c path="cs.system.reflection.Delegate_ModuleResolveEventHandler"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.reflection.ModuleResolveEventHandler"/>
				<x path="cs.system.reflection.ModuleResolveEventHandler"/>
				<x path="cs.system.reflection.ModuleResolveEventHandler"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.reflection.ModuleResolveEventHandler"/>
				<x path="cs.system.reflection.ModuleResolveEventHandler"/>
				<x path="cs.system.reflection.ModuleResolveEventHandler"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<enum path="cs.system.reflection.ParameterAttributes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ParameterAttributes">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<In><meta><m n=":csNative"><e>1</e></m></meta></In>
		<Out><meta><m n=":csNative"><e>2</e></m></meta></Out>
		<Lcid><meta><m n=":csNative"><e>4</e></m></meta></Lcid>
		<Retval><meta><m n=":csNative"><e>8</e></m></meta></Retval>
		<Optional><meta><m n=":csNative"><e>16</e></m></meta></Optional>
		<HasDefault><meta><m n=":csNative"><e>4096</e></m></meta></HasDefault>
		<HasFieldMarshal><meta><m n=":csNative"><e>8192</e></m></meta></HasFieldMarshal>
		<Reserved3><meta><m n=":csNative"><e>16384</e></m></meta></Reserved3>
		<Reserved4><meta><m n=":csNative"><e>32768</e></m></meta></Reserved4>
		<ReservedMask><meta><m n=":csNative"><e>61440</e></m></meta></ReservedMask>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.ParameterAttributes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.runtime.interopservices._ParameterInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._ParameterInfo" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._ParameterInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.ParameterInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ParameterInfo" extern="1">
		<implements path="cs.system.reflection.ICustomAttributeProvider"/>
		<implements path="cs.system.runtime.interopservices._ParameterInfo"/>
		<RawDefaultValue public="1" get="accessor" set="null"><d/></RawDefaultValue>
		<MetadataToken public="1" get="accessor" set="null"><x path="Int"/></MetadataToken>
		<Position public="1" get="accessor" set="null"><x path="Int"/></Position>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<Member public="1" get="accessor" set="null"><c path="cs.system.reflection.MemberInfo"/></Member>
		<IsRetval public="1" get="accessor" set="null"><x path="Bool"/></IsRetval>
		<IsOut public="1" get="accessor" set="null"><x path="Bool"/></IsOut>
		<IsOptional public="1" get="accessor" set="null"><x path="Bool"/></IsOptional>
		<IsLcid public="1" get="accessor" set="null"><x path="Bool"/></IsLcid>
		<IsIn public="1" get="accessor" set="null"><x path="Bool"/></IsIn>
		<DefaultValue public="1" get="accessor" set="null"><d/></DefaultValue>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.ParameterAttributes"/></Attributes>
		<ParameterType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ParameterType>
		<AttrsImpl><e path="cs.system.reflection.ParameterAttributes"/></AttrsImpl>
		<PositionImpl><x path="Int"/></PositionImpl>
		<NameImpl><c path="String"/></NameImpl>
		<MemberImpl><c path="cs.system.reflection.MemberInfo"/></MemberImpl>
		<DefaultValueImpl><d/></DefaultValueImpl>
		<ClassImpl><c path="cs.system.Type"/></ClassImpl>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<get_ParameterType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ParameterType>
		<get_Attributes public="1" set="method"><f a=""><e path="cs.system.reflection.ParameterAttributes"/></f></get_Attributes>
		<get_DefaultValue public="1" set="method"><f a=""><d/></f></get_DefaultValue>
		<get_IsIn final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsIn>
		<get_IsLcid final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsLcid>
		<get_IsOptional final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsOptional>
		<get_IsOut final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsOut>
		<get_IsRetval final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsRetval>
		<get_Member public="1" set="method"><f a=""><c path="cs.system.reflection.MemberInfo"/></f></get_Member>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_Position public="1" set="method"><f a=""><x path="Int"/></f></get_Position>
		<get_MetadataToken final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_MetadataToken>
		<GetCustomAttributes public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<GetOptionalCustomModifiers public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetOptionalCustomModifiers>
		<GetRequiredCustomModifiers public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetRequiredCustomModifiers>
		<get_RawDefaultValue public="1" set="method"><f a=""><d/></f></get_RawDefaultValue>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.ParameterInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.ParameterModifier" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ParameterModifier" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<get_Item final="1" public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Bool"/>
</f></get_Item>
		<set_Item final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></set_Item>
		<new final="1" public="1" set="method"><f a="parameterCount">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.ParameterModifier"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.PortableExecutableKinds" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.PortableExecutableKinds">
		<NotAPortableExecutableImage><meta><m n=":csNative"><e>0</e></m></meta></NotAPortableExecutableImage>
		<ILOnly><meta><m n=":csNative"><e>1</e></m></meta></ILOnly>
		<Required32Bit><meta><m n=":csNative"><e>2</e></m></meta></Required32Bit>
		<PE32Plus><meta><m n=":csNative"><e>4</e></m></meta></PE32Plus>
		<Unmanaged32Bit><meta><m n=":csNative"><e>8</e></m></meta></Unmanaged32Bit>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.PortableExecutableKinds"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.reflection.ProcessorArchitecture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ProcessorArchitecture">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<MSIL><meta><m n=":csNative"><e>1</e></m></meta></MSIL>
		<X86><meta><m n=":csNative"><e>2</e></m></meta></X86>
		<IA64><meta><m n=":csNative"><e>3</e></m></meta></IA64>
		<Amd64><meta><m n=":csNative"><e>4</e></m></meta></Amd64>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.ProcessorArchitecture"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.reflection.PropertyAttributes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.PropertyAttributes">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<SpecialName><meta><m n=":csNative"><e>512</e></m></meta></SpecialName>
		<RTSpecialName><meta><m n=":csNative"><e>1024</e></m></meta></RTSpecialName>
		<HasDefault><meta><m n=":csNative"><e>4096</e></m></meta></HasDefault>
		<Reserved2><meta><m n=":csNative"><e>8192</e></m></meta></Reserved2>
		<Reserved3><meta><m n=":csNative"><e>16384</e></m></meta></Reserved3>
		<Reserved4><meta><m n=":csNative"><e>32768</e></m></meta></Reserved4>
		<ReservedMask><meta><m n=":csNative"><e>62464</e></m></meta></ReservedMask>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.PropertyAttributes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.runtime.interopservices._PropertyInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._PropertyInfo" extern="1" interface="1">
		<ReflectedType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ReflectedType>
		<PropertyType public="1" get="accessor" set="null"><c path="cs.system.Type"/></PropertyType>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<MemberType public="1" get="accessor" set="null"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<IsSpecialName public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialName>
		<DeclaringType public="1" get="accessor" set="null"><c path="cs.system.Type"/></DeclaringType>
		<CanWrite public="1" get="accessor" set="null"><x path="Bool"/></CanWrite>
		<CanRead public="1" get="accessor" set="null"><x path="Bool"/></CanRead>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.PropertyAttributes"/></Attributes>
		<GetAccessors public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c></f>
			<overloads><GetAccessors public="1" set="method"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c>
</f></GetAccessors></overloads>
		</GetAccessors>
		<GetCustomAttributes public="1" set="method">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetGetMethod public="1" set="method">
			<f a=""><c path="cs.system.reflection.MethodInfo"/></f>
			<overloads><GetGetMethod public="1" set="method"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetGetMethod></overloads>
		</GetGetMethod>
		<GetIndexParameters public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ParameterInfo"/></c></f></GetIndexParameters>
		<GetSetMethod public="1" set="method">
			<f a=""><c path="cs.system.reflection.MethodInfo"/></f>
			<overloads><GetSetMethod public="1" set="method"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetSetMethod></overloads>
		</GetSetMethod>
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<GetType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></GetType>
		<GetValue public="1" set="method">
			<f a="obj:index">
				<d/>
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<overloads><GetValue public="1" set="method"><f a="obj:invokeAttr:binder:index:culture">
	<d/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<d/>
</f></GetValue></overloads>
		</GetValue>
		<IsDefined public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<SetValue public="1" set="method">
			<f a="obj:value:index">
				<d/>
				<d/>
				<c path="cs.NativeArray"><d/></c>
				<x path="Void"/>
			</f>
			<overloads><SetValue public="1" set="method"><f a="obj:value:invokeAttr:binder:index:culture">
	<d/>
	<d/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<x path="Void"/>
</f></SetValue></overloads>
		</SetValue>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<get_Attributes public="1" set="method"><f a=""><e path="cs.system.reflection.PropertyAttributes"/></f></get_Attributes>
		<get_CanRead public="1" set="method"><f a=""><x path="Bool"/></f></get_CanRead>
		<get_CanWrite public="1" set="method"><f a=""><x path="Bool"/></f></get_CanWrite>
		<get_DeclaringType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_IsSpecialName public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialName>
		<get_MemberType public="1" set="method"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_PropertyType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_PropertyType>
		<get_ReflectedType public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._PropertyInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.PropertyInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.PropertyInfo" extern="1" abstract="1">
		<extends path="cs.system.reflection.MemberInfo"/>
		<implements path="cs.system.runtime.interopservices._PropertyInfo"/>
		<PropertyType public="1" get="accessor" set="null"><c path="cs.system.Type"/></PropertyType>
		<MemberType public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.MemberTypes"/></MemberType>
		<IsSpecialName public="1" get="accessor" set="null"><x path="Bool"/></IsSpecialName>
		<CanWrite public="1" get="accessor" set="null"><x path="Bool"/></CanWrite>
		<CanRead public="1" get="accessor" set="null"><x path="Bool"/></CanRead>
		<Attributes public="1" get="accessor" set="null"><e path="cs.system.reflection.PropertyAttributes"/></Attributes>
		<get_Attributes abstract="1" public="1" set="method"><f a=""><e path="cs.system.reflection.PropertyAttributes"/></f></get_Attributes>
		<get_CanRead abstract="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_CanRead>
		<get_CanWrite abstract="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_CanWrite>
		<get_IsSpecialName final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSpecialName>
		<get_MemberType public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.MemberTypes"/></f></get_MemberType>
		<get_PropertyType abstract="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_PropertyType>
		<GetAccessors final="1" public="1" set="method">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c></f>
			<overloads><GetAccessors abstract="1" public="1" set="method"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c>
</f></GetAccessors></overloads>
		</GetAccessors>
		<GetGetMethod final="1" public="1" set="method">
			<f a=""><c path="cs.system.reflection.MethodInfo"/></f>
			<overloads><GetGetMethod abstract="1" public="1" set="method"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetGetMethod></overloads>
		</GetGetMethod>
		<GetIndexParameters abstract="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ParameterInfo"/></c></f></GetIndexParameters>
		<GetSetMethod final="1" public="1" set="method">
			<f a=""><c path="cs.system.reflection.MethodInfo"/></f>
			<overloads><GetSetMethod abstract="1" public="1" set="method"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetSetMethod></overloads>
		</GetSetMethod>
		<GetValue public="1" set="method">
			<f a="obj:index">
				<d/>
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<overloads><GetValue abstract="1" public="1" set="method"><f a="obj:invokeAttr:binder:index:culture">
	<d/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<d/>
</f></GetValue></overloads>
		</GetValue>
		<SetValue public="1" set="method">
			<f a="obj:value:index">
				<d/>
				<d/>
				<c path="cs.NativeArray"><d/></c>
				<x path="Void"/>
			</f>
			<overloads><SetValue abstract="1" public="1" set="method"><f a="obj:value:invokeAttr:binder:index:culture">
	<d/>
	<d/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<x path="Void"/>
</f></SetValue></overloads>
		</SetValue>
		<GetOptionalCustomModifiers public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetOptionalCustomModifiers>
		<GetRequiredCustomModifiers public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetRequiredCustomModifiers>
		<GetConstantValue public="1" set="method"><f a=""><d/></f></GetConstantValue>
		<GetRawConstantValue public="1" set="method"><f a=""><d/></f></GetRawConstantValue>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.PropertyInfo"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.ResourceAttributes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ResourceAttributes">
		<Public><meta><m n=":csNative"><e>1</e></m></meta></Public>
		<Private><meta><m n=":csNative"><e>2</e></m></meta></Private>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.ResourceAttributes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.reflection.ResourceLocation" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.ResourceLocation">
		<Embedded><meta><m n=":csNative"><e>1</e></m></meta></Embedded>
		<ContainedInAnotherAssembly><meta><m n=":csNative"><e>2</e></m></meta></ContainedInAnotherAssembly>
		<ContainedInManifestFile><meta><m n=":csNative"><e>4</e></m></meta></ContainedInManifestFile>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.ResourceLocation"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.reflection.StrongNameKeyPair" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.StrongNameKeyPair" extern="1">
		<implements path="cs.system.runtime.serialization.IDeserializationCallback"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<PublicKey public="1" get="accessor" set="null"><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></PublicKey>
		<get_PublicKey final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></get_PublicKey>
		<new final="1" public="1" set="method">
			<f a="keyPairArray">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" set="method">
					<f a="info:context">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" public="1" set="method"><f a="keyPairContainer">
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="keyPairFile">
	<c path="cs.system.io.FileStream"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.StrongNameKeyPair"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.TargetInvocationException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.TargetInvocationException" extern="1" final="1">
		<extends path="cs.system.ApplicationException"/>
		<new final="1" public="1" set="method">
			<f a="inner">
				<c path="cs.system.Exception"/>
				<x path="Void"/>
			</f>
			<overloads><new final="1" public="1" set="method"><f a="message:inner">
	<c path="String"/>
	<c path="cs.system.Exception"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.TargetInvocationException"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.TypeAttributes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.TypeAttributes">
		<NotPublic><meta><m n=":csNative"><e>0</e></m></meta></NotPublic>
		<AutoLayout><meta><m n=":csNative"><e>0</e></m></meta></AutoLayout>
		<Class><meta><m n=":csNative"><e>0</e></m></meta></Class>
		<AnsiClass><meta><m n=":csNative"><e>0</e></m></meta></AnsiClass>
		<Public><meta><m n=":csNative"><e>1</e></m></meta></Public>
		<NestedPublic><meta><m n=":csNative"><e>2</e></m></meta></NestedPublic>
		<NestedPrivate><meta><m n=":csNative"><e>3</e></m></meta></NestedPrivate>
		<NestedFamily><meta><m n=":csNative"><e>4</e></m></meta></NestedFamily>
		<NestedAssembly><meta><m n=":csNative"><e>5</e></m></meta></NestedAssembly>
		<NestedFamANDAssem><meta><m n=":csNative"><e>6</e></m></meta></NestedFamANDAssem>
		<VisibilityMask><meta><m n=":csNative"><e>7</e></m></meta></VisibilityMask>
		<NestedFamORAssem><meta><m n=":csNative"><e>7</e></m></meta></NestedFamORAssem>
		<SequentialLayout><meta><m n=":csNative"><e>8</e></m></meta></SequentialLayout>
		<ExplicitLayout><meta><m n=":csNative"><e>16</e></m></meta></ExplicitLayout>
		<LayoutMask><meta><m n=":csNative"><e>24</e></m></meta></LayoutMask>
		<ClassSemanticsMask><meta><m n=":csNative"><e>32</e></m></meta></ClassSemanticsMask>
		<Interface><meta><m n=":csNative"><e>32</e></m></meta></Interface>
		<Abstract><meta><m n=":csNative"><e>128</e></m></meta></Abstract>
		<Sealed><meta><m n=":csNative"><e>256</e></m></meta></Sealed>
		<SpecialName><meta><m n=":csNative"><e>1024</e></m></meta></SpecialName>
		<RTSpecialName><meta><m n=":csNative"><e>2048</e></m></meta></RTSpecialName>
		<Import><meta><m n=":csNative"><e>4096</e></m></meta></Import>
		<Serializable><meta><m n=":csNative"><e>8192</e></m></meta></Serializable>
		<UnicodeClass><meta><m n=":csNative"><e>65536</e></m></meta></UnicodeClass>
		<AutoClass><meta><m n=":csNative"><e>131072</e></m></meta></AutoClass>
		<StringFormatMask><meta><m n=":csNative"><e>196608</e></m></meta></StringFormatMask>
		<CustomFormatClass><meta><m n=":csNative"><e>196608</e></m></meta></CustomFormatClass>
		<HasSecurity><meta><m n=":csNative"><e>262144</e></m></meta></HasSecurity>
		<ReservedMask><meta><m n=":csNative"><e>264192</e></m></meta></ReservedMask>
		<BeforeFieldInit><meta><m n=":csNative"><e>1048576</e></m></meta></BeforeFieldInit>
		<CustomFormatMask><meta><m n=":csNative"><e>12582912</e></m></meta></CustomFormatMask>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.TypeAttributes"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.reflection.Delegate_TypeFilter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.TypeFilter" module="cs.system.reflection.TypeFilter" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.reflection.TypeFilter"/>
	<x path="cs.system.reflection.TypeFilter"/>
	<x path="cs.system.reflection.TypeFilter"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.reflection.TypeFilter"/>
	<x path="cs.system.reflection.TypeFilter"/>
	<x path="cs.system.reflection.TypeFilter"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="m:filterCriteria">
	<c path="cs.system.Type"/>
	<d/>
	<x path="Bool"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="m:filterCriteria:callback:object">
	<c path="cs.system.Type"/>
	<d/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Bool"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.TypeFilter"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.reflection.TypeFilter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.TypeFilter">
		<from><icast field="FromHaxeFunction"><f a=":">
	<c path="cs.system.Type"/>
	<d/>
	<x path="Bool"/>
</f></icast></from>
		<this><c path="cs.system.reflection.Delegate_TypeFilter"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.reflection._TypeFilter.TypeFilter_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.TypeFilter" private="1" module="cs.system.reflection.TypeFilter" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<c path="cs.system.Type"/>
				<d/>
				<x path="Bool"/>
			</f>
			<x path="cs.system.reflection.TypeFilter"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":">
				<c path="cs.system.Type"/>
				<d/>
				<x path="Bool"/>
			</f>
			<x path="cs.system.reflection.TypeFilter"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.reflection.Delegate_TypeFilter"/>
	<c path="cs.system.reflection.Delegate_TypeFilter"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.reflection.TypeFilter"/>
			<x path="cs.system.reflection.TypeFilter"/>
			<x path="cs.system.reflection.TypeFilter"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.reflection.TypeFilter"/>
			<x path="cs.system.reflection.TypeFilter"/>
			<x path="cs.system.reflection.TypeFilter"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.reflection._TypeFilter.TypeFilter_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.TypeFilter" private="1" module="cs.system.reflection.TypeFilter" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<c path="cs.system.Type"/>
					<d/>
					<x path="Bool"/>
				</f>
				<x path="cs.system.reflection.TypeFilter"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":">
					<c path="cs.system.Type"/>
					<d/>
					<x path="Bool"/>
				</f>
				<x path="cs.system.reflection.TypeFilter"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.reflection.Delegate_TypeFilter"/>
	<c path="cs.system.reflection.Delegate_TypeFilter"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.reflection.TypeFilter"/>
				<x path="cs.system.reflection.TypeFilter"/>
				<x path="cs.system.reflection.TypeFilter"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.reflection.TypeFilter"/>
				<x path="cs.system.reflection.TypeFilter"/>
				<x path="cs.system.reflection.TypeFilter"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.runtime.interopservices._AssemblyBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._AssemblyBuilder" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._AssemblyBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.AssemblyBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.AssemblyBuilder" extern="1" final="1">
		<extends path="cs.system.reflection.Assembly"/>
		<implements path="cs.system.runtime.interopservices._AssemblyBuilder"/>
		<ReflectionOnly public="1" get="accessor" set="null" override="1"><x path="Bool"/></ReflectionOnly>
		<ImageRuntimeVersion public="1" get="accessor" set="null" override="1"><c path="String"/></ImageRuntimeVersion>
		<Location public="1" get="accessor" set="null" override="1"><c path="String"/></Location>
		<EntryPoint public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.MethodInfo"/></EntryPoint>
		<CodeBase public="1" get="accessor" set="null" override="1"><c path="String"/></CodeBase>
		<get_CodeBase public="1" set="method" override="1"><f a=""><c path="String"/></f></get_CodeBase>
		<get_EntryPoint public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.MethodInfo"/></f></get_EntryPoint>
		<get_Location public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Location>
		<get_ImageRuntimeVersion public="1" set="method" override="1"><f a=""><c path="String"/></f></get_ImageRuntimeVersion>
		<get_ReflectionOnly public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_ReflectionOnly>
		<AddResourceFile final="1" public="1" set="method">
			<f a="name:fileName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><AddResourceFile final="1" public="1" set="method"><f a="name:fileName:attribute">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.reflection.ResourceAttributes"/>
	<x path="Void"/>
</f></AddResourceFile></overloads>
		</AddResourceFile>
		<DefineDynamicModule final="1" public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.emit.ModuleBuilder"/>
			</f>
			<overloads>
				<DefineDynamicModule final="1" public="1" set="method"><f a="name:fileName:emitSymbolInfo">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.reflection.emit.ModuleBuilder"/>
</f></DefineDynamicModule>
				<DefineDynamicModule final="1" public="1" set="method"><f a="name:fileName">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.reflection.emit.ModuleBuilder"/>
</f></DefineDynamicModule>
				<DefineDynamicModule final="1" public="1" set="method"><f a="name:emitSymbolInfo">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.reflection.emit.ModuleBuilder"/>
</f></DefineDynamicModule>
			</overloads>
		</DefineDynamicModule>
		<DefineResource final="1" public="1" set="method">
			<f a="name:description:fileName">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="cs.system.resources.IResourceWriter"/>
			</f>
			<overloads><DefineResource final="1" public="1" set="method"><f a="name:description:fileName:attribute">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.reflection.ResourceAttributes"/>
	<c path="cs.system.resources.IResourceWriter"/>
</f></DefineResource></overloads>
		</DefineResource>
		<DefineUnmanagedResource final="1" public="1" set="method">
			<f a="resource">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Void"/>
			</f>
			<overloads><DefineUnmanagedResource final="1" public="1" set="method"><f a="resourceFileName">
	<c path="String"/>
	<x path="Void"/>
</f></DefineUnmanagedResource></overloads>
		</DefineUnmanagedResource>
		<DefineVersionInfoResource final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><DefineVersionInfoResource final="1" public="1" set="method"><f a="product:productVersion:company:copyright:trademark">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></DefineVersionInfoResource></overloads>
		</DefineVersionInfoResource>
		<GetDynamicModule final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.reflection.emit.ModuleBuilder"/>
</f></GetDynamicModule>
		<GetExportedTypes public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetExportedTypes>
		<GetFile public="1" set="method" override="1"><f a="name">
	<c path="String"/>
	<c path="cs.system.io.FileStream"/>
</f></GetFile>
		<GetFiles public="1" set="method" override="1"><f a="getResourceModules">
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.io.FileStream"/></c>
</f></GetFiles>
		<GetManifestResourceInfo public="1" set="method" override="1"><f a="resourceName">
	<c path="String"/>
	<c path="cs.system.reflection.ManifestResourceInfo"/>
</f></GetManifestResourceInfo>
		<GetManifestResourceNames public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></GetManifestResourceNames>
		<GetManifestResourceStream public="1" set="method" override="1">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.io.Stream"/>
			</f>
			<overloads><GetManifestResourceStream public="1" set="method"><f a="type:name">
	<c path="cs.system.Type"/>
	<c path="String"/>
	<c path="cs.system.io.Stream"/>
</f></GetManifestResourceStream></overloads>
		</GetManifestResourceStream>
		<Save final="1" public="1" set="method">
			<f a="assemblyFileName:portableExecutableKind:imageFileMachine">
				<c path="String"/>
				<e path="cs.system.reflection.PortableExecutableKinds"/>
				<e path="cs.system.reflection.ImageFileMachine"/>
				<x path="Void"/>
			</f>
			<overloads><Save final="1" public="1" set="method"><f a="assemblyFileName">
	<c path="String"/>
	<x path="Void"/>
</f></Save></overloads>
		</Save>
		<SetEntryPoint final="1" public="1" set="method">
			<f a="entryMethod">
				<c path="cs.system.reflection.MethodInfo"/>
				<x path="Void"/>
			</f>
			<overloads><SetEntryPoint final="1" public="1" set="method"><f a="entryMethod:fileKind">
	<c path="cs.system.reflection.MethodInfo"/>
	<e path="cs.system.reflection.emit.PEFileKinds"/>
	<x path="Void"/>
</f></SetEntryPoint></overloads>
		</SetEntryPoint>
		<SetCustomAttribute final="1" public="1" set="method">
			<f a="customBuilder">
				<c path="cs.system.reflection.emit.CustomAttributeBuilder"/>
				<x path="Void"/>
			</f>
			<overloads><SetCustomAttribute final="1" public="1" set="method"><f a="con:binaryAttribute">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetCustomAttribute></overloads>
		</SetCustomAttribute>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.AssemblyBuilder"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.emit.AssemblyBuilderAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.AssemblyBuilderAccess">
		<Run><meta><m n=":csNative"><e>1</e></m></meta></Run>
		<Save><meta><m n=":csNative"><e>2</e></m></meta></Save>
		<RunAndSave><meta><m n=":csNative"><e>3</e></m></meta></RunAndSave>
		<ReflectionOnly><meta><m n=":csNative"><e>6</e></m></meta></ReflectionOnly>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.Emit.AssemblyBuilderAccess"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.runtime.interopservices._ConstructorBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._ConstructorBuilder" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._ConstructorBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.ConstructorBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.ConstructorBuilder" extern="1" final="1">
		<extends path="cs.system.reflection.ConstructorInfo"/>
		<implements path="cs.system.runtime.interopservices._ConstructorBuilder"/>
		<Module public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.Module"/></Module>
		<Signature public="1" get="accessor" set="null"><c path="String"/></Signature>
		<Name public="1" get="accessor" set="null" override="1"><c path="String"/></Name>
		<ReturnType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ReturnType>
		<DeclaringType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></DeclaringType>
		<ReflectedType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></ReflectedType>
		<Attributes public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.MethodAttributes"/></Attributes>
		<MethodHandle public="1" get="accessor" set="null" override="1"><c path="cs.system.RuntimeMethodHandle"/></MethodHandle>
		<InitLocals public="1" get="accessor" set="accessor"><x path="Bool"/></InitLocals>
		<CallingConvention public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.CallingConventions"/></CallingConvention>
		<get_CallingConvention public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.CallingConventions"/></f></get_CallingConvention>
		<get_InitLocals final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_InitLocals>
		<set_InitLocals final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_InitLocals>
		<GetMethodImplementationFlags public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.MethodImplAttributes"/></f></GetMethodImplementationFlags>
		<GetParameters public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ParameterInfo"/></c></f></GetParameters>
		<Invoke public="1" set="method" override="1">
			<f a="obj:invokeAttr:binder:parameters:culture">
				<d/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<c path="cs.NativeArray"><d/></c>
				<c path="cs.system.globalization.CultureInfo"/>
				<d/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
			<overloads><Invoke public="1" set="method">
	<f a="invokeAttr:binder:parameters:culture">
		<e path="cs.system.reflection.BindingFlags"/>
		<c path="cs.system.reflection.Binder"/>
		<c path="cs.NativeArray"><d/></c>
		<c path="cs.system.globalization.CultureInfo"/>
		<d/>
	</f>
	<meta>
		<m n=":noCompletion"/>
		<m n=":skipReflection"/>
	</meta>
</Invoke></overloads>
		</Invoke>
		<get_MethodHandle public="1" set="method" override="1"><f a=""><c path="cs.system.RuntimeMethodHandle"/></f></get_MethodHandle>
		<get_Attributes public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.MethodAttributes"/></f></get_Attributes>
		<get_ReflectedType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<get_DeclaringType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_ReturnType final="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ReturnType>
		<get_Name public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Name>
		<get_Signature final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Signature>
		<AddDeclarativeSecurity final="1" public="1" set="method"><f a="action:pset">
	<e path="cs.system.security.permissions.SecurityAction"/>
	<c path="cs.system.security.PermissionSet"/>
	<x path="Void"/>
</f></AddDeclarativeSecurity>
		<DefineParameter final="1" public="1" set="method"><f a="iSequence:attributes:strParamName">
	<x path="Int"/>
	<e path="cs.system.reflection.ParameterAttributes"/>
	<c path="String"/>
	<c path="cs.system.reflection.emit.ParameterBuilder"/>
</f></DefineParameter>
		<IsDefined public="1" set="method" override="1"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<GetCustomAttributes public="1" set="method" override="1">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetILGenerator final="1" public="1" set="method">
			<f a=""><c path="cs.system.reflection.emit.ILGenerator"/></f>
			<overloads><GetILGenerator final="1" public="1" set="method"><f a="streamSize">
	<x path="Int"/>
	<c path="cs.system.reflection.emit.ILGenerator"/>
</f></GetILGenerator></overloads>
		</GetILGenerator>
		<SetCustomAttribute final="1" public="1" set="method">
			<f a="customBuilder">
				<c path="cs.system.reflection.emit.CustomAttributeBuilder"/>
				<x path="Void"/>
			</f>
			<overloads><SetCustomAttribute final="1" public="1" set="method"><f a="con:binaryAttribute">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetCustomAttribute></overloads>
		</SetCustomAttribute>
		<SetImplementationFlags final="1" public="1" set="method"><f a="attributes">
	<e path="cs.system.reflection.MethodImplAttributes"/>
	<x path="Void"/>
</f></SetImplementationFlags>
		<GetModule final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.Module"/></f></GetModule>
		<GetToken final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.emit.MethodToken"/></f></GetToken>
		<SetSymCustomAttribute final="1" public="1" set="method"><f a="name:data">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetSymCustomAttribute>
		<get_Module public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.Module"/></f></get_Module>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.ConstructorBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.CustomAttributeBuilder_CustomAttributeInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.CustomAttributeBuilder" module="cs.system.reflection.emit.CustomAttributeBuilder" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<namedParamValues public="1"><c path="cs.NativeArray"><d/></c></namedParamValues>
		<namedParamNames public="1"><c path="cs.NativeArray"><c path="String"/></c></namedParamNames>
		<ctorArgs public="1"><c path="cs.NativeArray"><d/></c></ctorArgs>
		<ctor public="1"><c path="cs.system.reflection.ConstructorInfo"/></ctor>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.CustomAttributeBuilder.CustomAttributeInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._CustomAttributeBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._CustomAttributeBuilder" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._CustomAttributeBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.CustomAttributeBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.CustomAttributeBuilder" extern="1">
		<implements path="cs.system.runtime.interopservices._CustomAttributeBuilder"/>
		<new final="1" public="1" set="method">
			<f a="con:constructorArgs">
				<c path="cs.system.reflection.ConstructorInfo"/>
				<c path="cs.NativeArray"><d/></c>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="con:constructorArgs:namedProperties:propertyValues:namedFields:fieldValues">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.PropertyInfo"/></c>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c>
	<c path="cs.NativeArray"><d/></c>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="con:constructorArgs:namedProperties:propertyValues">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.PropertyInfo"/></c>
	<c path="cs.NativeArray"><d/></c>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="con:constructorArgs:namedFields:fieldValues">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c>
	<c path="cs.NativeArray"><d/></c>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.CustomAttributeBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._EnumBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._EnumBuilder" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._EnumBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.EnumBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.EnumBuilder" extern="1" final="1">
		<extends path="cs.system.Type"/>
		<implements path="cs.system.runtime.interopservices._EnumBuilder"/>
		<UnderlyingSystemType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></UnderlyingSystemType>
		<UnderlyingField public="1" get="accessor" set="null"><c path="cs.system.reflection.emit.FieldBuilder"/></UnderlyingField>
		<TypeToken public="1" get="accessor" set="null"><c path="cs.system.reflection.emit.TypeToken"/></TypeToken>
		<TypeHandle public="1" get="accessor" set="null" override="1"><c path="cs.system.RuntimeTypeHandle"/></TypeHandle>
		<ReflectedType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></ReflectedType>
		<Namespace public="1" get="accessor" set="null" override="1"><c path="String"/></Namespace>
		<Name public="1" get="accessor" set="null" override="1"><c path="String"/></Name>
		<Module public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.Module"/></Module>
		<GUID public="1" get="accessor" set="null" override="1"><c path="cs.system.Guid"/></GUID>
		<FullName public="1" get="accessor" set="null" override="1"><c path="String"/></FullName>
		<DeclaringType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></DeclaringType>
		<BaseType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></BaseType>
		<AssemblyQualifiedName public="1" get="accessor" set="null" override="1"><c path="String"/></AssemblyQualifiedName>
		<Assembly public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.Assembly"/></Assembly>
		<get_Assembly public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.Assembly"/></f></get_Assembly>
		<get_AssemblyQualifiedName public="1" set="method" override="1"><f a=""><c path="String"/></f></get_AssemblyQualifiedName>
		<get_BaseType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_BaseType>
		<get_DeclaringType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_FullName public="1" set="method" override="1"><f a=""><c path="String"/></f></get_FullName>
		<get_GUID public="1" set="method" override="1"><f a=""><c path="cs.system.Guid"/></f></get_GUID>
		<get_Module public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.Module"/></f></get_Module>
		<get_Name public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Name>
		<get_Namespace public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Namespace>
		<get_ReflectedType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<get_TypeHandle public="1" set="method" override="1"><f a=""><c path="cs.system.RuntimeTypeHandle"/></f></get_TypeHandle>
		<get_TypeToken final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.emit.TypeToken"/></f></get_TypeToken>
		<get_UnderlyingField final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.emit.FieldBuilder"/></f></get_UnderlyingField>
		<get_UnderlyingSystemType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_UnderlyingSystemType>
		<CreateType final="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></CreateType>
		<DefineLiteral final="1" public="1" set="method"><f a="literalName:literalValue">
	<c path="String"/>
	<d/>
	<c path="cs.system.reflection.emit.FieldBuilder"/>
</f></DefineLiteral>
		<GetAttributeFlagsImpl set="method" override="1">
			<f a=""><e path="cs.system.reflection.TypeAttributes"/></f>
			<meta><m n=":protected"/></meta>
		</GetAttributeFlagsImpl>
		<GetConstructorImpl set="method" override="1">
			<f a="bindingAttr:binder:callConvention:types:modifiers">
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.ConstructorInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetConstructorImpl>
		<GetConstructors public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ConstructorInfo"/></c>
</f></GetConstructors>
		<GetCustomAttributes public="1" set="method" override="1">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetElementType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></GetElementType>
		<GetEvent public="1" set="method" override="1"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.EventInfo"/>
</f></GetEvent>
		<GetEvents public="1" set="method" override="1">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.EventInfo"/></c></f>
			<overloads><GetEvents public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.EventInfo"/></c>
</f></GetEvents></overloads>
		</GetEvents>
		<GetField public="1" set="method" override="1"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.FieldInfo"/>
</f></GetField>
		<GetFields public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c>
</f></GetFields>
		<GetInterface public="1" set="method" override="1"><f a="name:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetInterface>
		<GetInterfaceMap public="1" set="method" override="1"><f a="interfaceType">
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.InterfaceMapping"/>
</f></GetInterfaceMap>
		<GetInterfaces public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetInterfaces>
		<GetMember public="1" set="method" override="1"><f a="name:type:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.MemberTypes"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMember>
		<GetMembers public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMembers>
		<GetMethodImpl set="method" override="1">
			<f a="name:bindingAttr:binder:callConvention:types:modifiers">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.MethodInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetMethodImpl>
		<GetMethods public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c>
</f></GetMethods>
		<GetNestedType public="1" set="method" override="1"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.Type"/>
</f></GetNestedType>
		<GetNestedTypes public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
</f></GetNestedTypes>
		<GetProperties public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.PropertyInfo"/></c>
</f></GetProperties>
		<GetPropertyImpl set="method" override="1">
			<f a="name:bindingAttr:binder:returnType:types:modifiers">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<c path="cs.system.Type"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.PropertyInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetPropertyImpl>
		<HasElementTypeImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</HasElementTypeImpl>
		<InvokeMember public="1" set="method" override="1"><f a="name:invokeAttr:binder:target:args:modifiers:culture:namedParameters">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<d/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<d/>
</f></InvokeMember>
		<IsArrayImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsArrayImpl>
		<IsByRefImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsByRefImpl>
		<IsCOMObjectImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsCOMObjectImpl>
		<IsPointerImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsPointerImpl>
		<IsPrimitiveImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsPrimitiveImpl>
		<IsValueTypeImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsValueTypeImpl>
		<IsDefined public="1" set="method" override="1"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<MakeArrayType public="1" set="method" override="1">
			<f a=""><c path="cs.system.Type"/></f>
			<overloads><MakeArrayType public="1" set="method"><f a="rank">
	<x path="Int"/>
	<c path="cs.system.Type"/>
</f></MakeArrayType></overloads>
		</MakeArrayType>
		<MakeByRefType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></MakeByRefType>
		<MakePointerType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></MakePointerType>
		<SetCustomAttribute final="1" public="1" set="method">
			<f a="customBuilder">
				<c path="cs.system.reflection.emit.CustomAttributeBuilder"/>
				<x path="Void"/>
			</f>
			<overloads><SetCustomAttribute final="1" public="1" set="method"><f a="con:binaryAttribute">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetCustomAttribute></overloads>
		</SetCustomAttribute>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.EnumBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._EventBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._EventBuilder" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._EventBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.EventBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.EventBuilder" extern="1" final="1">
		<implements path="cs.system.runtime.interopservices._EventBuilder"/>
		<AddOtherMethod final="1" public="1" set="method"><f a="mdBuilder">
	<c path="cs.system.reflection.emit.MethodBuilder"/>
	<x path="Void"/>
</f></AddOtherMethod>
		<GetEventToken final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.emit.EventToken"/></f></GetEventToken>
		<SetAddOnMethod final="1" public="1" set="method"><f a="mdBuilder">
	<c path="cs.system.reflection.emit.MethodBuilder"/>
	<x path="Void"/>
</f></SetAddOnMethod>
		<SetRaiseMethod final="1" public="1" set="method"><f a="mdBuilder">
	<c path="cs.system.reflection.emit.MethodBuilder"/>
	<x path="Void"/>
</f></SetRaiseMethod>
		<SetRemoveOnMethod final="1" public="1" set="method"><f a="mdBuilder">
	<c path="cs.system.reflection.emit.MethodBuilder"/>
	<x path="Void"/>
</f></SetRemoveOnMethod>
		<SetCustomAttribute final="1" public="1" set="method">
			<f a="customBuilder">
				<c path="cs.system.reflection.emit.CustomAttributeBuilder"/>
				<x path="Void"/>
			</f>
			<overloads><SetCustomAttribute final="1" public="1" set="method"><f a="con:binaryAttribute">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetCustomAttribute></overloads>
		</SetCustomAttribute>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.EventBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.EventToken" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.EventToken" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<Empty public="1" set="null" static="1">
			<c path="cs.system.reflection.emit.EventToken"/>
			<meta><m n=":readOnly"/></meta>
		</Empty>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.EventToken"/>
	<c path="cs.system.reflection.emit.EventToken"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.EventToken"/>
	<c path="cs.system.reflection.emit.EventToken"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Token public="1" get="accessor" set="null"><x path="Int"/></Token>
		<get_Token final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Token>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.EventToken"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._FieldBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._FieldBuilder" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._FieldBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.FieldBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.FieldBuilder" extern="1" final="1">
		<extends path="cs.system.reflection.FieldInfo"/>
		<implements path="cs.system.runtime.interopservices._FieldBuilder"/>
		<Module public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.Module"/></Module>
		<ReflectedType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></ReflectedType>
		<Name public="1" get="accessor" set="null" override="1"><c path="String"/></Name>
		<FieldType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></FieldType>
		<FieldHandle public="1" get="accessor" set="null" override="1"><c path="cs.system.RuntimeFieldHandle"/></FieldHandle>
		<DeclaringType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></DeclaringType>
		<Attributes public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.FieldAttributes"/></Attributes>
		<get_Attributes public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.FieldAttributes"/></f></get_Attributes>
		<get_DeclaringType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_FieldHandle public="1" set="method" override="1"><f a=""><c path="cs.system.RuntimeFieldHandle"/></f></get_FieldHandle>
		<get_FieldType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_FieldType>
		<get_Name public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Name>
		<get_ReflectedType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<GetCustomAttributes public="1" set="method" override="1">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetToken final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.emit.FieldToken"/></f></GetToken>
		<GetValue public="1" set="method" override="1"><f a="obj">
	<d/>
	<d/>
</f></GetValue>
		<IsDefined public="1" set="method" override="1"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<SetConstant final="1" public="1" set="method"><f a="defaultValue">
	<d/>
	<x path="Void"/>
</f></SetConstant>
		<SetCustomAttribute final="1" public="1" set="method">
			<f a="customBuilder">
				<c path="cs.system.reflection.emit.CustomAttributeBuilder"/>
				<x path="Void"/>
			</f>
			<overloads><SetCustomAttribute final="1" public="1" set="method"><f a="con:binaryAttribute">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetCustomAttribute></overloads>
		</SetCustomAttribute>
		<SetMarshal final="1" public="1" set="method"><f a="unmanagedMarshal">
	<c path="cs.system.reflection.emit.UnmanagedMarshal"/>
	<x path="Void"/>
</f></SetMarshal>
		<SetOffset final="1" public="1" set="method"><f a="iOffset">
	<x path="Int"/>
	<x path="Void"/>
</f></SetOffset>
		<SetValue public="1" set="method" override="1"><f a="obj:val:invokeAttr:binder:culture">
	<d/>
	<d/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.system.globalization.CultureInfo"/>
	<x path="Void"/>
</f></SetValue>
		<get_Module public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.Module"/></f></get_Module>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.FieldBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.FieldToken" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.FieldToken" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<Empty public="1" set="null" static="1">
			<c path="cs.system.reflection.emit.FieldToken"/>
			<meta><m n=":readOnly"/></meta>
		</Empty>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.FieldToken"/>
	<c path="cs.system.reflection.emit.FieldToken"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.FieldToken"/>
	<c path="cs.system.reflection.emit.FieldToken"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Token public="1" get="accessor" set="null"><x path="Int"/></Token>
		<get_Token final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Token>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.FieldToken"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.emit.FlowControl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.FlowControl">
		<Branch><meta><m n=":csNative"><e>0</e></m></meta></Branch>
		<Break><meta><m n=":csNative"><e>1</e></m></meta></Break>
		<Call><meta><m n=":csNative"><e>2</e></m></meta></Call>
		<Cond_Branch><meta><m n=":csNative"><e>3</e></m></meta></Cond_Branch>
		<Meta><meta><m n=":csNative"><e>4</e></m></meta></Meta>
		<Next><meta><m n=":csNative"><e>5</e></m></meta></Next>
		<Phi><meta><m n=":csNative"><e>6</e></m></meta></Phi>
		<Return><meta><m n=":csNative"><e>7</e></m></meta></Return>
		<Throw><meta><m n=":csNative"><e>8</e></m></meta></Throw>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.Emit.FlowControl"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.reflection.emit.GenericTypeParameterBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.GenericTypeParameterBuilder" extern="1" final="1">
		<extends path="cs.system.Type"/>
		<DeclaringMethod public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.MethodBase"/></DeclaringMethod>
		<GenericParameterPosition public="1" get="accessor" set="null" override="1"><x path="Int"/></GenericParameterPosition>
		<GenericParameterAttributes public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.GenericParameterAttributes"/></GenericParameterAttributes>
		<IsGenericTypeDefinition public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsGenericTypeDefinition>
		<IsGenericType public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsGenericType>
		<IsGenericParameter public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsGenericParameter>
		<ContainsGenericParameters public="1" get="accessor" set="null" override="1"><x path="Bool"/></ContainsGenericParameters>
		<TypeHandle public="1" get="accessor" set="null" override="1"><c path="cs.system.RuntimeTypeHandle"/></TypeHandle>
		<ReflectedType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></ReflectedType>
		<DeclaringType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></DeclaringType>
		<Module public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.Module"/></Module>
		<Namespace public="1" get="accessor" set="null" override="1"><c path="String"/></Namespace>
		<Name public="1" get="accessor" set="null" override="1"><c path="String"/></Name>
		<GUID public="1" get="accessor" set="null" override="1"><c path="cs.system.Guid"/></GUID>
		<FullName public="1" get="accessor" set="null" override="1"><c path="String"/></FullName>
		<BaseType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></BaseType>
		<AssemblyQualifiedName public="1" get="accessor" set="null" override="1"><c path="String"/></AssemblyQualifiedName>
		<Assembly public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.Assembly"/></Assembly>
		<UnderlyingSystemType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></UnderlyingSystemType>
		<SetBaseTypeConstraint final="1" public="1" set="method"><f a="baseTypeConstraint">
	<c path="cs.system.Type"/>
	<x path="Void"/>
</f></SetBaseTypeConstraint>
		<SetInterfaceConstraints final="1" public="1" set="method"><f a="interfaceConstraints">
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<x path="Void"/>
</f></SetInterfaceConstraints>
		<SetGenericParameterAttributes final="1" public="1" set="method"><f a="genericParameterAttributes">
	<e path="cs.system.reflection.GenericParameterAttributes"/>
	<x path="Void"/>
</f></SetGenericParameterAttributes>
		<IsSubclassOf public="1" set="method" override="1"><f a="c">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsSubclassOf>
		<GetAttributeFlagsImpl set="method" override="1">
			<f a=""><e path="cs.system.reflection.TypeAttributes"/></f>
			<meta><m n=":protected"/></meta>
		</GetAttributeFlagsImpl>
		<GetConstructorImpl set="method" override="1">
			<f a="bindingAttr:binder:callConvention:types:modifiers">
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.ConstructorInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetConstructorImpl>
		<GetConstructors public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ConstructorInfo"/></c>
</f></GetConstructors>
		<GetEvent public="1" set="method" override="1"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.EventInfo"/>
</f></GetEvent>
		<GetEvents public="1" set="method" override="1">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.EventInfo"/></c></f>
			<overloads><GetEvents public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.EventInfo"/></c>
</f></GetEvents></overloads>
		</GetEvents>
		<GetField public="1" set="method" override="1"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.FieldInfo"/>
</f></GetField>
		<GetFields public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c>
</f></GetFields>
		<GetInterface public="1" set="method" override="1"><f a="name:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetInterface>
		<GetInterfaces public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetInterfaces>
		<GetMembers public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMembers>
		<GetMember public="1" set="method" override="1"><f a="name:type:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.MemberTypes"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMember>
		<GetMethods public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c>
</f></GetMethods>
		<GetMethodImpl set="method" override="1">
			<f a="name:bindingAttr:binder:callConvention:types:modifiers">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.MethodInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetMethodImpl>
		<GetNestedType public="1" set="method" override="1"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.Type"/>
</f></GetNestedType>
		<GetNestedTypes public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
</f></GetNestedTypes>
		<GetProperties public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.PropertyInfo"/></c>
</f></GetProperties>
		<GetPropertyImpl set="method" override="1">
			<f a="name:bindingAttr:binder:returnType:types:modifiers">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<c path="cs.system.Type"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.PropertyInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetPropertyImpl>
		<HasElementTypeImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</HasElementTypeImpl>
		<IsAssignableFrom public="1" set="method" override="1"><f a="c">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsAssignableFrom>
		<IsInstanceOfType public="1" set="method" override="1"><f a="o">
	<d/>
	<x path="Bool"/>
</f></IsInstanceOfType>
		<IsArrayImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsArrayImpl>
		<IsByRefImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsByRefImpl>
		<IsCOMObjectImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsCOMObjectImpl>
		<IsPointerImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsPointerImpl>
		<IsPrimitiveImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsPrimitiveImpl>
		<IsValueTypeImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsValueTypeImpl>
		<InvokeMember public="1" set="method" override="1"><f a="name:invokeAttr:binder:target:args:modifiers:culture:namedParameters">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<d/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<d/>
</f></InvokeMember>
		<GetElementType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></GetElementType>
		<get_UnderlyingSystemType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_UnderlyingSystemType>
		<get_Assembly public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.Assembly"/></f></get_Assembly>
		<get_AssemblyQualifiedName public="1" set="method" override="1"><f a=""><c path="String"/></f></get_AssemblyQualifiedName>
		<get_BaseType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_BaseType>
		<get_FullName public="1" set="method" override="1"><f a=""><c path="String"/></f></get_FullName>
		<get_GUID public="1" set="method" override="1"><f a=""><c path="cs.system.Guid"/></f></get_GUID>
		<IsDefined public="1" set="method" override="1"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<GetCustomAttributes public="1" set="method" override="1">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetInterfaceMap public="1" set="method" override="1"><f a="interfaceType">
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.InterfaceMapping"/>
</f></GetInterfaceMap>
		<get_Name public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Name>
		<get_Namespace public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Namespace>
		<get_Module public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.Module"/></f></get_Module>
		<get_DeclaringType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_ReflectedType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<get_TypeHandle public="1" set="method" override="1"><f a=""><c path="cs.system.RuntimeTypeHandle"/></f></get_TypeHandle>
		<GetGenericArguments public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetGenericArguments>
		<GetGenericTypeDefinition public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></GetGenericTypeDefinition>
		<get_ContainsGenericParameters public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_ContainsGenericParameters>
		<get_IsGenericParameter public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsGenericParameter>
		<get_IsGenericType public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsGenericType>
		<get_IsGenericTypeDefinition public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsGenericTypeDefinition>
		<get_GenericParameterAttributes public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.GenericParameterAttributes"/></f></get_GenericParameterAttributes>
		<get_GenericParameterPosition public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_GenericParameterPosition>
		<GetGenericParameterConstraints public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetGenericParameterConstraints>
		<get_DeclaringMethod public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.MethodBase"/></f></get_DeclaringMethod>
		<SetCustomAttribute final="1" public="1" set="method">
			<f a="customBuilder">
				<c path="cs.system.reflection.emit.CustomAttributeBuilder"/>
				<x path="Void"/>
			</f>
			<overloads><SetCustomAttribute final="1" public="1" set="method"><f a="con:binaryAttribute">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetCustomAttribute></overloads>
		</SetCustomAttribute>
		<ToString public="1" set="method" override="1"><f a=""><c path="String"/></f></ToString>
		<MakeArrayType public="1" set="method" override="1">
			<f a=""><c path="cs.system.Type"/></f>
			<overloads><MakeArrayType public="1" set="method"><f a="rank">
	<x path="Int"/>
	<c path="cs.system.Type"/>
</f></MakeArrayType></overloads>
		</MakeArrayType>
		<MakeByRefType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></MakeByRefType>
		<MakeGenericType public="1" set="method" override="1"><f a="typeArguments">
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.Type"/>
</f></MakeGenericType>
		<MakePointerType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></MakePointerType>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.GenericTypeParameterBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.ILGenerator_LabelData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.ILGenerator" module="cs.system.reflection.emit.ILGenerator" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<maxStack public="1"><x path="Int"/></maxStack>
		<addr public="1"><x path="Int"/></addr>
		<new final="1" public="1" set="method"><f a="addr:maxStack">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.ILGenerator.LabelData"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.ILGenerator_LabelFixup" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.ILGenerator" module="cs.system.reflection.emit.ILGenerator" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<label_idx public="1"><x path="Int"/></label_idx>
		<pos public="1"><x path="Int"/></pos>
		<offset public="1"><x path="Int"/></offset>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.ILGenerator.LabelFixup"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._ILGenerator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._ILGenerator" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._ILGenerator"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.ILGenerator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.ILGenerator" extern="1">
		<implements path="cs.system.runtime.interopservices._ILGenerator"/>
		<BeginCatchBlock public="1" set="method"><f a="exceptionType">
	<c path="cs.system.Type"/>
	<x path="Void"/>
</f></BeginCatchBlock>
		<BeginExceptFilterBlock public="1" set="method"><f a=""><x path="Void"/></f></BeginExceptFilterBlock>
		<BeginExceptionBlock public="1" set="method"><f a=""><c path="cs.system.reflection.emit.Label"/></f></BeginExceptionBlock>
		<BeginFaultBlock public="1" set="method"><f a=""><x path="Void"/></f></BeginFaultBlock>
		<BeginFinallyBlock public="1" set="method"><f a=""><x path="Void"/></f></BeginFinallyBlock>
		<BeginScope public="1" set="method"><f a=""><x path="Void"/></f></BeginScope>
		<DeclareLocal public="1" set="method">
			<f a="localType">
				<c path="cs.system.Type"/>
				<c path="cs.system.reflection.emit.LocalBuilder"/>
			</f>
			<overloads><DeclareLocal public="1" set="method"><f a="localType:pinned">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.system.reflection.emit.LocalBuilder"/>
</f></DeclareLocal></overloads>
		</DeclareLocal>
		<DefineLabel public="1" set="method"><f a=""><c path="cs.system.reflection.emit.Label"/></f></DefineLabel>
		<Emit public="1" set="method">
			<f a="opcode">
				<c path="cs.system.reflection.emit.OpCode"/>
				<x path="Void"/>
			</f>
			<overloads>
				<Emit public="1" set="method"><f a="opcode:cls">
	<c path="cs.system.reflection.emit.OpCode"/>
	<c path="cs.system.Type"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:str">
	<c path="cs.system.reflection.emit.OpCode"/>
	<c path="String"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:arg">
	<c path="cs.system.reflection.emit.OpCode"/>
	<x path="Single"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:signature">
	<c path="cs.system.reflection.emit.OpCode"/>
	<c path="cs.system.reflection.emit.SignatureHelper"/>
	<x path="Void"/>
</f></Emit>
				<Emit final="1" public="1" set="method"><f a="opcode:arg">
	<c path="cs.system.reflection.emit.OpCode"/>
	<t path="cs.types.Int8"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:meth">
	<c path="cs.system.reflection.emit.OpCode"/>
	<c path="cs.system.reflection.MethodInfo"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:local">
	<c path="cs.system.reflection.emit.OpCode"/>
	<c path="cs.system.reflection.emit.LocalBuilder"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:labels">
	<c path="cs.system.reflection.emit.OpCode"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.emit.Label"/></c>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:label">
	<c path="cs.system.reflection.emit.OpCode"/>
	<c path="cs.system.reflection.emit.Label"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:arg">
	<c path="cs.system.reflection.emit.OpCode"/>
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:arg">
	<c path="cs.system.reflection.emit.OpCode"/>
	<x path="Int"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:arg">
	<c path="cs.system.reflection.emit.OpCode"/>
	<t path="cs.types.Int16"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:field">
	<c path="cs.system.reflection.emit.OpCode"/>
	<c path="cs.system.reflection.FieldInfo"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:arg">
	<c path="cs.system.reflection.emit.OpCode"/>
	<x path="Float"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:con">
	<c path="cs.system.reflection.emit.OpCode"/>
	<c path="cs.system.reflection.ConstructorInfo"/>
	<x path="Void"/>
</f></Emit>
				<Emit public="1" set="method"><f a="opcode:arg">
	<c path="cs.system.reflection.emit.OpCode"/>
	<t path="cs.types.UInt8"/>
	<x path="Void"/>
</f></Emit>
			</overloads>
		</Emit>
		<EmitCall public="1" set="method"><f a="opcode:methodInfo:optionalParameterTypes">
	<c path="cs.system.reflection.emit.OpCode"/>
	<c path="cs.system.reflection.MethodInfo"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<x path="Void"/>
</f></EmitCall>
		<EmitCalli public="1" set="method">
			<f a="opcode:unmanagedCallConv:returnType:parameterTypes">
				<c path="cs.system.reflection.emit.OpCode"/>
				<e path="cs.system.runtime.interopservices.CallingConvention"/>
				<c path="cs.system.Type"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<x path="Void"/>
			</f>
			<overloads><EmitCalli public="1" set="method"><f a="opcode:callingConvention:returnType:parameterTypes:optionalParameterTypes">
	<c path="cs.system.reflection.emit.OpCode"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<x path="Void"/>
</f></EmitCalli></overloads>
		</EmitCalli>
		<EmitWriteLine public="1" set="method">
			<f a="fld">
				<c path="cs.system.reflection.FieldInfo"/>
				<x path="Void"/>
			</f>
			<overloads>
				<EmitWriteLine public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></EmitWriteLine>
				<EmitWriteLine public="1" set="method"><f a="localBuilder">
	<c path="cs.system.reflection.emit.LocalBuilder"/>
	<x path="Void"/>
</f></EmitWriteLine>
			</overloads>
		</EmitWriteLine>
		<EndExceptionBlock public="1" set="method"><f a=""><x path="Void"/></f></EndExceptionBlock>
		<EndScope public="1" set="method"><f a=""><x path="Void"/></f></EndScope>
		<MarkLabel public="1" set="method"><f a="loc">
	<c path="cs.system.reflection.emit.Label"/>
	<x path="Void"/>
</f></MarkLabel>
		<MarkSequencePoint public="1" set="method"><f a="document:startLine:startColumn:endLine:endColumn">
	<c path="cs.system.diagnostics.symbolstore.ISymbolDocumentWriter"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></MarkSequencePoint>
		<ThrowException public="1" set="method"><f a="excType">
	<c path="cs.system.Type"/>
	<x path="Void"/>
</f></ThrowException>
		<UsingNamespace public="1" set="method"><f a="usingNamespace">
	<c path="String"/>
	<x path="Void"/>
</f></UsingNamespace>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.ILGenerator"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.Label" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.Label" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.Label"/>
	<c path="cs.system.reflection.emit.Label"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.Label"/>
	<c path="cs.system.reflection.emit.Label"/>
	<x path="Bool"/>
</f></op_Inequality>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.Label"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._LocalBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._LocalBuilder" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._LocalBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.LocalBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.LocalBuilder" extern="1" final="1">
		<extends path="cs.system.reflection.LocalVariableInfo"/>
		<implements path="cs.system.runtime.interopservices._LocalBuilder"/>
		<LocalIndex public="1" get="accessor" set="null" override="1"><x path="Int"/></LocalIndex>
		<IsPinned public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsPinned>
		<LocalType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></LocalType>
		<SetLocalSymInfo final="1" public="1" set="method">
			<f a="name:startOffset:endOffset">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads><SetLocalSymInfo final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></SetLocalSymInfo></overloads>
		</SetLocalSymInfo>
		<get_LocalType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_LocalType>
		<get_IsPinned public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsPinned>
		<get_LocalIndex public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_LocalIndex>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.LocalBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._MethodBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._MethodBuilder" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._MethodBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.MethodBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.MethodBuilder" extern="1" final="1">
		<extends path="cs.system.reflection.MethodInfo"/>
		<implements path="cs.system.runtime.interopservices._MethodBuilder"/>
		<Module public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.Module"/></Module>
		<IsGenericMethod public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsGenericMethod>
		<IsGenericMethodDefinition public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsGenericMethodDefinition>
		<Signature public="1" get="accessor" set="null"><c path="String"/></Signature>
		<CallingConvention public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.CallingConventions"/></CallingConvention>
		<ReturnTypeCustomAttributes public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.ICustomAttributeProvider"/></ReturnTypeCustomAttributes>
		<Attributes public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.MethodAttributes"/></Attributes>
		<Name public="1" get="accessor" set="null" override="1"><c path="String"/></Name>
		<DeclaringType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></DeclaringType>
		<ReflectedType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></ReflectedType>
		<ReturnType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></ReturnType>
		<MethodHandle public="1" get="accessor" set="null" override="1"><c path="cs.system.RuntimeMethodHandle"/></MethodHandle>
		<InitLocals public="1" get="accessor" set="accessor"><x path="Bool"/></InitLocals>
		<ContainsGenericParameters public="1" get="accessor" set="null" override="1"><x path="Bool"/></ContainsGenericParameters>
		<get_ContainsGenericParameters public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_ContainsGenericParameters>
		<get_InitLocals final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_InitLocals>
		<set_InitLocals final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_InitLocals>
		<get_MethodHandle public="1" set="method" override="1"><f a=""><c path="cs.system.RuntimeMethodHandle"/></f></get_MethodHandle>
		<get_ReturnType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_ReturnType>
		<get_ReflectedType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<get_DeclaringType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_Name public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Name>
		<get_Attributes public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.MethodAttributes"/></f></get_Attributes>
		<get_ReturnTypeCustomAttributes public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.ICustomAttributeProvider"/></f></get_ReturnTypeCustomAttributes>
		<get_CallingConvention public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.CallingConventions"/></f></get_CallingConvention>
		<get_Signature final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Signature>
		<GetToken final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.emit.MethodToken"/></f></GetToken>
		<GetBaseDefinition public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.MethodInfo"/></f></GetBaseDefinition>
		<GetMethodImplementationFlags public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.MethodImplAttributes"/></f></GetMethodImplementationFlags>
		<GetParameters public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ParameterInfo"/></c></f></GetParameters>
		<GetModule final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.Module"/></f></GetModule>
		<CreateMethodBody final="1" public="1" set="method"><f a="il:count">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></CreateMethodBody>
		<Invoke public="1" set="method" override="1">
			<f a="obj:invokeAttr:binder:parameters:culture">
				<d/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<c path="cs.NativeArray"><d/></c>
				<c path="cs.system.globalization.CultureInfo"/>
				<d/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</Invoke>
		<IsDefined public="1" set="method" override="1"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<GetCustomAttributes public="1" set="method" override="1">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetILGenerator final="1" public="1" set="method">
			<f a=""><c path="cs.system.reflection.emit.ILGenerator"/></f>
			<overloads><GetILGenerator final="1" public="1" set="method"><f a="size">
	<x path="Int"/>
	<c path="cs.system.reflection.emit.ILGenerator"/>
</f></GetILGenerator></overloads>
		</GetILGenerator>
		<DefineParameter final="1" public="1" set="method"><f a="position:attributes:strParamName">
	<x path="Int"/>
	<e path="cs.system.reflection.ParameterAttributes"/>
	<c path="String"/>
	<c path="cs.system.reflection.emit.ParameterBuilder"/>
</f></DefineParameter>
		<SetCustomAttribute final="1" public="1" set="method">
			<f a="customBuilder">
				<c path="cs.system.reflection.emit.CustomAttributeBuilder"/>
				<x path="Void"/>
			</f>
			<overloads><SetCustomAttribute final="1" public="1" set="method"><f a="con:binaryAttribute">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetCustomAttribute></overloads>
		</SetCustomAttribute>
		<SetImplementationFlags final="1" public="1" set="method"><f a="attributes">
	<e path="cs.system.reflection.MethodImplAttributes"/>
	<x path="Void"/>
</f></SetImplementationFlags>
		<AddDeclarativeSecurity final="1" public="1" set="method"><f a="action:pset">
	<e path="cs.system.security.permissions.SecurityAction"/>
	<c path="cs.system.security.PermissionSet"/>
	<x path="Void"/>
</f></AddDeclarativeSecurity>
		<SetMarshal final="1" public="1" set="method"><f a="unmanagedMarshal">
	<c path="cs.system.reflection.emit.UnmanagedMarshal"/>
	<x path="Void"/>
</f></SetMarshal>
		<SetSymCustomAttribute final="1" public="1" set="method"><f a="name:data">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetSymCustomAttribute>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<MakeGenericMethod public="1" set="method" override="1"><f a="typeArguments">
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></MakeGenericMethod>
		<get_IsGenericMethodDefinition public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsGenericMethodDefinition>
		<get_IsGenericMethod public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsGenericMethod>
		<GetGenericMethodDefinition public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.MethodInfo"/></f></GetGenericMethodDefinition>
		<GetGenericArguments public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetGenericArguments>
		<DefineGenericParameters final="1" public="1" set="method"><f a="names">
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.emit.GenericTypeParameterBuilder"/></c>
</f></DefineGenericParameters>
		<SetReturnType final="1" public="1" set="method"><f a="returnType">
	<c path="cs.system.Type"/>
	<x path="Void"/>
</f></SetReturnType>
		<SetParameters final="1" public="1" set="method"><f a="parameterTypes">
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<x path="Void"/>
</f></SetParameters>
		<SetSignature final="1" public="1" set="method"><f a="returnType:returnTypeRequiredCustomModifiers:returnTypeOptionalCustomModifiers:parameterTypes:parameterTypeRequiredCustomModifiers:parameterTypeOptionalCustomModifiers">
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<x path="Void"/>
</f></SetSignature>
		<get_Module public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.Module"/></f></get_Module>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.MethodBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.MethodToken" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.MethodToken" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<Empty public="1" set="null" static="1">
			<c path="cs.system.reflection.emit.MethodToken"/>
			<meta><m n=":readOnly"/></meta>
		</Empty>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.MethodToken"/>
	<c path="cs.system.reflection.emit.MethodToken"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.MethodToken"/>
	<c path="cs.system.reflection.emit.MethodToken"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Token public="1" get="accessor" set="null"><x path="Int"/></Token>
		<get_Token final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Token>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.MethodToken"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._ModuleBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._ModuleBuilder" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._ModuleBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.ModuleBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.ModuleBuilder" extern="1">
		<extends path="cs.system.reflection.Module"/>
		<implements path="cs.system.runtime.interopservices._ModuleBuilder"/>
		<FullyQualifiedName public="1" get="accessor" set="null" override="1"><c path="String"/></FullyQualifiedName>
		<get_FullyQualifiedName public="1" set="method" override="1"><f a=""><c path="String"/></f></get_FullyQualifiedName>
		<IsTransient final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsTransient>
		<CreateGlobalFunctions final="1" public="1" set="method"><f a=""><x path="Void"/></f></CreateGlobalFunctions>
		<DefineInitializedData final="1" public="1" set="method"><f a="name:data:attributes">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<e path="cs.system.reflection.FieldAttributes"/>
	<c path="cs.system.reflection.emit.FieldBuilder"/>
</f></DefineInitializedData>
		<DefineUninitializedData final="1" public="1" set="method"><f a="name:size:attributes">
	<c path="String"/>
	<x path="Int"/>
	<e path="cs.system.reflection.FieldAttributes"/>
	<c path="cs.system.reflection.emit.FieldBuilder"/>
</f></DefineUninitializedData>
		<DefineGlobalMethod final="1" public="1" set="method">
			<f a="name:attributes:returnType:parameterTypes">
				<c path="String"/>
				<e path="cs.system.reflection.MethodAttributes"/>
				<c path="cs.system.Type"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.system.reflection.emit.MethodBuilder"/>
			</f>
			<overloads>
				<DefineGlobalMethod final="1" public="1" set="method"><f a="name:attributes:callingConvention:returnType:requiredReturnTypeCustomModifiers:optionalReturnTypeCustomModifiers:parameterTypes:requiredParameterTypeCustomModifiers:optionalParameterTypeCustomModifiers">
	<c path="String"/>
	<e path="cs.system.reflection.MethodAttributes"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.system.reflection.emit.MethodBuilder"/>
</f></DefineGlobalMethod>
				<DefineGlobalMethod final="1" public="1" set="method"><f a="name:attributes:callingConvention:returnType:parameterTypes">
	<c path="String"/>
	<e path="cs.system.reflection.MethodAttributes"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.emit.MethodBuilder"/>
</f></DefineGlobalMethod>
			</overloads>
		</DefineGlobalMethod>
		<DefinePInvokeMethod final="1" public="1" set="method">
			<f a="name:dllName:attributes:callingConvention:returnType:parameterTypes:nativeCallConv:nativeCharSet">
				<c path="String"/>
				<c path="String"/>
				<e path="cs.system.reflection.MethodAttributes"/>
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.system.Type"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<e path="cs.system.runtime.interopservices.CallingConvention"/>
				<e path="cs.system.runtime.interopservices.CharSet"/>
				<c path="cs.system.reflection.emit.MethodBuilder"/>
			</f>
			<overloads><DefinePInvokeMethod final="1" public="1" set="method"><f a="name:dllName:entryName:attributes:callingConvention:returnType:parameterTypes:nativeCallConv:nativeCharSet">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.reflection.MethodAttributes"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<e path="cs.system.runtime.interopservices.CallingConvention"/>
	<e path="cs.system.runtime.interopservices.CharSet"/>
	<c path="cs.system.reflection.emit.MethodBuilder"/>
</f></DefinePInvokeMethod></overloads>
		</DefinePInvokeMethod>
		<DefineType final="1" public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.emit.TypeBuilder"/>
			</f>
			<overloads>
				<DefineType final="1" public="1" set="method"><f a="name:attr:parent:packingSize:typesize">
	<c path="String"/>
	<e path="cs.system.reflection.TypeAttributes"/>
	<c path="cs.system.Type"/>
	<e path="cs.system.reflection.emit.PackingSize"/>
	<x path="Int"/>
	<c path="cs.system.reflection.emit.TypeBuilder"/>
</f></DefineType>
				<DefineType final="1" public="1" set="method"><f a="name:attr:parent:packsize">
	<c path="String"/>
	<e path="cs.system.reflection.TypeAttributes"/>
	<c path="cs.system.Type"/>
	<e path="cs.system.reflection.emit.PackingSize"/>
	<c path="cs.system.reflection.emit.TypeBuilder"/>
</f></DefineType>
				<DefineType final="1" public="1" set="method"><f a="name:attr:parent:typesize">
	<c path="String"/>
	<e path="cs.system.reflection.TypeAttributes"/>
	<c path="cs.system.Type"/>
	<x path="Int"/>
	<c path="cs.system.reflection.emit.TypeBuilder"/>
</f></DefineType>
				<DefineType final="1" public="1" set="method"><f a="name:attr:parent:interfaces">
	<c path="String"/>
	<e path="cs.system.reflection.TypeAttributes"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.emit.TypeBuilder"/>
</f></DefineType>
				<DefineType final="1" public="1" set="method"><f a="name:attr:parent">
	<c path="String"/>
	<e path="cs.system.reflection.TypeAttributes"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.emit.TypeBuilder"/>
</f></DefineType>
				<DefineType final="1" public="1" set="method"><f a="name:attr">
	<c path="String"/>
	<e path="cs.system.reflection.TypeAttributes"/>
	<c path="cs.system.reflection.emit.TypeBuilder"/>
</f></DefineType>
			</overloads>
		</DefineType>
		<GetArrayMethod final="1" public="1" set="method"><f a="arrayClass:methodName:callingConvention:returnType:parameterTypes">
	<c path="cs.system.Type"/>
	<c path="String"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetArrayMethod>
		<DefineEnum final="1" public="1" set="method"><f a="name:visibility:underlyingType">
	<c path="String"/>
	<e path="cs.system.reflection.TypeAttributes"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.emit.EnumBuilder"/>
</f></DefineEnum>
		<GetType public="1" set="method" override="1">
			<f a="className">
				<c path="String"/>
				<c path="cs.system.Type"/>
			</f>
			<overloads>
				<GetType public="1" set="method"><f a="className:throwOnError:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetType>
				<GetType public="1" set="method"><f a="className:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetType>
			</overloads>
		</GetType>
		<SetCustomAttribute final="1" public="1" set="method">
			<f a="customBuilder">
				<c path="cs.system.reflection.emit.CustomAttributeBuilder"/>
				<x path="Void"/>
			</f>
			<overloads><SetCustomAttribute final="1" public="1" set="method"><f a="con:binaryAttribute">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetCustomAttribute></overloads>
		</SetCustomAttribute>
		<GetSymWriter final="1" public="1" set="method"><f a=""><c path="cs.system.diagnostics.symbolstore.ISymbolWriter"/></f></GetSymWriter>
		<DefineDocument final="1" public="1" set="method"><f a="url:language:languageVendor:documentType">
	<c path="String"/>
	<c path="cs.system.Guid"/>
	<c path="cs.system.Guid"/>
	<c path="cs.system.Guid"/>
	<c path="cs.system.diagnostics.symbolstore.ISymbolDocumentWriter"/>
</f></DefineDocument>
		<GetTypes public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetTypes>
		<DefineResource final="1" public="1" set="method">
			<f a="name:description:attribute">
				<c path="String"/>
				<c path="String"/>
				<e path="cs.system.reflection.ResourceAttributes"/>
				<c path="cs.system.resources.IResourceWriter"/>
			</f>
			<overloads><DefineResource final="1" public="1" set="method"><f a="name:description">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.resources.IResourceWriter"/>
</f></DefineResource></overloads>
		</DefineResource>
		<DefineUnmanagedResource final="1" public="1" set="method">
			<f a="resource">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Void"/>
			</f>
			<overloads><DefineUnmanagedResource final="1" public="1" set="method"><f a="resourceFileName">
	<c path="String"/>
	<x path="Void"/>
</f></DefineUnmanagedResource></overloads>
		</DefineUnmanagedResource>
		<DefineManifestResource final="1" public="1" set="method"><f a="name:stream:attribute">
	<c path="String"/>
	<c path="cs.system.io.Stream"/>
	<e path="cs.system.reflection.ResourceAttributes"/>
	<x path="Void"/>
</f></DefineManifestResource>
		<SetSymCustomAttribute final="1" public="1" set="method"><f a="name:data">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetSymCustomAttribute>
		<SetUserEntryPoint final="1" public="1" set="method"><f a="entryPoint">
	<c path="cs.system.reflection.MethodInfo"/>
	<x path="Void"/>
</f></SetUserEntryPoint>
		<GetMethodToken final="1" public="1" set="method"><f a="method">
	<c path="cs.system.reflection.MethodInfo"/>
	<c path="cs.system.reflection.emit.MethodToken"/>
</f></GetMethodToken>
		<GetArrayMethodToken final="1" public="1" set="method"><f a="arrayClass:methodName:callingConvention:returnType:parameterTypes">
	<c path="cs.system.Type"/>
	<c path="String"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.emit.MethodToken"/>
</f></GetArrayMethodToken>
		<GetConstructorToken final="1" public="1" set="method"><f a="con">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.system.reflection.emit.MethodToken"/>
</f></GetConstructorToken>
		<GetFieldToken final="1" public="1" set="method"><f a="field">
	<c path="cs.system.reflection.FieldInfo"/>
	<c path="cs.system.reflection.emit.FieldToken"/>
</f></GetFieldToken>
		<GetSignatureToken final="1" public="1" set="method">
			<f a="sigBytes:sigLength">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Int"/>
				<c path="cs.system.reflection.emit.SignatureToken"/>
			</f>
			<overloads><GetSignatureToken final="1" public="1" set="method"><f a="sigHelper">
	<c path="cs.system.reflection.emit.SignatureHelper"/>
	<c path="cs.system.reflection.emit.SignatureToken"/>
</f></GetSignatureToken></overloads>
		</GetSignatureToken>
		<GetStringConstant final="1" public="1" set="method"><f a="str">
	<c path="String"/>
	<c path="cs.system.reflection.emit.StringToken"/>
</f></GetStringConstant>
		<GetTypeToken final="1" public="1" set="method">
			<f a="type">
				<c path="cs.system.Type"/>
				<c path="cs.system.reflection.emit.TypeToken"/>
			</f>
			<overloads><GetTypeToken final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.reflection.emit.TypeToken"/>
</f></GetTypeToken></overloads>
		</GetTypeToken>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.ModuleBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.OpCode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.OpCode" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.OpCode"/>
	<c path="cs.system.reflection.emit.OpCode"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.OpCode"/>
	<c path="cs.system.reflection.emit.OpCode"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Value public="1" get="accessor" set="null"><t path="cs.types.Int16"/></Value>
		<StackBehaviourPush public="1" get="accessor" set="null"><e path="cs.system.reflection.emit.StackBehaviour"/></StackBehaviourPush>
		<StackBehaviourPop public="1" get="accessor" set="null"><e path="cs.system.reflection.emit.StackBehaviour"/></StackBehaviourPop>
		<FlowControl public="1" get="accessor" set="null"><e path="cs.system.reflection.emit.FlowControl"/></FlowControl>
		<OperandType public="1" get="accessor" set="null"><e path="cs.system.reflection.emit.OperandType"/></OperandType>
		<OpCodeType public="1" get="accessor" set="null"><e path="cs.system.reflection.emit.OpCodeType"/></OpCodeType>
		<Size public="1" get="accessor" set="null"><x path="Int"/></Size>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<ToString public="1" set="method" override="1"><f a=""><c path="String"/></f></ToString>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_Size final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Size>
		<get_OpCodeType final="1" public="1" set="method"><f a=""><e path="cs.system.reflection.emit.OpCodeType"/></f></get_OpCodeType>
		<get_OperandType final="1" public="1" set="method"><f a=""><e path="cs.system.reflection.emit.OperandType"/></f></get_OperandType>
		<get_FlowControl final="1" public="1" set="method"><f a=""><e path="cs.system.reflection.emit.FlowControl"/></f></get_FlowControl>
		<get_StackBehaviourPop final="1" public="1" set="method"><f a=""><e path="cs.system.reflection.emit.StackBehaviour"/></f></get_StackBehaviourPop>
		<get_StackBehaviourPush final="1" public="1" set="method"><f a=""><e path="cs.system.reflection.emit.StackBehaviour"/></f></get_StackBehaviourPush>
		<get_Value final="1" public="1" set="method"><f a=""><t path="cs.types.Int16"/></f></get_Value>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.OpCode"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.emit.OpCodeType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.OpCodeType">
		<Annotation><meta><m n=":csNative"><e>0</e></m></meta></Annotation>
		<Macro><meta><m n=":csNative"><e>1</e></m></meta></Macro>
		<Nternal><meta><m n=":csNative"><e>2</e></m></meta></Nternal>
		<Objmodel><meta><m n=":csNative"><e>3</e></m></meta></Objmodel>
		<Prefix><meta><m n=":csNative"><e>4</e></m></meta></Prefix>
		<Primitive><meta><m n=":csNative"><e>5</e></m></meta></Primitive>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.Emit.OpCodeType"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.reflection.emit.OperandType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.OperandType">
		<InlineBrTarget><meta><m n=":csNative"><e>0</e></m></meta></InlineBrTarget>
		<InlineField><meta><m n=":csNative"><e>1</e></m></meta></InlineField>
		<InlineI><meta><m n=":csNative"><e>2</e></m></meta></InlineI>
		<InlineI8><meta><m n=":csNative"><e>3</e></m></meta></InlineI8>
		<InlineMethod><meta><m n=":csNative"><e>4</e></m></meta></InlineMethod>
		<InlineNone><meta><m n=":csNative"><e>5</e></m></meta></InlineNone>
		<InlinePhi><meta><m n=":csNative"><e>6</e></m></meta></InlinePhi>
		<InlineR><meta><m n=":csNative"><e>7</e></m></meta></InlineR>
		<InlineSig><meta><m n=":csNative"><e>9</e></m></meta></InlineSig>
		<InlineString><meta><m n=":csNative"><e>10</e></m></meta></InlineString>
		<InlineSwitch><meta><m n=":csNative"><e>11</e></m></meta></InlineSwitch>
		<InlineTok><meta><m n=":csNative"><e>12</e></m></meta></InlineTok>
		<InlineType><meta><m n=":csNative"><e>13</e></m></meta></InlineType>
		<InlineVar><meta><m n=":csNative"><e>14</e></m></meta></InlineVar>
		<ShortInlineBrTarget><meta><m n=":csNative"><e>15</e></m></meta></ShortInlineBrTarget>
		<ShortInlineI><meta><m n=":csNative"><e>16</e></m></meta></ShortInlineI>
		<ShortInlineR><meta><m n=":csNative"><e>17</e></m></meta></ShortInlineR>
		<ShortInlineVar><meta><m n=":csNative"><e>18</e></m></meta></ShortInlineVar>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.Emit.OperandType"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.reflection.emit.PEFileKinds" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.PEFileKinds">
		<Dll><meta><m n=":csNative"><e>1</e></m></meta></Dll>
		<ConsoleApplication><meta><m n=":csNative"><e>2</e></m></meta></ConsoleApplication>
		<WindowApplication><meta><m n=":csNative"><e>3</e></m></meta></WindowApplication>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.Emit.PEFileKinds"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.reflection.emit.PackingSize" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.PackingSize">
		<Unspecified><meta><m n=":csNative"><e>0</e></m></meta></Unspecified>
		<Size1><meta><m n=":csNative"><e>1</e></m></meta></Size1>
		<Size2><meta><m n=":csNative"><e>2</e></m></meta></Size2>
		<Size4><meta><m n=":csNative"><e>4</e></m></meta></Size4>
		<Size8><meta><m n=":csNative"><e>8</e></m></meta></Size8>
		<Size16><meta><m n=":csNative"><e>16</e></m></meta></Size16>
		<Size32><meta><m n=":csNative"><e>32</e></m></meta></Size32>
		<Size64><meta><m n=":csNative"><e>64</e></m></meta></Size64>
		<Size128><meta><m n=":csNative"><e>128</e></m></meta></Size128>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.Emit.PackingSize"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.runtime.interopservices._ParameterBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._ParameterBuilder" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._ParameterBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.ParameterBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.ParameterBuilder" extern="1">
		<implements path="cs.system.runtime.interopservices._ParameterBuilder"/>
		<Position public="1" get="accessor" set="null"><x path="Int"/></Position>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<IsOptional public="1" get="accessor" set="null"><x path="Bool"/></IsOptional>
		<IsOut public="1" get="accessor" set="null"><x path="Bool"/></IsOut>
		<IsIn public="1" get="accessor" set="null"><x path="Bool"/></IsIn>
		<Attributes public="1" get="accessor" set="null"><x path="Int"/></Attributes>
		<get_Attributes public="1" set="method"><f a=""><x path="Int"/></f></get_Attributes>
		<get_IsIn final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsIn>
		<get_IsOut final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsOut>
		<get_IsOptional final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsOptional>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_Position public="1" set="method"><f a=""><x path="Int"/></f></get_Position>
		<GetToken public="1" set="method"><f a=""><c path="cs.system.reflection.emit.ParameterToken"/></f></GetToken>
		<SetConstant public="1" set="method"><f a="defaultValue">
	<d/>
	<x path="Void"/>
</f></SetConstant>
		<SetCustomAttribute final="1" public="1" set="method">
			<f a="customBuilder">
				<c path="cs.system.reflection.emit.CustomAttributeBuilder"/>
				<x path="Void"/>
			</f>
			<overloads><SetCustomAttribute final="1" public="1" set="method"><f a="con:binaryAttribute">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetCustomAttribute></overloads>
		</SetCustomAttribute>
		<SetMarshal public="1" set="method"><f a="unmanagedMarshal">
	<c path="cs.system.reflection.emit.UnmanagedMarshal"/>
	<x path="Void"/>
</f></SetMarshal>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.ParameterBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.ParameterToken" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.ParameterToken" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<Empty public="1" set="null" static="1">
			<c path="cs.system.reflection.emit.ParameterToken"/>
			<meta><m n=":readOnly"/></meta>
		</Empty>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.ParameterToken"/>
	<c path="cs.system.reflection.emit.ParameterToken"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.ParameterToken"/>
	<c path="cs.system.reflection.emit.ParameterToken"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Token public="1" get="accessor" set="null"><x path="Int"/></Token>
		<get_Token final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Token>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.ParameterToken"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._PropertyBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._PropertyBuilder" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._PropertyBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.PropertyBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.PropertyBuilder" extern="1" final="1">
		<extends path="cs.system.reflection.PropertyInfo"/>
		<implements path="cs.system.runtime.interopservices._PropertyBuilder"/>
		<Module public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.Module"/></Module>
		<ReflectedType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></ReflectedType>
		<PropertyType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></PropertyType>
		<PropertyToken public="1" get="accessor" set="null"><c path="cs.system.reflection.emit.PropertyToken"/></PropertyToken>
		<Name public="1" get="accessor" set="null" override="1"><c path="String"/></Name>
		<DeclaringType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></DeclaringType>
		<CanWrite public="1" get="accessor" set="null" override="1"><x path="Bool"/></CanWrite>
		<CanRead public="1" get="accessor" set="null" override="1"><x path="Bool"/></CanRead>
		<Attributes public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.PropertyAttributes"/></Attributes>
		<get_Attributes public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.PropertyAttributes"/></f></get_Attributes>
		<get_CanRead public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_CanRead>
		<get_CanWrite public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_CanWrite>
		<get_DeclaringType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<get_Name public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Name>
		<get_PropertyToken final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.emit.PropertyToken"/></f></get_PropertyToken>
		<get_PropertyType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_PropertyType>
		<get_ReflectedType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<AddOtherMethod final="1" public="1" set="method"><f a="mdBuilder">
	<c path="cs.system.reflection.emit.MethodBuilder"/>
	<x path="Void"/>
</f></AddOtherMethod>
		<GetAccessors public="1" set="method" override="1"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c>
</f></GetAccessors>
		<GetCustomAttributes public="1" set="method" override="1">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<GetGetMethod public="1" set="method" override="1"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetGetMethod>
		<GetIndexParameters public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.ParameterInfo"/></c></f></GetIndexParameters>
		<GetSetMethod public="1" set="method" override="1"><f a="nonPublic">
	<x path="Bool"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetSetMethod>
		<GetValue public="1" set="method" override="1">
			<f a="obj:index">
				<d/>
				<c path="cs.NativeArray"><d/></c>
				<d/>
			</f>
			<overloads><GetValue public="1" set="method"><f a="obj:invokeAttr:binder:index:culture">
	<d/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<d/>
</f></GetValue></overloads>
		</GetValue>
		<IsDefined public="1" set="method" override="1"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<SetConstant final="1" public="1" set="method"><f a="defaultValue">
	<d/>
	<x path="Void"/>
</f></SetConstant>
		<SetCustomAttribute final="1" public="1" set="method">
			<f a="customBuilder">
				<c path="cs.system.reflection.emit.CustomAttributeBuilder"/>
				<x path="Void"/>
			</f>
			<overloads><SetCustomAttribute final="1" public="1" set="method"><f a="con:binaryAttribute">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetCustomAttribute></overloads>
		</SetCustomAttribute>
		<SetGetMethod final="1" public="1" set="method"><f a="mdBuilder">
	<c path="cs.system.reflection.emit.MethodBuilder"/>
	<x path="Void"/>
</f></SetGetMethod>
		<SetSetMethod final="1" public="1" set="method"><f a="mdBuilder">
	<c path="cs.system.reflection.emit.MethodBuilder"/>
	<x path="Void"/>
</f></SetSetMethod>
		<SetValue public="1" set="method" override="1">
			<f a="obj:value:index">
				<d/>
				<d/>
				<c path="cs.NativeArray"><d/></c>
				<x path="Void"/>
			</f>
			<overloads><SetValue public="1" set="method"><f a="obj:value:invokeAttr:binder:index:culture">
	<d/>
	<d/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<x path="Void"/>
</f></SetValue></overloads>
		</SetValue>
		<get_Module public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.Module"/></f></get_Module>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.PropertyBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.PropertyToken" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.PropertyToken" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<Empty public="1" set="null" static="1">
			<c path="cs.system.reflection.emit.PropertyToken"/>
			<meta><m n=":readOnly"/></meta>
		</Empty>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.PropertyToken"/>
	<c path="cs.system.reflection.emit.PropertyToken"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.PropertyToken"/>
	<c path="cs.system.reflection.emit.PropertyToken"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Token public="1" get="accessor" set="null"><x path="Int"/></Token>
		<get_Token final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Token>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.PropertyToken"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.emit.SignatureHelper_SignatureHelperType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.SignatureHelper" module="cs.system.reflection.emit.SignatureHelper">
		<HELPER_FIELD><meta><m n=":csNative"><e>0</e></m></meta></HELPER_FIELD>
		<HELPER_LOCAL><meta><m n=":csNative"><e>1</e></m></meta></HELPER_LOCAL>
		<HELPER_METHOD><meta><m n=":csNative"><e>2</e></m></meta></HELPER_METHOD>
		<HELPER_PROPERTY><meta><m n=":csNative"><e>3</e></m></meta></HELPER_PROPERTY>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.Emit.SignatureHelper.SignatureHelperType"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.runtime.interopservices._SignatureHelper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._SignatureHelper" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._SignatureHelper"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.SignatureHelper" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.SignatureHelper" extern="1" final="1">
		<implements path="cs.system.runtime.interopservices._SignatureHelper"/>
		<GetFieldSigHelper public="1" set="method" static="1"><f a="mod">
	<c path="cs.system.reflection.Module"/>
	<c path="cs.system.reflection.emit.SignatureHelper"/>
</f></GetFieldSigHelper>
		<GetLocalVarSigHelper public="1" set="method" static="1">
			<f a="mod">
				<c path="cs.system.reflection.Module"/>
				<c path="cs.system.reflection.emit.SignatureHelper"/>
			</f>
			<overloads><GetLocalVarSigHelper public="1" set="method"><f a=""><c path="cs.system.reflection.emit.SignatureHelper"/></f></GetLocalVarSigHelper></overloads>
		</GetLocalVarSigHelper>
		<GetMethodSigHelper public="1" set="method" static="1">
			<f a="callingConvention:returnType">
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.system.Type"/>
				<c path="cs.system.reflection.emit.SignatureHelper"/>
			</f>
			<overloads>
				<GetMethodSigHelper public="1" set="method"><f a="mod:returnType:parameterTypes">
	<c path="cs.system.reflection.Module"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.emit.SignatureHelper"/>
</f></GetMethodSigHelper>
				<GetMethodSigHelper public="1" set="method"><f a="mod:unmanagedCallConv:returnType">
	<c path="cs.system.reflection.Module"/>
	<e path="cs.system.runtime.interopservices.CallingConvention"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.emit.SignatureHelper"/>
</f></GetMethodSigHelper>
				<GetMethodSigHelper public="1" set="method"><f a="mod:callingConvention:returnType">
	<c path="cs.system.reflection.Module"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.emit.SignatureHelper"/>
</f></GetMethodSigHelper>
				<GetMethodSigHelper public="1" set="method"><f a="unmanagedCallingConvention:returnType">
	<e path="cs.system.runtime.interopservices.CallingConvention"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.emit.SignatureHelper"/>
</f></GetMethodSigHelper>
			</overloads>
		</GetMethodSigHelper>
		<GetPropertySigHelper public="1" set="method" static="1">
			<f a="mod:returnType:parameterTypes">
				<c path="cs.system.reflection.Module"/>
				<c path="cs.system.Type"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.system.reflection.emit.SignatureHelper"/>
			</f>
			<overloads><GetPropertySigHelper public="1" set="method"><f a="mod:returnType:requiredReturnTypeCustomModifiers:optionalReturnTypeCustomModifiers:parameterTypes:requiredParameterTypeCustomModifiers:optionalParameterTypeCustomModifiers">
	<c path="cs.system.reflection.Module"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.system.reflection.emit.SignatureHelper"/>
</f></GetPropertySigHelper></overloads>
		</GetPropertySigHelper>
		<AddArguments final="1" public="1" set="method"><f a="arguments:requiredCustomModifiers:optionalCustomModifiers">
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<x path="Void"/>
</f></AddArguments>
		<AddArgument final="1" public="1" set="method">
			<f a="argument:pinned">
				<c path="cs.system.Type"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<overloads>
				<AddArgument final="1" public="1" set="method"><f a="clsArgument">
	<c path="cs.system.Type"/>
	<x path="Void"/>
</f></AddArgument>
				<AddArgument final="1" public="1" set="method"><f a="argument:requiredCustomModifiers:optionalCustomModifiers">
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<x path="Void"/>
</f></AddArgument>
			</overloads>
		</AddArgument>
		<AddSentinel final="1" public="1" set="method"><f a=""><x path="Void"/></f></AddSentinel>
		<GetSignature final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetSignature>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.SignatureHelper"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.SignatureToken" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.SignatureToken" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<Empty public="1" set="null" static="1">
			<c path="cs.system.reflection.emit.SignatureToken"/>
			<meta><m n=":readOnly"/></meta>
		</Empty>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.SignatureToken"/>
	<c path="cs.system.reflection.emit.SignatureToken"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.SignatureToken"/>
	<c path="cs.system.reflection.emit.SignatureToken"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Token public="1" get="accessor" set="null"><x path="Int"/></Token>
		<get_Token final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Token>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.SignatureToken"</e></m>
		</meta>
	</class>
	<enum path="cs.system.reflection.emit.StackBehaviour" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.StackBehaviour">
		<Pop0><meta><m n=":csNative"><e>0</e></m></meta></Pop0>
		<Pop1><meta><m n=":csNative"><e>1</e></m></meta></Pop1>
		<Pop1_pop1><meta><m n=":csNative"><e>2</e></m></meta></Pop1_pop1>
		<Popi><meta><m n=":csNative"><e>3</e></m></meta></Popi>
		<Popi_pop1><meta><m n=":csNative"><e>4</e></m></meta></Popi_pop1>
		<Popi_popi><meta><m n=":csNative"><e>5</e></m></meta></Popi_popi>
		<Popi_popi8><meta><m n=":csNative"><e>6</e></m></meta></Popi_popi8>
		<Popi_popi_popi><meta><m n=":csNative"><e>7</e></m></meta></Popi_popi_popi>
		<Popi_popr4><meta><m n=":csNative"><e>8</e></m></meta></Popi_popr4>
		<Popi_popr8><meta><m n=":csNative"><e>9</e></m></meta></Popi_popr8>
		<Popref><meta><m n=":csNative"><e>10</e></m></meta></Popref>
		<Popref_pop1><meta><m n=":csNative"><e>11</e></m></meta></Popref_pop1>
		<Popref_popi><meta><m n=":csNative"><e>12</e></m></meta></Popref_popi>
		<Popref_popi_popi><meta><m n=":csNative"><e>13</e></m></meta></Popref_popi_popi>
		<Popref_popi_popi8><meta><m n=":csNative"><e>14</e></m></meta></Popref_popi_popi8>
		<Popref_popi_popr4><meta><m n=":csNative"><e>15</e></m></meta></Popref_popi_popr4>
		<Popref_popi_popr8><meta><m n=":csNative"><e>16</e></m></meta></Popref_popi_popr8>
		<Popref_popi_popref><meta><m n=":csNative"><e>17</e></m></meta></Popref_popi_popref>
		<Push0><meta><m n=":csNative"><e>18</e></m></meta></Push0>
		<Push1><meta><m n=":csNative"><e>19</e></m></meta></Push1>
		<Push1_push1><meta><m n=":csNative"><e>20</e></m></meta></Push1_push1>
		<Pushi><meta><m n=":csNative"><e>21</e></m></meta></Pushi>
		<Pushi8><meta><m n=":csNative"><e>22</e></m></meta></Pushi8>
		<Pushr4><meta><m n=":csNative"><e>23</e></m></meta></Pushr4>
		<Pushr8><meta><m n=":csNative"><e>24</e></m></meta></Pushr8>
		<Pushref><meta><m n=":csNative"><e>25</e></m></meta></Pushref>
		<Varpop><meta><m n=":csNative"><e>26</e></m></meta></Varpop>
		<Varpush><meta><m n=":csNative"><e>27</e></m></meta></Varpush>
		<Popref_popi_pop1><meta><m n=":csNative"><e>28</e></m></meta></Popref_popi_pop1>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Reflection.Emit.StackBehaviour"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.reflection.emit.StringToken" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.StringToken" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.StringToken"/>
	<c path="cs.system.reflection.emit.StringToken"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.StringToken"/>
	<c path="cs.system.reflection.emit.StringToken"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Token public="1" get="accessor" set="null"><x path="Int"/></Token>
		<get_Token final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Token>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.StringToken"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices._TypeBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._TypeBuilder" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._TypeBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.TypeBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.TypeBuilder" extern="1" final="1">
		<extends path="cs.system.Type"/>
		<implements path="cs.system.runtime.interopservices._TypeBuilder"/>
		<UnspecifiedTypeSize public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":readOnly"/></meta>
		</UnspecifiedTypeSize>
		<GetConstructor public="1" set="method" static="1"><f a="type:constructor">
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.system.reflection.ConstructorInfo"/>
</f></GetConstructor>
		<_GetConstructor public="1" set="method" static="1">
			<f a="type:constructor">
				<c path="cs.system.Type"/>
				<c path="cs.system.reflection.ConstructorInfo"/>
				<c path="cs.system.reflection.ConstructorInfo"/>
			</f>
			<meta><m n=":native"><e>"GetConstructor"</e></m></meta>
		</_GetConstructor>
		<GetMethod public="1" set="method" static="1"><f a="type:method">
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.MethodInfo"/>
	<c path="cs.system.reflection.MethodInfo"/>
</f></GetMethod>
		<_GetMethod public="1" set="method" static="1">
			<f a="type:method">
				<c path="cs.system.Type"/>
				<c path="cs.system.reflection.MethodInfo"/>
				<c path="cs.system.reflection.MethodInfo"/>
			</f>
			<meta><m n=":native"><e>"GetMethod"</e></m></meta>
		</_GetMethod>
		<GetField public="1" set="method" static="1"><f a="type:field">
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.FieldInfo"/>
	<c path="cs.system.reflection.FieldInfo"/>
</f></GetField>
		<_GetField public="1" set="method" static="1">
			<f a="type:field">
				<c path="cs.system.Type"/>
				<c path="cs.system.reflection.FieldInfo"/>
				<c path="cs.system.reflection.FieldInfo"/>
			</f>
			<meta><m n=":native"><e>"GetField"</e></m></meta>
		</_GetField>
		<DeclaringMethod public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.MethodBase"/></DeclaringMethod>
		<GenericParameterPosition public="1" get="accessor" set="null" override="1"><x path="Int"/></GenericParameterPosition>
		<IsGenericType public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsGenericType>
		<IsGenericTypeDefinition public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsGenericTypeDefinition>
		<GenericParameterAttributes public="1" get="accessor" set="null" override="1"><e path="cs.system.reflection.GenericParameterAttributes"/></GenericParameterAttributes>
		<IsGenericParameter public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsGenericParameter>
		<ContainsGenericParameters public="1" get="accessor" set="null" override="1"><x path="Bool"/></ContainsGenericParameters>
		<TypeToken public="1" get="accessor" set="null"><c path="cs.system.reflection.emit.TypeToken"/></TypeToken>
		<TypeHandle public="1" get="accessor" set="null" override="1"><c path="cs.system.RuntimeTypeHandle"/></TypeHandle>
		<ReflectedType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></ReflectedType>
		<Size public="1" get="accessor" set="null"><x path="Int"/></Size>
		<PackingSize public="1" get="accessor" set="null"><e path="cs.system.reflection.emit.PackingSize"/></PackingSize>
		<Namespace public="1" get="accessor" set="null" override="1"><c path="String"/></Namespace>
		<Name public="1" get="accessor" set="null" override="1"><c path="String"/></Name>
		<Module public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.Module"/></Module>
		<GUID public="1" get="accessor" set="null" override="1"><c path="cs.system.Guid"/></GUID>
		<FullName public="1" get="accessor" set="null" override="1"><c path="String"/></FullName>
		<UnderlyingSystemType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></UnderlyingSystemType>
		<DeclaringType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></DeclaringType>
		<BaseType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></BaseType>
		<AssemblyQualifiedName public="1" get="accessor" set="null" override="1"><c path="String"/></AssemblyQualifiedName>
		<Assembly public="1" get="accessor" set="null" override="1"><c path="cs.system.reflection.Assembly"/></Assembly>
		<GetAttributeFlagsImpl set="method" override="1">
			<f a=""><e path="cs.system.reflection.TypeAttributes"/></f>
			<meta><m n=":protected"/></meta>
		</GetAttributeFlagsImpl>
		<get_Assembly public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.Assembly"/></f></get_Assembly>
		<get_AssemblyQualifiedName public="1" set="method" override="1"><f a=""><c path="String"/></f></get_AssemblyQualifiedName>
		<get_BaseType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_BaseType>
		<get_DeclaringType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_DeclaringType>
		<IsSubclassOf public="1" set="method" override="1"><f a="c">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsSubclassOf>
		<get_UnderlyingSystemType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_UnderlyingSystemType>
		<get_FullName public="1" set="method" override="1"><f a=""><c path="String"/></f></get_FullName>
		<get_GUID public="1" set="method" override="1"><f a=""><c path="cs.system.Guid"/></f></get_GUID>
		<get_Module public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.Module"/></f></get_Module>
		<get_Name public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Name>
		<get_Namespace public="1" set="method" override="1"><f a=""><c path="String"/></f></get_Namespace>
		<get_PackingSize final="1" public="1" set="method"><f a=""><e path="cs.system.reflection.emit.PackingSize"/></f></get_PackingSize>
		<get_Size final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Size>
		<get_ReflectedType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_ReflectedType>
		<AddDeclarativeSecurity final="1" public="1" set="method"><f a="action:pset">
	<e path="cs.system.security.permissions.SecurityAction"/>
	<c path="cs.system.security.PermissionSet"/>
	<x path="Void"/>
</f></AddDeclarativeSecurity>
		<AddInterfaceImplementation final="1" public="1" set="method"><f a="interfaceType">
	<c path="cs.system.Type"/>
	<x path="Void"/>
</f></AddInterfaceImplementation>
		<GetConstructorImpl set="method" override="1">
			<f a="bindingAttr:binder:callConvention:types:modifiers">
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.ConstructorInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetConstructorImpl>
		<IsDefined public="1" set="method" override="1"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></IsDefined>
		<GetCustomAttributes public="1" set="method" override="1">
			<f a="inherit">
				<x path="Bool"/>
				<c path="cs.NativeArray"><d/></c>
			</f>
			<overloads><GetCustomAttributes public="1" set="method"><f a="attributeType:inherit">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
	<c path="cs.NativeArray"><d/></c>
</f></GetCustomAttributes></overloads>
		</GetCustomAttributes>
		<DefineNestedType final="1" public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.reflection.emit.TypeBuilder"/>
			</f>
			<overloads>
				<DefineNestedType final="1" public="1" set="method"><f a="name:attr:parent:packSize">
	<c path="String"/>
	<e path="cs.system.reflection.TypeAttributes"/>
	<c path="cs.system.Type"/>
	<e path="cs.system.reflection.emit.PackingSize"/>
	<c path="cs.system.reflection.emit.TypeBuilder"/>
</f></DefineNestedType>
				<DefineNestedType final="1" public="1" set="method"><f a="name:attr:parent:typeSize">
	<c path="String"/>
	<e path="cs.system.reflection.TypeAttributes"/>
	<c path="cs.system.Type"/>
	<x path="Int"/>
	<c path="cs.system.reflection.emit.TypeBuilder"/>
</f></DefineNestedType>
				<DefineNestedType final="1" public="1" set="method"><f a="name:attr:parent:interfaces">
	<c path="String"/>
	<e path="cs.system.reflection.TypeAttributes"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.emit.TypeBuilder"/>
</f></DefineNestedType>
				<DefineNestedType final="1" public="1" set="method"><f a="name:attr:parent">
	<c path="String"/>
	<e path="cs.system.reflection.TypeAttributes"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.emit.TypeBuilder"/>
</f></DefineNestedType>
				<DefineNestedType final="1" public="1" set="method"><f a="name:attr">
	<c path="String"/>
	<e path="cs.system.reflection.TypeAttributes"/>
	<c path="cs.system.reflection.emit.TypeBuilder"/>
</f></DefineNestedType>
			</overloads>
		</DefineNestedType>
		<DefineConstructor final="1" public="1" set="method">
			<f a="attributes:callingConvention:parameterTypes">
				<e path="cs.system.reflection.MethodAttributes"/>
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.system.reflection.emit.ConstructorBuilder"/>
			</f>
			<overloads><DefineConstructor final="1" public="1" set="method"><f a="attributes:callingConvention:parameterTypes:requiredCustomModifiers:optionalCustomModifiers">
	<e path="cs.system.reflection.MethodAttributes"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.system.reflection.emit.ConstructorBuilder"/>
</f></DefineConstructor></overloads>
		</DefineConstructor>
		<DefineDefaultConstructor final="1" public="1" set="method"><f a="attributes">
	<e path="cs.system.reflection.MethodAttributes"/>
	<c path="cs.system.reflection.emit.ConstructorBuilder"/>
</f></DefineDefaultConstructor>
		<DefineMethod final="1" public="1" set="method">
			<f a="name:attributes:returnType:parameterTypes">
				<c path="String"/>
				<e path="cs.system.reflection.MethodAttributes"/>
				<c path="cs.system.Type"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.system.reflection.emit.MethodBuilder"/>
			</f>
			<overloads>
				<DefineMethod final="1" public="1" set="method"><f a="name:attributes:callingConvention">
	<c path="String"/>
	<e path="cs.system.reflection.MethodAttributes"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.reflection.emit.MethodBuilder"/>
</f></DefineMethod>
				<DefineMethod final="1" public="1" set="method"><f a="name:attributes">
	<c path="String"/>
	<e path="cs.system.reflection.MethodAttributes"/>
	<c path="cs.system.reflection.emit.MethodBuilder"/>
</f></DefineMethod>
				<DefineMethod final="1" public="1" set="method"><f a="name:attributes:callingConvention:returnType:returnTypeRequiredCustomModifiers:returnTypeOptionalCustomModifiers:parameterTypes:parameterTypeRequiredCustomModifiers:parameterTypeOptionalCustomModifiers">
	<c path="String"/>
	<e path="cs.system.reflection.MethodAttributes"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.system.reflection.emit.MethodBuilder"/>
</f></DefineMethod>
				<DefineMethod final="1" public="1" set="method"><f a="name:attributes:callingConvention:returnType:parameterTypes">
	<c path="String"/>
	<e path="cs.system.reflection.MethodAttributes"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.reflection.emit.MethodBuilder"/>
</f></DefineMethod>
			</overloads>
		</DefineMethod>
		<DefinePInvokeMethod final="1" public="1" set="method">
			<f a="name:dllName:entryName:attributes:callingConvention:returnType:parameterTypes:nativeCallConv:nativeCharSet">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="cs.system.reflection.MethodAttributes"/>
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.system.Type"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<e path="cs.system.runtime.interopservices.CallingConvention"/>
				<e path="cs.system.runtime.interopservices.CharSet"/>
				<c path="cs.system.reflection.emit.MethodBuilder"/>
			</f>
			<overloads>
				<DefinePInvokeMethod final="1" public="1" set="method"><f a="name:dllName:attributes:callingConvention:returnType:parameterTypes:nativeCallConv:nativeCharSet">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.reflection.MethodAttributes"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<e path="cs.system.runtime.interopservices.CallingConvention"/>
	<e path="cs.system.runtime.interopservices.CharSet"/>
	<c path="cs.system.reflection.emit.MethodBuilder"/>
</f></DefinePInvokeMethod>
				<DefinePInvokeMethod final="1" public="1" set="method"><f a="name:dllName:entryName:attributes:callingConvention:returnType:returnTypeRequiredCustomModifiers:returnTypeOptionalCustomModifiers:parameterTypes:parameterTypeRequiredCustomModifiers:parameterTypeOptionalCustomModifiers:nativeCallConv:nativeCharSet">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.reflection.MethodAttributes"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<e path="cs.system.runtime.interopservices.CallingConvention"/>
	<e path="cs.system.runtime.interopservices.CharSet"/>
	<c path="cs.system.reflection.emit.MethodBuilder"/>
</f></DefinePInvokeMethod>
			</overloads>
		</DefinePInvokeMethod>
		<DefineMethodOverride final="1" public="1" set="method"><f a="methodInfoBody:methodInfoDeclaration">
	<c path="cs.system.reflection.MethodInfo"/>
	<c path="cs.system.reflection.MethodInfo"/>
	<x path="Void"/>
</f></DefineMethodOverride>
		<DefineField final="1" public="1" set="method">
			<f a="fieldName:type:attributes">
				<c path="String"/>
				<c path="cs.system.Type"/>
				<e path="cs.system.reflection.FieldAttributes"/>
				<c path="cs.system.reflection.emit.FieldBuilder"/>
			</f>
			<overloads><DefineField final="1" public="1" set="method"><f a="fieldName:type:requiredCustomModifiers:optionalCustomModifiers:attributes">
	<c path="String"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<e path="cs.system.reflection.FieldAttributes"/>
	<c path="cs.system.reflection.emit.FieldBuilder"/>
</f></DefineField></overloads>
		</DefineField>
		<DefineProperty final="1" public="1" set="method">
			<f a="name:attributes:returnType:parameterTypes">
				<c path="String"/>
				<e path="cs.system.reflection.PropertyAttributes"/>
				<c path="cs.system.Type"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.system.reflection.emit.PropertyBuilder"/>
			</f>
			<overloads>
				<DefineProperty final="1" public="1" set="method"><f a="name:attributes:callingConvention:returnType:returnTypeRequiredCustomModifiers:returnTypeOptionalCustomModifiers:parameterTypes:parameterTypeRequiredCustomModifiers:parameterTypeOptionalCustomModifiers">
	<c path="String"/>
	<e path="cs.system.reflection.PropertyAttributes"/>
	<e path="cs.system.reflection.CallingConventions"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.system.reflection.emit.PropertyBuilder"/>
</f></DefineProperty>
				<DefineProperty final="1" public="1" set="method"><f a="name:attributes:returnType:returnTypeRequiredCustomModifiers:returnTypeOptionalCustomModifiers:parameterTypes:parameterTypeRequiredCustomModifiers:parameterTypeOptionalCustomModifiers">
	<c path="String"/>
	<e path="cs.system.reflection.PropertyAttributes"/>
	<c path="cs.system.Type"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.NativeArray"><c path="cs.NativeArray"><c path="cs.system.Type"/></c></c>
	<c path="cs.system.reflection.emit.PropertyBuilder"/>
</f></DefineProperty>
			</overloads>
		</DefineProperty>
		<DefineTypeInitializer final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.emit.ConstructorBuilder"/></f></DefineTypeInitializer>
		<CreateType final="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></CreateType>
		<GetConstructors public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ConstructorInfo"/></c>
</f></GetConstructors>
		<GetElementType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></GetElementType>
		<GetEvent public="1" set="method" override="1"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.EventInfo"/>
</f></GetEvent>
		<GetEvents public="1" set="method" override="1">
			<f a=""><c path="cs.NativeArray"><c path="cs.system.reflection.EventInfo"/></c></f>
			<overloads><GetEvents public="1" set="method"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.EventInfo"/></c>
</f></GetEvents></overloads>
		</GetEvents>
		<GetField public="1" set="method" override="1"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.FieldInfo"/>
</f></GetField>
		<GetFields public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.FieldInfo"/></c>
</f></GetFields>
		<GetInterface public="1" set="method" override="1"><f a="name:ignoreCase">
	<c path="String"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
</f></GetInterface>
		<GetInterfaces public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetInterfaces>
		<GetMember public="1" set="method" override="1"><f a="name:type:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.MemberTypes"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMember>
		<GetMembers public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MemberInfo"/></c>
</f></GetMembers>
		<GetMethods public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.MethodInfo"/></c>
</f></GetMethods>
		<GetMethodImpl set="method" override="1">
			<f a="name:bindingAttr:binder:callConvention:types:modifiers">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<e path="cs.system.reflection.CallingConventions"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.MethodInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetMethodImpl>
		<GetNestedType public="1" set="method" override="1"><f a="name:bindingAttr">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.Type"/>
</f></GetNestedType>
		<GetNestedTypes public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
</f></GetNestedTypes>
		<GetProperties public="1" set="method" override="1"><f a="bindingAttr">
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.NativeArray"><c path="cs.system.reflection.PropertyInfo"/></c>
</f></GetProperties>
		<GetPropertyImpl set="method" override="1">
			<f a="name:bindingAttr:binder:returnType:types:modifiers">
				<c path="String"/>
				<e path="cs.system.reflection.BindingFlags"/>
				<c path="cs.system.reflection.Binder"/>
				<c path="cs.system.Type"/>
				<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
				<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
				<c path="cs.system.reflection.PropertyInfo"/>
			</f>
			<meta><m n=":protected"/></meta>
		</GetPropertyImpl>
		<HasElementTypeImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</HasElementTypeImpl>
		<InvokeMember public="1" set="method" override="1"><f a="name:invokeAttr:binder:target:args:modifiers:culture:namedParameters">
	<c path="String"/>
	<e path="cs.system.reflection.BindingFlags"/>
	<c path="cs.system.reflection.Binder"/>
	<d/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.ParameterModifier"/></c>
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<d/>
</f></InvokeMember>
		<IsArrayImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsArrayImpl>
		<IsByRefImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsByRefImpl>
		<IsCOMObjectImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsCOMObjectImpl>
		<IsPointerImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsPointerImpl>
		<IsPrimitiveImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsPrimitiveImpl>
		<IsValueTypeImpl set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</IsValueTypeImpl>
		<MakeArrayType public="1" set="method" override="1">
			<f a=""><c path="cs.system.Type"/></f>
			<overloads><MakeArrayType public="1" set="method"><f a="rank">
	<x path="Int"/>
	<c path="cs.system.Type"/>
</f></MakeArrayType></overloads>
		</MakeArrayType>
		<MakeByRefType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></MakeByRefType>
		<MakeGenericType public="1" set="method" override="1"><f a="typeArguments">
	<c path="cs.NativeArray"><c path="cs.system.Type"/></c>
	<c path="cs.system.Type"/>
</f></MakeGenericType>
		<MakePointerType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></MakePointerType>
		<get_TypeHandle public="1" set="method" override="1"><f a=""><c path="cs.system.RuntimeTypeHandle"/></f></get_TypeHandle>
		<SetCustomAttribute final="1" public="1" set="method">
			<f a="customBuilder">
				<c path="cs.system.reflection.emit.CustomAttributeBuilder"/>
				<x path="Void"/>
			</f>
			<overloads><SetCustomAttribute final="1" public="1" set="method"><f a="con:binaryAttribute">
	<c path="cs.system.reflection.ConstructorInfo"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></SetCustomAttribute></overloads>
		</SetCustomAttribute>
		<DefineEvent final="1" public="1" set="method"><f a="name:attributes:eventtype">
	<c path="String"/>
	<e path="cs.system.reflection.EventAttributes"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.emit.EventBuilder"/>
</f></DefineEvent>
		<DefineInitializedData final="1" public="1" set="method"><f a="name:data:attributes">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<e path="cs.system.reflection.FieldAttributes"/>
	<c path="cs.system.reflection.emit.FieldBuilder"/>
</f></DefineInitializedData>
		<DefineUninitializedData final="1" public="1" set="method"><f a="name:size:attributes">
	<c path="String"/>
	<x path="Int"/>
	<e path="cs.system.reflection.FieldAttributes"/>
	<c path="cs.system.reflection.emit.FieldBuilder"/>
</f></DefineUninitializedData>
		<get_TypeToken final="1" public="1" set="method"><f a=""><c path="cs.system.reflection.emit.TypeToken"/></f></get_TypeToken>
		<SetParent final="1" public="1" set="method"><f a="parent">
	<c path="cs.system.Type"/>
	<x path="Void"/>
</f></SetParent>
		<GetInterfaceMap public="1" set="method" override="1"><f a="interfaceType">
	<c path="cs.system.Type"/>
	<c path="cs.system.reflection.InterfaceMapping"/>
</f></GetInterfaceMap>
		<ToString public="1" set="method" override="1"><f a=""><c path="String"/></f></ToString>
		<IsAssignableFrom public="1" set="method" override="1"><f a="c">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsAssignableFrom>
		<IsCreated final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsCreated>
		<GetGenericArguments public="1" set="method" override="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.Type"/></c></f></GetGenericArguments>
		<GetGenericTypeDefinition public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></GetGenericTypeDefinition>
		<get_ContainsGenericParameters public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_ContainsGenericParameters>
		<get_IsGenericParameter public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsGenericParameter>
		<get_GenericParameterAttributes public="1" set="method" override="1"><f a=""><e path="cs.system.reflection.GenericParameterAttributes"/></f></get_GenericParameterAttributes>
		<get_IsGenericTypeDefinition public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsGenericTypeDefinition>
		<get_IsGenericType public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsGenericType>
		<get_GenericParameterPosition public="1" set="method" override="1"><f a=""><x path="Int"/></f></get_GenericParameterPosition>
		<get_DeclaringMethod public="1" set="method" override="1"><f a=""><c path="cs.system.reflection.MethodBase"/></f></get_DeclaringMethod>
		<DefineGenericParameters final="1" public="1" set="method"><f a="names">
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.NativeArray"><c path="cs.system.reflection.emit.GenericTypeParameterBuilder"/></c>
</f></DefineGenericParameters>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.TypeBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.TypeToken" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.TypeToken" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<Empty public="1" set="null" static="1">
			<c path="cs.system.reflection.emit.TypeToken"/>
			<meta><m n=":readOnly"/></meta>
		</Empty>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.TypeToken"/>
	<c path="cs.system.reflection.emit.TypeToken"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.reflection.emit.TypeToken"/>
	<c path="cs.system.reflection.emit.TypeToken"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Token public="1" get="accessor" set="null"><x path="Int"/></Token>
		<get_Token final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Token>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.TypeToken"</e></m>
		</meta>
	</class>
	<class path="cs.system.reflection.emit.UnmanagedMarshal" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.reflection.emit.UnmanagedMarshal" extern="1" final="1">
		<DefineByValArray public="1" set="method" static="1"><f a="elemCount">
	<x path="Int"/>
	<c path="cs.system.reflection.emit.UnmanagedMarshal"/>
</f></DefineByValArray>
		<DefineByValTStr public="1" set="method" static="1"><f a="elemCount">
	<x path="Int"/>
	<c path="cs.system.reflection.emit.UnmanagedMarshal"/>
</f></DefineByValTStr>
		<DefineLPArray public="1" set="method" static="1"><f a="elemType">
	<e path="cs.system.runtime.interopservices.UnmanagedType"/>
	<c path="cs.system.reflection.emit.UnmanagedMarshal"/>
</f></DefineLPArray>
		<DefineSafeArray public="1" set="method" static="1"><f a="elemType">
	<e path="cs.system.runtime.interopservices.UnmanagedType"/>
	<c path="cs.system.reflection.emit.UnmanagedMarshal"/>
</f></DefineSafeArray>
		<DefineUnmanagedMarshal public="1" set="method" static="1"><f a="unmanagedType">
	<e path="cs.system.runtime.interopservices.UnmanagedType"/>
	<c path="cs.system.reflection.emit.UnmanagedMarshal"/>
</f></DefineUnmanagedMarshal>
		<DefineCustom public="1" set="method" static="1"><f a="typeref:cookie:mtype:id">
	<c path="cs.system.Type"/>
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.Guid"/>
	<c path="cs.system.reflection.emit.UnmanagedMarshal"/>
</f></DefineCustom>
		<IIDGuid public="1" get="accessor" set="null"><c path="cs.system.Guid"/></IIDGuid>
		<GetUnmanagedType public="1" get="accessor" set="null"><e path="cs.system.runtime.interopservices.UnmanagedType"/></GetUnmanagedType>
		<ElementCount public="1" get="accessor" set="null"><x path="Int"/></ElementCount>
		<BaseType public="1" get="accessor" set="null"><e path="cs.system.runtime.interopservices.UnmanagedType"/></BaseType>
		<get_BaseType final="1" public="1" set="method"><f a=""><e path="cs.system.runtime.interopservices.UnmanagedType"/></f></get_BaseType>
		<get_ElementCount final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_ElementCount>
		<get_GetUnmanagedType final="1" public="1" set="method"><f a=""><e path="cs.system.runtime.interopservices.UnmanagedType"/></f></get_GetUnmanagedType>
		<get_IIDGuid final="1" public="1" set="method"><f a=""><c path="cs.system.Guid"/></f></get_IIDGuid>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Reflection.Emit.UnmanagedMarshal"</e></m>
		</meta>
	</class>
	<class path="cs.system.resources.IResourceWriter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.resources.IResourceWriter" extern="1" interface="1">
		<extends path="cs.system.IDisposable"/>
		<AddResource public="1" set="method">
			<f a="name:value">
				<c path="String"/>
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Void"/>
			</f>
			<overloads>
				<AddResource public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></AddResource>
				<AddResource public="1" set="method"><f a="name:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></AddResource>
			</overloads>
		</AddResource>
		<Close public="1" set="method"><f a=""><x path="Void"/></f></Close>
		<Generate public="1" set="method"><f a=""><x path="Void"/></f></Generate>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Resources.IResourceWriter"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.constrainedexecution.CriticalFinalizerObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.constrainedexecution.CriticalFinalizerObject" extern="1" abstract="1">
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.ConstrainedExecution.CriticalFinalizerObject"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.hosting.ActivationArguments" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.hosting.ActivationArguments" extern="1" final="1">
		<ApplicationIdentity public="1" get="accessor" set="null"><c path="cs.system.ApplicationIdentity"/></ApplicationIdentity>
		<ActivationData public="1" get="accessor" set="null"><c path="cs.NativeArray"><c path="String"/></c></ActivationData>
		<ActivationContext public="1" get="accessor" set="null"><c path="cs.system.ActivationContext"/></ActivationContext>
		<get_ActivationContext final="1" public="1" set="method"><f a=""><c path="cs.system.ActivationContext"/></f></get_ActivationContext>
		<get_ActivationData final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="String"/></c></f></get_ActivationData>
		<get_ApplicationIdentity final="1" public="1" set="method"><f a=""><c path="cs.system.ApplicationIdentity"/></f></get_ApplicationIdentity>
		<new final="1" public="1" set="method">
			<f a="activationData">
				<c path="cs.system.ActivationContext"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="applicationIdentity:activationData">
	<c path="cs.system.ApplicationIdentity"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="activationContext:activationData">
	<c path="cs.system.ActivationContext"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="applicationIdentity">
	<c path="cs.system.ApplicationIdentity"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Hosting.ActivationArguments"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.hosting.ApplicationActivator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.hosting.ApplicationActivator" extern="1">
		<CreateInstanceHelper set="method" static="1">
			<f a="adSetup">
				<c path="cs.system.AppDomainSetup"/>
				<c path="cs.system.runtime.remoting.ObjectHandle"/>
			</f>
			<meta><m n=":protected"/></meta>
		</CreateInstanceHelper>
		<CreateInstance public="1" set="method">
			<f a="activationContext">
				<c path="cs.system.ActivationContext"/>
				<c path="cs.system.runtime.remoting.ObjectHandle"/>
			</f>
			<overloads><CreateInstance public="1" set="method"><f a="activationContext:activationCustomData">
	<c path="cs.system.ActivationContext"/>
	<c path="cs.NativeArray"><c path="String"/></c>
	<c path="cs.system.runtime.remoting.ObjectHandle"/>
</f></CreateInstance></overloads>
		</CreateInstance>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Hosting.ApplicationActivator"</e></m>
		</meta>
	</class>
	<enum path="cs.system.runtime.interopservices.CallingConvention" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices.CallingConvention">
		<Winapi><meta><m n=":csNative"><e>1</e></m></meta></Winapi>
		<Cdecl><meta><m n=":csNative"><e>2</e></m></meta></Cdecl>
		<StdCall><meta><m n=":csNative"><e>3</e></m></meta></StdCall>
		<ThisCall><meta><m n=":csNative"><e>4</e></m></meta></ThisCall>
		<FastCall><meta><m n=":csNative"><e>5</e></m></meta></FastCall>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Runtime.InteropServices.CallingConvention"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.runtime.interopservices.CharSet" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices.CharSet">
		<None><meta><m n=":csNative"><e>1</e></m></meta></None>
		<Ansi><meta><m n=":csNative"><e>2</e></m></meta></Ansi>
		<Unicode><meta><m n=":csNative"><e>3</e></m></meta></Unicode>
		<Auto><meta><m n=":csNative"><e>4</e></m></meta></Auto>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Runtime.InteropServices.CharSet"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.runtime.interopservices.LayoutKind" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices.LayoutKind">
		<Sequential><meta><m n=":csNative"><e>0</e></m></meta></Sequential>
		<Explicit><meta><m n=":csNative"><e>2</e></m></meta></Explicit>
		<Auto><meta><m n=":csNative"><e>3</e></m></meta></Auto>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Runtime.InteropServices.LayoutKind"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.runtime.interopservices.SafeHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices.SafeHandle" extern="1" abstract="1">
		<extends path="cs.system.runtime.constrainedexecution.CriticalFinalizerObject"/>
		<implements path="cs.system.IDisposable"/>
		<IsInvalid public="1" get="accessor" set="null"><x path="Bool"/></IsInvalid>
		<IsClosed public="1" get="accessor" set="null"><x path="Bool"/></IsClosed>
		<handle><c path="cs.system.IntPtr"/></handle>
		<Close final="1" public="1" set="method"><f a=""><x path="Void"/></f></Close>
		<DangerousAddRef final="1" public="1" set="method"><f a="success">
	<t path="cs.Ref"><x path="Bool"/></t>
	<x path="Void"/>
</f></DangerousAddRef>
		<DangerousGetHandle final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></DangerousGetHandle>
		<DangerousRelease final="1" public="1" set="method"><f a=""><x path="Void"/></f></DangerousRelease>
		<Dispose final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><Dispose set="method">
	<f a="disposing">
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":protected"/></meta>
</Dispose></overloads>
		</Dispose>
		<SetHandleAsInvalid final="1" public="1" set="method"><f a=""><x path="Void"/></f></SetHandleAsInvalid>
		<ReleaseHandle abstract="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</ReleaseHandle>
		<SetHandle final="1" set="method">
			<f a="handle">
				<c path="cs.system.IntPtr"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</SetHandle>
		<get_IsClosed final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsClosed>
		<get_IsInvalid abstract="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsInvalid>
		<new final="1" set="method">
			<f a="invalidHandleValue:ownsHandle">
				<c path="cs.system.IntPtr"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices.SafeHandle"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.interopservices.StructLayoutAttribute" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices.StructLayoutAttribute" extern="1" final="1">
		<extends path="cs.system.Attribute"/>
		<Value public="1" get="accessor" set="null"><e path="cs.system.runtime.interopservices.LayoutKind"/></Value>
		<Size public="1"><x path="Int"/></Size>
		<Pack public="1"><x path="Int"/></Pack>
		<CharSet public="1"><e path="cs.system.runtime.interopservices.CharSet"/></CharSet>
		<get_Value final="1" public="1" set="method"><f a=""><e path="cs.system.runtime.interopservices.LayoutKind"/></f></get_Value>
		<new final="1" public="1" set="method">
			<f a="layoutKind">
				<t path="cs.types.Int16"/>
				<x path="Void"/>
			</f>
			<overloads><new final="1" public="1" set="method"><f a="layoutKind">
	<e path="cs.system.runtime.interopservices.LayoutKind"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices.StructLayoutAttribute"</e></m>
		</meta>
	</class>
	<enum path="cs.system.runtime.interopservices.UnmanagedType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices.UnmanagedType">
		<Bool><meta><m n=":csNative"><e>2</e></m></meta></Bool>
		<I1><meta><m n=":csNative"><e>3</e></m></meta></I1>
		<U1><meta><m n=":csNative"><e>4</e></m></meta></U1>
		<I2><meta><m n=":csNative"><e>5</e></m></meta></I2>
		<U2><meta><m n=":csNative"><e>6</e></m></meta></U2>
		<I4><meta><m n=":csNative"><e>7</e></m></meta></I4>
		<U4><meta><m n=":csNative"><e>8</e></m></meta></U4>
		<I8><meta><m n=":csNative"><e>9</e></m></meta></I8>
		<U8><meta><m n=":csNative"><e>10</e></m></meta></U8>
		<R4><meta><m n=":csNative"><e>11</e></m></meta></R4>
		<R8><meta><m n=":csNative"><e>12</e></m></meta></R8>
		<Currency><meta><m n=":csNative"><e>15</e></m></meta></Currency>
		<BStr><meta><m n=":csNative"><e>19</e></m></meta></BStr>
		<LPStr><meta><m n=":csNative"><e>20</e></m></meta></LPStr>
		<LPWStr><meta><m n=":csNative"><e>21</e></m></meta></LPWStr>
		<LPTStr><meta><m n=":csNative"><e>22</e></m></meta></LPTStr>
		<ByValTStr><meta><m n=":csNative"><e>23</e></m></meta></ByValTStr>
		<IUnknown><meta><m n=":csNative"><e>25</e></m></meta></IUnknown>
		<IDispatch><meta><m n=":csNative"><e>26</e></m></meta></IDispatch>
		<Struct><meta><m n=":csNative"><e>27</e></m></meta></Struct>
		<Interface><meta><m n=":csNative"><e>28</e></m></meta></Interface>
		<SafeArray><meta><m n=":csNative"><e>29</e></m></meta></SafeArray>
		<ByValArray><meta><m n=":csNative"><e>30</e></m></meta></ByValArray>
		<SysInt><meta><m n=":csNative"><e>31</e></m></meta></SysInt>
		<SysUInt><meta><m n=":csNative"><e>32</e></m></meta></SysUInt>
		<VBByRefStr><meta><m n=":csNative"><e>34</e></m></meta></VBByRefStr>
		<AnsiBStr><meta><m n=":csNative"><e>35</e></m></meta></AnsiBStr>
		<TBStr><meta><m n=":csNative"><e>36</e></m></meta></TBStr>
		<VariantBool><meta><m n=":csNative"><e>37</e></m></meta></VariantBool>
		<FunctionPtr><meta><m n=":csNative"><e>38</e></m></meta></FunctionPtr>
		<AsAny><meta><m n=":csNative"><e>40</e></m></meta></AsAny>
		<LPArray><meta><m n=":csNative"><e>42</e></m></meta></LPArray>
		<LPStruct><meta><m n=":csNative"><e>43</e></m></meta></LPStruct>
		<CustomMarshaler><meta><m n=":csNative"><e>44</e></m></meta></CustomMarshaler>
		<Error><meta><m n=":csNative"><e>45</e></m></meta></Error>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Runtime.InteropServices.UnmanagedType"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.runtime.interopservices._Thread" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.interopservices._Thread" extern="1" interface="1">
		<GetIDsOfNames public="1" set="method"><f a="riid:rgszNames:cNames:lcid:rgDispId">
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetIDsOfNames>
		<GetTypeInfo public="1" set="method"><f a="iTInfo:lcid:ppTInfo">
	<x path="UInt"/>
	<x path="UInt"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></GetTypeInfo>
		<GetTypeInfoCount public="1" set="method"><f a="pcTInfo">
	<t path="cs.Out"><x path="UInt"/></t>
	<x path="Void"/>
</f></GetTypeInfoCount>
		<Invoke public="1" set="method"><f a="dispIdMember:riid:lcid:wFlags:pDispParams:pVarResult:pExcepInfo:puArgErr">
	<x path="UInt"/>
	<t path="cs.Ref"><c path="cs.system.Guid"/></t>
	<x path="UInt"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></Invoke>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.InteropServices._Thread"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.IChannelInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.IChannelInfo" extern="1" interface="1">
		<ChannelData public="1" get="accessor" set="accessor"><c path="cs.NativeArray"><d/></c></ChannelData>
		<get_ChannelData public="1" set="method"><f a=""><c path="cs.NativeArray"><d/></c></f></get_ChannelData>
		<set_ChannelData public="1" set="method"><f a="value">
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><d/></c>
</f></set_ChannelData>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.IChannelInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.IEnvoyInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.IEnvoyInfo" extern="1" interface="1">
		<EnvoySinks public="1" get="accessor" set="accessor"><c path="cs.system.runtime.remoting.messaging.IMessageSink"/></EnvoySinks>
		<get_EnvoySinks public="1" set="method"><f a=""><c path="cs.system.runtime.remoting.messaging.IMessageSink"/></f></get_EnvoySinks>
		<set_EnvoySinks public="1" set="method"><f a="value">
	<c path="cs.system.runtime.remoting.messaging.IMessageSink"/>
	<c path="cs.system.runtime.remoting.messaging.IMessageSink"/>
</f></set_EnvoySinks>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.IEnvoyInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.IObjectHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.IObjectHandle" extern="1" interface="1">
		<Unwrap public="1" set="method"><f a=""><d/></f></Unwrap>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.IObjectHandle"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.IRemotingTypeInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.IRemotingTypeInfo" extern="1" interface="1">
		<TypeName public="1" get="accessor" set="accessor"><c path="String"/></TypeName>
		<get_TypeName public="1" set="method"><f a=""><c path="String"/></f></get_TypeName>
		<set_TypeName public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_TypeName>
		<CanCastTo public="1" set="method"><f a="fromType:o">
	<c path="cs.system.Type"/>
	<d/>
	<x path="Bool"/>
</f></CanCastTo>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.IRemotingTypeInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.ObjRef" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.ObjRef" extern="1">
		<implements path="cs.system.runtime.serialization.IObjectReference"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<URI public="1" get="accessor" set="accessor"><c path="String"/></URI>
		<TypeInfo public="1" get="accessor" set="accessor"><c path="cs.system.runtime.remoting.IRemotingTypeInfo"/></TypeInfo>
		<EnvoyInfo public="1" get="accessor" set="accessor"><c path="cs.system.runtime.remoting.IEnvoyInfo"/></EnvoyInfo>
		<ChannelInfo public="1" get="accessor" set="accessor"><c path="cs.system.runtime.remoting.IChannelInfo"/></ChannelInfo>
		<get_ChannelInfo public="1" set="method"><f a=""><c path="cs.system.runtime.remoting.IChannelInfo"/></f></get_ChannelInfo>
		<set_ChannelInfo public="1" set="method"><f a="value">
	<c path="cs.system.runtime.remoting.IChannelInfo"/>
	<c path="cs.system.runtime.remoting.IChannelInfo"/>
</f></set_ChannelInfo>
		<get_EnvoyInfo public="1" set="method"><f a=""><c path="cs.system.runtime.remoting.IEnvoyInfo"/></f></get_EnvoyInfo>
		<set_EnvoyInfo public="1" set="method"><f a="value">
	<c path="cs.system.runtime.remoting.IEnvoyInfo"/>
	<c path="cs.system.runtime.remoting.IEnvoyInfo"/>
</f></set_EnvoyInfo>
		<get_TypeInfo public="1" set="method"><f a=""><c path="cs.system.runtime.remoting.IRemotingTypeInfo"/></f></get_TypeInfo>
		<set_TypeInfo public="1" set="method"><f a="value">
	<c path="cs.system.runtime.remoting.IRemotingTypeInfo"/>
	<c path="cs.system.runtime.remoting.IRemotingTypeInfo"/>
</f></set_TypeInfo>
		<get_URI public="1" set="method"><f a=""><c path="String"/></f></get_URI>
		<set_URI public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_URI>
		<GetObjectData public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<GetRealObject public="1" set="method"><f a="context">
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<d/>
</f></GetRealObject>
		<IsFromThisAppDomain final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsFromThisAppDomain>
		<IsFromThisProcess final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsFromThisProcess>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" set="method">
					<f a="info:context">
						<c path="cs.system.runtime.serialization.SerializationInfo"/>
						<c path="cs.system.runtime.serialization.StreamingContext"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" public="1" set="method"><f a="o:requestedType">
	<c path="cs.system.MarshalByRefObject"/>
	<c path="cs.system.Type"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.ObjRef"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.ObjectHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.ObjectHandle" extern="1">
		<extends path="cs.system.MarshalByRefObject"/>
		<implements path="cs.system.runtime.remoting.IObjectHandle"/>
		<InitializeLifetimeService public="1" set="method" override="1"><f a=""><d/></f></InitializeLifetimeService>
		<Unwrap final="1" public="1" set="method"><f a=""><d/></f></Unwrap>
		<new final="1" public="1" set="method"><f a="o">
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.ObjectHandle"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.contexts.Context_NamedSlots" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.contexts.Context" module="cs.system.runtime.remoting.contexts.Context" extern="1">
		<namedSlots public="1" static="1"><c path="cs.system.collections.Hashtable"/></namedSlots>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.Contexts.Context.NamedSlots"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.contexts.Context" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.contexts.Context" extern="1">
		<DefaultContext public="1" get="accessor" set="null" static="1"><c path="cs.system.runtime.remoting.contexts.Context"/></DefaultContext>
		<get_DefaultContext public="1" set="method" static="1"><f a=""><c path="cs.system.runtime.remoting.contexts.Context"/></f></get_DefaultContext>
		<RegisterDynamicProperty public="1" set="method" static="1"><f a="prop:obj:ctx">
	<c path="cs.system.runtime.remoting.contexts.IDynamicProperty"/>
	<c path="cs.system.ContextBoundObject"/>
	<c path="cs.system.runtime.remoting.contexts.Context"/>
	<x path="Bool"/>
</f></RegisterDynamicProperty>
		<UnregisterDynamicProperty public="1" set="method" static="1"><f a="name:obj:ctx">
	<c path="String"/>
	<c path="cs.system.ContextBoundObject"/>
	<c path="cs.system.runtime.remoting.contexts.Context"/>
	<x path="Bool"/>
</f></UnregisterDynamicProperty>
		<AllocateDataSlot public="1" set="method" static="1"><f a=""><c path="cs.system.LocalDataStoreSlot"/></f></AllocateDataSlot>
		<AllocateNamedDataSlot public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<c path="cs.system.LocalDataStoreSlot"/>
</f></AllocateNamedDataSlot>
		<FreeNamedDataSlot public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></FreeNamedDataSlot>
		<GetData public="1" set="method" static="1"><f a="slot">
	<c path="cs.system.LocalDataStoreSlot"/>
	<d/>
</f></GetData>
		<GetNamedDataSlot public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<c path="cs.system.LocalDataStoreSlot"/>
</f></GetNamedDataSlot>
		<SetData public="1" set="method" static="1"><f a="slot:data">
	<c path="cs.system.LocalDataStoreSlot"/>
	<d/>
	<x path="Void"/>
</f></SetData>
		<ContextProperties public="1" get="accessor" set="null"><c path="cs.NativeArray"><c path="cs.system.runtime.remoting.contexts.IContextProperty"/></c></ContextProperties>
		<ContextID public="1" get="accessor" set="null"><x path="Int"/></ContextID>
		<get_ContextID public="1" set="method"><f a=""><x path="Int"/></f></get_ContextID>
		<get_ContextProperties public="1" set="method"><f a=""><c path="cs.NativeArray"><c path="cs.system.runtime.remoting.contexts.IContextProperty"/></c></f></get_ContextProperties>
		<GetProperty public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.runtime.remoting.contexts.IContextProperty"/>
</f></GetProperty>
		<SetProperty public="1" set="method"><f a="prop">
	<c path="cs.system.runtime.remoting.contexts.IContextProperty"/>
	<x path="Void"/>
</f></SetProperty>
		<Freeze public="1" set="method"><f a=""><x path="Void"/></f></Freeze>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<DoCallBack final="1" public="1" set="method"><f a="deleg">
	<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
	<x path="Void"/>
</f></DoCallBack>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.Contexts.Context"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.contexts.Delegate_CrossContextDelegate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.contexts.CrossContextDelegate" module="cs.system.runtime.remoting.contexts.CrossContextDelegate" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
	<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
	<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
	<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
	<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a=""><x path="Void"/></f></Invoke>
		<BeginInvoke public="1" set="method"><f a="callback:object">
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.Contexts.CrossContextDelegate"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.runtime.remoting.contexts.CrossContextDelegate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.contexts.CrossContextDelegate">
		<from><icast field="FromHaxeFunction"><f a=""><x path="Void"/></f></icast></from>
		<this><c path="cs.system.runtime.remoting.contexts.Delegate_CrossContextDelegate"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.runtime.remoting.contexts._CrossContextDelegate.CrossContextDelegate_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.contexts.CrossContextDelegate" private="1" module="cs.system.runtime.remoting.contexts.CrossContextDelegate" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=""><x path="Void"/></f>
			<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=""><x path="Void"/></f>
			<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.runtime.remoting.contexts.Delegate_CrossContextDelegate"/>
	<c path="cs.system.runtime.remoting.contexts.Delegate_CrossContextDelegate"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
			<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
			<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
			<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
			<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.runtime.remoting.contexts._CrossContextDelegate.CrossContextDelegate_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.contexts.CrossContextDelegate" private="1" module="cs.system.runtime.remoting.contexts.CrossContextDelegate" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=""><x path="Void"/></f>
				<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=""><x path="Void"/></f>
				<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.runtime.remoting.contexts.Delegate_CrossContextDelegate"/>
	<c path="cs.system.runtime.remoting.contexts.Delegate_CrossContextDelegate"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
				<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
				<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
				<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
				<x path="cs.system.runtime.remoting.contexts.CrossContextDelegate"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.runtime.remoting.contexts.IContextProperty" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.contexts.IContextProperty" extern="1" interface="1">
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<Freeze public="1" set="method"><f a="newContext">
	<c path="cs.system.runtime.remoting.contexts.Context"/>
	<x path="Void"/>
</f></Freeze>
		<IsNewContextOK public="1" set="method"><f a="newCtx">
	<c path="cs.system.runtime.remoting.contexts.Context"/>
	<x path="Bool"/>
</f></IsNewContextOK>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.Contexts.IContextProperty"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.contexts.IDynamicProperty" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.contexts.IDynamicProperty" extern="1" interface="1">
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.Contexts.IDynamicProperty"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.messaging.IMessage" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.messaging.IMessage" extern="1" interface="1">
		<Properties public="1" get="accessor" set="null"><c path="cs.system.collections.IDictionary"/></Properties>
		<get_Properties public="1" set="method"><f a=""><c path="cs.system.collections.IDictionary"/></f></get_Properties>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.Messaging.IMessage"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.messaging.IMessageCtrl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.messaging.IMessageCtrl" extern="1" interface="1">
		<Cancel public="1" set="method"><f a="msToCancel">
	<x path="Int"/>
	<x path="Void"/>
</f></Cancel>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.Messaging.IMessageCtrl"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.remoting.messaging.IMessageSink" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.remoting.messaging.IMessageSink" extern="1" interface="1">
		<NextSink public="1" get="accessor" set="null"><c path="cs.system.runtime.remoting.messaging.IMessageSink"/></NextSink>
		<SyncProcessMessage public="1" set="method"><f a="msg">
	<c path="cs.system.runtime.remoting.messaging.IMessage"/>
	<c path="cs.system.runtime.remoting.messaging.IMessage"/>
</f></SyncProcessMessage>
		<AsyncProcessMessage public="1" set="method"><f a="msg:replySink">
	<c path="cs.system.runtime.remoting.messaging.IMessage"/>
	<c path="cs.system.runtime.remoting.messaging.IMessageSink"/>
	<c path="cs.system.runtime.remoting.messaging.IMessageCtrl"/>
</f></AsyncProcessMessage>
		<get_NextSink public="1" set="method"><f a=""><c path="cs.system.runtime.remoting.messaging.IMessageSink"/></f></get_NextSink>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Remoting.Messaging.IMessageSink"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.serialization.IFormatterConverter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.serialization.IFormatterConverter" extern="1" interface="1">
		<Convert public="1" set="method">
			<f a="value:type">
				<d/>
				<c path="cs.system.Type"/>
				<d/>
			</f>
			<overloads><Convert public="1" set="method"><f a="value:typeCode">
	<d/>
	<e path="cs.system.TypeCode"/>
	<d/>
</f></Convert></overloads>
		</Convert>
		<ToBoolean public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></ToBoolean>
		<ToByte public="1" set="method"><f a="value">
	<d/>
	<t path="cs.types.UInt8"/>
</f></ToByte>
		<ToChar public="1" set="method"><f a="value">
	<d/>
	<t path="cs.types.Char16"/>
</f></ToChar>
		<ToDateTime public="1" set="method"><f a="value">
	<d/>
	<c path="cs.system.DateTime"/>
</f></ToDateTime>
		<ToDecimal public="1" set="method"><f a="value">
	<d/>
	<c path="cs.system.Decimal"/>
</f></ToDecimal>
		<ToDouble public="1" set="method"><f a="value">
	<d/>
	<x path="Float"/>
</f></ToDouble>
		<ToInt16 public="1" set="method"><f a="value">
	<d/>
	<t path="cs.types.Int16"/>
</f></ToInt16>
		<ToInt32 public="1" set="method"><f a="value">
	<d/>
	<x path="Int"/>
</f></ToInt32>
		<ToInt64 public="1" set="method"><f a="value">
	<d/>
	<x path="haxe.Int64"/>
</f></ToInt64>
		<ToSByte public="1" set="method"><f a="value">
	<d/>
	<t path="cs.types.Int8"/>
</f></ToSByte>
		<ToSingle public="1" set="method"><f a="value">
	<d/>
	<x path="Single"/>
</f></ToSingle>
		<ToString public="1" set="method"><f a="value">
	<d/>
	<c path="String"/>
</f></ToString>
		<ToUInt16 public="1" set="method"><f a="value">
	<d/>
	<t path="cs.types.UInt16"/>
</f></ToUInt16>
		<ToUInt32 public="1" set="method"><f a="value">
	<d/>
	<x path="UInt"/>
</f></ToUInt32>
		<ToUInt64 public="1" set="method"><f a="value">
	<d/>
	<t path="cs.types.UInt64"/>
</f></ToUInt64>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Serialization.IFormatterConverter"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.serialization.SerializationEntry" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.serialization.SerializationEntry" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<Value public="1" get="accessor" set="null"><d/></Value>
		<ObjectType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ObjectType>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_ObjectType final="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ObjectType>
		<get_Value final="1" public="1" set="method"><f a=""><d/></f></get_Value>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Serialization.SerializationEntry"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.serialization.SerializationInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.serialization.SerializationInfo" extern="1" final="1">
		<MemberCount public="1" get="accessor" set="null"><x path="Int"/></MemberCount>
		<FullTypeName public="1" get="accessor" set="accessor"><c path="String"/></FullTypeName>
		<AssemblyName public="1" get="accessor" set="accessor"><c path="String"/></AssemblyName>
		<get_AssemblyName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_AssemblyName>
		<set_AssemblyName final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_AssemblyName>
		<get_FullTypeName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_FullTypeName>
		<set_FullTypeName final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_FullTypeName>
		<get_MemberCount final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_MemberCount>
		<AddValue final="1" public="1" set="method">
			<f a="name:value:type">
				<c path="String"/>
				<d/>
				<c path="cs.system.Type"/>
				<x path="Void"/>
			</f>
			<overloads>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<t path="cs.types.UInt64"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<x path="Single"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="cs.system.Decimal"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<t path="cs.types.Int8"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<t path="cs.types.Char16"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<t path="cs.types.UInt8"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<t path="cs.types.UInt16"/>
	<x path="Void"/>
</f></AddValue>
				<AddValue final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<t path="cs.types.Int16"/>
	<x path="Void"/>
</f></AddValue>
			</overloads>
		</AddValue>
		<GetValue final="1" public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="cs.system.Type"/>
	<d/>
</f></GetValue>
		<SetType final="1" public="1" set="method"><f a="type">
	<c path="cs.system.Type"/>
	<x path="Void"/>
</f></SetType>
		<GetEnumerator final="1" public="1" set="method"><f a=""><c path="cs.system.runtime.serialization.SerializationInfoEnumerator"/></f></GetEnumerator>
		<GetBoolean final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></GetBoolean>
		<GetByte final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="cs.types.UInt8"/>
</f></GetByte>
		<GetChar final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="cs.types.Char16"/>
</f></GetChar>
		<GetDateTime final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.DateTime"/>
</f></GetDateTime>
		<GetDecimal final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.Decimal"/>
</f></GetDecimal>
		<GetDouble final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Float"/>
</f></GetDouble>
		<GetInt16 final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="cs.types.Int16"/>
</f></GetInt16>
		<GetInt32 final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Int"/>
</f></GetInt32>
		<GetInt64 final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="haxe.Int64"/>
</f></GetInt64>
		<GetSByte final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="cs.types.Int8"/>
</f></GetSByte>
		<GetSingle final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Single"/>
</f></GetSingle>
		<GetString final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></GetString>
		<GetUInt16 final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="cs.types.UInt16"/>
</f></GetUInt16>
		<GetUInt32 final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="UInt"/>
</f></GetUInt32>
		<GetUInt64 final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="cs.types.UInt64"/>
</f></GetUInt64>
		<new final="1" public="1" set="method"><f a="type:converter">
	<c path="cs.system.Type"/>
	<c path="cs.system.runtime.serialization.IFormatterConverter"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Serialization.SerializationInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.serialization.SerializationInfoEnumerator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.serialization.SerializationInfoEnumerator" extern="1" final="1">
		<implements path="cs.system.collections.IEnumerator"/>
		<Value public="1" get="accessor" set="null"><d/></Value>
		<ObjectType public="1" get="accessor" set="null"><c path="cs.system.Type"/></ObjectType>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<Current public="1" get="accessor" set="null">
			<c path="cs.system.runtime.serialization.SerializationEntry"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</Current>
		<get_Current final="1" public="1" set="method">
			<f a=""><c path="cs.system.runtime.serialization.SerializationEntry"/></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</get_Current>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_ObjectType final="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_ObjectType>
		<get_Value final="1" public="1" set="method"><f a=""><d/></f></get_Value>
		<MoveNext final="1" public="1" set="method"><f a=""><x path="Bool"/></f></MoveNext>
		<Reset final="1" public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Serialization.SerializationInfoEnumerator"</e></m>
		</meta>
	</class>
	<class path="cs.system.runtime.serialization.StreamingContext" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.serialization.StreamingContext" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<State public="1" get="accessor" set="null"><e path="cs.system.runtime.serialization.StreamingContextStates"/></State>
		<Context public="1" get="accessor" set="null"><d/></Context>
		<get_Context final="1" public="1" set="method"><f a=""><d/></f></get_Context>
		<get_State final="1" public="1" set="method"><f a=""><e path="cs.system.runtime.serialization.StreamingContextStates"/></f></get_State>
		<new final="1" public="1" set="method">
			<f a="state">
				<e path="cs.system.runtime.serialization.StreamingContextStates"/>
				<x path="Void"/>
			</f>
			<overloads><new final="1" public="1" set="method"><f a="state:additional">
	<e path="cs.system.runtime.serialization.StreamingContextStates"/>
	<d/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Runtime.Serialization.StreamingContext"</e></m>
		</meta>
	</class>
	<enum path="cs.system.runtime.serialization.StreamingContextStates" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.runtime.serialization.StreamingContextStates">
		<CrossProcess><meta><m n=":csNative"><e>1</e></m></meta></CrossProcess>
		<CrossMachine><meta><m n=":csNative"><e>2</e></m></meta></CrossMachine>
		<File><meta><m n=":csNative"><e>4</e></m></meta></File>
		<Persistence><meta><m n=":csNative"><e>8</e></m></meta></Persistence>
		<Remoting><meta><m n=":csNative"><e>16</e></m></meta></Remoting>
		<Other><meta><m n=":csNative"><e>32</e></m></meta></Other>
		<Clone><meta><m n=":csNative"><e>64</e></m></meta></Clone>
		<CrossAppDomain><meta><m n=":csNative"><e>128</e></m></meta></CrossAppDomain>
		<All><meta><m n=":csNative"><e>255</e></m></meta></All>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Runtime.Serialization.StreamingContextStates"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.security.HostSecurityManager" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.HostSecurityManager" extern="1">
		<Flags public="1" get="accessor" set="null"><e path="cs.system.security.HostSecurityManagerOptions"/></Flags>
		<DomainPolicy public="1" get="accessor" set="null"><c path="cs.system.security.policy.PolicyLevel"/></DomainPolicy>
		<get_DomainPolicy public="1" set="method"><f a=""><c path="cs.system.security.policy.PolicyLevel"/></f></get_DomainPolicy>
		<get_Flags public="1" set="method"><f a=""><e path="cs.system.security.HostSecurityManagerOptions"/></f></get_Flags>
		<DetermineApplicationTrust public="1" set="method"><f a="applicationEvidence:activatorEvidence:context">
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.policy.TrustManagerContext"/>
	<c path="cs.system.security.policy.ApplicationTrust"/>
</f></DetermineApplicationTrust>
		<ProvideAppDomainEvidence public="1" set="method"><f a="inputEvidence">
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.policy.Evidence"/>
</f></ProvideAppDomainEvidence>
		<ProvideAssemblyEvidence public="1" set="method"><f a="loadedAssembly:inputEvidence">
	<c path="cs.system.reflection.Assembly"/>
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.policy.Evidence"/>
</f></ProvideAssemblyEvidence>
		<ResolvePolicy public="1" set="method"><f a="evidence">
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.PermissionSet"/>
</f></ResolvePolicy>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.HostSecurityManager"</e></m>
		</meta>
	</class>
	<enum path="cs.system.security.HostSecurityManagerOptions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.HostSecurityManagerOptions">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<HostAppDomainEvidence><meta><m n=":csNative"><e>1</e></m></meta></HostAppDomainEvidence>
		<HostPolicyLevel><meta><m n=":csNative"><e>2</e></m></meta></HostPolicyLevel>
		<HostAssemblyEvidence><meta><m n=":csNative"><e>4</e></m></meta></HostAssemblyEvidence>
		<HostDetermineApplicationTrust><meta><m n=":csNative"><e>8</e></m></meta></HostDetermineApplicationTrust>
		<HostResolvePolicy><meta><m n=":csNative"><e>16</e></m></meta></HostResolvePolicy>
		<AllFlags><meta><m n=":csNative"><e>31</e></m></meta></AllFlags>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.HostSecurityManagerOptions"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.security.ISecurityEncodable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.ISecurityEncodable" extern="1" interface="1">
		<FromXml public="1" set="method"><f a="e">
	<c path="cs.system.security.SecurityElement"/>
	<x path="Void"/>
</f></FromXml>
		<ToXml public="1" set="method"><f a=""><c path="cs.system.security.SecurityElement"/></f></ToXml>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.ISecurityEncodable"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.IPermission" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.IPermission" extern="1" interface="1">
		<extends path="cs.system.security.ISecurityEncodable"/>
		<Copy public="1" set="method"><f a=""><c path="cs.system.security.IPermission"/></f></Copy>
		<Demand public="1" set="method"><f a=""><x path="Void"/></f></Demand>
		<Intersect public="1" set="method"><f a="target">
	<c path="cs.system.security.IPermission"/>
	<c path="cs.system.security.IPermission"/>
</f></Intersect>
		<IsSubsetOf public="1" set="method"><f a="target">
	<c path="cs.system.security.IPermission"/>
	<x path="Bool"/>
</f></IsSubsetOf>
		<Union public="1" set="method"><f a="target">
	<c path="cs.system.security.IPermission"/>
	<c path="cs.system.security.IPermission"/>
</f></Union>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.IPermission"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.ISecurityPolicyEncodable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.ISecurityPolicyEncodable" extern="1" interface="1">
		<FromXml public="1" set="method"><f a="e:level">
	<c path="cs.system.security.SecurityElement"/>
	<c path="cs.system.security.policy.PolicyLevel"/>
	<x path="Void"/>
</f></FromXml>
		<ToXml public="1" set="method"><f a="level">
	<c path="cs.system.security.policy.PolicyLevel"/>
	<c path="cs.system.security.SecurityElement"/>
</f></ToXml>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.ISecurityPolicyEncodable"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.IStackWalk" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.IStackWalk" extern="1" interface="1">
		<Assert public="1" set="method"><f a=""><x path="Void"/></f></Assert>
		<Demand public="1" set="method"><f a=""><x path="Void"/></f></Demand>
		<Deny public="1" set="method"><f a=""><x path="Void"/></f></Deny>
		<PermitOnly public="1" set="method"><f a=""><x path="Void"/></f></PermitOnly>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.IStackWalk"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.PermissionSet" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.PermissionSet" extern="1">
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<implements path="cs.system.runtime.serialization.IDeserializationCallback"/>
		<implements path="cs.system.security.ISecurityEncodable"/>
		<implements path="cs.system.security.IStackWalk"/>
		<ConvertPermissionSet public="1" set="method" static="1"><f a="inFormat:inData:outFormat">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></ConvertPermissionSet>
		<RevertAssert public="1" set="method" static="1"><f a=""><x path="Void"/></f></RevertAssert>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<AddPermission final="1" public="1" set="method"><f a="perm">
	<c path="cs.system.security.IPermission"/>
	<c path="cs.system.security.IPermission"/>
</f></AddPermission>
		<Assert final="1" public="1" set="method"><f a=""><x path="Void"/></f></Assert>
		<Copy public="1" set="method"><f a=""><c path="cs.system.security.PermissionSet"/></f></Copy>
		<CopyTo public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<Demand final="1" public="1" set="method"><f a=""><x path="Void"/></f></Demand>
		<Deny final="1" public="1" set="method"><f a=""><x path="Void"/></f></Deny>
		<FromXml public="1" set="method"><f a="et">
	<c path="cs.system.security.SecurityElement"/>
	<x path="Void"/>
</f></FromXml>
		<GetEnumerator final="1" public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<IsSubsetOf final="1" public="1" set="method"><f a="target">
	<c path="cs.system.security.PermissionSet"/>
	<x path="Bool"/>
</f></IsSubsetOf>
		<PermitOnly final="1" public="1" set="method"><f a=""><x path="Void"/></f></PermitOnly>
		<ContainsNonCodeAccessPermissions final="1" public="1" set="method"><f a=""><x path="Bool"/></f></ContainsNonCodeAccessPermissions>
		<GetPermission final="1" public="1" set="method"><f a="permClass">
	<c path="cs.system.Type"/>
	<c path="cs.system.security.IPermission"/>
</f></GetPermission>
		<Intersect final="1" public="1" set="method"><f a="other">
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
</f></Intersect>
		<IsEmpty final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsEmpty>
		<IsUnrestricted final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsUnrestricted>
		<RemovePermission final="1" public="1" set="method"><f a="permClass">
	<c path="cs.system.Type"/>
	<c path="cs.system.security.IPermission"/>
</f></RemovePermission>
		<SetPermission final="1" public="1" set="method"><f a="perm">
	<c path="cs.system.security.IPermission"/>
	<c path="cs.system.security.IPermission"/>
</f></SetPermission>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<ToXml public="1" set="method"><f a=""><c path="cs.system.security.SecurityElement"/></f></ToXml>
		<Union final="1" public="1" set="method"><f a="other">
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
</f></Union>
		<get_Count public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_IsSynchronized public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_IsReadOnly public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_SyncRoot public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<new final="1" public="1" set="method">
			<f a="state">
				<e path="cs.system.security.permissions.PermissionState"/>
				<x path="Void"/>
			</f>
			<overloads><new final="1" public="1" set="method"><f a="permSet">
	<c path="cs.system.security.PermissionSet"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.PermissionSet"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.NamedPermissionSet" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.NamedPermissionSet" extern="1" final="1">
		<extends path="cs.system.security.PermissionSet"/>
		<Name public="1" get="accessor" set="accessor"><c path="String"/></Name>
		<Description public="1" get="accessor" set="accessor"><c path="String"/></Description>
		<get_Description final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Description>
		<set_Description final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Description>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<set_Name final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Name>
		<Copy public="1" set="method" override="1">
			<f a=""><c path="cs.system.security.PermissionSet"/></f>
			<overloads><Copy final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.security.NamedPermissionSet"/>
</f></Copy></overloads>
		</Copy>
		<FromXml public="1" set="method" override="1"><f a="et">
	<c path="cs.system.security.SecurityElement"/>
	<x path="Void"/>
</f></FromXml>
		<ToXml public="1" set="method" override="1"><f a=""><c path="cs.system.security.SecurityElement"/></f></ToXml>
		<new final="1" public="1" set="method">
			<f a="name:permSet">
				<c path="String"/>
				<c path="cs.system.security.PermissionSet"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="permSet">
	<c path="cs.system.security.NamedPermissionSet"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="name:state">
	<c path="String"/>
	<e path="cs.system.security.permissions.PermissionState"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.NamedPermissionSet"</e></m>
		</meta>
	</class>
	<enum path="cs.system.security.PolicyLevelType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.PolicyLevelType">
		<User><meta><m n=":csNative"><e>0</e></m></meta></User>
		<Machine><meta><m n=":csNative"><e>1</e></m></meta></Machine>
		<Enterprise><meta><m n=":csNative"><e>2</e></m></meta></Enterprise>
		<AppDomain><meta><m n=":csNative"><e>3</e></m></meta></AppDomain>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.PolicyLevelType"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.security.SecureString" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.SecureString" extern="1" final="1">
		<extends path="cs.system.runtime.constrainedexecution.CriticalFinalizerObject"/>
		<implements path="cs.system.IDisposable"/>
		<Length public="1" get="accessor" set="null"><x path="Int"/></Length>
		<get_Length final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Length>
		<AppendChar final="1" public="1" set="method"><f a="c">
	<t path="cs.types.Char16"/>
	<x path="Void"/>
</f></AppendChar>
		<Clear final="1" public="1" set="method"><f a=""><x path="Void"/></f></Clear>
		<Copy final="1" public="1" set="method"><f a=""><c path="cs.system.security.SecureString"/></f></Copy>
		<Dispose final="1" public="1" set="method"><f a=""><x path="Void"/></f></Dispose>
		<InsertAt final="1" public="1" set="method"><f a="index:c">
	<x path="Int"/>
	<t path="cs.types.Char16"/>
	<x path="Void"/>
</f></InsertAt>
		<IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsReadOnly>
		<MakeReadOnly final="1" public="1" set="method"><f a=""><x path="Void"/></f></MakeReadOnly>
		<RemoveAt final="1" public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></RemoveAt>
		<SetAt final="1" public="1" set="method"><f a="index:c">
	<x path="Int"/>
	<t path="cs.types.Char16"/>
	<x path="Void"/>
</f></SetAt>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.SecureString"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.SecurityElement_SecurityAttribute" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.SecurityElement" module="cs.system.security.SecurityElement" extern="1">
		<Value public="1" get="accessor" set="null"><c path="String"/></Value>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_Value final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Value>
		<new final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.SecurityElement.SecurityAttribute"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.SecurityElement" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.SecurityElement" extern="1" final="1">
		<Escape public="1" set="method" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></Escape>
		<FromString public="1" set="method" static="1"><f a="xml">
	<c path="String"/>
	<c path="cs.system.security.SecurityElement"/>
</f></FromString>
		<IsValidAttributeName public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></IsValidAttributeName>
		<IsValidAttributeValue public="1" set="method" static="1"><f a="value">
	<c path="String"/>
	<x path="Bool"/>
</f></IsValidAttributeValue>
		<IsValidTag public="1" set="method" static="1"><f a="tag">
	<c path="String"/>
	<x path="Bool"/>
</f></IsValidTag>
		<IsValidText public="1" set="method" static="1"><f a="text">
	<c path="String"/>
	<x path="Bool"/>
</f></IsValidText>
		<Text public="1" get="accessor" set="accessor"><c path="String"/></Text>
		<Tag public="1" get="accessor" set="accessor"><c path="String"/></Tag>
		<Children public="1" get="accessor" set="accessor"><c path="cs.system.collections.ArrayList"/></Children>
		<Attributes public="1" get="accessor" set="accessor"><c path="cs.system.collections.Hashtable"/></Attributes>
		<get_Attributes final="1" public="1" set="method"><f a=""><c path="cs.system.collections.Hashtable"/></f></get_Attributes>
		<set_Attributes final="1" public="1" set="method"><f a="value">
	<c path="cs.system.collections.Hashtable"/>
	<c path="cs.system.collections.Hashtable"/>
</f></set_Attributes>
		<get_Children final="1" public="1" set="method"><f a=""><c path="cs.system.collections.ArrayList"/></f></get_Children>
		<set_Children final="1" public="1" set="method"><f a="value">
	<c path="cs.system.collections.ArrayList"/>
	<c path="cs.system.collections.ArrayList"/>
</f></set_Children>
		<get_Tag final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Tag>
		<set_Tag final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Tag>
		<get_Text final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Text>
		<set_Text final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Text>
		<AddAttribute final="1" public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></AddAttribute>
		<AddChild final="1" public="1" set="method"><f a="child">
	<c path="cs.system.security.SecurityElement"/>
	<x path="Void"/>
</f></AddChild>
		<Attribute final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></Attribute>
		<Copy final="1" public="1" set="method"><f a=""><c path="cs.system.security.SecurityElement"/></f></Copy>
		<Equal final="1" public="1" set="method"><f a="other">
	<c path="cs.system.security.SecurityElement"/>
	<x path="Bool"/>
</f></Equal>
		<SearchForChildByTag final="1" public="1" set="method"><f a="tag">
	<c path="String"/>
	<c path="cs.system.security.SecurityElement"/>
</f></SearchForChildByTag>
		<SearchForTextOfTag final="1" public="1" set="method"><f a="tag">
	<c path="String"/>
	<c path="String"/>
</f></SearchForTextOfTag>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<new final="1" public="1" set="method">
			<f a="tag">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><new final="1" public="1" set="method"><f a="tag:text">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.SecurityElement"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.SecurityState" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.SecurityState" extern="1" abstract="1">
		<EnsureState abstract="1" public="1" set="method"><f a=""><x path="Void"/></f></EnsureState>
		<IsStateAvailable final="1" public="1" set="method"><f a=""><x path="Bool"/></f></IsStateAvailable>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.SecurityState"</e></m>
		</meta>
	</class>
	<enum path="cs.system.security.accesscontrol.AccessControlModification" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.AccessControlModification">
		<Add><meta><m n=":csNative"><e>0</e></m></meta></Add>
		<Set><meta><m n=":csNative"><e>1</e></m></meta></Set>
		<Reset><meta><m n=":csNative"><e>2</e></m></meta></Reset>
		<Remove><meta><m n=":csNative"><e>3</e></m></meta></Remove>
		<RemoveAll><meta><m n=":csNative"><e>4</e></m></meta></RemoveAll>
		<RemoveSpecific><meta><m n=":csNative"><e>5</e></m></meta></RemoveSpecific>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.AccessControl.AccessControlModification"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.security.accesscontrol.AccessControlSections" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.AccessControlSections">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<Audit><meta><m n=":csNative"><e>1</e></m></meta></Audit>
		<Access><meta><m n=":csNative"><e>2</e></m></meta></Access>
		<Owner><meta><m n=":csNative"><e>4</e></m></meta></Owner>
		<Group><meta><m n=":csNative"><e>8</e></m></meta></Group>
		<All><meta><m n=":csNative"><e>15</e></m></meta></All>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.AccessControl.AccessControlSections"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.security.accesscontrol.AccessControlType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.AccessControlType">
		<Allow><meta><m n=":csNative"><e>0</e></m></meta></Allow>
		<Deny><meta><m n=":csNative"><e>1</e></m></meta></Deny>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.AccessControl.AccessControlType"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.security.accesscontrol.AuthorizationRule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.AuthorizationRule" extern="1" abstract="1">
		<AccessMask get="null" set="null"><x path="Int"/></AccessMask>
		<PropagationFlags public="1" get="accessor" set="null"><e path="cs.system.security.accesscontrol.PropagationFlags"/></PropagationFlags>
		<IsInherited public="1" get="accessor" set="null"><x path="Bool"/></IsInherited>
		<InheritanceFlags public="1" get="accessor" set="null"><e path="cs.system.security.accesscontrol.InheritanceFlags"/></InheritanceFlags>
		<IdentityReference public="1" get="accessor" set="null"><c path="cs.system.security.principal.IdentityReference"/></IdentityReference>
		<get_IdentityReference final="1" public="1" set="method"><f a=""><c path="cs.system.security.principal.IdentityReference"/></f></get_IdentityReference>
		<get_InheritanceFlags final="1" public="1" set="method"><f a=""><e path="cs.system.security.accesscontrol.InheritanceFlags"/></f></get_InheritanceFlags>
		<get_IsInherited final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsInherited>
		<get_PropagationFlags final="1" public="1" set="method"><f a=""><e path="cs.system.security.accesscontrol.PropagationFlags"/></f></get_PropagationFlags>
		<get_AccessMask final="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":protected"/></meta>
		</get_AccessMask>
		<new final="1" set="method">
			<f a="identity:accessMask:isInherited:inheritanceFlags:propagationFlags">
				<c path="cs.system.security.principal.IdentityReference"/>
				<x path="Int"/>
				<x path="Bool"/>
				<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
				<e path="cs.system.security.accesscontrol.PropagationFlags"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.AuthorizationRule"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.AccessRule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.AccessRule" extern="1" abstract="1">
		<extends path="cs.system.security.accesscontrol.AuthorizationRule"/>
		<AccessControlType public="1" get="accessor" set="null"><e path="cs.system.security.accesscontrol.AccessControlType"/></AccessControlType>
		<get_AccessControlType final="1" public="1" set="method"><f a=""><e path="cs.system.security.accesscontrol.AccessControlType"/></f></get_AccessControlType>
		<new final="1" set="method">
			<f a="identity:accessMask:isInherited:inheritanceFlags:propagationFlags:type">
				<c path="cs.system.security.principal.IdentityReference"/>
				<x path="Int"/>
				<x path="Bool"/>
				<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
				<e path="cs.system.security.accesscontrol.PropagationFlags"/>
				<e path="cs.system.security.accesscontrol.AccessControlType"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.AccessRule"</e></m>
		</meta>
	</class>
	<enum path="cs.system.security.accesscontrol.AuditFlags" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.AuditFlags">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<Success><meta><m n=":csNative"><e>1</e></m></meta></Success>
		<Failure><meta><m n=":csNative"><e>2</e></m></meta></Failure>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.AccessControl.AuditFlags"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.security.accesscontrol.AuditRule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.AuditRule" extern="1" abstract="1">
		<extends path="cs.system.security.accesscontrol.AuthorizationRule"/>
		<AuditFlags public="1" get="accessor" set="null"><e path="cs.system.security.accesscontrol.AuditFlags"/></AuditFlags>
		<get_AuditFlags final="1" public="1" set="method"><f a=""><e path="cs.system.security.accesscontrol.AuditFlags"/></f></get_AuditFlags>
		<new final="1" set="method">
			<f a="identity:accessMask:isInherited:inheritanceFlags:propagationFlags:auditFlags">
				<c path="cs.system.security.principal.IdentityReference"/>
				<x path="Int"/>
				<x path="Bool"/>
				<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
				<e path="cs.system.security.accesscontrol.PropagationFlags"/>
				<e path="cs.system.security.accesscontrol.AuditFlags"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.AuditRule"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.AuthorizationRuleCollection" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.AuthorizationRuleCollection" extern="1" final="1">
		<extends path="cs.system.collections.ReadOnlyCollectionBase"/>
		<get_Item final="1" public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="cs.system.security.accesscontrol.AuthorizationRule"/>
</f></get_Item>
		<CopyTo final="1" public="1" set="method"><f a="rules:index">
	<c path="cs.NativeArray"><c path="cs.system.security.accesscontrol.AuthorizationRule"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.AuthorizationRuleCollection"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.ObjectSecurity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.ObjectSecurity" extern="1" abstract="1">
		<IsSddlConversionSupported public="1" set="method" static="1"><f a=""><x path="Bool"/></f></IsSddlConversionSupported>
		<OwnerModified get="null" set="null"><x path="Bool"/></OwnerModified>
		<IsDS get="null" set="null"><x path="Bool"/></IsDS>
		<IsContainer get="null" set="null"><x path="Bool"/></IsContainer>
		<GroupModified get="null" set="null"><x path="Bool"/></GroupModified>
		<AuditRulesModified get="null" set="null"><x path="Bool"/></AuditRulesModified>
		<AccessRulesModified get="null" set="null"><x path="Bool"/></AccessRulesModified>
		<AreAuditRulesProtected public="1" get="accessor" set="null"><x path="Bool"/></AreAuditRulesProtected>
		<AreAuditRulesCanonical public="1" get="accessor" set="null"><x path="Bool"/></AreAuditRulesCanonical>
		<AreAccessRulesProtected public="1" get="accessor" set="null"><x path="Bool"/></AreAccessRulesProtected>
		<AreAccessRulesCanonical public="1" get="accessor" set="null"><x path="Bool"/></AreAccessRulesCanonical>
		<AuditRuleType public="1" get="accessor" set="null"><c path="cs.system.Type"/></AuditRuleType>
		<AccessRuleType public="1" get="accessor" set="null"><c path="cs.system.Type"/></AccessRuleType>
		<AccessRightType public="1" get="accessor" set="null"><c path="cs.system.Type"/></AccessRightType>
		<get_AccessRightType abstract="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_AccessRightType>
		<get_AccessRuleType abstract="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_AccessRuleType>
		<get_AuditRuleType abstract="1" public="1" set="method"><f a=""><c path="cs.system.Type"/></f></get_AuditRuleType>
		<get_AreAccessRulesCanonical final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_AreAccessRulesCanonical>
		<get_AreAccessRulesProtected final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_AreAccessRulesProtected>
		<get_AreAuditRulesCanonical final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_AreAuditRulesCanonical>
		<get_AreAuditRulesProtected final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_AreAuditRulesProtected>
		<get_AccessRulesModified final="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</get_AccessRulesModified>
		<set_AccessRulesModified final="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</set_AccessRulesModified>
		<get_AuditRulesModified final="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</get_AuditRulesModified>
		<set_AuditRulesModified final="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</set_AuditRulesModified>
		<get_GroupModified final="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</get_GroupModified>
		<set_GroupModified final="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</set_GroupModified>
		<get_IsContainer final="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</get_IsContainer>
		<get_IsDS final="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</get_IsDS>
		<get_OwnerModified final="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</get_OwnerModified>
		<set_OwnerModified final="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</set_OwnerModified>
		<AccessRuleFactory abstract="1" public="1" set="method"><f a="identityReference:accessMask:isInherited:inheritanceFlags:propagationFlags:type">
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Int"/>
	<x path="Bool"/>
	<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
	<e path="cs.system.security.accesscontrol.PropagationFlags"/>
	<e path="cs.system.security.accesscontrol.AccessControlType"/>
	<c path="cs.system.security.accesscontrol.AccessRule"/>
</f></AccessRuleFactory>
		<AuditRuleFactory abstract="1" public="1" set="method"><f a="identityReference:accessMask:isInherited:inheritanceFlags:propagationFlags:flags">
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Int"/>
	<x path="Bool"/>
	<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
	<e path="cs.system.security.accesscontrol.PropagationFlags"/>
	<e path="cs.system.security.accesscontrol.AuditFlags"/>
	<c path="cs.system.security.accesscontrol.AuditRule"/>
</f></AuditRuleFactory>
		<GetGroup final="1" public="1" set="method"><f a="targetType">
	<c path="cs.system.Type"/>
	<c path="cs.system.security.principal.IdentityReference"/>
</f></GetGroup>
		<GetOwner final="1" public="1" set="method"><f a="targetType">
	<c path="cs.system.Type"/>
	<c path="cs.system.security.principal.IdentityReference"/>
</f></GetOwner>
		<GetSecurityDescriptorBinaryForm final="1" public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetSecurityDescriptorBinaryForm>
		<GetSecurityDescriptorSddlForm final="1" public="1" set="method"><f a="includeSections">
	<e path="cs.system.security.accesscontrol.AccessControlSections"/>
	<c path="String"/>
</f></GetSecurityDescriptorSddlForm>
		<ModifyAccessRule public="1" set="method"><f a="modification:rule:modified">
	<e path="cs.system.security.accesscontrol.AccessControlModification"/>
	<c path="cs.system.security.accesscontrol.AccessRule"/>
	<t path="cs.Out"><x path="Bool"/></t>
	<x path="Bool"/>
</f></ModifyAccessRule>
		<ModifyAuditRule public="1" set="method"><f a="modification:rule:modified">
	<e path="cs.system.security.accesscontrol.AccessControlModification"/>
	<c path="cs.system.security.accesscontrol.AuditRule"/>
	<t path="cs.Out"><x path="Bool"/></t>
	<x path="Bool"/>
</f></ModifyAuditRule>
		<PurgeAccessRules public="1" set="method"><f a="identity">
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Void"/>
</f></PurgeAccessRules>
		<PurgeAuditRules public="1" set="method"><f a="identity">
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Void"/>
</f></PurgeAuditRules>
		<SetAccessRuleProtection final="1" public="1" set="method"><f a="isProtected:preserveInheritance">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></SetAccessRuleProtection>
		<SetAuditRuleProtection final="1" public="1" set="method"><f a="isProtected:preserveInheritance">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></SetAuditRuleProtection>
		<SetGroup final="1" public="1" set="method"><f a="identity">
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Void"/>
</f></SetGroup>
		<SetOwner final="1" public="1" set="method"><f a="identity">
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Void"/>
</f></SetOwner>
		<SetSecurityDescriptorBinaryForm final="1" public="1" set="method">
			<f a="binaryForm">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Void"/>
			</f>
			<overloads><SetSecurityDescriptorBinaryForm final="1" public="1" set="method"><f a="binaryForm:includeSections">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<e path="cs.system.security.accesscontrol.AccessControlSections"/>
	<x path="Void"/>
</f></SetSecurityDescriptorBinaryForm></overloads>
		</SetSecurityDescriptorBinaryForm>
		<SetSecurityDescriptorSddlForm final="1" public="1" set="method">
			<f a="sddlForm">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><SetSecurityDescriptorSddlForm final="1" public="1" set="method"><f a="sddlForm:includeSections">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.AccessControlSections"/>
	<x path="Void"/>
</f></SetSecurityDescriptorSddlForm></overloads>
		</SetSecurityDescriptorSddlForm>
		<ModifyAccess abstract="1" set="method">
			<f a="modification:rule:modified">
				<e path="cs.system.security.accesscontrol.AccessControlModification"/>
				<c path="cs.system.security.accesscontrol.AccessRule"/>
				<t path="cs.Out"><x path="Bool"/></t>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</ModifyAccess>
		<ModifyAudit abstract="1" set="method">
			<f a="modification:rule:modified">
				<e path="cs.system.security.accesscontrol.AccessControlModification"/>
				<c path="cs.system.security.accesscontrol.AuditRule"/>
				<t path="cs.Out"><x path="Bool"/></t>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</ModifyAudit>
		<Persist set="method">
			<f a="handle:includeSections">
				<c path="cs.system.runtime.interopservices.SafeHandle"/>
				<e path="cs.system.security.accesscontrol.AccessControlSections"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
			<overloads>
				<Persist set="method">
					<f a="enableOwnershipPrivilege:name:includeSections">
						<x path="Bool"/>
						<c path="String"/>
						<e path="cs.system.security.accesscontrol.AccessControlSections"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</Persist>
				<Persist set="method">
					<f a="name:includeSections">
						<c path="String"/>
						<e path="cs.system.security.accesscontrol.AccessControlSections"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</Persist>
			</overloads>
		</Persist>
		<ReadLock final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</ReadLock>
		<ReadUnlock final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</ReadUnlock>
		<WriteLock final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</WriteLock>
		<WriteUnlock final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</WriteUnlock>
		<new final="1" set="method">
			<f a="isContainer:isDS">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.ObjectSecurity"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.CommonObjectSecurity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.CommonObjectSecurity" extern="1" abstract="1">
		<extends path="cs.system.security.accesscontrol.ObjectSecurity"/>
		<GetAccessRules final="1" public="1" set="method"><f a="includeExplicit:includeInherited:targetType">
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.security.accesscontrol.AuthorizationRuleCollection"/>
</f></GetAccessRules>
		<GetAuditRules final="1" public="1" set="method"><f a="includeExplicit:includeInherited:targetType">
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="cs.system.Type"/>
	<c path="cs.system.security.accesscontrol.AuthorizationRuleCollection"/>
</f></GetAuditRules>
		<AddAccessRule final="1" set="method">
			<f a="rule">
				<c path="cs.system.security.accesscontrol.AccessRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</AddAccessRule>
		<RemoveAccessRule final="1" set="method">
			<f a="rule">
				<c path="cs.system.security.accesscontrol.AccessRule"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</RemoveAccessRule>
		<RemoveAccessRuleAll final="1" set="method">
			<f a="rule">
				<c path="cs.system.security.accesscontrol.AccessRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</RemoveAccessRuleAll>
		<RemoveAccessRuleSpecific final="1" set="method">
			<f a="rule">
				<c path="cs.system.security.accesscontrol.AccessRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</RemoveAccessRuleSpecific>
		<ResetAccessRule final="1" set="method">
			<f a="rule">
				<c path="cs.system.security.accesscontrol.AccessRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</ResetAccessRule>
		<SetAccessRule final="1" set="method">
			<f a="rule">
				<c path="cs.system.security.accesscontrol.AccessRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</SetAccessRule>
		<ModifyAccess set="method" override="1">
			<f a="modification:rule:modified">
				<e path="cs.system.security.accesscontrol.AccessControlModification"/>
				<c path="cs.system.security.accesscontrol.AccessRule"/>
				<t path="cs.Out"><x path="Bool"/></t>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</ModifyAccess>
		<AddAuditRule final="1" set="method">
			<f a="rule">
				<c path="cs.system.security.accesscontrol.AuditRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</AddAuditRule>
		<RemoveAuditRule final="1" set="method">
			<f a="rule">
				<c path="cs.system.security.accesscontrol.AuditRule"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</RemoveAuditRule>
		<RemoveAuditRuleAll final="1" set="method">
			<f a="rule">
				<c path="cs.system.security.accesscontrol.AuditRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</RemoveAuditRuleAll>
		<RemoveAuditRuleSpecific final="1" set="method">
			<f a="rule">
				<c path="cs.system.security.accesscontrol.AuditRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</RemoveAuditRuleSpecific>
		<SetAuditRule final="1" set="method">
			<f a="rule">
				<c path="cs.system.security.accesscontrol.AuditRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</SetAuditRule>
		<ModifyAudit set="method" override="1">
			<f a="modification:rule:modified">
				<e path="cs.system.security.accesscontrol.AccessControlModification"/>
				<c path="cs.system.security.accesscontrol.AuditRule"/>
				<t path="cs.Out"><x path="Bool"/></t>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</ModifyAudit>
		<new final="1" set="method">
			<f a="isContainer">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.CommonObjectSecurity"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.NativeObjectSecurity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.NativeObjectSecurity" extern="1" abstract="1">
		<extends path="cs.system.security.accesscontrol.CommonObjectSecurity"/>
		<Persist final="1" set="method" override="1">
			<f a="handle:includeSections">
				<c path="cs.system.runtime.interopservices.SafeHandle"/>
				<e path="cs.system.security.accesscontrol.AccessControlSections"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
			<overloads>
				<Persist final="1" set="method">
					<f a="name:includeSections:exceptionContext">
						<c path="String"/>
						<e path="cs.system.security.accesscontrol.AccessControlSections"/>
						<d/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</Persist>
				<Persist final="1" set="method">
					<f a="handle:includeSections:exceptionContext">
						<c path="cs.system.runtime.interopservices.SafeHandle"/>
						<e path="cs.system.security.accesscontrol.AccessControlSections"/>
						<d/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</Persist>
				<Persist final="1" set="method">
					<f a="name:includeSections">
						<c path="String"/>
						<e path="cs.system.security.accesscontrol.AccessControlSections"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</Persist>
			</overloads>
		</Persist>
		<new final="1" set="method">
			<f a="isContainer:resourceType">
				<x path="Bool"/>
				<e path="cs.system.security.accesscontrol.ResourceType"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
			<overloads>
				<new final="1" set="method">
					<f a="isContainer:resourceType:name:includeSections:exceptionFromErrorCode:exceptionContext">
						<x path="Bool"/>
						<e path="cs.system.security.accesscontrol.ResourceType"/>
						<c path="String"/>
						<e path="cs.system.security.accesscontrol.AccessControlSections"/>
						<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
						<d/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" set="method">
					<f a="isContainer:resourceType:handle:includeSections:exceptionFromErrorCode:exceptionContext">
						<x path="Bool"/>
						<e path="cs.system.security.accesscontrol.ResourceType"/>
						<c path="cs.system.runtime.interopservices.SafeHandle"/>
						<e path="cs.system.security.accesscontrol.AccessControlSections"/>
						<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
						<d/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" set="method">
					<f a="isContainer:resourceType:name:includeSections">
						<x path="Bool"/>
						<e path="cs.system.security.accesscontrol.ResourceType"/>
						<c path="String"/>
						<e path="cs.system.security.accesscontrol.AccessControlSections"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" set="method">
					<f a="isContainer:resourceType:handle:includeSections">
						<x path="Bool"/>
						<e path="cs.system.security.accesscontrol.ResourceType"/>
						<c path="cs.system.runtime.interopservices.SafeHandle"/>
						<e path="cs.system.security.accesscontrol.AccessControlSections"/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
				<new final="1" set="method">
					<f a="isContainer:resourceType:exceptionFromErrorCode:exceptionContext">
						<x path="Bool"/>
						<e path="cs.system.security.accesscontrol.ResourceType"/>
						<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
						<d/>
						<x path="Void"/>
					</f>
					<meta><m n=":protected"/></meta>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.NativeObjectSecurity"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.FileSystemSecurity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.FileSystemSecurity" extern="1" abstract="1">
		<extends path="cs.system.security.accesscontrol.NativeObjectSecurity"/>
		<AuditRuleType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></AuditRuleType>
		<AccessRuleType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></AccessRuleType>
		<AccessRightType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></AccessRightType>
		<get_AccessRightType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_AccessRightType>
		<get_AccessRuleType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_AccessRuleType>
		<get_AuditRuleType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_AuditRuleType>
		<AccessRuleFactory final="1" public="1" set="method" override="1"><f a="identityReference:accessMask:isInherited:inheritanceFlags:propagationFlags:type">
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Int"/>
	<x path="Bool"/>
	<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
	<e path="cs.system.security.accesscontrol.PropagationFlags"/>
	<e path="cs.system.security.accesscontrol.AccessControlType"/>
	<c path="cs.system.security.accesscontrol.AccessRule"/>
</f></AccessRuleFactory>
		<AddAccessRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.FileSystemAccessRule"/>
	<x path="Void"/>
</f></AddAccessRule>
		<RemoveAccessRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.FileSystemAccessRule"/>
	<x path="Bool"/>
</f></RemoveAccessRule>
		<RemoveAccessRuleAll final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.FileSystemAccessRule"/>
	<x path="Void"/>
</f></RemoveAccessRuleAll>
		<RemoveAccessRuleSpecific final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.FileSystemAccessRule"/>
	<x path="Void"/>
</f></RemoveAccessRuleSpecific>
		<ResetAccessRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.FileSystemAccessRule"/>
	<x path="Void"/>
</f></ResetAccessRule>
		<SetAccessRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.FileSystemAccessRule"/>
	<x path="Void"/>
</f></SetAccessRule>
		<AuditRuleFactory final="1" public="1" set="method" override="1"><f a="identityReference:accessMask:isInherited:inheritanceFlags:propagationFlags:flags">
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Int"/>
	<x path="Bool"/>
	<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
	<e path="cs.system.security.accesscontrol.PropagationFlags"/>
	<e path="cs.system.security.accesscontrol.AuditFlags"/>
	<c path="cs.system.security.accesscontrol.AuditRule"/>
</f></AuditRuleFactory>
		<AddAuditRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.FileSystemAuditRule"/>
	<x path="Void"/>
</f></AddAuditRule>
		<RemoveAuditRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.FileSystemAuditRule"/>
	<x path="Bool"/>
</f></RemoveAuditRule>
		<RemoveAuditRuleAll final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.FileSystemAuditRule"/>
	<x path="Void"/>
</f></RemoveAuditRuleAll>
		<RemoveAuditRuleSpecific final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.FileSystemAuditRule"/>
	<x path="Void"/>
</f></RemoveAuditRuleSpecific>
		<SetAuditRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.FileSystemAuditRule"/>
	<x path="Void"/>
</f></SetAuditRule>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.FileSystemSecurity"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.DirectorySecurity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.DirectorySecurity" extern="1" final="1">
		<extends path="cs.system.security.accesscontrol.FileSystemSecurity"/>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><new final="1" public="1" set="method"><f a="name:includeSections">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.AccessControlSections"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.DirectorySecurity"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.EventWaitHandleAccessRule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.EventWaitHandleAccessRule" extern="1" final="1">
		<extends path="cs.system.security.accesscontrol.AccessRule"/>
		<EventWaitHandleRights public="1" get="accessor" set="null"><e path="cs.system.security.accesscontrol.EventWaitHandleRights"/></EventWaitHandleRights>
		<get_EventWaitHandleRights final="1" public="1" set="method"><f a=""><e path="cs.system.security.accesscontrol.EventWaitHandleRights"/></f></get_EventWaitHandleRights>
		<new final="1" public="1" set="method">
			<f a="identity:eventRights:type">
				<c path="cs.system.security.principal.IdentityReference"/>
				<e path="cs.system.security.accesscontrol.EventWaitHandleRights"/>
				<e path="cs.system.security.accesscontrol.AccessControlType"/>
				<x path="Void"/>
			</f>
			<overloads><new final="1" public="1" set="method"><f a="identity:eventRights:type">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.EventWaitHandleRights"/>
	<e path="cs.system.security.accesscontrol.AccessControlType"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.EventWaitHandleAccessRule"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.EventWaitHandleAuditRule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.EventWaitHandleAuditRule" extern="1" final="1">
		<extends path="cs.system.security.accesscontrol.AuditRule"/>
		<EventWaitHandleRights public="1" get="accessor" set="null"><e path="cs.system.security.accesscontrol.EventWaitHandleRights"/></EventWaitHandleRights>
		<get_EventWaitHandleRights final="1" public="1" set="method"><f a=""><e path="cs.system.security.accesscontrol.EventWaitHandleRights"/></f></get_EventWaitHandleRights>
		<new final="1" public="1" set="method"><f a="identity:eventRights:flags">
	<c path="cs.system.security.principal.IdentityReference"/>
	<e path="cs.system.security.accesscontrol.EventWaitHandleRights"/>
	<e path="cs.system.security.accesscontrol.AuditFlags"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.EventWaitHandleAuditRule"</e></m>
		</meta>
	</class>
	<enum path="cs.system.security.accesscontrol.EventWaitHandleRights" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.EventWaitHandleRights">
		<Modify><meta><m n=":csNative"><e>2</e></m></meta></Modify>
		<Delete><meta><m n=":csNative"><e>65536</e></m></meta></Delete>
		<ReadPermissions><meta><m n=":csNative"><e>131072</e></m></meta></ReadPermissions>
		<ChangePermissions><meta><m n=":csNative"><e>262144</e></m></meta></ChangePermissions>
		<TakeOwnership><meta><m n=":csNative"><e>524288</e></m></meta></TakeOwnership>
		<Synchronize><meta><m n=":csNative"><e>1048576</e></m></meta></Synchronize>
		<FullControl><meta><m n=":csNative"><e>2031619</e></m></meta></FullControl>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.AccessControl.EventWaitHandleRights"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.security.accesscontrol.EventWaitHandleSecurity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.EventWaitHandleSecurity" extern="1" final="1">
		<extends path="cs.system.security.accesscontrol.NativeObjectSecurity"/>
		<AuditRuleType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></AuditRuleType>
		<AccessRuleType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></AccessRuleType>
		<AccessRightType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></AccessRightType>
		<get_AccessRightType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_AccessRightType>
		<get_AccessRuleType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_AccessRuleType>
		<get_AuditRuleType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_AuditRuleType>
		<AccessRuleFactory public="1" set="method" override="1"><f a="identityReference:accessMask:isInherited:inheritanceFlags:propagationFlags:type">
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Int"/>
	<x path="Bool"/>
	<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
	<e path="cs.system.security.accesscontrol.PropagationFlags"/>
	<e path="cs.system.security.accesscontrol.AccessControlType"/>
	<c path="cs.system.security.accesscontrol.AccessRule"/>
</f></AccessRuleFactory>
		<AddAccessRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.EventWaitHandleAccessRule"/>
	<x path="Void"/>
</f></AddAccessRule>
		<RemoveAccessRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.EventWaitHandleAccessRule"/>
	<x path="Bool"/>
</f></RemoveAccessRule>
		<RemoveAccessRuleAll final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.EventWaitHandleAccessRule"/>
	<x path="Void"/>
</f></RemoveAccessRuleAll>
		<RemoveAccessRuleSpecific final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.EventWaitHandleAccessRule"/>
	<x path="Void"/>
</f></RemoveAccessRuleSpecific>
		<ResetAccessRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.EventWaitHandleAccessRule"/>
	<x path="Void"/>
</f></ResetAccessRule>
		<SetAccessRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.EventWaitHandleAccessRule"/>
	<x path="Void"/>
</f></SetAccessRule>
		<AuditRuleFactory public="1" set="method" override="1"><f a="identityReference:accessMask:isInherited:inheritanceFlags:propagationFlags:flags">
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Int"/>
	<x path="Bool"/>
	<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
	<e path="cs.system.security.accesscontrol.PropagationFlags"/>
	<e path="cs.system.security.accesscontrol.AuditFlags"/>
	<c path="cs.system.security.accesscontrol.AuditRule"/>
</f></AuditRuleFactory>
		<AddAuditRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.EventWaitHandleAuditRule"/>
	<x path="Void"/>
</f></AddAuditRule>
		<RemoveAuditRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.EventWaitHandleAuditRule"/>
	<x path="Bool"/>
</f></RemoveAuditRule>
		<RemoveAuditRuleAll final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.EventWaitHandleAuditRule"/>
	<x path="Void"/>
</f></RemoveAuditRuleAll>
		<RemoveAuditRuleSpecific final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.EventWaitHandleAuditRule"/>
	<x path="Void"/>
</f></RemoveAuditRuleSpecific>
		<SetAuditRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.EventWaitHandleAuditRule"/>
	<x path="Void"/>
</f></SetAuditRule>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.EventWaitHandleSecurity"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.FileSecurity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.FileSecurity" extern="1" final="1">
		<extends path="cs.system.security.accesscontrol.FileSystemSecurity"/>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><new final="1" public="1" set="method"><f a="fileName:includeSections">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.AccessControlSections"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.FileSecurity"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.FileSystemAccessRule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.FileSystemAccessRule" extern="1" final="1">
		<extends path="cs.system.security.accesscontrol.AccessRule"/>
		<FileSystemRights public="1" get="accessor" set="null"><e path="cs.system.security.accesscontrol.FileSystemRights"/></FileSystemRights>
		<get_FileSystemRights final="1" public="1" set="method"><f a=""><e path="cs.system.security.accesscontrol.FileSystemRights"/></f></get_FileSystemRights>
		<new final="1" public="1" set="method">
			<f a="identity:fileSystemRights:type">
				<c path="cs.system.security.principal.IdentityReference"/>
				<e path="cs.system.security.accesscontrol.FileSystemRights"/>
				<e path="cs.system.security.accesscontrol.AccessControlType"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="identity:fileSystemRights:inheritanceFlags:propagationFlags:type">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.FileSystemRights"/>
	<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
	<e path="cs.system.security.accesscontrol.PropagationFlags"/>
	<e path="cs.system.security.accesscontrol.AccessControlType"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="identity:fileSystemRights:inheritanceFlags:propagationFlags:type">
	<c path="cs.system.security.principal.IdentityReference"/>
	<e path="cs.system.security.accesscontrol.FileSystemRights"/>
	<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
	<e path="cs.system.security.accesscontrol.PropagationFlags"/>
	<e path="cs.system.security.accesscontrol.AccessControlType"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="identity:fileSystemRights:type">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.FileSystemRights"/>
	<e path="cs.system.security.accesscontrol.AccessControlType"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.FileSystemAccessRule"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.FileSystemAuditRule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.FileSystemAuditRule" extern="1" final="1">
		<extends path="cs.system.security.accesscontrol.AuditRule"/>
		<FileSystemRights public="1" get="accessor" set="null"><e path="cs.system.security.accesscontrol.FileSystemRights"/></FileSystemRights>
		<get_FileSystemRights final="1" public="1" set="method"><f a=""><e path="cs.system.security.accesscontrol.FileSystemRights"/></f></get_FileSystemRights>
		<new final="1" public="1" set="method">
			<f a="identity:fileSystemRights:flags">
				<c path="cs.system.security.principal.IdentityReference"/>
				<e path="cs.system.security.accesscontrol.FileSystemRights"/>
				<e path="cs.system.security.accesscontrol.AuditFlags"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="identity:fileSystemRights:inheritanceFlags:propagationFlags:flags">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.FileSystemRights"/>
	<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
	<e path="cs.system.security.accesscontrol.PropagationFlags"/>
	<e path="cs.system.security.accesscontrol.AuditFlags"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="identity:fileSystemRights:inheritanceFlags:propagationFlags:flags">
	<c path="cs.system.security.principal.IdentityReference"/>
	<e path="cs.system.security.accesscontrol.FileSystemRights"/>
	<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
	<e path="cs.system.security.accesscontrol.PropagationFlags"/>
	<e path="cs.system.security.accesscontrol.AuditFlags"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="identity:fileSystemRights:flags">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.FileSystemRights"/>
	<e path="cs.system.security.accesscontrol.AuditFlags"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.FileSystemAuditRule"</e></m>
		</meta>
	</class>
	<enum path="cs.system.security.accesscontrol.FileSystemRights" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.FileSystemRights">
		<ListDirectory><meta><m n=":csNative"><e>1</e></m></meta></ListDirectory>
		<ReadData><meta><m n=":csNative"><e>1</e></m></meta></ReadData>
		<CreateFiles><meta><m n=":csNative"><e>2</e></m></meta></CreateFiles>
		<WriteData><meta><m n=":csNative"><e>2</e></m></meta></WriteData>
		<AppendData><meta><m n=":csNative"><e>4</e></m></meta></AppendData>
		<CreateDirectories><meta><m n=":csNative"><e>4</e></m></meta></CreateDirectories>
		<ReadExtendedAttributes><meta><m n=":csNative"><e>8</e></m></meta></ReadExtendedAttributes>
		<WriteExtendedAttributes><meta><m n=":csNative"><e>16</e></m></meta></WriteExtendedAttributes>
		<ExecuteFile><meta><m n=":csNative"><e>32</e></m></meta></ExecuteFile>
		<Traverse><meta><m n=":csNative"><e>32</e></m></meta></Traverse>
		<DeleteSubdirectoriesAndFiles><meta><m n=":csNative"><e>64</e></m></meta></DeleteSubdirectoriesAndFiles>
		<ReadAttributes><meta><m n=":csNative"><e>128</e></m></meta></ReadAttributes>
		<WriteAttributes><meta><m n=":csNative"><e>256</e></m></meta></WriteAttributes>
		<Write><meta><m n=":csNative"><e>278</e></m></meta></Write>
		<Delete><meta><m n=":csNative"><e>65536</e></m></meta></Delete>
		<ReadPermissions><meta><m n=":csNative"><e>131072</e></m></meta></ReadPermissions>
		<Read><meta><m n=":csNative"><e>131209</e></m></meta></Read>
		<ReadAndExecute><meta><m n=":csNative"><e>131241</e></m></meta></ReadAndExecute>
		<Modify><meta><m n=":csNative"><e>197055</e></m></meta></Modify>
		<ChangePermissions><meta><m n=":csNative"><e>262144</e></m></meta></ChangePermissions>
		<TakeOwnership><meta><m n=":csNative"><e>524288</e></m></meta></TakeOwnership>
		<Synchronize><meta><m n=":csNative"><e>1048576</e></m></meta></Synchronize>
		<FullControl><meta><m n=":csNative"><e>2032127</e></m></meta></FullControl>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.AccessControl.FileSystemRights"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.security.accesscontrol.InheritanceFlags" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.InheritanceFlags">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<ContainerInherit><meta><m n=":csNative"><e>1</e></m></meta></ContainerInherit>
		<ObjectInherit><meta><m n=":csNative"><e>2</e></m></meta></ObjectInherit>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.AccessControl.InheritanceFlags"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.security.accesscontrol.MutexAccessRule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.MutexAccessRule" extern="1" final="1">
		<extends path="cs.system.security.accesscontrol.AccessRule"/>
		<MutexRights public="1" get="accessor" set="null"><e path="cs.system.security.accesscontrol.MutexRights"/></MutexRights>
		<get_MutexRights final="1" public="1" set="method"><f a=""><e path="cs.system.security.accesscontrol.MutexRights"/></f></get_MutexRights>
		<new final="1" public="1" set="method">
			<f a="identity:eventRights:type">
				<c path="cs.system.security.principal.IdentityReference"/>
				<e path="cs.system.security.accesscontrol.MutexRights"/>
				<e path="cs.system.security.accesscontrol.AccessControlType"/>
				<x path="Void"/>
			</f>
			<overloads><new final="1" public="1" set="method"><f a="identity:eventRights:type">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.MutexRights"/>
	<e path="cs.system.security.accesscontrol.AccessControlType"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.MutexAccessRule"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.MutexAuditRule" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.MutexAuditRule" extern="1" final="1">
		<extends path="cs.system.security.accesscontrol.AuditRule"/>
		<MutexRights public="1" get="accessor" set="null"><e path="cs.system.security.accesscontrol.MutexRights"/></MutexRights>
		<get_MutexRights final="1" public="1" set="method"><f a=""><e path="cs.system.security.accesscontrol.MutexRights"/></f></get_MutexRights>
		<new final="1" public="1" set="method"><f a="identity:eventRights:flags">
	<c path="cs.system.security.principal.IdentityReference"/>
	<e path="cs.system.security.accesscontrol.MutexRights"/>
	<e path="cs.system.security.accesscontrol.AuditFlags"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.MutexAuditRule"</e></m>
		</meta>
	</class>
	<enum path="cs.system.security.accesscontrol.MutexRights" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.MutexRights">
		<Modify><meta><m n=":csNative"><e>1</e></m></meta></Modify>
		<Delete><meta><m n=":csNative"><e>65536</e></m></meta></Delete>
		<ReadPermissions><meta><m n=":csNative"><e>131072</e></m></meta></ReadPermissions>
		<ChangePermissions><meta><m n=":csNative"><e>262144</e></m></meta></ChangePermissions>
		<TakeOwnership><meta><m n=":csNative"><e>524288</e></m></meta></TakeOwnership>
		<Synchronize><meta><m n=":csNative"><e>1048576</e></m></meta></Synchronize>
		<FullControl><meta><m n=":csNative"><e>2031617</e></m></meta></FullControl>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.AccessControl.MutexRights"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.security.accesscontrol.MutexSecurity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.MutexSecurity" extern="1" final="1">
		<extends path="cs.system.security.accesscontrol.NativeObjectSecurity"/>
		<AuditRuleType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></AuditRuleType>
		<AccessRuleType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></AccessRuleType>
		<AccessRightType public="1" get="accessor" set="null" override="1"><c path="cs.system.Type"/></AccessRightType>
		<get_AccessRightType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_AccessRightType>
		<get_AccessRuleType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_AccessRuleType>
		<get_AuditRuleType public="1" set="method" override="1"><f a=""><c path="cs.system.Type"/></f></get_AuditRuleType>
		<AccessRuleFactory public="1" set="method" override="1"><f a="identityReference:accessMask:isInherited:inheritanceFlags:propagationFlags:type">
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Int"/>
	<x path="Bool"/>
	<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
	<e path="cs.system.security.accesscontrol.PropagationFlags"/>
	<e path="cs.system.security.accesscontrol.AccessControlType"/>
	<c path="cs.system.security.accesscontrol.AccessRule"/>
</f></AccessRuleFactory>
		<AddAccessRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.MutexAccessRule"/>
	<x path="Void"/>
</f></AddAccessRule>
		<RemoveAccessRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.MutexAccessRule"/>
	<x path="Bool"/>
</f></RemoveAccessRule>
		<RemoveAccessRuleAll final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.MutexAccessRule"/>
	<x path="Void"/>
</f></RemoveAccessRuleAll>
		<RemoveAccessRuleSpecific final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.MutexAccessRule"/>
	<x path="Void"/>
</f></RemoveAccessRuleSpecific>
		<ResetAccessRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.MutexAccessRule"/>
	<x path="Void"/>
</f></ResetAccessRule>
		<SetAccessRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.MutexAccessRule"/>
	<x path="Void"/>
</f></SetAccessRule>
		<AuditRuleFactory public="1" set="method" override="1"><f a="identityReference:accessMask:isInherited:inheritanceFlags:propagationFlags:flags">
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Int"/>
	<x path="Bool"/>
	<e path="cs.system.security.accesscontrol.InheritanceFlags"/>
	<e path="cs.system.security.accesscontrol.PropagationFlags"/>
	<e path="cs.system.security.accesscontrol.AuditFlags"/>
	<c path="cs.system.security.accesscontrol.AuditRule"/>
</f></AuditRuleFactory>
		<AddAuditRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.MutexAuditRule"/>
	<x path="Void"/>
</f></AddAuditRule>
		<RemoveAuditRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.MutexAuditRule"/>
	<x path="Bool"/>
</f></RemoveAuditRule>
		<RemoveAuditRuleAll final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.MutexAuditRule"/>
	<x path="Void"/>
</f></RemoveAuditRuleAll>
		<RemoveAuditRuleSpecific final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.MutexAuditRule"/>
	<x path="Void"/>
</f></RemoveAuditRuleSpecific>
		<SetAuditRule final="1" public="1" set="method" override="1"><f a="rule">
	<c path="cs.system.security.accesscontrol.MutexAuditRule"/>
	<x path="Void"/>
</f></SetAuditRule>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><new final="1" public="1" set="method"><f a="name:includeSections">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.AccessControlSections"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.MutexSecurity"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.accesscontrol.NativeObjectSecurity_Delegate_ExceptionFromErrorCode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.NativeObjectSecurity" module="cs.system.security.accesscontrol.NativeObjectSecurity" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
	<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
	<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
	<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
	<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="errorCode:name:handle:context">
	<x path="Int"/>
	<c path="String"/>
	<c path="cs.system.runtime.interopservices.SafeHandle"/>
	<d/>
	<c path="cs.system.Exception"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="errorCode:name:handle:context:callback:object">
	<x path="Int"/>
	<c path="String"/>
	<c path="cs.system.runtime.interopservices.SafeHandle"/>
	<d/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<c path="cs.system.Exception"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.AccessControl.NativeObjectSecurity.ExceptionFromErrorCode"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.NativeObjectSecurity" module="cs.system.security.accesscontrol.NativeObjectSecurity">
		<from><icast field="FromHaxeFunction"><f a=":::">
	<x path="Int"/>
	<c path="String"/>
	<c path="cs.system.runtime.interopservices.SafeHandle"/>
	<d/>
	<c path="cs.system.Exception"/>
</f></icast></from>
		<this><c path="cs.system.security.accesscontrol.NativeObjectSecurity_Delegate_ExceptionFromErrorCode"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.security.accesscontrol._NativeObjectSecurity.NativeObjectSecurity_ExceptionFromErrorCode_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.NativeObjectSecurity" private="1" module="cs.system.security.accesscontrol.NativeObjectSecurity" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":::">
				<x path="Int"/>
				<c path="String"/>
				<c path="cs.system.runtime.interopservices.SafeHandle"/>
				<d/>
				<c path="cs.system.Exception"/>
			</f>
			<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=":::">
				<x path="Int"/>
				<c path="String"/>
				<c path="cs.system.runtime.interopservices.SafeHandle"/>
				<d/>
				<c path="cs.system.Exception"/>
			</f>
			<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.security.accesscontrol.NativeObjectSecurity_Delegate_ExceptionFromErrorCode"/>
	<c path="cs.system.security.accesscontrol.NativeObjectSecurity_Delegate_ExceptionFromErrorCode"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
			<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
			<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
			<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
			<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.security.accesscontrol._NativeObjectSecurity.NativeObjectSecurity_ExceptionFromErrorCode_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.NativeObjectSecurity" private="1" module="cs.system.security.accesscontrol.NativeObjectSecurity" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":::">
					<x path="Int"/>
					<c path="String"/>
					<c path="cs.system.runtime.interopservices.SafeHandle"/>
					<d/>
					<c path="cs.system.Exception"/>
				</f>
				<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=":::">
					<x path="Int"/>
					<c path="String"/>
					<c path="cs.system.runtime.interopservices.SafeHandle"/>
					<d/>
					<c path="cs.system.Exception"/>
				</f>
				<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.security.accesscontrol.NativeObjectSecurity_Delegate_ExceptionFromErrorCode"/>
	<c path="cs.system.security.accesscontrol.NativeObjectSecurity_Delegate_ExceptionFromErrorCode"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
				<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
				<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
				<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
				<x path="cs.system.security.accesscontrol.NativeObjectSecurity_ExceptionFromErrorCode"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<enum path="cs.system.security.accesscontrol.PropagationFlags" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.PropagationFlags">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<NoPropagateInherit><meta><m n=":csNative"><e>1</e></m></meta></NoPropagateInherit>
		<InheritOnly><meta><m n=":csNative"><e>2</e></m></meta></InheritOnly>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.AccessControl.PropagationFlags"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.security.accesscontrol.ResourceType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.accesscontrol.ResourceType">
		<Unknown><meta><m n=":csNative"><e>0</e></m></meta></Unknown>
		<FileObject><meta><m n=":csNative"><e>1</e></m></meta></FileObject>
		<Service><meta><m n=":csNative"><e>2</e></m></meta></Service>
		<Printer><meta><m n=":csNative"><e>3</e></m></meta></Printer>
		<RegistryKey><meta><m n=":csNative"><e>4</e></m></meta></RegistryKey>
		<LMShare><meta><m n=":csNative"><e>5</e></m></meta></LMShare>
		<KernelObject><meta><m n=":csNative"><e>6</e></m></meta></KernelObject>
		<WindowObject><meta><m n=":csNative"><e>7</e></m></meta></WindowObject>
		<DSObject><meta><m n=":csNative"><e>8</e></m></meta></DSObject>
		<DSObjectAll><meta><m n=":csNative"><e>9</e></m></meta></DSObjectAll>
		<ProviderDefined><meta><m n=":csNative"><e>10</e></m></meta></ProviderDefined>
		<WmiGuidObject><meta><m n=":csNative"><e>11</e></m></meta></WmiGuidObject>
		<RegistryWow6432Key><meta><m n=":csNative"><e>12</e></m></meta></RegistryWow6432Key>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.AccessControl.ResourceType"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.security.cryptography.x509certificates.X509Certificate_CertificateContext" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.cryptography.x509certificates.X509Certificate" module="cs.system.security.cryptography.x509certificates.X509Certificate" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<hCertStore public="1"><c path="cs.system.IntPtr"/></hCertStore>
		<pCertInfo public="1"><c path="cs.system.IntPtr"/></pCertInfo>
		<cbCertEncoded public="1"><x path="UInt"/></cbCertEncoded>
		<pbCertEncoded public="1"><c path="cs.system.IntPtr"/></pbCertEncoded>
		<dwCertEncodingType public="1"><x path="UInt"/></dwCertEncodingType>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Cryptography.X509Certificates.X509Certificate.CertificateContext"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.cryptography.x509certificates.X509Certificate" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.cryptography.x509certificates.X509Certificate" extern="1">
		<implements path="cs.system.runtime.serialization.IDeserializationCallback"/>
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<CreateFromCertFile public="1" set="method" static="1"><f a="filename">
	<c path="String"/>
	<c path="cs.system.security.cryptography.x509certificates.X509Certificate"/>
</f></CreateFromCertFile>
		<CreateFromSignedFile public="1" set="method" static="1"><f a="filename">
	<c path="String"/>
	<c path="cs.system.security.cryptography.x509certificates.X509Certificate"/>
</f></CreateFromSignedFile>
		<Handle public="1" get="accessor" set="null"><c path="cs.system.IntPtr"/></Handle>
		<Subject public="1" get="accessor" set="null"><c path="String"/></Subject>
		<Issuer public="1" get="accessor" set="null"><c path="String"/></Issuer>
		<GetCertHash public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetCertHash>
		<GetCertHashString public="1" set="method"><f a=""><c path="String"/></f></GetCertHashString>
		<GetEffectiveDateString public="1" set="method"><f a=""><c path="String"/></f></GetEffectiveDateString>
		<GetExpirationDateString public="1" set="method"><f a=""><c path="String"/></f></GetExpirationDateString>
		<GetFormat public="1" set="method"><f a=""><c path="String"/></f></GetFormat>
		<GetIssuerName public="1" set="method"><f a=""><c path="String"/></f></GetIssuerName>
		<GetKeyAlgorithm public="1" set="method"><f a=""><c path="String"/></f></GetKeyAlgorithm>
		<GetKeyAlgorithmParameters public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetKeyAlgorithmParameters>
		<GetKeyAlgorithmParametersString public="1" set="method"><f a=""><c path="String"/></f></GetKeyAlgorithmParametersString>
		<GetName public="1" set="method"><f a=""><c path="String"/></f></GetName>
		<GetPublicKey public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetPublicKey>
		<GetPublicKeyString public="1" set="method"><f a=""><c path="String"/></f></GetPublicKeyString>
		<GetRawCertData public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetRawCertData>
		<GetRawCertDataString public="1" set="method"><f a=""><c path="String"/></f></GetRawCertDataString>
		<GetSerialNumber public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetSerialNumber>
		<GetSerialNumberString public="1" set="method"><f a=""><c path="String"/></f></GetSerialNumberString>
		<ToString public="1" set="method">
			<f a=""><c path="String"/></f>
			<overloads><ToString public="1" set="method"><f a="fVerbose">
	<x path="Bool"/>
	<c path="String"/>
</f></ToString></overloads>
		</ToString>
		<get_Issuer final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Issuer>
		<get_Subject final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Subject>
		<get_Handle final="1" public="1" set="method"><f a=""><c path="cs.system.IntPtr"/></f></get_Handle>
		<Export public="1" set="method">
			<f a="contentType">
				<e path="cs.system.security.cryptography.x509certificates.X509ContentType"/>
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
			</f>
			<overloads>
				<Export public="1" set="method"><f a="contentType:password">
	<e path="cs.system.security.cryptography.x509certificates.X509ContentType"/>
	<c path="cs.system.security.SecureString"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></Export>
				<Export public="1" set="method"><f a="contentType:password">
	<e path="cs.system.security.cryptography.x509certificates.X509ContentType"/>
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></Export>
			</overloads>
		</Export>
		<Import public="1" set="method">
			<f a="rawData">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Void"/>
			</f>
			<overloads>
				<Import public="1" set="method"><f a="fileName:password:keyStorageFlags">
	<c path="String"/>
	<c path="cs.system.security.SecureString"/>
	<e path="cs.system.security.cryptography.x509certificates.X509KeyStorageFlags"/>
	<x path="Void"/>
</f></Import>
				<Import public="1" set="method"><f a="fileName:password:keyStorageFlags">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.security.cryptography.x509certificates.X509KeyStorageFlags"/>
	<x path="Void"/>
</f></Import>
				<Import public="1" set="method"><f a="fileName">
	<c path="String"/>
	<x path="Void"/>
</f></Import>
				<Import public="1" set="method"><f a="rawData:password:keyStorageFlags">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.security.SecureString"/>
	<e path="cs.system.security.cryptography.x509certificates.X509KeyStorageFlags"/>
	<x path="Void"/>
</f></Import>
				<Import public="1" set="method"><f a="rawData:password:keyStorageFlags">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="String"/>
	<e path="cs.system.security.cryptography.x509certificates.X509KeyStorageFlags"/>
	<x path="Void"/>
</f></Import>
			</overloads>
		</Import>
		<Reset public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<new final="1" public="1" set="method">
			<f a="data">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="fileName:password:keyStorageFlags">
	<c path="String"/>
	<c path="cs.system.security.SecureString"/>
	<e path="cs.system.security.cryptography.x509certificates.X509KeyStorageFlags"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="fileName:password:keyStorageFlags">
	<c path="String"/>
	<c path="String"/>
	<e path="cs.system.security.cryptography.x509certificates.X509KeyStorageFlags"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="fileName:password">
	<c path="String"/>
	<c path="cs.system.security.SecureString"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="fileName:password">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="fileName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="rawData:password:keyStorageFlags">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.security.SecureString"/>
	<e path="cs.system.security.cryptography.x509certificates.X509KeyStorageFlags"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="rawData:password:keyStorageFlags">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="String"/>
	<e path="cs.system.security.cryptography.x509certificates.X509KeyStorageFlags"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="rawData:password">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.system.security.SecureString"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="rawData:password">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
				<new final="1" public="1" set="method"><f a="cert">
	<c path="cs.system.security.cryptography.x509certificates.X509Certificate"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="handle">
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Cryptography.X509Certificates.X509Certificate"</e></m>
		</meta>
	</class>
	<enum path="cs.system.security.cryptography.x509certificates.X509ContentType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.cryptography.x509certificates.X509ContentType">
		<Unknown><meta><m n=":csNative"><e>0</e></m></meta></Unknown>
		<Cert><meta><m n=":csNative"><e>1</e></m></meta></Cert>
		<SerializedCert><meta><m n=":csNative"><e>2</e></m></meta></SerializedCert>
		<Pfx><meta><m n=":csNative"><e>3</e></m></meta></Pfx>
		<Pkcs12><meta><m n=":csNative"><e>3</e></m></meta></Pkcs12>
		<SerializedStore><meta><m n=":csNative"><e>4</e></m></meta></SerializedStore>
		<Pkcs7><meta><m n=":csNative"><e>5</e></m></meta></Pkcs7>
		<Authenticode><meta><m n=":csNative"><e>6</e></m></meta></Authenticode>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.Cryptography.X509Certificates.X509ContentType"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.security.cryptography.x509certificates.X509KeyStorageFlags" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.cryptography.x509certificates.X509KeyStorageFlags">
		<DefaultKeySet><meta><m n=":csNative"><e>0</e></m></meta></DefaultKeySet>
		<UserKeySet><meta><m n=":csNative"><e>1</e></m></meta></UserKeySet>
		<MachineKeySet><meta><m n=":csNative"><e>2</e></m></meta></MachineKeySet>
		<Exportable><meta><m n=":csNative"><e>4</e></m></meta></Exportable>
		<UserProtected><meta><m n=":csNative"><e>8</e></m></meta></UserProtected>
		<PersistKeySet><meta><m n=":csNative"><e>16</e></m></meta></PersistKeySet>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.Cryptography.X509Certificates.X509KeyStorageFlags"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.security.permissions.PermissionState" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.permissions.PermissionState">
		<None><meta><m n=":csNative"><e>0</e></m></meta></None>
		<Unrestricted><meta><m n=":csNative"><e>1</e></m></meta></Unrestricted>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.Permissions.PermissionState"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<enum path="cs.system.security.permissions.SecurityAction" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.permissions.SecurityAction">
		<Demand><meta><m n=":csNative"><e>2</e></m></meta></Demand>
		<Assert><meta><m n=":csNative"><e>3</e></m></meta></Assert>
		<Deny><meta><m n=":csNative"><e>4</e></m></meta></Deny>
		<PermitOnly><meta><m n=":csNative"><e>5</e></m></meta></PermitOnly>
		<LinkDemand><meta><m n=":csNative"><e>6</e></m></meta></LinkDemand>
		<InheritanceDemand><meta><m n=":csNative"><e>7</e></m></meta></InheritanceDemand>
		<RequestMinimum><meta><m n=":csNative"><e>8</e></m></meta></RequestMinimum>
		<RequestOptional><meta><m n=":csNative"><e>9</e></m></meta></RequestOptional>
		<RequestRefuse><meta><m n=":csNative"><e>10</e></m></meta></RequestRefuse>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.Permissions.SecurityAction"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.security.permissions.StrongNamePublicKeyBlob" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.permissions.StrongNamePublicKeyBlob" extern="1" final="1">
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<new final="1" public="1" set="method"><f a="publicKey">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Permissions.StrongNamePublicKeyBlob"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.policy.ApplicationTrust" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.ApplicationTrust" extern="1" final="1">
		<implements path="cs.system.security.ISecurityEncodable"/>
		<Persist public="1" get="accessor" set="accessor"><x path="Bool"/></Persist>
		<IsApplicationTrustedToRun public="1" get="accessor" set="accessor"><x path="Bool"/></IsApplicationTrustedToRun>
		<ExtraInfo public="1" get="accessor" set="accessor"><d/></ExtraInfo>
		<DefaultGrantSet public="1" get="accessor" set="accessor"><c path="cs.system.security.policy.PolicyStatement"/></DefaultGrantSet>
		<ApplicationIdentity public="1" get="accessor" set="accessor"><c path="cs.system.ApplicationIdentity"/></ApplicationIdentity>
		<get_ApplicationIdentity final="1" public="1" set="method"><f a=""><c path="cs.system.ApplicationIdentity"/></f></get_ApplicationIdentity>
		<set_ApplicationIdentity final="1" public="1" set="method"><f a="value">
	<c path="cs.system.ApplicationIdentity"/>
	<c path="cs.system.ApplicationIdentity"/>
</f></set_ApplicationIdentity>
		<get_DefaultGrantSet final="1" public="1" set="method"><f a=""><c path="cs.system.security.policy.PolicyStatement"/></f></get_DefaultGrantSet>
		<set_DefaultGrantSet final="1" public="1" set="method"><f a="value">
	<c path="cs.system.security.policy.PolicyStatement"/>
	<c path="cs.system.security.policy.PolicyStatement"/>
</f></set_DefaultGrantSet>
		<get_ExtraInfo final="1" public="1" set="method"><f a=""><d/></f></get_ExtraInfo>
		<set_ExtraInfo final="1" public="1" set="method"><f a="value">
	<d/>
	<d/>
</f></set_ExtraInfo>
		<get_IsApplicationTrustedToRun final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsApplicationTrustedToRun>
		<set_IsApplicationTrustedToRun final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_IsApplicationTrustedToRun>
		<get_Persist final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_Persist>
		<set_Persist final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_Persist>
		<FromXml final="1" public="1" set="method"><f a="element">
	<c path="cs.system.security.SecurityElement"/>
	<x path="Void"/>
</f></FromXml>
		<ToXml final="1" public="1" set="method"><f a=""><c path="cs.system.security.SecurityElement"/></f></ToXml>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><new final="1" public="1" set="method"><f a="applicationIdentity">
	<c path="cs.system.ApplicationIdentity"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Policy.ApplicationTrust"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.policy.CodeGroup" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.CodeGroup" extern="1" abstract="1">
		<PermissionSetName public="1" get="accessor" set="null"><c path="String"/></PermissionSetName>
		<AttributeString public="1" get="accessor" set="null"><c path="String"/></AttributeString>
		<Children public="1" get="accessor" set="accessor"><c path="cs.system.collections.IList"/></Children>
		<Name public="1" get="accessor" set="accessor"><c path="String"/></Name>
		<MembershipCondition public="1" get="accessor" set="accessor"><c path="cs.system.security.policy.IMembershipCondition"/></MembershipCondition>
		<Description public="1" get="accessor" set="accessor"><c path="String"/></Description>
		<PolicyStatement public="1" get="accessor" set="accessor"><c path="cs.system.security.policy.PolicyStatement"/></PolicyStatement>
		<MergeLogic public="1" get="accessor" set="null"><c path="String"/></MergeLogic>
		<Copy abstract="1" public="1" set="method"><f a=""><c path="cs.system.security.policy.CodeGroup"/></f></Copy>
		<get_MergeLogic abstract="1" public="1" set="method"><f a=""><c path="String"/></f></get_MergeLogic>
		<Resolve abstract="1" public="1" set="method"><f a="evidence">
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.policy.PolicyStatement"/>
</f></Resolve>
		<ResolveMatchingCodeGroups abstract="1" public="1" set="method"><f a="evidence">
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.policy.CodeGroup"/>
</f></ResolveMatchingCodeGroups>
		<get_PolicyStatement final="1" public="1" set="method"><f a=""><c path="cs.system.security.policy.PolicyStatement"/></f></get_PolicyStatement>
		<set_PolicyStatement final="1" public="1" set="method"><f a="value">
	<c path="cs.system.security.policy.PolicyStatement"/>
	<c path="cs.system.security.policy.PolicyStatement"/>
</f></set_PolicyStatement>
		<get_Description final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Description>
		<set_Description final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Description>
		<get_MembershipCondition final="1" public="1" set="method"><f a=""><c path="cs.system.security.policy.IMembershipCondition"/></f></get_MembershipCondition>
		<set_MembershipCondition final="1" public="1" set="method"><f a="value">
	<c path="cs.system.security.policy.IMembershipCondition"/>
	<c path="cs.system.security.policy.IMembershipCondition"/>
</f></set_MembershipCondition>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<set_Name final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Name>
		<get_Children final="1" public="1" set="method"><f a=""><c path="cs.system.collections.IList"/></f></get_Children>
		<set_Children final="1" public="1" set="method"><f a="value">
	<c path="cs.system.collections.IList"/>
	<c path="cs.system.collections.IList"/>
</f></set_Children>
		<get_AttributeString public="1" set="method"><f a=""><c path="String"/></f></get_AttributeString>
		<get_PermissionSetName public="1" set="method"><f a=""><c path="String"/></f></get_PermissionSetName>
		<AddChild final="1" public="1" set="method"><f a="group">
	<c path="cs.system.security.policy.CodeGroup"/>
	<x path="Void"/>
</f></AddChild>
		<RemoveChild final="1" public="1" set="method"><f a="group">
	<c path="cs.system.security.policy.CodeGroup"/>
	<x path="Void"/>
</f></RemoveChild>
		<FromXml final="1" public="1" set="method">
			<f a="e">
				<c path="cs.system.security.SecurityElement"/>
				<x path="Void"/>
			</f>
			<overloads><FromXml final="1" public="1" set="method"><f a="e:level">
	<c path="cs.system.security.SecurityElement"/>
	<c path="cs.system.security.policy.PolicyLevel"/>
	<x path="Void"/>
</f></FromXml></overloads>
		</FromXml>
		<ParseXml set="method">
			<f a="e:level">
				<c path="cs.system.security.SecurityElement"/>
				<c path="cs.system.security.policy.PolicyLevel"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</ParseXml>
		<ToXml final="1" public="1" set="method">
			<f a=""><c path="cs.system.security.SecurityElement"/></f>
			<overloads><ToXml final="1" public="1" set="method"><f a="level">
	<c path="cs.system.security.policy.PolicyLevel"/>
	<c path="cs.system.security.SecurityElement"/>
</f></ToXml></overloads>
		</ToXml>
		<CreateXml set="method">
			<f a="element:level">
				<c path="cs.system.security.SecurityElement"/>
				<c path="cs.system.security.policy.PolicyLevel"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</CreateXml>
		<new final="1" set="method">
			<f a="membershipCondition:policy">
				<c path="cs.system.security.policy.IMembershipCondition"/>
				<c path="cs.system.security.policy.PolicyStatement"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Policy.CodeGroup"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.policy.Evidence_EvidenceEnumerator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.Evidence" module="cs.system.security.policy.Evidence" extern="1">
		<implements path="cs.system.collections.IEnumerator"/>
		<Current public="1" get="accessor" set="null"><d/></Current>
		<MoveNext final="1" public="1" set="method"><f a=""><x path="Bool"/></f></MoveNext>
		<Reset final="1" public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<get_Current final="1" public="1" set="method"><f a=""><d/></f></get_Current>
		<new final="1" public="1" set="method"><f a="hostenum:assemblyenum">
	<c path="cs.system.collections.IEnumerator"/>
	<c path="cs.system.collections.IEnumerator"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Policy.Evidence.EvidenceEnumerator"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.policy.Evidence" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.Evidence" extern="1" final="1">
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<Locked public="1" get="accessor" set="accessor"><x path="Bool"/></Locked>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<get_Count final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_IsSynchronized final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_Locked final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_Locked>
		<set_Locked final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_Locked>
		<get_SyncRoot final="1" public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<AddAssembly final="1" public="1" set="method"><f a="id">
	<d/>
	<x path="Void"/>
</f></AddAssembly>
		<AddHost final="1" public="1" set="method"><f a="id">
	<d/>
	<x path="Void"/>
</f></AddHost>
		<Clear final="1" public="1" set="method"><f a=""><x path="Void"/></f></Clear>
		<CopyTo final="1" public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<GetEnumerator final="1" public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<GetAssemblyEnumerator final="1" public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetAssemblyEnumerator>
		<GetHostEnumerator final="1" public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetHostEnumerator>
		<Merge final="1" public="1" set="method"><f a="evidence">
	<c path="cs.system.security.policy.Evidence"/>
	<x path="Void"/>
</f></Merge>
		<RemoveType final="1" public="1" set="method"><f a="t">
	<c path="cs.system.Type"/>
	<x path="Void"/>
</f></RemoveType>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="hostEvidence:assemblyEvidence">
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.NativeArray"><d/></c>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="evidence">
	<c path="cs.system.security.policy.Evidence"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Policy.Evidence"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.policy.IBuiltInEvidence" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.IBuiltInEvidence" extern="1" interface="1">
		<GetRequiredSize public="1" set="method"><f a="verbose">
	<x path="Bool"/>
	<x path="Int"/>
</f></GetRequiredSize>
		<InitFromBuffer public="1" set="method"><f a="buffer:position">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
</f></InitFromBuffer>
		<OutputToBuffer public="1" set="method"><f a="buffer:position:verbose">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></OutputToBuffer>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Policy.IBuiltInEvidence"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.policy.IConstantMembershipCondition" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.IConstantMembershipCondition" extern="1" interface="1"><meta>
	<m n=":nativeGen"/>
	<m n=":abstract"/>
	<m n=":libType"/>
	<m n=":csNative"/>
	<m n=":native"><e>"System.Security.Policy.IConstantMembershipCondition"</e></m>
</meta></class>
	<class path="cs.system.security.policy.IIdentityPermissionFactory" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.IIdentityPermissionFactory" extern="1" interface="1">
		<CreateIdentityPermission public="1" set="method"><f a="evidence">
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.IPermission"/>
</f></CreateIdentityPermission>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Policy.IIdentityPermissionFactory"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.policy.IMembershipCondition" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.IMembershipCondition" extern="1" interface="1">
		<extends path="cs.system.security.ISecurityEncodable"/>
		<extends path="cs.system.security.ISecurityPolicyEncodable"/>
		<Check public="1" set="method"><f a="evidence">
	<c path="cs.system.security.policy.Evidence"/>
	<x path="Bool"/>
</f></Check>
		<Copy public="1" set="method"><f a=""><c path="cs.system.security.policy.IMembershipCondition"/></f></Copy>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Policy.IMembershipCondition"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.policy.PolicyLevel" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.PolicyLevel" extern="1" final="1">
		<CreateAppDomainLevel public="1" set="method" static="1"><f a=""><c path="cs.system.security.policy.PolicyLevel"/></f></CreateAppDomainLevel>
		<Type public="1" get="accessor" set="null"><e path="cs.system.security.PolicyLevelType"/></Type>
		<StoreLocation public="1" get="accessor" set="null"><c path="String"/></StoreLocation>
		<RootCodeGroup public="1" get="accessor" set="accessor"><c path="cs.system.security.policy.CodeGroup"/></RootCodeGroup>
		<NamedPermissionSets public="1" get="accessor" set="null"><c path="cs.system.collections.IList"/></NamedPermissionSets>
		<Label public="1" get="accessor" set="null"><c path="String"/></Label>
		<FullTrustAssemblies public="1" get="accessor" set="null"><c path="cs.system.collections.IList"/></FullTrustAssemblies>
		<get_FullTrustAssemblies final="1" public="1" set="method"><f a=""><c path="cs.system.collections.IList"/></f></get_FullTrustAssemblies>
		<get_Label final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Label>
		<get_NamedPermissionSets final="1" public="1" set="method"><f a=""><c path="cs.system.collections.IList"/></f></get_NamedPermissionSets>
		<get_RootCodeGroup final="1" public="1" set="method"><f a=""><c path="cs.system.security.policy.CodeGroup"/></f></get_RootCodeGroup>
		<set_RootCodeGroup final="1" public="1" set="method"><f a="value">
	<c path="cs.system.security.policy.CodeGroup"/>
	<c path="cs.system.security.policy.CodeGroup"/>
</f></set_RootCodeGroup>
		<get_StoreLocation final="1" public="1" set="method"><f a=""><c path="String"/></f></get_StoreLocation>
		<get_Type final="1" public="1" set="method"><f a=""><e path="cs.system.security.PolicyLevelType"/></f></get_Type>
		<AddFullTrustAssembly final="1" public="1" set="method">
			<f a="sn">
				<c path="cs.system.security.policy.StrongName"/>
				<x path="Void"/>
			</f>
			<overloads><AddFullTrustAssembly final="1" public="1" set="method"><f a="snMC">
	<c path="cs.system.security.policy.StrongNameMembershipCondition"/>
	<x path="Void"/>
</f></AddFullTrustAssembly></overloads>
		</AddFullTrustAssembly>
		<AddNamedPermissionSet final="1" public="1" set="method"><f a="permSet">
	<c path="cs.system.security.NamedPermissionSet"/>
	<x path="Void"/>
</f></AddNamedPermissionSet>
		<ChangeNamedPermissionSet final="1" public="1" set="method"><f a="name:pSet">
	<c path="String"/>
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.NamedPermissionSet"/>
</f></ChangeNamedPermissionSet>
		<FromXml final="1" public="1" set="method"><f a="e">
	<c path="cs.system.security.SecurityElement"/>
	<x path="Void"/>
</f></FromXml>
		<GetNamedPermissionSet final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.security.NamedPermissionSet"/>
</f></GetNamedPermissionSet>
		<Recover final="1" public="1" set="method"><f a=""><x path="Void"/></f></Recover>
		<RemoveFullTrustAssembly final="1" public="1" set="method">
			<f a="sn">
				<c path="cs.system.security.policy.StrongName"/>
				<x path="Void"/>
			</f>
			<overloads><RemoveFullTrustAssembly final="1" public="1" set="method"><f a="snMC">
	<c path="cs.system.security.policy.StrongNameMembershipCondition"/>
	<x path="Void"/>
</f></RemoveFullTrustAssembly></overloads>
		</RemoveFullTrustAssembly>
		<RemoveNamedPermissionSet final="1" public="1" set="method">
			<f a="permSet">
				<c path="cs.system.security.NamedPermissionSet"/>
				<c path="cs.system.security.NamedPermissionSet"/>
			</f>
			<overloads><RemoveNamedPermissionSet final="1" public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.security.NamedPermissionSet"/>
</f></RemoveNamedPermissionSet></overloads>
		</RemoveNamedPermissionSet>
		<Reset final="1" public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<Resolve final="1" public="1" set="method"><f a="evidence">
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.policy.PolicyStatement"/>
</f></Resolve>
		<ResolveMatchingCodeGroups final="1" public="1" set="method"><f a="evidence">
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.policy.CodeGroup"/>
</f></ResolveMatchingCodeGroups>
		<ToXml final="1" public="1" set="method"><f a=""><c path="cs.system.security.SecurityElement"/></f></ToXml>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Policy.PolicyLevel"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.policy.PolicyStatement" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.PolicyStatement" extern="1" final="1">
		<implements path="cs.system.security.ISecurityEncodable"/>
		<implements path="cs.system.security.ISecurityPolicyEncodable"/>
		<AttributeString public="1" get="accessor" set="null"><c path="String"/></AttributeString>
		<Attributes public="1" get="accessor" set="accessor"><e path="cs.system.security.policy.PolicyStatementAttribute"/></Attributes>
		<PermissionSet public="1" get="accessor" set="accessor"><c path="cs.system.security.PermissionSet"/></PermissionSet>
		<get_PermissionSet final="1" public="1" set="method"><f a=""><c path="cs.system.security.PermissionSet"/></f></get_PermissionSet>
		<set_PermissionSet final="1" public="1" set="method"><f a="value">
	<c path="cs.system.security.PermissionSet"/>
	<c path="cs.system.security.PermissionSet"/>
</f></set_PermissionSet>
		<get_Attributes final="1" public="1" set="method"><f a=""><e path="cs.system.security.policy.PolicyStatementAttribute"/></f></get_Attributes>
		<set_Attributes final="1" public="1" set="method"><f a="value">
	<e path="cs.system.security.policy.PolicyStatementAttribute"/>
	<e path="cs.system.security.policy.PolicyStatementAttribute"/>
</f></set_Attributes>
		<get_AttributeString final="1" public="1" set="method"><f a=""><c path="String"/></f></get_AttributeString>
		<Copy final="1" public="1" set="method"><f a=""><c path="cs.system.security.policy.PolicyStatement"/></f></Copy>
		<FromXml final="1" public="1" set="method">
			<f a="et">
				<c path="cs.system.security.SecurityElement"/>
				<x path="Void"/>
			</f>
			<overloads><FromXml final="1" public="1" set="method"><f a="et:level">
	<c path="cs.system.security.SecurityElement"/>
	<c path="cs.system.security.policy.PolicyLevel"/>
	<x path="Void"/>
</f></FromXml></overloads>
		</FromXml>
		<ToXml final="1" public="1" set="method">
			<f a=""><c path="cs.system.security.SecurityElement"/></f>
			<overloads><ToXml final="1" public="1" set="method"><f a="level">
	<c path="cs.system.security.policy.PolicyLevel"/>
	<c path="cs.system.security.SecurityElement"/>
</f></ToXml></overloads>
		</ToXml>
		<new final="1" public="1" set="method">
			<f a="permSet">
				<c path="cs.system.security.PermissionSet"/>
				<x path="Void"/>
			</f>
			<overloads><new final="1" public="1" set="method"><f a="permSet:attributes">
	<c path="cs.system.security.PermissionSet"/>
	<e path="cs.system.security.policy.PolicyStatementAttribute"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Policy.PolicyStatement"</e></m>
		</meta>
	</class>
	<enum path="cs.system.security.policy.PolicyStatementAttribute" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.PolicyStatementAttribute">
		<Nothing><meta><m n=":csNative"><e>0</e></m></meta></Nothing>
		<Exclusive><meta><m n=":csNative"><e>1</e></m></meta></Exclusive>
		<LevelFinal><meta><m n=":csNative"><e>2</e></m></meta></LevelFinal>
		<All><meta><m n=":csNative"><e>3</e></m></meta></All>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.Policy.PolicyStatementAttribute"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.security.policy.StrongName" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.StrongName" extern="1" final="1">
		<implements path="cs.system.security.policy.IBuiltInEvidence"/>
		<implements path="cs.system.security.policy.IIdentityPermissionFactory"/>
		<Version public="1" get="accessor" set="null"><c path="cs.system.Version"/></Version>
		<PublicKey public="1" get="accessor" set="null"><c path="cs.system.security.permissions.StrongNamePublicKeyBlob"/></PublicKey>
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<get_PublicKey final="1" public="1" set="method"><f a=""><c path="cs.system.security.permissions.StrongNamePublicKeyBlob"/></f></get_PublicKey>
		<get_Version final="1" public="1" set="method"><f a=""><c path="cs.system.Version"/></f></get_Version>
		<Copy final="1" public="1" set="method"><f a=""><d/></f></Copy>
		<CreateIdentityPermission final="1" public="1" set="method"><f a="evidence">
	<c path="cs.system.security.policy.Evidence"/>
	<c path="cs.system.security.IPermission"/>
</f></CreateIdentityPermission>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<new final="1" public="1" set="method"><f a="blob:name:version">
	<c path="cs.system.security.permissions.StrongNamePublicKeyBlob"/>
	<c path="String"/>
	<c path="cs.system.Version"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Policy.StrongName"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.policy.StrongNameMembershipCondition" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.StrongNameMembershipCondition" extern="1" final="1">
		<implements path="cs.system.security.ISecurityEncodable"/>
		<implements path="cs.system.security.ISecurityPolicyEncodable"/>
		<implements path="cs.system.security.policy.IConstantMembershipCondition"/>
		<implements path="cs.system.security.policy.IMembershipCondition"/>
		<PublicKey public="1" get="accessor" set="accessor"><c path="cs.system.security.permissions.StrongNamePublicKeyBlob"/></PublicKey>
		<Version public="1" get="accessor" set="accessor"><c path="cs.system.Version"/></Version>
		<Name public="1" get="accessor" set="accessor"><c path="String"/></Name>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<set_Name final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Name>
		<get_Version final="1" public="1" set="method"><f a=""><c path="cs.system.Version"/></f></get_Version>
		<set_Version final="1" public="1" set="method"><f a="value">
	<c path="cs.system.Version"/>
	<c path="cs.system.Version"/>
</f></set_Version>
		<get_PublicKey final="1" public="1" set="method"><f a=""><c path="cs.system.security.permissions.StrongNamePublicKeyBlob"/></f></get_PublicKey>
		<set_PublicKey final="1" public="1" set="method"><f a="value">
	<c path="cs.system.security.permissions.StrongNamePublicKeyBlob"/>
	<c path="cs.system.security.permissions.StrongNamePublicKeyBlob"/>
</f></set_PublicKey>
		<Check final="1" public="1" set="method"><f a="evidence">
	<c path="cs.system.security.policy.Evidence"/>
	<x path="Bool"/>
</f></Check>
		<Copy final="1" public="1" set="method"><f a=""><c path="cs.system.security.policy.IMembershipCondition"/></f></Copy>
		<FromXml final="1" public="1" set="method">
			<f a="e">
				<c path="cs.system.security.SecurityElement"/>
				<x path="Void"/>
			</f>
			<overloads><FromXml final="1" public="1" set="method"><f a="e:level">
	<c path="cs.system.security.SecurityElement"/>
	<c path="cs.system.security.policy.PolicyLevel"/>
	<x path="Void"/>
</f></FromXml></overloads>
		</FromXml>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<ToXml final="1" public="1" set="method">
			<f a=""><c path="cs.system.security.SecurityElement"/></f>
			<overloads><ToXml final="1" public="1" set="method"><f a="level">
	<c path="cs.system.security.policy.PolicyLevel"/>
	<c path="cs.system.security.SecurityElement"/>
</f></ToXml></overloads>
		</ToXml>
		<new final="1" public="1" set="method"><f a="blob:name:version">
	<c path="cs.system.security.permissions.StrongNamePublicKeyBlob"/>
	<c path="String"/>
	<c path="cs.system.Version"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Policy.StrongNameMembershipCondition"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.policy.TrustManagerContext" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.TrustManagerContext" extern="1">
		<UIContext public="1" get="accessor" set="accessor"><e path="cs.system.security.policy.TrustManagerUIContext"/></UIContext>
		<PreviousApplicationIdentity public="1" get="accessor" set="accessor"><c path="cs.system.ApplicationIdentity"/></PreviousApplicationIdentity>
		<Persist public="1" get="accessor" set="accessor"><x path="Bool"/></Persist>
		<NoPrompt public="1" get="accessor" set="accessor"><x path="Bool"/></NoPrompt>
		<KeepAlive public="1" get="accessor" set="accessor"><x path="Bool"/></KeepAlive>
		<IgnorePersistedDecision public="1" get="accessor" set="accessor"><x path="Bool"/></IgnorePersistedDecision>
		<get_IgnorePersistedDecision public="1" set="method"><f a=""><x path="Bool"/></f></get_IgnorePersistedDecision>
		<set_IgnorePersistedDecision public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_IgnorePersistedDecision>
		<get_KeepAlive public="1" set="method"><f a=""><x path="Bool"/></f></get_KeepAlive>
		<set_KeepAlive public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_KeepAlive>
		<get_NoPrompt public="1" set="method"><f a=""><x path="Bool"/></f></get_NoPrompt>
		<set_NoPrompt public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NoPrompt>
		<get_Persist public="1" set="method"><f a=""><x path="Bool"/></f></get_Persist>
		<set_Persist public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_Persist>
		<get_PreviousApplicationIdentity public="1" set="method"><f a=""><c path="cs.system.ApplicationIdentity"/></f></get_PreviousApplicationIdentity>
		<set_PreviousApplicationIdentity public="1" set="method"><f a="value">
	<c path="cs.system.ApplicationIdentity"/>
	<c path="cs.system.ApplicationIdentity"/>
</f></set_PreviousApplicationIdentity>
		<get_UIContext public="1" set="method"><f a=""><e path="cs.system.security.policy.TrustManagerUIContext"/></f></get_UIContext>
		<set_UIContext public="1" set="method"><f a="value">
	<e path="cs.system.security.policy.TrustManagerUIContext"/>
	<e path="cs.system.security.policy.TrustManagerUIContext"/>
</f></set_UIContext>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><new final="1" public="1" set="method"><f a="uiContext">
	<e path="cs.system.security.policy.TrustManagerUIContext"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Policy.TrustManagerContext"</e></m>
		</meta>
	</class>
	<enum path="cs.system.security.policy.TrustManagerUIContext" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.policy.TrustManagerUIContext">
		<Install><meta><m n=":csNative"><e>0</e></m></meta></Install>
		<Upgrade><meta><m n=":csNative"><e>1</e></m></meta></Upgrade>
		<Run><meta><m n=":csNative"><e>2</e></m></meta></Run>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.Policy.TrustManagerUIContext"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.security.principal.IIdentity" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.principal.IIdentity" extern="1" interface="1">
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<IsAuthenticated public="1" get="accessor" set="null"><x path="Bool"/></IsAuthenticated>
		<AuthenticationType public="1" get="accessor" set="null"><c path="String"/></AuthenticationType>
		<get_AuthenticationType public="1" set="method"><f a=""><c path="String"/></f></get_AuthenticationType>
		<get_IsAuthenticated public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAuthenticated>
		<get_Name public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Principal.IIdentity"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.principal.IPrincipal" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.principal.IPrincipal" extern="1" interface="1">
		<Identity public="1" get="accessor" set="null"><c path="cs.system.security.principal.IIdentity"/></Identity>
		<get_Identity public="1" set="method"><f a=""><c path="cs.system.security.principal.IIdentity"/></f></get_Identity>
		<IsInRole public="1" set="method"><f a="role">
	<c path="String"/>
	<x path="Bool"/>
</f></IsInRole>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Principal.IPrincipal"</e></m>
		</meta>
	</class>
	<class path="cs.system.security.principal.IdentityReference" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.principal.IdentityReference" extern="1" abstract="1">
		<op_Equality public="1" set="method" static="1"><f a="left:right">
	<c path="cs.system.security.principal.IdentityReference"/>
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="left:right">
	<c path="cs.system.security.principal.IdentityReference"/>
	<c path="cs.system.security.principal.IdentityReference"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Value public="1" get="accessor" set="null"><c path="String"/></Value>
		<get_Value abstract="1" public="1" set="method"><f a=""><c path="String"/></f></get_Value>
		<IsValidTargetType abstract="1" public="1" set="method"><f a="targetType">
	<c path="cs.system.Type"/>
	<x path="Bool"/>
</f></IsValidTargetType>
		<ToString abstract="1" public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<Translate abstract="1" public="1" set="method"><f a="targetType">
	<c path="cs.system.Type"/>
	<c path="cs.system.security.principal.IdentityReference"/>
</f></Translate>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Security.Principal.IdentityReference"</e></m>
		</meta>
	</class>
	<enum path="cs.system.security.principal.PrincipalPolicy" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.security.principal.PrincipalPolicy">
		<UnauthenticatedPrincipal><meta><m n=":csNative"><e>0</e></m></meta></UnauthenticatedPrincipal>
		<NoPrincipal><meta><m n=":csNative"><e>1</e></m></meta></NoPrincipal>
		<WindowsPrincipal><meta><m n=":csNative"><e>2</e></m></meta></WindowsPrincipal>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Security.Principal.PrincipalPolicy"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.text.Decoder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.text.Decoder" extern="1" abstract="1">
		<FallbackBuffer public="1" get="accessor" set="null"><c path="cs.system.text.DecoderFallbackBuffer"/></FallbackBuffer>
		<Fallback public="1" get="accessor" set="accessor"><c path="cs.system.text.DecoderFallback"/></Fallback>
		<get_Fallback final="1" public="1" set="method"><f a=""><c path="cs.system.text.DecoderFallback"/></f></get_Fallback>
		<set_Fallback final="1" public="1" set="method"><f a="value">
	<c path="cs.system.text.DecoderFallback"/>
	<c path="cs.system.text.DecoderFallback"/>
</f></set_Fallback>
		<get_FallbackBuffer final="1" public="1" set="method"><f a=""><c path="cs.system.text.DecoderFallbackBuffer"/></f></get_FallbackBuffer>
		<GetCharCount abstract="1" public="1" set="method">
			<f a="bytes:index:count">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<overloads><GetCharCount public="1" set="method"><f a="bytes:index:count:flush">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></GetCharCount></overloads>
		</GetCharCount>
		<GetChars abstract="1" public="1" set="method">
			<f a="bytes:byteIndex:byteCount:chars:charIndex">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<overloads><GetChars public="1" set="method"><f a="bytes:byteIndex:byteCount:chars:charIndex:flush">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></GetChars></overloads>
		</GetChars>
		<Reset public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<Convert public="1" set="method"><f a="bytes:byteIndex:byteCount:chars:charIndex:charCount:flush:bytesUsed:charsUsed:completed">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<t path="cs.Out"><x path="Int"/></t>
	<t path="cs.Out"><x path="Int"/></t>
	<t path="cs.Out"><x path="Bool"/></t>
	<x path="Void"/>
</f></Convert>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.Decoder"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.DecoderFallback" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.text.DecoderFallback" extern="1" abstract="1">
		<ReplacementFallback public="1" get="accessor" set="null" static="1"><c path="cs.system.text.DecoderFallback"/></ReplacementFallback>
		<ExceptionFallback public="1" get="accessor" set="null" static="1"><c path="cs.system.text.DecoderFallback"/></ExceptionFallback>
		<get_ExceptionFallback public="1" set="method" static="1"><f a=""><c path="cs.system.text.DecoderFallback"/></f></get_ExceptionFallback>
		<get_ReplacementFallback public="1" set="method" static="1"><f a=""><c path="cs.system.text.DecoderFallback"/></f></get_ReplacementFallback>
		<MaxCharCount public="1" get="accessor" set="null"><x path="Int"/></MaxCharCount>
		<get_MaxCharCount abstract="1" public="1" set="method"><f a=""><x path="Int"/></f></get_MaxCharCount>
		<CreateFallbackBuffer abstract="1" public="1" set="method"><f a=""><c path="cs.system.text.DecoderFallbackBuffer"/></f></CreateFallbackBuffer>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.DecoderFallback"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.DecoderFallbackBuffer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.text.DecoderFallbackBuffer" extern="1" abstract="1">
		<Remaining public="1" get="accessor" set="null"><x path="Int"/></Remaining>
		<get_Remaining abstract="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Remaining>
		<Fallback abstract="1" public="1" set="method"><f a="bytesUnknown:index">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Bool"/>
</f></Fallback>
		<GetNextChar abstract="1" public="1" set="method"><f a=""><t path="cs.types.Char16"/></f></GetNextChar>
		<MovePrevious abstract="1" public="1" set="method"><f a=""><x path="Bool"/></f></MovePrevious>
		<Reset public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.DecoderFallbackBuffer"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.Encoder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.text.Encoder" extern="1" abstract="1">
		<FallbackBuffer public="1" get="accessor" set="null"><c path="cs.system.text.EncoderFallbackBuffer"/></FallbackBuffer>
		<Fallback public="1" get="accessor" set="accessor"><c path="cs.system.text.EncoderFallback"/></Fallback>
		<get_Fallback final="1" public="1" set="method"><f a=""><c path="cs.system.text.EncoderFallback"/></f></get_Fallback>
		<set_Fallback final="1" public="1" set="method"><f a="value">
	<c path="cs.system.text.EncoderFallback"/>
	<c path="cs.system.text.EncoderFallback"/>
</f></set_Fallback>
		<get_FallbackBuffer final="1" public="1" set="method"><f a=""><c path="cs.system.text.EncoderFallbackBuffer"/></f></get_FallbackBuffer>
		<GetByteCount abstract="1" public="1" set="method"><f a="chars:index:count:flush">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></GetByteCount>
		<GetBytes abstract="1" public="1" set="method"><f a="chars:charIndex:charCount:bytes:byteIndex:flush">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></GetBytes>
		<Reset public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<Convert public="1" set="method"><f a="chars:charIndex:charCount:bytes:byteIndex:byteCount:flush:charsUsed:bytesUsed:completed">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<t path="cs.Out"><x path="Int"/></t>
	<t path="cs.Out"><x path="Int"/></t>
	<t path="cs.Out"><x path="Bool"/></t>
	<x path="Void"/>
</f></Convert>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.Encoder"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.EncoderFallback" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.text.EncoderFallback" extern="1" abstract="1">
		<ReplacementFallback public="1" get="accessor" set="null" static="1"><c path="cs.system.text.EncoderFallback"/></ReplacementFallback>
		<ExceptionFallback public="1" get="accessor" set="null" static="1"><c path="cs.system.text.EncoderFallback"/></ExceptionFallback>
		<get_ExceptionFallback public="1" set="method" static="1"><f a=""><c path="cs.system.text.EncoderFallback"/></f></get_ExceptionFallback>
		<get_ReplacementFallback public="1" set="method" static="1"><f a=""><c path="cs.system.text.EncoderFallback"/></f></get_ReplacementFallback>
		<MaxCharCount public="1" get="accessor" set="null"><x path="Int"/></MaxCharCount>
		<get_MaxCharCount abstract="1" public="1" set="method"><f a=""><x path="Int"/></f></get_MaxCharCount>
		<CreateFallbackBuffer abstract="1" public="1" set="method"><f a=""><c path="cs.system.text.EncoderFallbackBuffer"/></f></CreateFallbackBuffer>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.EncoderFallback"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.EncoderFallbackBuffer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.text.EncoderFallbackBuffer" extern="1" abstract="1">
		<Remaining public="1" get="accessor" set="null"><x path="Int"/></Remaining>
		<get_Remaining abstract="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Remaining>
		<Fallback abstract="1" public="1" set="method">
			<f a="charUnknown:index">
				<t path="cs.types.Char16"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads><Fallback abstract="1" public="1" set="method"><f a="charUnknownHigh:charUnknownLow:index">
	<t path="cs.types.Char16"/>
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></Fallback></overloads>
		</Fallback>
		<GetNextChar abstract="1" public="1" set="method"><f a=""><t path="cs.types.Char16"/></f></GetNextChar>
		<MovePrevious abstract="1" public="1" set="method"><f a=""><x path="Bool"/></f></MovePrevious>
		<Reset public="1" set="method"><f a=""><x path="Void"/></f></Reset>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.EncoderFallbackBuffer"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.Encoding_ForwardingEncoder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.text.Encoding" module="cs.system.text.Encoding" extern="1" final="1">
		<extends path="cs.system.text.Encoder"/>
		<GetByteCount public="1" set="method" override="1"><f a="chars:index:count:flush">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></GetByteCount>
		<GetBytes public="1" set="method" override="1"><f a="chars:charIndex:charCount:bytes:byteCount:flush">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></GetBytes>
		<new final="1" public="1" set="method"><f a="enc">
	<c path="cs.system.text.Encoding"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.Encoding.ForwardingEncoder"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.Encoding_ForwardingDecoder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.text.Encoding" module="cs.system.text.Encoding" extern="1" final="1">
		<extends path="cs.system.text.Decoder"/>
		<GetCharCount public="1" set="method" override="1"><f a="bytes:index:count">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></GetCharCount>
		<GetChars public="1" set="method" override="1"><f a="bytes:byteIndex:byteCount:chars:charIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
</f></GetChars>
		<new final="1" public="1" set="method"><f a="enc">
	<c path="cs.system.text.Encoding"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.Encoding.ForwardingDecoder"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.Encoding" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.text.Encoding" extern="1" abstract="1">
		<implements path="cs.system.ICloneable"/>
		<UTF32 public="1" get="accessor" set="null" static="1"><c path="cs.system.text.Encoding"/></UTF32>
		<Unicode public="1" get="accessor" set="null" static="1"><c path="cs.system.text.Encoding"/></Unicode>
		<UTF8 public="1" get="accessor" set="null" static="1"><c path="cs.system.text.Encoding"/></UTF8>
		<UTF7 public="1" get="accessor" set="null" static="1"><c path="cs.system.text.Encoding"/></UTF7>
		<Default public="1" get="accessor" set="null" static="1"><c path="cs.system.text.Encoding"/></Default>
		<BigEndianUnicode public="1" get="accessor" set="null" static="1"><c path="cs.system.text.Encoding"/></BigEndianUnicode>
		<ASCII public="1" get="accessor" set="null" static="1"><c path="cs.system.text.Encoding"/></ASCII>
		<Convert public="1" set="method" static="1">
			<f a="srcEncoding:dstEncoding:bytes">
				<c path="cs.system.text.Encoding"/>
				<c path="cs.system.text.Encoding"/>
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
			</f>
			<overloads><Convert public="1" set="method"><f a="srcEncoding:dstEncoding:bytes:index:count">
	<c path="cs.system.text.Encoding"/>
	<c path="cs.system.text.Encoding"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></Convert></overloads>
		</Convert>
		<GetEncoding public="1" set="method" static="1">
			<f a="codepage">
				<x path="Int"/>
				<c path="cs.system.text.Encoding"/>
			</f>
			<overloads>
				<GetEncoding public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="cs.system.text.Encoding"/>
</f></GetEncoding>
				<GetEncoding public="1" set="method"><f a="name:encoderFallback:decoderFallback">
	<c path="String"/>
	<c path="cs.system.text.EncoderFallback"/>
	<c path="cs.system.text.DecoderFallback"/>
	<c path="cs.system.text.Encoding"/>
</f></GetEncoding>
				<GetEncoding public="1" set="method"><f a="codepage:encoderFallback:decoderFallback">
	<x path="Int"/>
	<c path="cs.system.text.EncoderFallback"/>
	<c path="cs.system.text.DecoderFallback"/>
	<c path="cs.system.text.Encoding"/>
</f></GetEncoding>
			</overloads>
		</GetEncoding>
		<GetEncodings public="1" set="method" static="1"><f a=""><c path="cs.NativeArray"><c path="cs.system.text.EncodingInfo"/></c></f></GetEncodings>
		<get_ASCII public="1" set="method" static="1"><f a=""><c path="cs.system.text.Encoding"/></f></get_ASCII>
		<get_BigEndianUnicode public="1" set="method" static="1"><f a=""><c path="cs.system.text.Encoding"/></f></get_BigEndianUnicode>
		<get_Default public="1" set="method" static="1"><f a=""><c path="cs.system.text.Encoding"/></f></get_Default>
		<get_UTF7 public="1" set="method" static="1"><f a=""><c path="cs.system.text.Encoding"/></f></get_UTF7>
		<get_UTF8 public="1" set="method" static="1"><f a=""><c path="cs.system.text.Encoding"/></f></get_UTF8>
		<get_Unicode public="1" set="method" static="1"><f a=""><c path="cs.system.text.Encoding"/></f></get_Unicode>
		<get_UTF32 public="1" set="method" static="1"><f a=""><c path="cs.system.text.Encoding"/></f></get_UTF32>
		<WindowsCodePage public="1" get="accessor" set="null"><x path="Int"/></WindowsCodePage>
		<WebName public="1" get="accessor" set="null"><c path="String"/></WebName>
		<IsMailNewsSave public="1" get="accessor" set="null"><x path="Bool"/></IsMailNewsSave>
		<IsMailNewsDisplay public="1" get="accessor" set="null"><x path="Bool"/></IsMailNewsDisplay>
		<IsBrowserSave public="1" get="accessor" set="null"><x path="Bool"/></IsBrowserSave>
		<IsBrowserDisplay public="1" get="accessor" set="null"><x path="Bool"/></IsBrowserDisplay>
		<HeaderName public="1" get="accessor" set="null"><c path="String"/></HeaderName>
		<EncodingName public="1" get="accessor" set="null"><c path="String"/></EncodingName>
		<CodePage public="1" get="accessor" set="null"><x path="Int"/></CodePage>
		<BodyName public="1" get="accessor" set="null"><c path="String"/></BodyName>
		<EncoderFallback public="1" get="accessor" set="accessor"><c path="cs.system.text.EncoderFallback"/></EncoderFallback>
		<DecoderFallback public="1" get="accessor" set="accessor"><c path="cs.system.text.DecoderFallback"/></DecoderFallback>
		<IsSingleByte public="1" get="accessor" set="null"><x path="Bool"/></IsSingleByte>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<get_IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_IsSingleByte public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSingleByte>
		<get_DecoderFallback final="1" public="1" set="method"><f a=""><c path="cs.system.text.DecoderFallback"/></f></get_DecoderFallback>
		<set_DecoderFallback final="1" public="1" set="method"><f a="value">
	<c path="cs.system.text.DecoderFallback"/>
	<c path="cs.system.text.DecoderFallback"/>
</f></set_DecoderFallback>
		<get_EncoderFallback final="1" public="1" set="method"><f a=""><c path="cs.system.text.EncoderFallback"/></f></get_EncoderFallback>
		<set_EncoderFallback final="1" public="1" set="method"><f a="value">
	<c path="cs.system.text.EncoderFallback"/>
	<c path="cs.system.text.EncoderFallback"/>
</f></set_EncoderFallback>
		<GetByteCount abstract="1" public="1" set="method">
			<f a="chars:index:count">
				<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<overloads>
				<GetByteCount public="1" set="method"><f a="chars">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
</f></GetByteCount>
				<GetByteCount public="1" set="method"><f a="s">
	<c path="String"/>
	<x path="Int"/>
</f></GetByteCount>
			</overloads>
		</GetByteCount>
		<GetBytes abstract="1" public="1" set="method">
			<f a="chars:charIndex:charCount:bytes:byteIndex">
				<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<overloads>
				<GetBytes public="1" set="method"><f a="chars">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></GetBytes>
				<GetBytes public="1" set="method"><f a="chars:index:count">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></GetBytes>
				<GetBytes public="1" set="method"><f a="s">
	<c path="String"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
</f></GetBytes>
				<GetBytes public="1" set="method"><f a="s:charIndex:charCount:bytes:byteIndex">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
</f></GetBytes>
			</overloads>
		</GetBytes>
		<GetCharCount abstract="1" public="1" set="method">
			<f a="bytes:index:count">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<overloads><GetCharCount public="1" set="method"><f a="bytes">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
</f></GetCharCount></overloads>
		</GetCharCount>
		<GetChars abstract="1" public="1" set="method">
			<f a="bytes:byteIndex:byteCount:chars:charIndex">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<overloads>
				<GetChars public="1" set="method"><f a="bytes">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
</f></GetChars>
				<GetChars public="1" set="method"><f a="bytes:index:count">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
</f></GetChars>
			</overloads>
		</GetChars>
		<GetDecoder public="1" set="method"><f a=""><c path="cs.system.text.Decoder"/></f></GetDecoder>
		<GetEncoder public="1" set="method"><f a=""><c path="cs.system.text.Encoder"/></f></GetEncoder>
		<Clone public="1" set="method"><f a=""><d/></f></Clone>
		<IsAlwaysNormalized final="1" public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<overloads><IsAlwaysNormalized public="1" set="method"><f a="form">
	<e path="cs.system.text.NormalizationForm"/>
	<x path="Bool"/>
</f></IsAlwaysNormalized></overloads>
		</IsAlwaysNormalized>
		<GetMaxByteCount abstract="1" public="1" set="method"><f a="charCount">
	<x path="Int"/>
	<x path="Int"/>
</f></GetMaxByteCount>
		<GetMaxCharCount abstract="1" public="1" set="method"><f a="byteCount">
	<x path="Int"/>
	<x path="Int"/>
</f></GetMaxCharCount>
		<GetPreamble public="1" set="method"><f a=""><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></f></GetPreamble>
		<GetString public="1" set="method">
			<f a="bytes:index:count">
				<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<overloads><GetString public="1" set="method"><f a="bytes">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<c path="String"/>
</f></GetString></overloads>
		</GetString>
		<get_BodyName public="1" set="method"><f a=""><c path="String"/></f></get_BodyName>
		<get_CodePage public="1" set="method"><f a=""><x path="Int"/></f></get_CodePage>
		<get_EncodingName public="1" set="method"><f a=""><c path="String"/></f></get_EncodingName>
		<get_HeaderName public="1" set="method"><f a=""><c path="String"/></f></get_HeaderName>
		<get_IsBrowserDisplay public="1" set="method"><f a=""><x path="Bool"/></f></get_IsBrowserDisplay>
		<get_IsBrowserSave public="1" set="method"><f a=""><x path="Bool"/></f></get_IsBrowserSave>
		<get_IsMailNewsDisplay public="1" set="method"><f a=""><x path="Bool"/></f></get_IsMailNewsDisplay>
		<get_IsMailNewsSave public="1" set="method"><f a=""><x path="Bool"/></f></get_IsMailNewsSave>
		<get_WebName public="1" set="method"><f a=""><c path="String"/></f></get_WebName>
		<get_WindowsCodePage public="1" set="method"><f a=""><x path="Int"/></f></get_WindowsCodePage>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
			<overloads><new final="1" set="method">
	<f a="codePage">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<meta><m n=":protected"/></meta>
</new></overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.Encoding"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.EncodingInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.text.EncodingInfo" extern="1" final="1">
		<Name public="1" get="accessor" set="null"><c path="String"/></Name>
		<DisplayName public="1" get="accessor" set="null"><c path="String"/></DisplayName>
		<CodePage public="1" get="accessor" set="null"><x path="Int"/></CodePage>
		<get_CodePage final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_CodePage>
		<get_DisplayName final="1" public="1" set="method"><f a=""><c path="String"/></f></get_DisplayName>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<GetEncoding final="1" public="1" set="method"><f a=""><c path="cs.system.text.Encoding"/></f></GetEncoding>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.EncodingInfo"</e></m>
		</meta>
	</class>
	<enum path="cs.system.text.NormalizationForm" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.text.NormalizationForm">
		<FormC><meta><m n=":csNative"><e>1</e></m></meta></FormC>
		<FormD><meta><m n=":csNative"><e>2</e></m></meta></FormD>
		<FormKC><meta><m n=":csNative"><e>5</e></m></meta></FormKC>
		<FormKD><meta><m n=":csNative"><e>6</e></m></meta></FormKD>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Text.NormalizationForm"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.text.StringBuilder" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.text.StringBuilder" extern="1" final="1">
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<Length public="1" get="accessor" set="accessor"><x path="Int"/></Length>
		<Capacity public="1" get="accessor" set="accessor"><x path="Int"/></Capacity>
		<MaxCapacity public="1" get="accessor" set="null"><x path="Int"/></MaxCapacity>
		<get_MaxCapacity final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_MaxCapacity>
		<get_Capacity final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Capacity>
		<set_Capacity final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_Capacity>
		<get_Length final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Length>
		<set_Length final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_Length>
		<get_Chars final="1" public="1" set="method"><f a="index">
	<x path="Int"/>
	<t path="cs.types.Char16"/>
</f></get_Chars>
		<set_Chars final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<t path="cs.types.Char16"/>
	<x path="Void"/>
</f></set_Chars>
		<ToString public="1" set="method">
			<f a=""><c path="String"/></f>
			<overloads><ToString final="1" public="1" set="method"><f a="startIndex:length">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></ToString></overloads>
		</ToString>
		<EnsureCapacity final="1" public="1" set="method"><f a="capacity">
	<x path="Int"/>
	<x path="Int"/>
</f></EnsureCapacity>
		<Remove final="1" public="1" set="method"><f a="startIndex:length">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Remove>
		<Replace final="1" public="1" set="method">
			<f a="oldChar:newChar">
				<t path="cs.types.Char16"/>
				<t path="cs.types.Char16"/>
				<c path="cs.system.text.StringBuilder"/>
			</f>
			<overloads>
				<Replace final="1" public="1" set="method"><f a="oldValue:newValue:startIndex:count">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Replace>
				<Replace final="1" public="1" set="method"><f a="oldValue:newValue">
	<c path="String"/>
	<c path="String"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Replace>
				<Replace final="1" public="1" set="method"><f a="oldChar:newChar:startIndex:count">
	<t path="cs.types.Char16"/>
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Replace>
			</overloads>
		</Replace>
		<Append final="1" public="1" set="method">
			<f a="value">
				<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
				<c path="cs.system.text.StringBuilder"/>
			</f>
			<overloads>
				<Append final="1" public="1" set="method"><f a="value:startIndex:count">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value:startIndex:charCount">
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value:repeatCount">
	<t path="cs.types.Char16"/>
	<x path="Int"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<t path="cs.types.Char16"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<t path="cs.types.UInt64"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<x path="UInt"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<t path="cs.types.UInt16"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<x path="Single"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<t path="cs.types.Int8"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<d/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<x path="haxe.Int64"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<x path="Int"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<t path="cs.types.Int16"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<x path="Float"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<c path="cs.system.Decimal"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<t path="cs.types.UInt8"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
				<Append final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Append>
			</overloads>
		</Append>
		<AppendLine final="1" public="1" set="method">
			<f a=""><c path="cs.system.text.StringBuilder"/></f>
			<overloads><AppendLine final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="cs.system.text.StringBuilder"/>
</f></AppendLine></overloads>
		</AppendLine>
		<AppendFormat final="1" public="1" set="method">
			<f a="format:args">
				<c path="String"/>
				<c path="cs.NativeArray"><d/></c>
				<c path="cs.system.text.StringBuilder"/>
			</f>
			<overloads>
				<AppendFormat final="1" public="1" set="method"><f a="format:arg0:arg1:arg2">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<c path="cs.system.text.StringBuilder"/>
</f></AppendFormat>
				<AppendFormat final="1" public="1" set="method"><f a="format:arg0:arg1">
	<c path="String"/>
	<d/>
	<d/>
	<c path="cs.system.text.StringBuilder"/>
</f></AppendFormat>
				<AppendFormat final="1" public="1" set="method"><f a="format:arg0">
	<c path="String"/>
	<d/>
	<c path="cs.system.text.StringBuilder"/>
</f></AppendFormat>
				<AppendFormat final="1" public="1" set="method"><f a="provider:format:args">
	<c path="cs.system.IFormatProvider"/>
	<c path="String"/>
	<c path="cs.NativeArray"><d/></c>
	<c path="cs.system.text.StringBuilder"/>
</f></AppendFormat>
			</overloads>
		</AppendFormat>
		<Insert final="1" public="1" set="method">
			<f a="index:value">
				<x path="Int"/>
				<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
				<c path="cs.system.text.StringBuilder"/>
			</f>
			<overloads>
				<Insert final="1" public="1" set="method"><f a="index:value:startIndex:charCount">
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value:count">
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<t path="cs.types.UInt64"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="UInt"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<t path="cs.types.UInt16"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Single"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<t path="cs.types.Int8"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<d/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="haxe.Int64"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Int"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<t path="cs.types.Int16"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Float"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<c path="cs.system.Decimal"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<t path="cs.types.Char16"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<t path="cs.types.UInt8"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Bool"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
				<Insert final="1" public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<c path="String"/>
	<c path="cs.system.text.StringBuilder"/>
</f></Insert>
			</overloads>
		</Insert>
		<CopyTo final="1" public="1" set="method"><f a="sourceIndex:destination:destinationIndex:count">
	<x path="Int"/>
	<c path="cs.NativeArray"><t path="cs.types.Char16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<new final="1" public="1" set="method">
			<f a="value:startIndex:length:capacity">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="value:capacity">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="capacity:maxCapacity">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="capacity">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.StringBuilder"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.regularexpressions.Capture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.Capture" extern="1">
		<Value public="1" get="accessor" set="null"><c path="String"/></Value>
		<Length public="1" get="accessor" set="null"><x path="Int"/></Length>
		<Index public="1" get="accessor" set="null"><x path="Int"/></Index>
		<get_Index final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Index>
		<get_Length final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Length>
		<get_Value final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Value>
		<ToString public="1" set="method"><f a=""><c path="String"/></f></ToString>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.Capture"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.regularexpressions.CaptureCollection" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.CaptureCollection" extern="1">
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<get_Count final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_IsSynchronized final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_Item final="1" public="1" set="method"><f a="i">
	<x path="Int"/>
	<c path="cs.system.text.regularexpressions.Capture"/>
</f></get_Item>
		<get_SyncRoot final="1" public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<CopyTo final="1" public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<GetEnumerator final="1" public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.CaptureCollection"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.regularexpressions.Group" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.Group" extern="1">
		<extends path="cs.system.text.regularexpressions.Capture"/>
		<Synchronized public="1" set="method" static="1"><f a="inner">
	<c path="cs.system.text.regularexpressions.Group"/>
	<c path="cs.system.text.regularexpressions.Group"/>
</f></Synchronized>
		<Success public="1" get="accessor" set="null"><x path="Bool"/></Success>
		<Captures public="1" get="accessor" set="null"><c path="cs.system.text.regularexpressions.CaptureCollection"/></Captures>
		<get_Captures final="1" public="1" set="method"><f a=""><c path="cs.system.text.regularexpressions.CaptureCollection"/></f></get_Captures>
		<get_Success final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_Success>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.Group"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.regularexpressions.GroupCollection" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.GroupCollection" extern="1">
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<get_Count final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_IsSynchronized final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_Item final="1" public="1" set="method">
			<f a="i">
				<x path="Int"/>
				<c path="cs.system.text.regularexpressions.Group"/>
			</f>
			<overloads><get_Item final="1" public="1" set="method"><f a="groupName">
	<c path="String"/>
	<c path="cs.system.text.regularexpressions.Group"/>
</f></get_Item></overloads>
		</get_Item>
		<get_SyncRoot final="1" public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<CopyTo final="1" public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<GetEnumerator final="1" public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.GroupCollection"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.regularexpressions.Match" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.Match" extern="1">
		<extends path="cs.system.text.regularexpressions.Group"/>
		<Empty public="1" get="accessor" set="null" static="1"><c path="cs.system.text.regularexpressions.Match"/></Empty>
		<get_Empty public="1" set="method" static="1"><f a=""><c path="cs.system.text.regularexpressions.Match"/></f></get_Empty>
		<Synchronized public="1" set="method" static="1"><f a="inner">
	<c path="cs.system.text.regularexpressions.Match"/>
	<c path="cs.system.text.regularexpressions.Match"/>
</f></Synchronized>
		<Groups public="1" get="accessor" set="null"><c path="cs.system.text.regularexpressions.GroupCollection"/></Groups>
		<get_Groups public="1" set="method"><f a=""><c path="cs.system.text.regularexpressions.GroupCollection"/></f></get_Groups>
		<NextMatch final="1" public="1" set="method"><f a=""><c path="cs.system.text.regularexpressions.Match"/></f></NextMatch>
		<Result public="1" set="method"><f a="replacement">
	<c path="String"/>
	<c path="String"/>
</f></Result>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.Match"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.regularexpressions.MatchCollection_Enumerator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.MatchCollection" module="cs.system.text.regularexpressions.MatchCollection" extern="1">
		<implements path="cs.system.collections.IEnumerator"/>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.MatchCollection.Enumerator"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.regularexpressions.MatchCollection" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.MatchCollection" extern="1">
		<implements path="cs.system.collections.ICollection"/>
		<implements path="cs.system.collections.IEnumerable"/>
		<SyncRoot public="1" get="accessor" set="null"><d/></SyncRoot>
		<IsSynchronized public="1" get="accessor" set="null"><x path="Bool"/></IsSynchronized>
		<IsReadOnly public="1" get="accessor" set="null"><x path="Bool"/></IsReadOnly>
		<Count public="1" get="accessor" set="null"><x path="Int"/></Count>
		<get_Count final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_Count>
		<get_IsReadOnly final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsReadOnly>
		<get_IsSynchronized final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsSynchronized>
		<get_Item public="1" set="method"><f a="i">
	<x path="Int"/>
	<c path="cs.system.text.regularexpressions.Match"/>
</f></get_Item>
		<get_SyncRoot final="1" public="1" set="method"><f a=""><d/></f></get_SyncRoot>
		<CopyTo final="1" public="1" set="method"><f a="array:index">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CopyTo>
		<GetEnumerator final="1" public="1" set="method"><f a=""><c path="cs.system.collections.IEnumerator"/></f></GetEnumerator>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.MatchCollection"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.regularexpressions.Delegate_MatchEvaluator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.MatchEvaluator" module="cs.system.text.regularexpressions.MatchEvaluator" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
	<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
	<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
	<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
	<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="match">
	<c path="cs.system.text.regularexpressions.Match"/>
	<c path="String"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="match:callback:object">
	<c path="cs.system.text.regularexpressions.Match"/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<c path="String"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.MatchEvaluator"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.text.regularexpressions.MatchEvaluator" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.MatchEvaluator">
		<from><icast field="FromHaxeFunction"><f a="">
	<c path="cs.system.text.regularexpressions.Match"/>
	<c path="String"/>
</f></icast></from>
		<this><c path="cs.system.text.regularexpressions.Delegate_MatchEvaluator"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.text.regularexpressions._MatchEvaluator.MatchEvaluator_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.MatchEvaluator" private="1" module="cs.system.text.regularexpressions.MatchEvaluator" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="cs.system.text.regularexpressions.Match"/>
				<c path="String"/>
			</f>
			<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<c path="cs.system.text.regularexpressions.Match"/>
				<c path="String"/>
			</f>
			<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.text.regularexpressions.Delegate_MatchEvaluator"/>
	<c path="cs.system.text.regularexpressions.Delegate_MatchEvaluator"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
			<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
			<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
			<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
			<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.text.regularexpressions._MatchEvaluator.MatchEvaluator_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.MatchEvaluator" private="1" module="cs.system.text.regularexpressions.MatchEvaluator" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="cs.system.text.regularexpressions.Match"/>
					<c path="String"/>
				</f>
				<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<c path="cs.system.text.regularexpressions.Match"/>
					<c path="String"/>
				</f>
				<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.text.regularexpressions.Delegate_MatchEvaluator"/>
	<c path="cs.system.text.regularexpressions.Delegate_MatchEvaluator"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
				<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
				<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
				<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
				<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.text.regularexpressions.Regex_Adapter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.Regex" module="cs.system.text.regularexpressions.Regex" extern="1">
		<Evaluate final="1" public="1" set="method"><f a="m:sb">
	<c path="cs.system.text.regularexpressions.Match"/>
	<c path="cs.system.text.StringBuilder"/>
	<x path="Void"/>
</f></Evaluate>
		<new final="1" public="1" set="method"><f a="ev">
	<x path="cs.system.text.regularexpressions.MatchEvaluator"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.Regex.Adapter"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.regularexpressions.RegexCompilationInfo" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.RegexCompilationInfo" extern="1">
		<Pattern public="1" get="accessor" set="accessor"><c path="String"/></Pattern>
		<Options public="1" get="accessor" set="accessor"><e path="cs.system.text.regularexpressions.RegexOptions"/></Options>
		<Namespace public="1" get="accessor" set="accessor"><c path="String"/></Namespace>
		<Name public="1" get="accessor" set="accessor"><c path="String"/></Name>
		<IsPublic public="1" get="accessor" set="accessor"><x path="Bool"/></IsPublic>
		<get_IsPublic final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsPublic>
		<set_IsPublic final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_IsPublic>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<set_Name final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Name>
		<get_Namespace final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Namespace>
		<set_Namespace final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Namespace>
		<get_Options final="1" public="1" set="method"><f a=""><e path="cs.system.text.regularexpressions.RegexOptions"/></f></get_Options>
		<set_Options final="1" public="1" set="method"><f a="value">
	<e path="cs.system.text.regularexpressions.RegexOptions"/>
	<e path="cs.system.text.regularexpressions.RegexOptions"/>
</f></set_Options>
		<get_Pattern final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Pattern>
		<set_Pattern final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Pattern>
		<new final="1" public="1" set="method"><f a="pattern:options:name:fullnamespace:ispublic">
	<c path="String"/>
	<e path="cs.system.text.regularexpressions.RegexOptions"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.RegexCompilationInfo"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.regularexpressions.RegexRunner" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.RegexRunner" extern="1" abstract="1">
		<CharInClass set="method" static="1">
			<f a="ch:charClass">
				<t path="cs.types.Char16"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</CharInClass>
		<CharInSet set="method" static="1">
			<f a="ch:set:category">
				<t path="cs.types.Char16"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</CharInSet>
		<runtrackpos><x path="Int"/></runtrackpos>
		<runtrackcount><x path="Int"/></runtrackcount>
		<runtrack><c path="cs.NativeArray"><x path="Int"/></c></runtrack>
		<runtextstart><x path="Int"/></runtextstart>
		<runtextpos><x path="Int"/></runtextpos>
		<runtextend><x path="Int"/></runtextend>
		<runtextbeg><x path="Int"/></runtextbeg>
		<runtext><c path="String"/></runtext>
		<runstackpos><x path="Int"/></runstackpos>
		<runstack><c path="cs.NativeArray"><x path="Int"/></c></runstack>
		<runregex><c path="cs.system.text.regularexpressions.Regex"/></runregex>
		<runmatch><c path="cs.system.text.regularexpressions.Match"/></runmatch>
		<runcrawlpos><x path="Int"/></runcrawlpos>
		<runcrawl><c path="cs.NativeArray"><x path="Int"/></c></runcrawl>
		<FindFirstChar abstract="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</FindFirstChar>
		<Go abstract="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</Go>
		<InitTrackCount abstract="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</InitTrackCount>
		<Capture final="1" set="method">
			<f a="capnum:start:end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</Capture>
		<Crawl final="1" set="method">
			<f a="i">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</Crawl>
		<Crawlpos final="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":protected"/></meta>
		</Crawlpos>
		<DoubleCrawl final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</DoubleCrawl>
		<DoubleStack final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</DoubleStack>
		<DoubleTrack final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</DoubleTrack>
		<EnsureStorage final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</EnsureStorage>
		<IsBoundary final="1" set="method">
			<f a="index:startpos:endpos">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</IsBoundary>
		<IsECMABoundary final="1" set="method">
			<f a="index:startpos:endpos">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</IsECMABoundary>
		<IsMatched final="1" set="method">
			<f a="cap">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":protected"/></meta>
		</IsMatched>
		<MatchIndex final="1" set="method">
			<f a="cap">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":protected"/></meta>
		</MatchIndex>
		<MatchLength final="1" set="method">
			<f a="cap">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":protected"/></meta>
		</MatchLength>
		<Popcrawl final="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":protected"/></meta>
		</Popcrawl>
		<TransferCapture final="1" set="method">
			<f a="capnum:uncapnum:start:end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</TransferCapture>
		<Uncapture final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</Uncapture>
		<Scan final="1" set="method">
			<f a="regex:text:textbeg:textend:textstart:prevlen:quick">
				<c path="cs.system.text.regularexpressions.Regex"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="cs.system.text.regularexpressions.Match"/>
			</f>
			<meta><m n=":protected"/></meta>
		</Scan>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.RegexRunner"</e></m>
		</meta>
	</class>
	<class path="cs.system.text.regularexpressions.RegexRunnerFactory" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/System.dll @ cs.system.text.regularexpressions.RegexRunnerFactory" extern="1" abstract="1">
		<CreateInstance abstract="1" set="method">
			<f a=""><c path="cs.system.text.regularexpressions.RegexRunner"/></f>
			<meta><m n=":protected"/></meta>
		</CreateInstance>
		<new final="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Text.RegularExpressions.RegexRunnerFactory"</e></m>
		</meta>
	</class>
	<enum path="cs.system.threading.ApartmentState" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ApartmentState">
		<STA><meta><m n=":csNative"><e>0</e></m></meta></STA>
		<MTA><meta><m n=":csNative"><e>1</e></m></meta></MTA>
		<Unknown><meta><m n=":csNative"><e>2</e></m></meta></Unknown>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Threading.ApartmentState"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.threading.AsyncFlowControl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.AsyncFlowControl" extern="1" final="1">
		<extends path="cs.system.ValueType"/>
		<implements path="cs.system.IDisposable"/>
		<op_Equality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.threading.AsyncFlowControl"/>
	<c path="cs.system.threading.AsyncFlowControl"/>
	<x path="Bool"/>
</f></op_Equality>
		<op_Inequality public="1" set="method" static="1"><f a="a:b">
	<c path="cs.system.threading.AsyncFlowControl"/>
	<c path="cs.system.threading.AsyncFlowControl"/>
	<x path="Bool"/>
</f></op_Inequality>
		<Undo final="1" public="1" set="method"><f a=""><x path="Void"/></f></Undo>
		<meta>
			<m n=":nativeGen"/>
			<m n=":struct"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.AsyncFlowControl"</e></m>
		</meta>
	</class>
	<class path="cs.system.threading.CompressedStack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.CompressedStack" extern="1" final="1">
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<Capture public="1" set="method" static="1"><f a=""><c path="cs.system.threading.CompressedStack"/></f></Capture>
		<GetCompressedStack public="1" set="method" static="1"><f a=""><c path="cs.system.threading.CompressedStack"/></f></GetCompressedStack>
		<Run public="1" set="method" static="1"><f a="compressedStack:callback:state">
	<c path="cs.system.threading.CompressedStack"/>
	<x path="cs.system.threading.ContextCallback"/>
	<d/>
	<x path="Void"/>
</f></Run>
		<CreateCopy final="1" public="1" set="method"><f a=""><c path="cs.system.threading.CompressedStack"/></f></CreateCopy>
		<GetObjectData final="1" public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.CompressedStack"</e></m>
		</meta>
	</class>
	<class path="cs.system.threading.Delegate_ContextCallback" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ContextCallback" module="cs.system.threading.ContextCallback" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.threading.ContextCallback"/>
	<x path="cs.system.threading.ContextCallback"/>
	<x path="cs.system.threading.ContextCallback"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.threading.ContextCallback"/>
	<x path="cs.system.threading.ContextCallback"/>
	<x path="cs.system.threading.ContextCallback"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="state">
	<d/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="state:callback:object">
	<d/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.ContextCallback"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.threading.ContextCallback" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ContextCallback">
		<from><icast field="FromHaxeFunction"><f a="">
	<d/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.threading.Delegate_ContextCallback"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.threading._ContextCallback.ContextCallback_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ContextCallback" private="1" module="cs.system.threading.ContextCallback" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<d/>
				<x path="Void"/>
			</f>
			<x path="cs.system.threading.ContextCallback"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<d/>
				<x path="Void"/>
			</f>
			<x path="cs.system.threading.ContextCallback"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.threading.Delegate_ContextCallback"/>
	<c path="cs.system.threading.Delegate_ContextCallback"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.threading.ContextCallback"/>
			<x path="cs.system.threading.ContextCallback"/>
			<x path="cs.system.threading.ContextCallback"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.threading.ContextCallback"/>
			<x path="cs.system.threading.ContextCallback"/>
			<x path="cs.system.threading.ContextCallback"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.threading._ContextCallback.ContextCallback_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ContextCallback" private="1" module="cs.system.threading.ContextCallback" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="cs.system.threading.ContextCallback"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="cs.system.threading.ContextCallback"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.threading.Delegate_ContextCallback"/>
	<c path="cs.system.threading.Delegate_ContextCallback"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.threading.ContextCallback"/>
				<x path="cs.system.threading.ContextCallback"/>
				<x path="cs.system.threading.ContextCallback"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.threading.ContextCallback"/>
				<x path="cs.system.threading.ContextCallback"/>
				<x path="cs.system.threading.ContextCallback"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<enum path="cs.system.threading.EventResetMode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.EventResetMode">
		<AutoReset><meta><m n=":csNative"><e>0</e></m></meta></AutoReset>
		<ManualReset><meta><m n=":csNative"><e>1</e></m></meta></ManualReset>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Threading.EventResetMode"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.threading.EventWaitHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.EventWaitHandle" extern="1">
		<extends path="cs.system.threading.WaitHandle"/>
		<OpenExisting public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.threading.EventWaitHandle"/>
			</f>
			<overloads><OpenExisting public="1" set="method"><f a="name:rights">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.EventWaitHandleRights"/>
	<c path="cs.system.threading.EventWaitHandle"/>
</f></OpenExisting></overloads>
		</OpenExisting>
		<GetAccessControl final="1" public="1" set="method"><f a=""><c path="cs.system.security.accesscontrol.EventWaitHandleSecurity"/></f></GetAccessControl>
		<Reset final="1" public="1" set="method"><f a=""><x path="Bool"/></f></Reset>
		<Set final="1" public="1" set="method"><f a=""><x path="Bool"/></f></Set>
		<SetAccessControl final="1" public="1" set="method"><f a="eventSecurity">
	<c path="cs.system.security.accesscontrol.EventWaitHandleSecurity"/>
	<x path="Void"/>
</f></SetAccessControl>
		<new final="1" public="1" set="method">
			<f a="initialState:mode">
				<x path="Bool"/>
				<e path="cs.system.threading.EventResetMode"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="initialState:mode:name:createdNew:eventSecurity">
	<x path="Bool"/>
	<e path="cs.system.threading.EventResetMode"/>
	<c path="String"/>
	<t path="cs.Out"><x path="Bool"/></t>
	<c path="cs.system.security.accesscontrol.EventWaitHandleSecurity"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="initialState:mode:name:createdNew">
	<x path="Bool"/>
	<e path="cs.system.threading.EventResetMode"/>
	<c path="String"/>
	<t path="cs.Out"><x path="Bool"/></t>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="initialState:mode:name">
	<x path="Bool"/>
	<e path="cs.system.threading.EventResetMode"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.EventWaitHandle"</e></m>
		</meta>
	</class>
	<class path="cs.system.threading.ExecutionContext" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ExecutionContext" extern="1" final="1">
		<implements path="cs.system.runtime.serialization.ISerializable"/>
		<Capture public="1" set="method" static="1"><f a=""><c path="cs.system.threading.ExecutionContext"/></f></Capture>
		<IsFlowSuppressed public="1" set="method" static="1"><f a=""><x path="Bool"/></f></IsFlowSuppressed>
		<RestoreFlow public="1" set="method" static="1"><f a=""><x path="Void"/></f></RestoreFlow>
		<Run public="1" set="method" static="1"><f a="executionContext:callback:state">
	<c path="cs.system.threading.ExecutionContext"/>
	<x path="cs.system.threading.ContextCallback"/>
	<d/>
	<x path="Void"/>
</f></Run>
		<SuppressFlow public="1" set="method" static="1"><f a=""><c path="cs.system.threading.AsyncFlowControl"/></f></SuppressFlow>
		<CreateCopy final="1" public="1" set="method"><f a=""><c path="cs.system.threading.ExecutionContext"/></f></CreateCopy>
		<GetObjectData final="1" public="1" set="method"><f a="info:context">
	<c path="cs.system.runtime.serialization.SerializationInfo"/>
	<c path="cs.system.runtime.serialization.StreamingContext"/>
	<x path="Void"/>
</f></GetObjectData>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.ExecutionContext"</e></m>
		</meta>
	</class>
	<class path="cs.system.threading.HostExecutionContext" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.HostExecutionContext" extern="1">
		<State get="null" set="null"><d/></State>
		<CreateCopy public="1" set="method"><f a=""><c path="cs.system.threading.HostExecutionContext"/></f></CreateCopy>
		<get_State final="1" set="method">
			<f a=""><d/></f>
			<meta><m n=":protected"/></meta>
		</get_State>
		<set_State final="1" set="method">
			<f a="value">
				<d/>
				<d/>
			</f>
			<meta><m n=":protected"/></meta>
		</set_State>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><new final="1" public="1" set="method"><f a="state">
	<d/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.HostExecutionContext"</e></m>
		</meta>
	</class>
	<class path="cs.system.threading.HostExecutionContextManager" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.HostExecutionContextManager" extern="1">
		<Capture public="1" set="method"><f a=""><c path="cs.system.threading.HostExecutionContext"/></f></Capture>
		<Revert public="1" set="method"><f a="previousState">
	<d/>
	<x path="Void"/>
</f></Revert>
		<SetHostExecutionContext public="1" set="method"><f a="hostExecutionContext">
	<c path="cs.system.threading.HostExecutionContext"/>
	<d/>
</f></SetHostExecutionContext>
		<new final="1" public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.HostExecutionContextManager"</e></m>
		</meta>
	</class>
	<class path="cs.system.threading.ManualResetEvent" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ManualResetEvent" extern="1" final="1">
		<extends path="cs.system.threading.EventWaitHandle"/>
		<new final="1" public="1" set="method"><f a="initialState">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.ManualResetEvent"</e></m>
		</meta>
	</class>
	<class path="cs.system.threading.Mutex" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.Mutex" extern="1" final="1">
		<extends path="cs.system.threading.WaitHandle"/>
		<OpenExisting public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="cs.system.threading.Mutex"/>
			</f>
			<overloads><OpenExisting public="1" set="method"><f a="name:rights">
	<c path="String"/>
	<e path="cs.system.security.accesscontrol.MutexRights"/>
	<c path="cs.system.threading.Mutex"/>
</f></OpenExisting></overloads>
		</OpenExisting>
		<GetAccessControl final="1" public="1" set="method"><f a=""><c path="cs.system.security.accesscontrol.MutexSecurity"/></f></GetAccessControl>
		<ReleaseMutex final="1" public="1" set="method"><f a=""><x path="Void"/></f></ReleaseMutex>
		<SetAccessControl final="1" public="1" set="method"><f a="mutexSecurity">
	<c path="cs.system.security.accesscontrol.MutexSecurity"/>
	<x path="Void"/>
</f></SetAccessControl>
		<new final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new final="1" public="1" set="method"><f a="initiallyOwned:name:createdNew:mutexSecurity">
	<x path="Bool"/>
	<c path="String"/>
	<t path="cs.Out"><x path="Bool"/></t>
	<c path="cs.system.security.accesscontrol.MutexSecurity"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="initiallyOwned:name:createdNew">
	<x path="Bool"/>
	<c path="String"/>
	<t path="cs.Out"><x path="Bool"/></t>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="initiallyOwned:name">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="initiallyOwned">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.Mutex"</e></m>
		</meta>
	</class>
	<class path="cs.system.threading.Delegate_ParameterizedThreadStart" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ParameterizedThreadStart" module="cs.system.threading.ParameterizedThreadStart" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.threading.ParameterizedThreadStart"/>
	<x path="cs.system.threading.ParameterizedThreadStart"/>
	<x path="cs.system.threading.ParameterizedThreadStart"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.threading.ParameterizedThreadStart"/>
	<x path="cs.system.threading.ParameterizedThreadStart"/>
	<x path="cs.system.threading.ParameterizedThreadStart"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a="obj">
	<d/>
	<x path="Void"/>
</f></Invoke>
		<BeginInvoke public="1" set="method"><f a="obj:callback:object">
	<d/>
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.ParameterizedThreadStart"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.threading.ParameterizedThreadStart" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ParameterizedThreadStart">
		<from><icast field="FromHaxeFunction"><f a="">
	<d/>
	<x path="Void"/>
</f></icast></from>
		<this><c path="cs.system.threading.Delegate_ParameterizedThreadStart"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.threading._ParameterizedThreadStart.ParameterizedThreadStart_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ParameterizedThreadStart" private="1" module="cs.system.threading.ParameterizedThreadStart" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<d/>
				<x path="Void"/>
			</f>
			<x path="cs.system.threading.ParameterizedThreadStart"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a="">
				<d/>
				<x path="Void"/>
			</f>
			<x path="cs.system.threading.ParameterizedThreadStart"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.threading.Delegate_ParameterizedThreadStart"/>
	<c path="cs.system.threading.Delegate_ParameterizedThreadStart"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.threading.ParameterizedThreadStart"/>
			<x path="cs.system.threading.ParameterizedThreadStart"/>
			<x path="cs.system.threading.ParameterizedThreadStart"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.threading.ParameterizedThreadStart"/>
			<x path="cs.system.threading.ParameterizedThreadStart"/>
			<x path="cs.system.threading.ParameterizedThreadStart"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.threading._ParameterizedThreadStart.ParameterizedThreadStart_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ParameterizedThreadStart" private="1" module="cs.system.threading.ParameterizedThreadStart" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="cs.system.threading.ParameterizedThreadStart"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="cs.system.threading.ParameterizedThreadStart"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.threading.Delegate_ParameterizedThreadStart"/>
	<c path="cs.system.threading.Delegate_ParameterizedThreadStart"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.threading.ParameterizedThreadStart"/>
				<x path="cs.system.threading.ParameterizedThreadStart"/>
				<x path="cs.system.threading.ParameterizedThreadStart"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.threading.ParameterizedThreadStart"/>
				<x path="cs.system.threading.ParameterizedThreadStart"/>
				<x path="cs.system.threading.ParameterizedThreadStart"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="cs.system.threading.Thread" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.Thread" extern="1" final="1">
		<extends path="cs.system.runtime.constrainedexecution.CriticalFinalizerObject"/>
		<implements path="cs.system.runtime.interopservices._Thread"/>
		<CurrentThread public="1" get="accessor" set="null" static="1"><c path="cs.system.threading.Thread"/></CurrentThread>
		<CurrentPrincipal public="1" get="accessor" set="accessor" static="1"><c path="cs.system.security.principal.IPrincipal"/></CurrentPrincipal>
		<CurrentContext public="1" get="accessor" set="null" static="1"><c path="cs.system.runtime.remoting.contexts.Context"/></CurrentContext>
		<get_CurrentContext public="1" set="method" static="1"><f a=""><c path="cs.system.runtime.remoting.contexts.Context"/></f></get_CurrentContext>
		<get_CurrentPrincipal public="1" set="method" static="1"><f a=""><c path="cs.system.security.principal.IPrincipal"/></f></get_CurrentPrincipal>
		<set_CurrentPrincipal public="1" set="method" static="1"><f a="value">
	<c path="cs.system.security.principal.IPrincipal"/>
	<c path="cs.system.security.principal.IPrincipal"/>
</f></set_CurrentPrincipal>
		<get_CurrentThread public="1" set="method" static="1"><f a=""><c path="cs.system.threading.Thread"/></f></get_CurrentThread>
		<AllocateNamedDataSlot public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<c path="cs.system.LocalDataStoreSlot"/>
</f></AllocateNamedDataSlot>
		<FreeNamedDataSlot public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></FreeNamedDataSlot>
		<AllocateDataSlot public="1" set="method" static="1"><f a=""><c path="cs.system.LocalDataStoreSlot"/></f></AllocateDataSlot>
		<GetData public="1" set="method" static="1"><f a="slot">
	<c path="cs.system.LocalDataStoreSlot"/>
	<d/>
</f></GetData>
		<SetData public="1" set="method" static="1"><f a="slot:data">
	<c path="cs.system.LocalDataStoreSlot"/>
	<d/>
	<x path="Void"/>
</f></SetData>
		<GetNamedDataSlot public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<c path="cs.system.LocalDataStoreSlot"/>
</f></GetNamedDataSlot>
		<GetDomain public="1" set="method" static="1"><f a=""><c path="cs.system.AppDomain"/></f></GetDomain>
		<GetDomainID public="1" set="method" static="1"><f a=""><x path="Int"/></f></GetDomainID>
		<ResetAbort public="1" set="method" static="1"><f a=""><x path="Void"/></f></ResetAbort>
		<Sleep public="1" set="method" static="1">
			<f a="millisecondsTimeout">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads><Sleep public="1" set="method"><f a="timeout">
	<c path="cs.system.TimeSpan"/>
	<x path="Void"/>
</f></Sleep></overloads>
		</Sleep>
		<MemoryBarrier public="1" set="method" static="1"><f a=""><x path="Void"/></f></MemoryBarrier>
		<SpinWait public="1" set="method" static="1"><f a="iterations">
	<x path="Int"/>
	<x path="Void"/>
</f></SpinWait>
		<VolatileRead public="1" set="method" static="1">
			<f a="address">
				<t path="cs.Ref"><t path="cs.types.UInt8"/></t>
				<t path="cs.types.UInt8"/>
			</f>
			<overloads>
				<VolatileRead public="1" set="method"><f a="address">
	<t path="cs.Ref"><c path="cs.system.UIntPtr"/></t>
	<c path="cs.system.UIntPtr"/>
</f></VolatileRead>
				<VolatileRead public="1" set="method"><f a="address">
	<t path="cs.Ref"><t path="cs.types.UInt64"/></t>
	<t path="cs.types.UInt64"/>
</f></VolatileRead>
				<VolatileRead public="1" set="method"><f a="address">
	<t path="cs.Ref"><x path="UInt"/></t>
	<x path="UInt"/>
</f></VolatileRead>
				<VolatileRead public="1" set="method"><f a="address">
	<t path="cs.Ref"><t path="cs.types.UInt16"/></t>
	<t path="cs.types.UInt16"/>
</f></VolatileRead>
				<VolatileRead public="1" set="method"><f a="address">
	<t path="cs.Ref"><x path="Single"/></t>
	<x path="Single"/>
</f></VolatileRead>
				<VolatileRead public="1" set="method"><f a="address">
	<t path="cs.Ref"><t path="cs.types.Int8"/></t>
	<t path="cs.types.Int8"/>
</f></VolatileRead>
				<VolatileRead public="1" set="method"><f a="address">
	<t path="cs.Ref"><d/></t>
	<d/>
</f></VolatileRead>
				<VolatileRead public="1" set="method"><f a="address">
	<t path="cs.Ref"><c path="cs.system.IntPtr"/></t>
	<c path="cs.system.IntPtr"/>
</f></VolatileRead>
				<VolatileRead public="1" set="method"><f a="address">
	<t path="cs.Ref"><x path="haxe.Int64"/></t>
	<x path="haxe.Int64"/>
</f></VolatileRead>
				<VolatileRead public="1" set="method"><f a="address">
	<t path="cs.Ref"><x path="Int"/></t>
	<x path="Int"/>
</f></VolatileRead>
				<VolatileRead public="1" set="method"><f a="address">
	<t path="cs.Ref"><t path="cs.types.Int16"/></t>
	<t path="cs.types.Int16"/>
</f></VolatileRead>
				<VolatileRead public="1" set="method"><f a="address">
	<t path="cs.Ref"><x path="Float"/></t>
	<x path="Float"/>
</f></VolatileRead>
			</overloads>
		</VolatileRead>
		<VolatileWrite public="1" set="method" static="1">
			<f a="address:value">
				<t path="cs.Ref"><t path="cs.types.UInt8"/></t>
				<t path="cs.types.UInt8"/>
				<x path="Void"/>
			</f>
			<overloads>
				<VolatileWrite public="1" set="method"><f a="address:value">
	<t path="cs.Ref"><c path="cs.system.UIntPtr"/></t>
	<c path="cs.system.UIntPtr"/>
	<x path="Void"/>
</f></VolatileWrite>
				<VolatileWrite public="1" set="method"><f a="address:value">
	<t path="cs.Ref"><t path="cs.types.UInt64"/></t>
	<t path="cs.types.UInt64"/>
	<x path="Void"/>
</f></VolatileWrite>
				<VolatileWrite public="1" set="method"><f a="address:value">
	<t path="cs.Ref"><x path="UInt"/></t>
	<x path="UInt"/>
	<x path="Void"/>
</f></VolatileWrite>
				<VolatileWrite public="1" set="method"><f a="address:value">
	<t path="cs.Ref"><t path="cs.types.UInt16"/></t>
	<t path="cs.types.UInt16"/>
	<x path="Void"/>
</f></VolatileWrite>
				<VolatileWrite public="1" set="method"><f a="address:value">
	<t path="cs.Ref"><x path="Single"/></t>
	<x path="Single"/>
	<x path="Void"/>
</f></VolatileWrite>
				<VolatileWrite public="1" set="method"><f a="address:value">
	<t path="cs.Ref"><t path="cs.types.Int8"/></t>
	<t path="cs.types.Int8"/>
	<x path="Void"/>
</f></VolatileWrite>
				<VolatileWrite public="1" set="method"><f a="address:value">
	<t path="cs.Ref"><d/></t>
	<d/>
	<x path="Void"/>
</f></VolatileWrite>
				<VolatileWrite public="1" set="method"><f a="address:value">
	<t path="cs.Ref"><c path="cs.system.IntPtr"/></t>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></VolatileWrite>
				<VolatileWrite public="1" set="method"><f a="address:value">
	<t path="cs.Ref"><x path="haxe.Int64"/></t>
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></VolatileWrite>
				<VolatileWrite public="1" set="method"><f a="address:value">
	<t path="cs.Ref"><x path="Int"/></t>
	<x path="Int"/>
	<x path="Void"/>
</f></VolatileWrite>
				<VolatileWrite public="1" set="method"><f a="address:value">
	<t path="cs.Ref"><t path="cs.types.Int16"/></t>
	<t path="cs.types.Int16"/>
	<x path="Void"/>
</f></VolatileWrite>
				<VolatileWrite public="1" set="method"><f a="address:value">
	<t path="cs.Ref"><x path="Float"/></t>
	<x path="Float"/>
	<x path="Void"/>
</f></VolatileWrite>
			</overloads>
		</VolatileWrite>
		<BeginCriticalRegion public="1" set="method" static="1"><f a=""><x path="Void"/></f></BeginCriticalRegion>
		<EndCriticalRegion public="1" set="method" static="1"><f a=""><x path="Void"/></f></EndCriticalRegion>
		<BeginThreadAffinity public="1" set="method" static="1"><f a=""><x path="Void"/></f></BeginThreadAffinity>
		<EndThreadAffinity public="1" set="method" static="1"><f a=""><x path="Void"/></f></EndThreadAffinity>
		<ManagedThreadId public="1" get="accessor" set="null"><x path="Int"/></ManagedThreadId>
		<ExecutionContext public="1" get="accessor" set="null"><c path="cs.system.threading.ExecutionContext"/></ExecutionContext>
		<ThreadState public="1" get="accessor" set="null"><e path="cs.system.threading.ThreadState"/></ThreadState>
		<Priority public="1" get="accessor" set="accessor"><e path="cs.system.threading.ThreadPriority"/></Priority>
		<Name public="1" get="accessor" set="accessor"><c path="String"/></Name>
		<IsBackground public="1" get="accessor" set="accessor"><x path="Bool"/></IsBackground>
		<IsAlive public="1" get="accessor" set="null"><x path="Bool"/></IsAlive>
		<IsThreadPoolThread public="1" get="accessor" set="null"><x path="Bool"/></IsThreadPoolThread>
		<CurrentUICulture public="1" get="accessor" set="accessor"><c path="cs.system.globalization.CultureInfo"/></CurrentUICulture>
		<CurrentCulture public="1" get="accessor" set="accessor"><c path="cs.system.globalization.CultureInfo"/></CurrentCulture>
		<ApartmentState public="1" get="accessor" set="accessor"><e path="cs.system.threading.ApartmentState"/></ApartmentState>
		<get_ApartmentState final="1" public="1" set="method"><f a=""><e path="cs.system.threading.ApartmentState"/></f></get_ApartmentState>
		<set_ApartmentState final="1" public="1" set="method"><f a="value">
	<e path="cs.system.threading.ApartmentState"/>
	<e path="cs.system.threading.ApartmentState"/>
</f></set_ApartmentState>
		<get_CurrentCulture final="1" public="1" set="method"><f a=""><c path="cs.system.globalization.CultureInfo"/></f></get_CurrentCulture>
		<set_CurrentCulture final="1" public="1" set="method"><f a="value">
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.system.globalization.CultureInfo"/>
</f></set_CurrentCulture>
		<get_CurrentUICulture final="1" public="1" set="method"><f a=""><c path="cs.system.globalization.CultureInfo"/></f></get_CurrentUICulture>
		<set_CurrentUICulture final="1" public="1" set="method"><f a="value">
	<c path="cs.system.globalization.CultureInfo"/>
	<c path="cs.system.globalization.CultureInfo"/>
</f></set_CurrentUICulture>
		<get_IsThreadPoolThread final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsThreadPoolThread>
		<get_IsAlive final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsAlive>
		<get_IsBackground final="1" public="1" set="method"><f a=""><x path="Bool"/></f></get_IsBackground>
		<set_IsBackground final="1" public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_IsBackground>
		<get_Name final="1" public="1" set="method"><f a=""><c path="String"/></f></get_Name>
		<set_Name final="1" public="1" set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_Name>
		<get_Priority final="1" public="1" set="method"><f a=""><e path="cs.system.threading.ThreadPriority"/></f></get_Priority>
		<set_Priority final="1" public="1" set="method"><f a="value">
	<e path="cs.system.threading.ThreadPriority"/>
	<e path="cs.system.threading.ThreadPriority"/>
</f></set_Priority>
		<get_ThreadState final="1" public="1" set="method"><f a=""><e path="cs.system.threading.ThreadState"/></f></get_ThreadState>
		<Abort final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><Abort final="1" public="1" set="method"><f a="stateInfo">
	<d/>
	<x path="Void"/>
</f></Abort></overloads>
		</Abort>
		<Interrupt final="1" public="1" set="method"><f a=""><x path="Void"/></f></Interrupt>
		<Join final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<Join final="1" public="1" set="method"><f a="timeout">
	<c path="cs.system.TimeSpan"/>
	<x path="Bool"/>
</f></Join>
				<Join final="1" public="1" set="method"><f a="millisecondsTimeout">
	<x path="Int"/>
	<x path="Bool"/>
</f></Join>
			</overloads>
		</Join>
		<Resume final="1" public="1" set="method"><f a=""><x path="Void"/></f></Resume>
		<Start final="1" public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads><Start final="1" public="1" set="method"><f a="parameter">
	<d/>
	<x path="Void"/>
</f></Start></overloads>
		</Start>
		<Suspend final="1" public="1" set="method"><f a=""><x path="Void"/></f></Suspend>
		<get_ExecutionContext final="1" public="1" set="method"><f a=""><c path="cs.system.threading.ExecutionContext"/></f></get_ExecutionContext>
		<get_ManagedThreadId final="1" public="1" set="method"><f a=""><x path="Int"/></f></get_ManagedThreadId>
		<GetApartmentState final="1" public="1" set="method"><f a=""><e path="cs.system.threading.ApartmentState"/></f></GetApartmentState>
		<SetApartmentState final="1" public="1" set="method"><f a="state">
	<e path="cs.system.threading.ApartmentState"/>
	<x path="Void"/>
</f></SetApartmentState>
		<TrySetApartmentState final="1" public="1" set="method"><f a="state">
	<e path="cs.system.threading.ApartmentState"/>
	<x path="Bool"/>
</f></TrySetApartmentState>
		<GetCompressedStack final="1" public="1" set="method"><f a=""><c path="cs.system.threading.CompressedStack"/></f></GetCompressedStack>
		<SetCompressedStack final="1" public="1" set="method"><f a="stack">
	<c path="cs.system.threading.CompressedStack"/>
	<x path="Void"/>
</f></SetCompressedStack>
		<new final="1" public="1" set="method">
			<f a="start">
				<x path="cs.system.threading.ThreadStart"/>
				<x path="Void"/>
			</f>
			<overloads>
				<new final="1" public="1" set="method"><f a="start:maxStackSize">
	<x path="cs.system.threading.ParameterizedThreadStart"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="start">
	<x path="cs.system.threading.ParameterizedThreadStart"/>
	<x path="Void"/>
</f></new>
				<new final="1" public="1" set="method"><f a="start:maxStackSize">
	<x path="cs.system.threading.ThreadStart"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.Thread"</e></m>
		</meta>
	</class>
	<enum path="cs.system.threading.ThreadPriority" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ThreadPriority">
		<Lowest><meta><m n=":csNative"><e>0</e></m></meta></Lowest>
		<BelowNormal><meta><m n=":csNative"><e>1</e></m></meta></BelowNormal>
		<Normal><meta><m n=":csNative"><e>2</e></m></meta></Normal>
		<AboveNormal><meta><m n=":csNative"><e>3</e></m></meta></AboveNormal>
		<Highest><meta><m n=":csNative"><e>4</e></m></meta></Highest>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Threading.ThreadPriority"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<class path="cs.system.threading.Delegate_ThreadStart" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ThreadStart" module="cs.system.threading.ThreadStart" extern="1" final="1">
		<extends path="cs.system.MulticastDelegate"/>
		<op_Addition public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.threading.ThreadStart"/>
	<x path="cs.system.threading.ThreadStart"/>
	<x path="cs.system.threading.ThreadStart"/>
</f></op_Addition>
		<op_Subtraction public="1" set="method" static="1"><f a="arg1:arg2">
	<x path="cs.system.threading.ThreadStart"/>
	<x path="cs.system.threading.ThreadStart"/>
	<x path="cs.system.threading.ThreadStart"/>
</f></op_Subtraction>
		<Invoke public="1" set="method"><f a=""><x path="Void"/></f></Invoke>
		<BeginInvoke public="1" set="method"><f a="callback:object">
	<x path="cs.system.AsyncCallback"/>
	<d/>
	<c path="cs.system.IAsyncResult"/>
</f></BeginInvoke>
		<EndInvoke public="1" set="method"><f a="result">
	<c path="cs.system.IAsyncResult"/>
	<x path="Void"/>
</f></EndInvoke>
		<new final="1" public="1" set="method"><f a="object:method">
	<d/>
	<c path="cs.system.IntPtr"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"System.Threading.ThreadStart"</e></m>
		</meta>
	</class>
	<abstract path="cs.system.threading.ThreadStart" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ThreadStart">
		<from><icast field="FromHaxeFunction"><f a=""><x path="Void"/></f></icast></from>
		<this><c path="cs.system.threading.Delegate_ThreadStart"/></this>
		<meta>
			<m n=":nativeGen"/>
			<m n=":delegate"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="cs.system.threading._ThreadStart.ThreadStart_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ThreadStart" private="1" module="cs.system.threading.ThreadStart" final="1">
	<_new public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=""><x path="Void"/></f>
			<x path="cs.system.threading.ThreadStart"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
		<f a="hxfunc">
			<f a=""><x path="Void"/></f>
			<x path="cs.system.threading.ThreadStart"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":from"/>
		</meta>
	</FromHaxeFunction>
	<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.threading.Delegate_ThreadStart"/>
	<c path="cs.system.threading.Delegate_ThreadStart"/>
</f></AsDelegate>
	<Add public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.threading.ThreadStart"/>
			<x path="cs.system.threading.ThreadStart"/>
			<x path="cs.system.threading.ThreadStart"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</Add>
	<Remove public="1" get="inline" set="null" line="1" static="1">
		<f a="arg1:arg2">
			<x path="cs.system.threading.ThreadStart"/>
			<x path="cs.system.threading.ThreadStart"/>
			<x path="cs.system.threading.ThreadStart"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</Remove>
	<meta><m n=":nativeGen"/></meta>
</class></impl>
	</abstract>
	<class path="cs.system.threading._ThreadStart.ThreadStart_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ThreadStart" private="1" module="cs.system.threading.ThreadStart" final="1">
		<_new public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=""><x path="Void"/></f>
				<x path="cs.system.threading.ThreadStart"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<FromHaxeFunction public="1" get="inline" set="null" line="1" static="1">
			<f a="hxfunc">
				<f a=""><x path="Void"/></f>
				<x path="cs.system.threading.ThreadStart"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":from"/>
			</meta>
		</FromHaxeFunction>
		<AsDelegate public="1" get="inline" set="null" line="1" static="1"><f a="this">
	<c path="cs.system.threading.Delegate_ThreadStart"/>
	<c path="cs.system.threading.Delegate_ThreadStart"/>
</f></AsDelegate>
		<Add public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.threading.ThreadStart"/>
				<x path="cs.system.threading.ThreadStart"/>
				<x path="cs.system.threading.ThreadStart"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</Add>
		<Remove public="1" get="inline" set="null" line="1" static="1">
			<f a="arg1:arg2">
				<x path="cs.system.threading.ThreadStart"/>
				<x path="cs.system.threading.ThreadStart"/>
				<x path="cs.system.threading.ThreadStart"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</Remove>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<enum path="cs.system.threading.ThreadState" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ cs.system.threading.ThreadState">
		<Running><meta><m n=":csNative"><e>0</e></m></meta></Running>
		<StopRequested><meta><m n=":csNative"><e>1</e></m></meta></StopRequested>
		<SuspendRequested><meta><m n=":csNative"><e>2</e></m></meta></SuspendRequested>
		<Background><meta><m n=":csNative"><e>4</e></m></meta></Background>
		<Unstarted><meta><m n=":csNative"><e>8</e></m></meta></Unstarted>
		<Stopped><meta><m n=":csNative"><e>16</e></m></meta></Stopped>
		<WaitSleepJoin><meta><m n=":csNative"><e>32</e></m></meta></WaitSleepJoin>
		<Suspended><meta><m n=":csNative"><e>64</e></m></meta></Suspended>
		<AbortRequested><meta><m n=":csNative"><e>128</e></m></meta></AbortRequested>
		<Aborted><meta><m n=":csNative"><e>256</e></m></meta></Aborted>
		<meta>
			<m n=":nativeGen"/>
			<m n=":flatEnum"/>
			<m n=":native"><e>"System.Threading.ThreadState"</e></m>
			<m n=":csNative"/>
		</meta>
	</enum>
	<typedef path="cs.types.Char16" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/types/Char16.hx">
		<x path="cs.Char16"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="cs.types.Int16" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/types/Int16.hx">
		<x path="cs.Int16"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="cs.types.Int8" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/types/Int8.hx">
		<x path="cs.Int8"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="cs.types.UInt16" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/types/UInt16.hx">
		<x path="cs.UInt16"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="cs.types.UInt64" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/types/UInt64.hx">
		<x path="cs.UInt64"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="cs.types.UInt8" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/types/UInt8.hx">
		<x path="cs.UInt8"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="earcut.Earcut" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/earcut/earcut/Earcut.hx">
		<earcut public="1" set="method" line="8" static="1">
			<f a="data:?holeIndices:?dim:?triangles" v="::2:">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ dim : 2 }</e></m></meta>
		</earcut>
		<linkedList set="method" line="80" static="1">
			<f a="data:start:end:dim:clockwise">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Create a circular doubly linked list from polygon points in the specified winding order</haxe_doc>
		</linkedList>
		<filterPoints set="method" line="110" static="1">
			<f a="?start:?end">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Eliminate colinear or duplicate points</haxe_doc>
		</filterPoints>
		<earcutLinked set="method" line="143" static="1">
			<f a="ear:triangles:dim:?minX:?minY:?invSize:?pass">
				<c path="earcut.Node"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Main ear slicing loop which triangulates a polygon (given as a linked list)</haxe_doc>
		</earcutLinked>
		<isEar set="method" line="203" static="1">
			<f a="ear">
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check whether a polygon node forms a valid ear with adjacent nodes</haxe_doc>
		</isEar>
		<isEarHashed set="method" line="225" static="1"><f a="ear:minX:minY:invSize">
	<c path="earcut.Node"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isEarHashed>
		<cureLocalIntersections set="method" line="283" static="1">
			<f a="start:triangles:dim">
				<c path="earcut.Node"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Float"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Go through all polygon nodes and cure small local self-intersections</haxe_doc>
		</cureLocalIntersections>
		<splitEarcut set="method" line="310" static="1">
			<f a="start:triangles:dim:minX:minY:invSize">
				<c path="earcut.Node"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Try splitting polygon into two and triangulate them independently</haxe_doc>
		</splitEarcut>
		<eliminateHoles set="method" line="342" static="1">
			<f a="data:holeIndices:outerNode:dim">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="earcut.Node"/>
				<x path="Int"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Link every hole into the outer loop, producing a single-ring polygon without holes</haxe_doc>
		</eliminateHoles>
		<compareX get="inline" set="null" line="371" static="1"><f a="a:b">
	<c path="earcut.Node"/>
	<c path="earcut.Node"/>
	<x path="Int"/>
</f></compareX>
		<eliminateHole get="inline" set="null" line="378" static="1">
			<f a="hole:outerNode">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Find a bridge between vertices that connects hole with an outer ring and and link it</haxe_doc>
		</eliminateHole>
		<findHoleBridge set="method" line="392" static="1">
			<f a="hole:outerNode">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* David Eberly's algorithm for finding a bridge between hole and outer polygon</haxe_doc>
		</findHoleBridge>
		<sectorContainsSector get="inline" set="null" line="465" static="1">
			<f a="m:p">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Whether sector in vertex m contains sector in vertex p in the same coordinates</haxe_doc>
		</sectorContainsSector>
		<indexCurve set="method" line="472" static="1">
			<f a="start:minX:minY:invSize">
				<c path="earcut.Node"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Interlink polygon nodes in z-order</haxe_doc>
		</indexCurve>
		<sortLinked set="method" line="496" static="1">
			<f a="list">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Simon Tatham's linked list merge sort algorithm
     * http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html</haxe_doc>
		</sortLinked>
		<zOrder set="method" line="564" static="1">
			<f a="x:y:minX:minY:invSize">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* z-order of a point given coords and size of the data bounding box</haxe_doc>
		</zOrder>
		<getLeftmost set="method" line="585" static="1">
			<f a="start">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Find the leftmost node of a polygon ring</haxe_doc>
		</getLeftmost>
		<pointInTriangle get="inline" set="null" line="601" static="1">
			<f a="ax:ay:bx:by:cx:cy:px:py">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a point lies within a convex triangle</haxe_doc>
		</pointInTriangle>
		<isValidDiagonal get="inline" set="null" line="610" static="1">
			<f a="a:b">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a diagonal between two polygon nodes is valid (lies in polygon interior)</haxe_doc>
		</isValidDiagonal>
		<area get="inline" set="null" line="620" static="1">
			<f a="p:q:r">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Signed area of a triangle</haxe_doc>
		</area>
		<equals get="inline" set="null" line="627" static="1">
			<f a="p1:p2">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if two points are equal</haxe_doc>
		</equals>
		<intersects get="inline" set="null" line="634" static="1">
			<f a="p1:q1:p2:q2">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if two segments intersect</haxe_doc>
		</intersects>
		<onSegment get="inline" set="null" line="653" static="1">
			<f a="p:q:r">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* For collinear points p, q, r, check if point q lies on segment pr</haxe_doc>
		</onSegment>
		<sign get="inline" set="null" line="657" static="1"><f a="num">
	<x path="Float"/>
	<x path="Int"/>
</f></sign>
		<intersectsPolygon set="method" line="664" static="1">
			<f a="a:b">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a polygon diagonal intersects any polygon segments</haxe_doc>
		</intersectsPolygon>
		<locallyInside get="inline" set="null" line="680" static="1">
			<f a="a:b">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a polygon diagonal is locally inside the polygon</haxe_doc>
		</locallyInside>
		<middleInside set="method" line="689" static="1">
			<f a="a:b">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if the middle point of a polygon diagonal is inside the polygon</haxe_doc>
		</middleInside>
		<splitPolygon set="method" line="710" static="1">
			<f a="a:b">
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
     * If one belongs to the outer ring and another to a hole, it merges it into a single ring</haxe_doc>
		</splitPolygon>
		<insertNode set="method" line="734" static="1">
			<f a="i:x:y:?last">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="earcut.Node"/>
				<c path="earcut.Node"/>
			</f>
			<haxe_doc>* Create a node and optionally link it with previous one (in a circular doubly linked list)</haxe_doc>
		</insertNode>
		<removeNode set="method" line="751" static="1"><f a="p">
	<c path="earcut.Node"/>
	<x path="Void"/>
</f></removeNode>
		<signedArea set="method" line="763" static="1"><f a="data:start:end:dim">
	<c path="Array"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></signedArea>
		<deviation set="method" line="778" static="1"><f a="data:holeIndices:dim:triangles">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Float"/>
</f></deviation>
		<flatten public="1" set="method" line="809" static="1"><f a="data">
	<c path="Array"><c path="Array"><c path="Array"><x path="Float"/></c></c></c>
	<d/>
</f></flatten>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="earcut.Node" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/earcut/earcut/Earcut.hx" module="earcut.Earcut">
		<recyclingEnabled public="1" expr="true" line="887" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</recyclingEnabled>
		<nextPoolIndex expr="0" line="889" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextPoolIndex>
		<pool expr="[]" line="891" static="1">
			<c path="Array"><c path="earcut.Node"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pool>
		<clearPool public="1" set="method" line="893" static="1"><f a=""><x path="Void"/></f></clearPool>
		<recycleAllNodes public="1" set="method" line="900" static="1"><f a=""><x path="Void"/></f></recycleAllNodes>
		<get public="1" set="method" line="906" static="1"><f a="i:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="earcut.Node"/>
</f></get>
		<i public="1"><x path="Int"/></i>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<prev public="1"><c path="earcut.Node"/></prev>
		<next public="1"><c path="earcut.Node"/></next>
		<z public="1" expr="-99999999" line="846">
			<x path="Int"/>
			<meta><m n=":value"><e>-99999999</e></m></meta>
		</z>
		<prevZ public="1"><c path="earcut.Node"/></prevZ>
		<nextZ public="1"><c path="earcut.Node"/></nextZ>
		<steiner public="1"><x path="Bool"/></steiner>
		<reset get="inline" set="null" line="860"><f a="i:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></reset>
		<new public="1" set="method" line="854"><f a="i:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<enum path="haxe.StackItem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line:?column">
			<x path="Null"><e path="haxe.StackItem"/></x>
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<x path="Null"><c path="String"/></x>
			<c path="String"/>
		</Method>
		<LocalFunction a="?v"><x path="Int"/></LocalFunction>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<abstract path="haxe.CallStack" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>The length of this stack.</haxe_doc>
	</length>
	<get_length get="inline" set="null" line="46" static="1"><f a="this">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<x path="Int"/>
</f></get_length>
	<callStack public="1" set="method" line="51" static="1">
		<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
		<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
	</callStack>
	<exceptionStack public="1" set="method" line="63" static="1">
		<f a="?fullStack" v="false">
			<x path="Bool"/>
			<c path="Array"><e path="haxe.StackItem"/></c>
		</f>
		<meta><m n=":value"><e>{ fullStack : false }</e></m></meta>
		<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.
		Set `fullStack` parameter to true in order to return the full exception stack.

		May not work if catch type was a derivative from `haxe.Exception`.</haxe_doc>
	</exceptionStack>
	<subtract public="1" set="method" line="84" static="1">
		<f a="this:stack">
			<c path="Array"><e path="haxe.StackItem"/></c>
			<x path="haxe.CallStack"/>
			<x path="haxe.CallStack"/>
		</f>
		<haxe_doc>Returns a range of entries of current stack from the beginning to the the
		common part of this and `stack`.</haxe_doc>
	</subtract>
	<get public="1" get="inline" set="null" line="111" static="1">
		<f a="this:index">
			<c path="Array"><e path="haxe.StackItem"/></c>
			<x path="Int"/>
			<e path="haxe.StackItem"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</get>
	<asArray get="inline" set="null" line="115" static="1"><f a="this">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<c path="Array"><e path="haxe.StackItem"/></c>
</f></asArray>
	<equalItems set="method" line="119" static="1"><f a="item1:item2">
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Bool"/>
</f></equalItems>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
		<m n=":using"><e>haxe.CallStack</e></m>
		<m n=":allow"><e>haxe.Exception</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe._CallStack.CallStack_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1">
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>The length of this stack.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="46" static="1"><f a="this">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<x path="Int"/>
</f></get_length>
		<callStack public="1" set="method" line="51" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="63" static="1">
			<f a="?fullStack" v="false">
				<x path="Bool"/>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":value"><e>{ fullStack : false }</e></m></meta>
			<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.
		Set `fullStack` parameter to true in order to return the full exception stack.

		May not work if catch type was a derivative from `haxe.Exception`.</haxe_doc>
		</exceptionStack>
		<subtract public="1" set="method" line="84" static="1">
			<f a="this:stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="haxe.CallStack"/>
				<x path="haxe.CallStack"/>
			</f>
			<haxe_doc>Returns a range of entries of current stack from the beginning to the the
		common part of this and `stack`.</haxe_doc>
		</subtract>
		<get public="1" get="inline" set="null" line="111" static="1">
			<f a="this:index">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="Int"/>
				<e path="haxe.StackItem"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</get>
		<asArray get="inline" set="null" line="115" static="1"><f a="this">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<c path="Array"><e path="haxe.StackItem"/></c>
</f></asArray>
		<equalItems set="method" line="119" static="1"><f a="item1:item2">
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Bool"/>
</f></equalItems>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":using"><e>haxe.CallStack</e></m>
			<m n=":allow"><e>haxe.Exception</e></m>
		</meta>
	</class>
	<abstract path="haxe.Function" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":callable"/>
		</meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta>
	<m n=":keep"/>
	<m n=":hxGen"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta>
	<m n=":keep"/>
	<m n=":hxGen"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta>
	<m n=":keep"/>
	<m n=":hxGen"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta>
	<m n=":keep"/>
	<m n=":hxGen"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Null"><c path="haxe.IMap.V"/></x>
</f></get>
		<set public="1" set="method"><f a="k:v">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
	<x path="Void"/>
</f></set>
		<exists public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></exists>
		<remove public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<keys public="1" set="method"><f a=""><t path="Iterator"><c path="haxe.IMap.K"/></t></f></keys>
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="haxe.IMap.V"/></t></f></iterator>
		<keyValueIterator public="1" set="method"><f a=""><t path="KeyValueIterator">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
</t></f></keyValueIterator>
		<copy public="1" set="method"><f a=""><c path="haxe.IMap">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
</c></f></copy>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="haxe.DynamicAccess" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/DynamicAccess.hx">
		<from><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></from>
		<this><d><c path="haxe.DynamicAccess.T"/></d></this>
		<to><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></to>
		<haxe_doc>DynamicAccess is an abstract type for working with anonymous structures
	that are intended to hold collections of objects by the string key.

	For example, these types of structures are often created from JSON.

	Basically, it wraps `Reflect` calls in a `Map`-like interface.</haxe_doc>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="haxe._DynamicAccess.DynamicAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/DynamicAccess.hx" private="1" module="haxe.DynamicAccess" final="1">
	<get public="1" get="inline" set="null" line="51" static="1">
		<f a="this:key">
			<d><c path="haxe.DynamicAccess.T"/></d>
			<c path="String"/>
			<x path="Null"><c path="haxe.DynamicAccess.T"/></x>
		</f>
		<meta><m n=":arrayAccess"/></meta>
		<haxe_doc>Returns a value by specified `key`.

		If the structure does not contain the given key, `null` is returned.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</get>
	<set public="1" get="inline" set="null" line="69" static="1">
		<f a="this:key:value">
			<d><c path="haxe.DynamicAccess.T"/></d>
			<c path="String"/>
			<c path="haxe.DynamicAccess.T"/>
			<c path="haxe.DynamicAccess.T"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
		<haxe_doc>Sets a `value` for a specified `key`.

		If the structure contains the given key, its value will be overwritten.

		Returns the given value.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</set>
	<exists public="1" get="inline" set="null" line="84" static="1">
		<f a="this:key">
			<d><c path="haxe.DynamicAccess.T"/></d>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Tells if the structure contains a specified `key`.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</exists>
	<remove public="1" get="inline" set="null" line="94" static="1">
		<f a="this:key">
			<d><c path="haxe.DynamicAccess.T"/></d>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Removes a specified `key` from the structure.

		Returns true, if `key` was present in structure, or false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</remove>
	<keys public="1" get="inline" set="null" line="100" static="1">
		<f a="this">
			<d><c path="haxe.DynamicAccess.T"/></d>
			<c path="Array"><c path="String"/></c>
		</f>
		<haxe_doc>Returns an array of `keys` in a structure.</haxe_doc>
	</keys>
	<keyValueIterator public="1" get="inline" set="null" line="122" static="1">
		<f a="this">
			<d><c path="haxe.DynamicAccess.T"/></d>
			<c path="haxe.iterators.DynamicAccessKeyValueIterator"><c path="haxe.DynamicAccess.T"/></c>
		</f>
		<haxe_doc>Returns an Iterator over the keys and values of this `DynamicAccess`.

		The order of values is undefined.</haxe_doc>
	</keyValueIterator>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe._DynamicAccess.DynamicAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/DynamicAccess.hx" private="1" module="haxe.DynamicAccess" final="1">
		<get public="1" get="inline" set="null" line="51" static="1">
			<f a="this:key">
				<d><c path="haxe.DynamicAccess.T"/></d>
				<c path="String"/>
				<x path="Null"><c path="haxe.DynamicAccess.T"/></x>
			</f>
			<meta><m n=":arrayAccess"/></meta>
			<haxe_doc>Returns a value by specified `key`.

		If the structure does not contain the given key, `null` is returned.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="69" static="1">
			<f a="this:key:value">
				<d><c path="haxe.DynamicAccess.T"/></d>
				<c path="String"/>
				<c path="haxe.DynamicAccess.T"/>
				<c path="haxe.DynamicAccess.T"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
			<haxe_doc>Sets a `value` for a specified `key`.

		If the structure contains the given key, its value will be overwritten.

		Returns the given value.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</set>
		<exists public="1" get="inline" set="null" line="84" static="1">
			<f a="this:key">
				<d><c path="haxe.DynamicAccess.T"/></d>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the structure contains a specified `key`.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</exists>
		<remove public="1" get="inline" set="null" line="94" static="1">
			<f a="this:key">
				<d><c path="haxe.DynamicAccess.T"/></d>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a specified `key` from the structure.

		Returns true, if `key` was present in structure, or false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="100" static="1">
			<f a="this">
				<d><c path="haxe.DynamicAccess.T"/></d>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns an array of `keys` in a structure.</haxe_doc>
		</keys>
		<keyValueIterator public="1" get="inline" set="null" line="122" static="1">
			<f a="this">
				<d><c path="haxe.DynamicAccess.T"/></d>
				<c path="haxe.iterators.DynamicAccessKeyValueIterator"><c path="haxe.DynamicAccess.T"/></c>
			</f>
			<haxe_doc>Returns an Iterator over the keys and values of this `DynamicAccess`.

		The order of values is undefined.</haxe_doc>
		</keyValueIterator>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="sys.thread._Thread.Thread_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread" final="1">
		<_new get="inline" set="null" line="35" static="1">
			<f a="thread">
				<c path="sys.thread._Thread.HaxeThread"/>
				<x path="sys.thread.Thread"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<create public="1" set="method" line="39" static="1"><f a="job">
	<f a=""><x path="Void"/></f>
	<x path="sys.thread.Thread"/>
</f></create>
		<current public="1" get="inline" set="null" line="70" static="1"><f a=""><x path="sys.thread.Thread"/></f></current>
		<processEvents set="method" line="93" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</processEvents>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="sys.thread.EventLoop" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/sys/thread/EventLoop.hx">
		<CREATED static="1"><x path="Bool"/></CREATED>
		<mutex final="1" expr="new Mutex()" line="25">
			<c path="sys.thread.Mutex"/>
			<meta><m n=":value"><e>new Mutex()</e></m></meta>
		</mutex>
		<oneTimeEvents final="1" expr="new Array&lt;Null&lt;Void -&gt; Void&gt;&gt;()" line="26">
			<c path="Array"><x path="Null"><f a=""><x path="Void"/></f></x></c>
			<meta><m n=":value"><e><![CDATA[new Array<Null<Void -> Void>>()]]></e></m></meta>
		</oneTimeEvents>
		<oneTimeEventsIdx expr="0" line="27">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</oneTimeEventsIdx>
		<waitLock final="1" expr="new Lock()" line="28">
			<c path="sys.thread.Lock"/>
			<meta><m n=":value"><e>new Lock()</e></m></meta>
		</waitLock>
		<promisedEventsCount expr="0" line="29">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</promisedEventsCount>
		<regularEvents><x path="Null"><c path="sys.thread._EventLoop.RegularEvent"/></x></regularEvents>
		<isMainThread><x path="Bool"/></isMainThread>
		<loop public="1" set="method" line="179">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Execute all pending events.
		Wait and execute as many events as the number of times `promise()` was called.
		Runs until all repeating events are cancelled and no more events are expected.

		Depending on a target platform this method may be non-reentrant. It must
		not be called from event callbacks.</haxe_doc>
		</loop>
		<__progress get="inline" set="null" line="205">
			<f a="now:recycleRegular:recycleOneTimers">
				<x path="Float"/>
				<c path="Array"><c path="sys.thread._EventLoop.RegularEvent"/></c>
				<c path="Array"><f a=""><x path="Void"/></f></c>
				<a>
					<nextEventAt><x path="Float"/></nextEventAt>
					<anyTime><x path="Bool"/></anyTime>
				</a>
			</f>
			<haxe_doc>`.progress` implementation with a reusable array for internal usage.
		The `nextEventAt` field of the return value denotes when the next event
		is expected to run:
		* -1 - never
		* -2 - now
		* other values - at specified time</haxe_doc>
		</__progress>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<haxe_doc>An event loop implementation used for `sys.thread.Thread`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.thread._Thread.HaxeThread" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread">
		<mainNativeThread static="1"><t path="cs.system.threading._Thread.NativeThread"/></mainNativeThread>
		<mainHaxeThread static="1"><c path="sys.thread._Thread.HaxeThread"/></mainHaxeThread>
		<threads static="1"><t path="Map">
	<x path="Int"/>
	<c path="cs.system.WeakReference"/>
</t></threads>
		<threadsMutex static="1"><t path="cs.system.threading._Mutex.NativeMutex"/></threadsMutex>
		<allocateCount static="1"><x path="Int"/></allocateCount>
		<get public="1" set="method" line="119" static="1"><f a="native">
	<t path="cs.system.threading._Thread.NativeThread"/>
	<c path="sys.thread._Thread.HaxeThread"/>
</f></get>
		<allocate public="1" set="method" line="134" static="1"><f a="native:withEventLoop">
	<t path="cs.system.threading._Thread.NativeThread"/>
	<x path="Bool"/>
	<c path="sys.thread._Thread.HaxeThread"/>
</f></allocate>
		<native final="1" public="1"><t path="cs.system.threading._Thread.NativeThread"/></native>
		<events public="1" set="null"><x path="Null"><c path="sys.thread.EventLoop"/></x></events>
		<new set="method" line="173"><f a="native">
	<t path="cs.system.threading._Thread.NativeThread"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.EntryPoint" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/EntryPoint.hx">
		<run public="1" set="method" line="126" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Start the main loop. Depending on the platform, this can return immediately or will only return when the application exits.</haxe_doc>
		</run>
		<haxe_doc>If `haxe.MainLoop` is kept from DCE, then we will insert an `haxe.EntryPoint.run()` call just at then end of `main()`.
	This class can be redefined by custom frameworks so they can handle their own main loop logic.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:

			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="138" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="149" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="163" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="175" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</class>
	<class path="haxe._Exception.NativeException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/Exception.hx" private="1" module="haxe.Exception" extern="1">
		<Data final="1">
			<c path="cs.system.collections.IDictionary"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</Data>
		<HelpLink>
			<c path="String"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</HelpLink>
		<InnerException final="1">
			<c path="cs.system.Exception"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</InnerException>
		<Message final="1">
			<c path="String"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</Message>
		<Source>
			<c path="String"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</Source>
		<StackTrace final="1">
			<c path="String"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</StackTrace>
		<TargetSite final="1">
			<c path="cs.system.reflection.MethodBase"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</TargetSite>
		<GetBaseException set="method">
			<f a=""><c path="cs.system.Exception"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</GetBaseException>
		<GetObjectData set="method">
			<f a="info:context">
				<c path="cs.system.runtime.serialization.SerializationInfo"/>
				<c path="cs.system.runtime.serialization.StreamingContext"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":overload"/>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</GetObjectData>
		<GetType set="method">
			<f a=""><c path="cs.system.Type"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</GetType>
		<ToString set="method">
			<f a=""><c path="cs.system.String"/></f>
			<meta>
				<m n=":overload"/>
				<m n=":noCompletion"/>
				<m n=":skipReflection"/>
			</meta>
		</ToString>
		<new set="method">
			<f a="message:innerException">
				<c path="String"/>
				<c path="haxe._Exception.NativeException"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":nativeGen"/>
			<m n=":noCompletion"/>
			<m n=":native"><e>"System.Exception"</e></m>
		</meta>
	</class>
	<class path="haxe.Exception" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/Exception.hx">
		<extends path="haxe._Exception.NativeException"/>
		<caught public="1" set="method" line="20" static="1"><f a="value">
	<x path="Any"/>
	<c path="haxe.Exception"/>
</f></caught>
		<thrown public="1" set="method" line="30" static="1"><f a="value">
	<x path="Any"/>
	<x path="Any"/>
</f></thrown>
		<message public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>Exception message.</haxe_doc>
		</message>
		<native public="1" get="accessor" set="null">
			<x path="Any"/>
			<haxe_doc>Native exception, which caused this exception.</haxe_doc>
		</native>
		<__nativeStack>
			<c path="cs.system.diagnostics.StackTrace"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeStack>
		<__ownStack>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__ownStack>
		<__skipStack expr="0" line="16">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__skipStack>
		<__nativeException>
			<t path="cs.system._Exception.CsException"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<unwrap public="1" set="method" line="62"><f a=""><x path="Any"/></f></unwrap>
		<toString public="1" set="method" line="66">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<__shiftStack get="inline" set="null" line="76">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__shiftStack>
		<get_message set="method" line="80"><f a=""><c path="String"/></f></get_message>
		<get_native final="1" set="method" line="88"><f a=""><x path="Any"/></f></get_native>
		<new public="1" set="method" line="42">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.Int32" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":transitive"/>
		</meta>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32" final="1"><meta>
	<m n=":keep"/>
	<m n=":hxGen"/>
</meta></class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<x path="cs.Int64"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<abstract path="haxe.Int64" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<meta>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
			<m n=":transitive"/>
		</meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/Int64.hx" private="1" module="haxe.Int64" final="1">
	<val get="accessor" set="null" static="1"><t path="haxe._Int64.__Int64"/></val>
	<get_val get="inline" set="null" line="43" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<t path="haxe._Int64.__Int64"/>
</f></get_val>
	<add public="1" get="inline" set="null" line="136" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
		<haxe_doc>Returns the sum of `a` and `b`.</haxe_doc>
	</add>
	<sub public="1" get="inline" set="null" line="142" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
		<haxe_doc>Returns `a` minus `b`.</haxe_doc>
	</sub>
	<eq public="1" get="inline" set="null" line="175" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
		<haxe_doc>Returns `true` if `a` is equal to `b`.</haxe_doc>
	</eq>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
		<m n=":coreApi"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe._Int64.Int64_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/Int64.hx" private="1" module="haxe.Int64" final="1">
		<val get="accessor" set="null" static="1"><t path="haxe._Int64.__Int64"/></val>
		<get_val get="inline" set="null" line="43" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<t path="haxe._Int64.__Int64"/>
</f></get_val>
		<add public="1" get="inline" set="null" line="136" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
			<haxe_doc>Returns the sum of `a` and `b`.</haxe_doc>
		</add>
		<sub public="1" get="inline" set="null" line="142" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
			<haxe_doc>Returns `a` minus `b`.</haxe_doc>
		</sub>
		<eq public="1" get="inline" set="null" line="175" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
			<haxe_doc>Returns `true` if `a` is equal to `b`.</haxe_doc>
		</eq>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.Json" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Json.hx">
		<parse public="1" get="inline" set="null" line="43" static="1">
			<f a="text">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[Parses given JSON-encoded `text` and returns the resulting object.

		JSON objects are parsed into anonymous structures and JSON arrays
		are parsed into `Array<Dynamic>`.

		If given `text` is not valid JSON, an exception will be thrown.

		@see https://haxe.org/manual/std-Json-parsing.html]]></haxe_doc>
		</parse>
		<stringify public="1" get="inline" set="null" line="59" static="1">
			<f a="value:?replacer:?space">
				<d/>
				<f a="key:value">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes the given `value` and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve the
		actual object to be encoded. The `replacer` function takes two parameters,
		the key and the value being encoded. Initial key value is an empty string.

		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.

		@see https://haxe.org/manual/std-Json-encoding.html</haxe_doc>
		</stringify>
		<haxe_doc>Cross-platform JSON API: it will automatically use the optimized native API if available.
	Use `-D haxeJSON` to force usage of the Haxe implementation even if a native API is found:
	This will provide extra encoding (but not decoding) features such as enums (replaced by their index) and StringMaps.

	@see https://haxe.org/manual/std-Json.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.MainEvent" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/MainLoop.hx" module="haxe.MainLoop">
		<f><f a=""><x path="Void"/></f></f>
		<prev><c path="haxe.MainEvent"/></prev>
		<next><c path="haxe.MainEvent"/></next>
		<isBlocking public="1" expr="true" line="17">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Tells if the event can lock the process from exiting (default:true)</haxe_doc>
		</isBlocking>
		<nextRun public="1" set="null"><x path="Float"/></nextRun>
		<priority public="1" set="null"><x path="Int"/></priority>
		<call public="1" get="inline" set="null" line="39">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Call the event. Will do nothing if the event has been stopped.</haxe_doc>
		</call>
		<new set="method" line="22"><f a="f:p">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.MainLoop" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/MainLoop.hx">
		<pending static="1"><c path="haxe.MainEvent"/></pending>
		<hasEvents public="1" set="method" line="71" static="1"><f a=""><x path="Bool"/></f></hasEvents>
		<sortEvents set="method" line="104" static="1"><f a=""><x path="Void"/></f></sortEvents>
		<tick set="method" line="169" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Run the pending events. Return the time for next event.</haxe_doc>
		</tick>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":access"><e>haxe.MainEvent</e></m>
		</meta>
	</class>
	<class path="haxe.NativeStackTrace" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/NativeStackTrace.hx">
		<exception static="1">
			<x path="Null"><c path="cs.system.Exception"/></x>
			<meta><m n=":meta"><e>System.ThreadStaticAttribute</e></m></meta>
		</exception>
		<saveStack public="1" get="inline" set="null" line="16" static="1">
			<f a="e">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":ifFeature"><e>"haxe.NativeStackTrace.exceptionStack"</e></m></meta>
		</saveStack>
		<callStack public="1" get="inline" set="null" line="20" static="1"><f a=""><c path="cs.system.diagnostics.StackTrace"/></f></callStack>
		<exceptionStack public="1" set="method" line="24" static="1"><f a=""><x path="Null"><c path="cs.system.diagnostics.StackTrace"/></x></f></exceptionStack>
		<toHaxe public="1" set="method" line="31" static="1">
			<f a="native:?skip" v=":0">
				<x path="Null"><c path="cs.system.diagnostics.StackTrace"/></x>
				<x path="Int"/>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":value"><e>{ skip : 0 }</e></m></meta>
		</toHaxe>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe._Rest.NativeRest" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/Rest.hx" private="1" module="haxe.Rest">
		<c path="cs.NativeArray"><c path="haxe._Rest.NativeRest.T"/></c>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<abstract path="haxe.Rest" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/Rest.hx">
		<from><icast field="of"><c path="Array"><c path="of.T"/></c></icast></from>
		<this><t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t></this>
		<to><icast field="toArray"><c path="Array"><c path="haxe.Rest.T"/></c></icast></to>
		<meta>
			<m n=":nativeGen"/>
			<m n=":coreApi"/>
		</meta>
		<impl><class path="haxe._Rest.Rest_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/Rest.hx" private="1" module="haxe.Rest" final="1"><meta>
	<m n=":keep"/>
	<m n=":nativeGen"/>
	<m n=":coreApi"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.Serializer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" expr="false" line="57" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set `USE_CACHE` to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of `Serializer` by
		setting their `useCache` field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" expr="false" line="69" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of `Serializer` by
		setting their `useEnumIndex` field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="71" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<BASE64_CODES expr="null" line="72" static="1">
			<x path="haxe.ds.Vector"><x path="Null"><x path="Int"/></x></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</BASE64_CODES>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See `USE_CACHE` for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See `USE_ENUM_INDEX` for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="118">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		https://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="154"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="174"><f a="v">
	<d/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="211"><f a="v">
	<a/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="229">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

	All haxe-defined values and objects with the exception of functions can
	be serialized. Serialization of external/native objects is not
	guaranteed to work.

	The values of `this.useCache` and `this.useEnumIndex` may affect
	serialization output.</haxe_doc>
		</serialize>
		<__getField get="inline" set="null" line="557"><f a="o:f">
	<d/>
	<c path="String"/>
	<d/>
</f></__getField>
		<new public="1" set="method" line="103">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each `Serializer` instance maintains its own cache if `this.useCache` is
		`true`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The Serializer class can be used to encode values and objects into a `String`,
	from which the `Unserializer` class can recreate the original representation.

	This class can be used in two ways:

	- create a `new Serializer()` instance, call its `serialize()` method with
		any argument and finally retrieve the String representation from
		`toString()`
	- call `Serializer.run()` to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/std-serialization-format.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.Timer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Timer.hx">
		<stamp public="1" get="inline" set="null" line="178" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a timestamp, in seconds with fractions.

		The value itself might differ depending on platforms, only differences
		between two values make sense.</haxe_doc>
		</stamp>
		<haxe_doc>The `Timer` class allows you to create asynchronous timers on platforms that
	support events.

	The intended usage is to create an instance of the `Timer` class with a given
	interval, set its `run()` method to a custom function to be invoked and
	eventually call `stop()` to stop the `Timer`.

	Note that a running `Timer` may or may not prevent the program to exit
	automatically when `main()` returns.

	It is also possible to extend this class and override its `run()` method in
	the child class.

	Notice for threaded targets:
	`Timer` instances require threads they were created in to run with Haxe's event loops.
	Main thread of a Haxe program always contains an event loop. For other cases use 
	`sys.thread.Thread.createWithEventLoop` and `sys.thread.Thread.runWithEventLoop` methods.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe._Unserializer.DefaultResolver" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Unserializer.hx" private="1" module="haxe.Unserializer">
		<resolveClass public="1" get="inline" set="null" line="515"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></resolveClass>
		<resolveEnum public="1" get="inline" set="null" line="518"><f a="name">
	<c path="String"/>
	<x path="Enum"><d/></x>
</f></resolveEnum>
		<new public="1" set="method" line="512"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.Unserializer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" expr="new DefaultResolver()" line="67" static="1">
			<t path="haxe.TypeResolver"/>
			<meta><m n=":value"><e>new DefaultResolver()</e></m></meta>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a `Class` or `Enum` instance from a given `String`.
		By default, the Haxe `Type` Api is used.

		A type resolver must provide two methods:

		1. `resolveClass(name:String):Class<Dynamic>` is called to determine a
				`Class` from a class name
		2. `resolveEnum(name:String):Enum<Dynamic>` is called to determine an
				`Enum` from an enum name

		This value is applied when a new `Unserializer` instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="69" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<CODES expr="null" line="72" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</CODES>
		<initCodes set="method" line="74" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<fastLength get="inline" set="null" line="478" static="1"><f a="s">
	<c path="String"/>
	<x path="Int"/>
</f></fastLength>
		<fastCharAt get="inline" set="null" line="494" static="1"><f a="s:pos">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></fastCharAt>
		<fastSubstr get="inline" set="null" line="502" static="1"><f a="s:pos:length">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></fastSubstr>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<get get="inline" set="null" line="142"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<readDigits set="method" line="150"><f a=""><x path="Int"/></f></readDigits>
		<readFloat set="method" line="175"><f a=""><x path="Float"/></f></readFloat>
		<unserializeObject set="method" line="190"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum params="T" set="method" line="205"><f a="edecl:tag">
	<x path="Enum"><c path="unserializeEnum.T"/></x>
	<c path="String"/>
	<c path="unserializeEnum.T"/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="237">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different Haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from `Type.createEmptyInstance`, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="101">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The `Unserializer` class is the complement to the `Serializer` class. It parses
	a serialization `String` and creates objects from the contained data.

	This class can be used in two ways:

	- create a `new Unserializer()` instance with a given serialization
		String, then call its `unserialize()` method until all values are
		extracted
	- call `Unserializer.run()`  to unserialize a single value from a given
		String

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/serialization/format>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.ValueException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<unwrap public="1" set="method" line="35" override="1">
			<f a=""><x path="Any"/></f>
			<haxe_doc>Extract an originally thrown value.

		This method must return the same value on subsequent calls.
		Used internally for catching non-native exceptions.
		Do _not_ override unless you know what you are doing.</haxe_doc>
		</unwrap>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.crypto.Md5" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/crypto/Md5.hx">
		<encode public="1" set="method" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<str2blks set="method" line="120" static="1"><f a="str">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<bitOR set="method" line="57"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitOR>
		<bitXOR set="method" line="63"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitXOR>
		<bitAND set="method" line="69"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitAND>
		<addme set="method" line="75"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></addme>
		<hex set="method" line="81"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<rol set="method" line="154"><f a="num:cnt">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></rol>
		<cmn set="method" line="158"><f a="q:a:b:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></cmn>
		<ff set="method" line="162"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ff>
		<gg set="method" line="166"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gg>
		<hh set="method" line="170"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hh>
		<ii set="method" line="174"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ii>
		<doEncode set="method" line="178"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<new set="method" line="55"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a MD5 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.ds.ArraySort" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/ArraySort.hx">
		<sort public="1" params="T" set="method" line="42" static="1">
			<f a="a:cmp">
				<c path="Array"><c path="sort.T"/></c>
				<f a=":">
					<c path="sort.T"/>
					<c path="sort.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
		`cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
		negative Int if `x < y`.

		This operation modifies Array `a` in place.

		This operation is stable: The order of equal elements is preserved.

		If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec params="T" set="method" line="46" static="1"><f a="a:cmp:from:to">
	<c path="Array"><c path="rec.T"/></c>
	<f a=":">
		<c path="rec.T"/>
		<c path="rec.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge params="T" set="method" line="68" static="1"><f a="a:cmp:from:pivot:to:len1:len2">
	<c path="Array"><c path="doMerge.T"/></c>
	<f a=":">
		<c path="doMerge.T"/>
		<c path="doMerge.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate params="T" set="method" line="94" static="1"><f a="a:cmp:from:mid:to">
	<c path="Array"><c path="rotate.T"/></c>
	<f a=":">
		<c path="rotate.T"/>
		<c path="rotate.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd set="method" line="115" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper params="T" set="method" line="124" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="upper.T"/></c>
	<f a=":">
		<c path="upper.T"/>
		<c path="upper.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower params="T" set="method" line="139" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="lower.T"/></c>
	<f a=":">
		<c path="lower.T"/>
		<c path="lower.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap params="T" set="method" line="153" static="1"><f a="a:i:j">
	<c path="Array"><c path="swap.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<compare params="T" get="inline" set="null" line="159" static="1"><f a="a:cmp:i:j">
	<c path="Array"><c path="compare.T"/></c>
	<f a=":">
		<c path="compare.T"/>
		<c path="compare.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></compare>
		<haxe_doc>ArraySort provides a stable implementation of merge sort through its `sort`
	method. It should be used instead of `Array.sort` in cases where the order
	of equal elements has to be retained on all targets.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/BalancedTree.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.BalancedTree.K"/>
			<c path="haxe.ds.BalancedTree.V"/>
		</implements>
		<iteratorLoop params="K:V" set="method" line="172" static="1"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="iteratorLoop.K"/>
		<c path="iteratorLoop.V"/>
	</c>
	<c path="Array"><c path="iteratorLoop.V"/></c>
	<x path="Void"/>
</f></iteratorLoop>
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.

		If `key` is already bound to a value, that binding disappears.

		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Null"><c path="haxe.ds.BalancedTree.V"/></x>
			</f>
			<haxe_doc>Returns the value `key` is bound to.

		If `key` is not bound to any value, `null` is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<remove public="1" set="method" line="85">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the current binding of `key`.

		If `key` has no binding, `this` BalancedTree is unchanged and false is
		returned.

		Otherwise the binding of `key` is removed and true is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="101">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `key` is bound to a value.

		This method returns true even if `key` is bound to null.

		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<iterator public="1" set="method" line="120">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.V"/></t></f>
			<haxe_doc>Iterates over the bound values of `this` BalancedTree.

		This operation is performed in-order.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="129">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<keys public="1" set="method" line="138">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.K"/></t></f>
			<haxe_doc>Iterates over the keys of `this` BalancedTree.

		This operation is performed in-order.</haxe_doc>
		</keys>
		<copy public="1" set="method" line="144"><f a=""><c path="haxe.ds.BalancedTree">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></f></copy>
		<setLoop set="method" line="150"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<removeLoop set="method" line="163"><f a="k:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeLoop>
		<keysLoop set="method" line="180"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.K"/></c>
	<x path="Void"/>
</f></keysLoop>
		<merge set="method" line="188"><f a="t1:t2">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></merge>
		<minBinding set="method" line="197"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></minBinding>
		<removeMinBinding set="method" line="201"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeMinBinding>
		<balance set="method" line="205"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="225"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<clear public="1" set="method" line="236">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all keys from `this` BalancedTree.</haxe_doc>
		</clear>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.

	Operations have a logarithmic average and worst-case cost.

	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<get_height public="1" get="inline" set="null" line="264"><f a=""><x path="Int"/></f></get_height>
		<new public="1" set="method" line="252">
			<f a="l:k:v:r:?h" v="::::-1">
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<c path="haxe.ds.TreeNode.K"/>
				<c path="haxe.ds.TreeNode.V"/>
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1 }</e></m></meta>
		</new>
		<haxe_doc>A tree node of `haxe.ds.BalancedTree`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="haxe.IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="32" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="57"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compareArg set="method" line="69"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compareArg>
		<copy public="1" set="method" line="79" override="1"><f a=""><c path="haxe.ds.EnumValueMap">
	<c path="haxe.ds.EnumValueMap.K"/>
	<c path="haxe.ds.EnumValueMap.V"/>
</c></f></copy>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.

	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.ds.GenericCell" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/GenericStack.hx" module="haxe.ds.GenericStack">
		<elt public="1"><c path="haxe.ds.GenericCell.T"/></elt>
		<next public="1"><c path="haxe.ds.GenericCell"><c path="haxe.ds.GenericCell.T"/></c></next>
		<new public="1" set="method" line="37"><f a="elt:next">
	<c path="haxe.ds.GenericCell.T"/>
	<c path="haxe.ds.GenericCell"><c path="haxe.ds.GenericCell.T"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>A cell of `haxe.ds.GenericStack`.

	@see https://haxe.org/manual/std-GenericStack.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.ds.GenericStack" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/GenericStack.hx">
		<head public="1"><c path="haxe.ds.GenericCell"><c path="haxe.ds.GenericStack.T"/></c></head>
		<add public="1" get="inline" set="null" line="112">
			<f a="item">
				<c path="haxe.ds.GenericStack.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Pushes element `item` onto the stack.</haxe_doc>
		</add>
		<pop public="1" get="inline" set="null" line="130">
			<f a=""><x path="Null"><c path="haxe.ds.GenericStack.T"/></x></f>
			<haxe_doc>Returns the topmost stack element and removes it.

		If the stack is empty, null is returned.</haxe_doc>
		</pop>
		<isEmpty public="1" get="inline" set="null" line="143">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tells if the stack is empty.</haxe_doc>
		</isEmpty>
		<new public="1" set="method" line="107">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty GenericStack.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[A stack of elements.

	This class is generic, which means one type is generated for each type
	parameter T on static targets. For example:

	- `new GenericStack<Int>()` generates `GenericStack_Int`
	- `new GenericStack<String>()` generates `GenericStack_String`

	The generated name is an implementation detail and should not be relied
	upon.

	@see https://haxe.org/manual/std-GenericStack.html]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.ds.IntMap" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/ds/IntMap.hx">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<arrayCopy get="inline" set="null" line="405" static="1"><f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></arrayCopy>
		<getInc get="inline" set="null" line="409" static="1"><f a="k:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getInc>
		<hash get="inline" set="null" line="413" static="1"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></hash>
		<getFlag get="inline" set="null" line="423" static="1"><f a="flags:i">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
</f></getFlag>
		<isDel get="inline" set="null" line="427" static="1"><f a="flag">
	<x path="Int"/>
	<x path="Bool"/>
</f></isDel>
		<isEmpty get="inline" set="null" line="431" static="1"><f a="flag">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEmpty>
		<isEither get="inline" set="null" line="435" static="1"><f a="flag">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEither>
		<setIsEmptyFalse get="inline" set="null" line="443" static="1"><f a="flags:i">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setIsEmptyFalse>
		<setIsBothFalse get="inline" set="null" line="447" static="1"><f a="flags:i">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setIsBothFalse>
		<setIsDelTrue get="inline" set="null" line="451" static="1"><f a="flags:i">
	<c path="cs.NativeArray"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setIsDelTrue>
		<roundUp get="inline" set="null" line="455" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></roundUp>
		<flagsSize get="inline" set="null" line="465" static="1"><f a="m">
	<x path="Int"/>
	<x path="Int"/>
</f></flagsSize>
		<flags><c path="cs.NativeArray"><x path="Int"/></c></flags>
		<_keys><c path="cs.NativeArray"><x path="Int"/></c></_keys>
		<vals><c path="cs.NativeArray"><c path="haxe.ds.IntMap.T"/></c></vals>
		<nBuckets><x path="Int"/></nBuckets>
		<size><x path="Int"/></size>
		<nOccupied><x path="Int"/></nOccupied>
		<upperBound><x path="Int"/></upperBound>
		<cachedKey><x path="Int"/></cachedKey>
		<cachedIndex><x path="Int"/></cachedIndex>
		<set public="1" set="method" line="57">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<lookup final="1" set="method" line="117"><f a="key">
	<x path="Int"/>
	<x path="Int"/>
</f></lookup>
		<get public="1" set="method" line="146">
			<f a="key">
				<x path="Int"/>
				<x path="Null"><c path="haxe.ds.IntMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="186">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="207">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<resize final="1" set="method" line="240"><f a="newNBuckets">
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<keys public="1" get="inline" set="null" line="346">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" get="inline" set="null" line="350">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="354">
			<f a=""><t path="KeyValueIterator">
	<x path="Int"/>
	<c path="haxe.ds.IntMap.T"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method" line="358">
			<f a=""><c path="haxe.ds.IntMap"><c path="haxe.ds.IntMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<clear public="1" set="method" line="380">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method" line="51">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds._IntMap.IntMapKeyIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/ds/IntMap.hx" private="1" module="haxe.ds.IntMap" final="1">
		<m><c path="haxe.ds.IntMap"><c path="haxe.ds._IntMap.IntMapKeyIterator.T"/></c></m>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" set="method" line="482"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" set="method" line="492"><f a=""><x path="Int"/></f></next>
		<new public="1" set="method" line="476"><f a="m">
	<c path="haxe.ds.IntMap"><c path="haxe.ds._IntMap.IntMapKeyIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":access"><e>haxe.ds.IntMap</e></m>
		</meta>
	</class>
	<class path="haxe.ds._IntMap.IntMapValueIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/ds/IntMap.hx" private="1" module="haxe.ds.IntMap" final="1">
		<m><c path="haxe.ds.IntMap"><c path="haxe.ds._IntMap.IntMapValueIterator.T"/></c></m>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" set="method" line="515"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="525"><f a=""><c path="haxe.ds._IntMap.IntMapValueIterator.T"/></f></next>
		<new public="1" set="method" line="509"><f a="m">
	<c path="haxe.ds.IntMap"><c path="haxe.ds._IntMap.IntMapValueIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":access"><e>haxe.ds.IntMap</e></m>
		</meta>
	</class>
	<class path="haxe.ds.List" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/List.hx">
		<h><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></h>
		<q><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="53">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<iterator public="1" get="inline" set="null" line="160">
			<f a=""><c path="haxe.ds._List.ListIterator"><c path="haxe.ds.List.T"/></c></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<new public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.ds._List.ListNode" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<create public="1" params="T" get="inline" set="null" line="271" static="1"><f a="item:next">
	<c path="create.T"/>
	<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
	<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
</f></create>
		<item public="1"><c path="haxe.ds._List.ListNode.T"/></item>
		<next public="1"><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></next>
		<new public="1" set="method" line="266"><f a="item:next">
	<c path="haxe.ds._List.ListNode.T"/>
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.ds._List.ListIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<head><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListIterator.T"/></c></head>
		<hasNext public="1" get="inline" set="null" line="284"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="288"><f a=""><c path="haxe.ds._List.ListIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="280"><f a="head">
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":transitive"/>
			<m n=":multiType"><e>@:followWithAbstracts K</e></m>
		</meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
	<_new public="1" set="method" static="1">
		<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
	</_new>
	<set public="1" get="inline" set="null" line="74" static="1">
		<f a="this:key:value">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<c path="haxe.ds.Map.V"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Maps `key` to `value`.

		If `key` already has a mapping, the previous value disappears.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</set>
	<get public="1" get="inline" set="null" line="92" static="1">
		<f a="this:key">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<x path="Null"><c path="haxe.ds.Map.V"/></x>
		</f>
		<meta><m n=":arrayAccess"/></meta>
		<haxe_doc>Returns the current mapping of `key`.

		If no such mapping exists, `null` is returned.

		Note that a check like `map.get(key) == null` can hold for two reasons:

		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`

		If it is important to distinguish these cases, `exists()` should be
		used.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</get>
	<exists public="1" get="inline" set="null" line="100" static="1">
		<f a="this:key">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Returns true if `key` has a mapping, false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</exists>
	<remove public="1" get="inline" set="null" line="109" static="1">
		<f a="this:key">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</remove>
	<keys public="1" get="inline" set="null" line="116" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<t path="Iterator"><c path="haxe.ds.Map.K"/></t>
		</f>
		<haxe_doc>Returns an Iterator over the keys of `this` Map.

		The order of keys is undefined.</haxe_doc>
	</keys>
	<iterator public="1" get="inline" set="null" line="125" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<t path="Iterator"><c path="haxe.ds.Map.V"/></t>
		</f>
		<haxe_doc>Returns an Iterator over the values of `this` Map.

		The order of values is undefined.</haxe_doc>
	</iterator>
	<keyValueIterator public="1" get="inline" set="null" line="134" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<t path="KeyValueIterator">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</t>
		</f>
		<haxe_doc>Returns an Iterator over the keys and values of `this` Map.

		The order of values is undefined.</haxe_doc>
	</keyValueIterator>
	<copy public="1" get="inline" set="null" line="143" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<x path="haxe.ds.Map">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</x>
		</f>
		<haxe_doc>Returns a shallow copy of `this` map.

		The order of values is undefined.</haxe_doc>
	</copy>
	<clear public="1" get="inline" set="null" line="159" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<x path="Void"/>
		</f>
		<haxe_doc>Removes all keys from `this` Map.</haxe_doc>
	</clear>
	<toStringMap params="K:V" get="inline" set="null" line="168" static="1">
		<f a="t">
			<c path="haxe.IMap">
				<c path="toStringMap.K"/>
				<c path="toStringMap.V"/>
			</c>
			<c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c>
		</f>
		<meta>
			<m n=":multiType"/>
			<m n=":to"/>
		</meta>
	</toStringMap>
	<toIntMap params="K:V" get="inline" set="null" line="172" static="1">
		<f a="t">
			<c path="haxe.IMap">
				<c path="toIntMap.K"/>
				<c path="toIntMap.V"/>
			</c>
			<c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c>
		</f>
		<meta>
			<m n=":multiType"/>
			<m n=":to"/>
		</meta>
	</toIntMap>
	<fromStringMap params="V" get="inline" set="null" line="184" static="1">
		<f a="map">
			<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="fromStringMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromStringMap>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/ds/ObjectMap.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<HASH_UPPER get="inline" set="null" expr="0.77" line="28" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.77</e></m></meta>
		</HASH_UPPER>
		<FLAG_EMPTY get="inline" set="null" expr="0" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FLAG_EMPTY>
		<FLAG_DEL get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</FLAG_DEL>
		<roundUp get="inline" set="null" line="414" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></roundUp>
		<getInc get="inline" set="null" line="425" static="1"><f a="k:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getInc>
		<isEither get="inline" set="null" line="428" static="1"><f a="v">
	<t path="haxe.ds._ObjectMap.HashType"/>
	<x path="Bool"/>
</f></isEither>
		<isEmpty get="inline" set="null" line="431" static="1"><f a="v">
	<t path="haxe.ds._ObjectMap.HashType"/>
	<x path="Bool"/>
</f></isEmpty>
		<isDel get="inline" set="null" line="434" static="1"><f a="v">
	<t path="haxe.ds._ObjectMap.HashType"/>
	<x path="Bool"/>
</f></isDel>
		<hash params="K" get="inline" set="null" line="437" static="1">
			<f a="s">
				<c path="hash.K"/>
				<t path="haxe.ds._ObjectMap.HashType"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</hash>
		<arrayCopy get="inline" set="null" line="465" static="1"><f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></arrayCopy>
		<assert get="inline" set="null" line="467" static="1"><f a="x">
	<x path="Bool"/>
	<x path="Void"/>
</f></assert>
		<hashes>
			<c path="cs.NativeArray"><t path="haxe.ds._ObjectMap.HashType"/></c>
			<haxe_doc>* This is the most important structure here and the reason why it's so fast.
	 * It's an array of all the hashes contained in the table. These hashes cannot be 0 nor 1,
	 * which stand for "empty" and "deleted" states.
	 *
	 * The lookup algorithm will keep looking until a 0 or the key wanted is found;
	 * The insertion algorithm will do the same but will also break when FLAG_DEL is found;</haxe_doc>
		</hashes>
		<_keys><c path="cs.NativeArray"><c path="haxe.ds.ObjectMap.K"/></c></_keys>
		<vals><c path="cs.NativeArray"><c path="haxe.ds.ObjectMap.V"/></c></vals>
		<nBuckets><x path="Int"/></nBuckets>
		<size><x path="Int"/></size>
		<nOccupied><x path="Int"/></nOccupied>
		<upperBound><x path="Int"/></upperBound>
		<cachedKey><c path="haxe.ds.ObjectMap.K"/></cachedKey>
		<cachedIndex><x path="Int"/></cachedIndex>
		<set public="1" set="method" line="68">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<lookup final="1" set="method" line="138"><f a="key">
	<c path="haxe.ds.ObjectMap.K"/>
	<x path="Int"/>
</f></lookup>
		<resize final="1" set="method" line="166"><f a="newNBuckets">
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<get public="1" set="method" line="271">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.V"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="313">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="334">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="360">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="364">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="368">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method" line="372">
			<f a=""><c path="haxe.ds.ObjectMap">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<clear public="1" set="method" line="394">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method" line="62">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds._ObjectMap.ObjectMapKeyIterator" params="T:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/ds/ObjectMap.hx" private="1" module="haxe.ds.ObjectMap" final="1">
		<m><c path="haxe.ds.ObjectMap">
	<c path="haxe.ds._ObjectMap.ObjectMapKeyIterator.T"/>
	<c path="haxe.ds._ObjectMap.ObjectMapKeyIterator.V"/>
</c></m>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" set="method" line="487"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" set="method" line="497"><f a=""><c path="haxe.ds._ObjectMap.ObjectMapKeyIterator.T"/></f></next>
		<new public="1" set="method" line="481"><f a="m">
	<c path="haxe.ds.ObjectMap">
		<c path="haxe.ds._ObjectMap.ObjectMapKeyIterator.T"/>
		<c path="haxe.ds._ObjectMap.ObjectMapKeyIterator.V"/>
	</c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":access"><e>haxe.ds.ObjectMap</e></m>
		</meta>
	</class>
	<class path="haxe.ds._ObjectMap.ObjectMapValueIterator" params="K:T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/ds/ObjectMap.hx" private="1" module="haxe.ds.ObjectMap" final="1">
		<m><c path="haxe.ds.ObjectMap">
	<c path="haxe.ds._ObjectMap.ObjectMapValueIterator.K"/>
	<c path="haxe.ds._ObjectMap.ObjectMapValueIterator.T"/>
</c></m>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" set="method" line="522"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="532"><f a=""><c path="haxe.ds._ObjectMap.ObjectMapValueIterator.T"/></f></next>
		<new public="1" set="method" line="516"><f a="m">
	<c path="haxe.ds.ObjectMap">
		<c path="haxe.ds._ObjectMap.ObjectMapValueIterator.K"/>
		<c path="haxe.ds._ObjectMap.ObjectMapValueIterator.T"/>
	</c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":access"><e>haxe.ds.ObjectMap</e></m>
		</meta>
	</class>
	<typedef path="haxe.ds._ObjectMap.HashType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/ds/ObjectMap.hx" private="1" module="haxe.ds.ObjectMap">
		<x path="Int"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":forward">
				<e>copy</e>
				<e>filter</e>
				<e>indexOf</e>
				<e>iterator</e>
				<e>keyValueIterator</e>
				<e>join</e>
				<e>lastIndexOf</e>
				<e>map</e>
				<e>slice</e>
				<e>contains</e>
				<e>toString</e>
			</m>
		</meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1"><meta>
	<m n=":keep"/>
	<m n=":hxGen"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<HASH_UPPER get="inline" set="null" expr="0.77" line="28" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.77</e></m></meta>
		</HASH_UPPER>
		<FLAG_EMPTY get="inline" set="null" expr="0" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FLAG_EMPTY>
		<FLAG_DEL get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</FLAG_DEL>
		<roundUp get="inline" set="null" line="413" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></roundUp>
		<isEither get="inline" set="null" line="424" static="1"><f a="v">
	<t path="haxe.ds._StringMap.HashType"/>
	<x path="Bool"/>
</f></isEither>
		<isEmpty get="inline" set="null" line="427" static="1"><f a="v">
	<t path="haxe.ds._StringMap.HashType"/>
	<x path="Bool"/>
</f></isEmpty>
		<isDel get="inline" set="null" line="430" static="1"><f a="v">
	<t path="haxe.ds._StringMap.HashType"/>
	<x path="Bool"/>
</f></isDel>
		<hash get="inline" set="null" line="433" static="1">
			<f a="s">
				<c path="String"/>
				<t path="haxe.ds._StringMap.HashType"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</hash>
		<arrayCopy get="inline" set="null" line="461" static="1"><f a="sourceArray:sourceIndex:destinationArray:destinationIndex:length">
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<c path="cs.system.Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></arrayCopy>
		<assert get="inline" set="null" line="463" static="1"><f a="x">
	<x path="Bool"/>
	<x path="Void"/>
</f></assert>
		<hashes>
			<c path="cs.NativeArray"><t path="haxe.ds._StringMap.HashType"/></c>
			<haxe_doc>* This is the most important structure here and the reason why it's so fast.
	 * It's an array of all the hashes contained in the table. These hashes cannot be 0 nor 1,
	 * which stand for "empty" and "deleted" states.
	 *
	 * The lookup algorithm will keep looking until a 0 or the key wanted is found;
	 * The insertion algorithm will do the same but will also break when FLAG_DEL is found;</haxe_doc>
		</hashes>
		<_keys><c path="cs.NativeArray"><c path="String"/></c></_keys>
		<vals><c path="cs.NativeArray"><c path="haxe.ds.StringMap.T"/></c></vals>
		<nBuckets><x path="Int"/></nBuckets>
		<size><x path="Int"/></size>
		<nOccupied><x path="Int"/></nOccupied>
		<upperBound><x path="Int"/></upperBound>
		<cachedKey><c path="String"/></cachedKey>
		<cachedIndex><x path="Int"/></cachedIndex>
		<set public="1" set="method" line="68">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<lookup final="1" set="method" line="140"><f a="key">
	<c path="String"/>
	<x path="Int"/>
</f></lookup>
		<resize final="1" set="method" line="168"><f a="newNBuckets">
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<get public="1" set="method" line="273">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="313">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="333">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="359">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" get="inline" set="null" line="363">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="367">
			<f a=""><t path="KeyValueIterator">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method" line="371">
			<f a=""><c path="haxe.ds.StringMap"><c path="haxe.ds.StringMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<clear public="1" set="method" line="393">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method" line="62">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.ds._StringMap.HashType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap">
		<x path="Int"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="haxe.ds._StringMap.StringMapKeyIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap" final="1">
		<m><c path="haxe.ds.StringMap"><c path="haxe.ds._StringMap.StringMapKeyIterator.T"/></c></m>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" set="method" line="485"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" set="method" line="495"><f a=""><c path="String"/></f></next>
		<new public="1" set="method" line="479"><f a="m">
	<c path="haxe.ds.StringMap"><c path="haxe.ds._StringMap.StringMapKeyIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":access"><e>haxe.ds.StringMap</e></m>
		</meta>
	</class>
	<class path="haxe.ds._StringMap.StringMapValueIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap" final="1">
		<m><c path="haxe.ds.StringMap"><c path="haxe.ds._StringMap.StringMapValueIterator.T"/></c></m>
		<i><x path="Int"/></i>
		<len><x path="Int"/></len>
		<hasNext public="1" set="method" line="518"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="528"><f a=""><c path="haxe.ds._StringMap.StringMapValueIterator.T"/></f></next>
		<new public="1" set="method" line="512"><f a="m">
	<c path="haxe.ds.StringMap"><c path="haxe.ds._StringMap.StringMapValueIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":access"><e>haxe.ds.StringMap</e></m>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
		<c path="cs.NativeArray"><c path="haxe.ds._Vector.VectorData.T"/></c>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<abstract path="haxe.ds.Vector" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1">
	<_new public="1" get="inline" set="null" line="64" static="1">
		<f a="length">
			<x path="Int"/>
			<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
		</f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new Vector of length `length`.

		Initially `this` Vector contains `length` neutral elements:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
		<overloads><_new public="1" get="inline" set="null" line="96">
	<f a="length:defaultValue">
		<x path="Int"/>
		<c path="haxe.ds.Vector.T"/>
		<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
	</f>
	<meta><m n=":noCompletion"/></meta>
	<haxe_doc>Creates a new Vector of length `length` filled with `defaultValue` elements.

		Can be faster than `new Vector(length)` for iteration on some targets for non-nullable elements.

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
</_new></overloads>
	</_new>
	<get public="1" get="inline" set="null" line="132" static="1">
		<f a="this:index">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<x path="Int"/>
			<c path="haxe.ds.Vector.T"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
		<haxe_doc>Returns the value at index `index`.

		If `index` is negative or exceeds `this.length`, the result is
		unspecified.</haxe_doc>
	</get>
	<set public="1" get="inline" set="null" line="150" static="1">
		<f a="this:index:val">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<x path="Int"/>
			<c path="haxe.ds.Vector.T"/>
			<c path="haxe.ds.Vector.T"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
		<haxe_doc>Sets the value at index `index` to `val`.

		If `index` is negative or exceeds `this.length`, the result is
		unspecified.</haxe_doc>
	</set>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
	</length>
	<get_length get="inline" set="null" line="167" static="1"><f a="this">
	<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
	<x path="Int"/>
</f></get_length>
	<fill public="1" get="inline" set="null" line="185" static="1">
		<f a="this:value">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<c path="haxe.ds.Vector.T"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Sets all `length` elements of `this` Vector to `value`.</haxe_doc>
	</fill>
	<blit public="1" params="T" get="inline" set="null" line="194" static="1">
		<f a="src:srcPos:dest:destPos:len">
			<x path="haxe.ds.Vector"><c path="blit.T"/></x>
			<x path="Int"/>
			<x path="haxe.ds.Vector"><c path="blit.T"/></x>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Copies `length` of elements from `src` Vector, beginning at `srcPos` to
		`dest` Vector, beginning at `destPos`

		The results are unspecified if `length` results in out-of-bounds access,
		or if `src` or `dest` are null</haxe_doc>
	</blit>
	<copy public="1" params="T" get="inline" set="null" line="318" static="1">
		<f a="this">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<x path="haxe.ds.Vector"><c path="copy.T"/></x>
		</f>
		<haxe_doc>Returns a shallow copy of `this` Vector.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
	</copy>
	<join public="1" params="T" get="inline" set="null" line="341" static="1">
		<f a="this:sep">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<c path="String"/>
			<c path="String"/>
		</f>
		<haxe_doc>Returns a string representation of `this` Vector, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` Vector has length 0, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
	</join>
	<map public="1" params="S" get="inline" set="null" line="364" static="1">
		<f a="this:f">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<f a="">
				<c path="haxe.ds.Vector.T"/>
				<c path="map.S"/>
			</f>
			<x path="haxe.ds.Vector"><c path="map.S"/></x>
		</f>
		<haxe_doc>Creates a new Vector by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
	</map>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":nativeGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.ds._Vector.Vector_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1">
		<_new public="1" get="inline" set="null" line="64" static="1">
			<f a="length">
				<x path="Int"/>
				<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new Vector of length `length`.

		Initially `this` Vector contains `length` neutral elements:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
			<overloads><_new public="1" get="inline" set="null" line="96">
	<f a="length:defaultValue">
		<x path="Int"/>
		<c path="haxe.ds.Vector.T"/>
		<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
	</f>
	<meta><m n=":noCompletion"/></meta>
	<haxe_doc>Creates a new Vector of length `length` filled with `defaultValue` elements.

		Can be faster than `new Vector(length)` for iteration on some targets for non-nullable elements.

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
</_new></overloads>
		</_new>
		<get public="1" get="inline" set="null" line="132" static="1">
			<f a="this:index">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<x path="Int"/>
				<c path="haxe.ds.Vector.T"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
			<haxe_doc>Returns the value at index `index`.

		If `index` is negative or exceeds `this.length`, the result is
		unspecified.</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="150" static="1">
			<f a="this:index:val">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<x path="Int"/>
				<c path="haxe.ds.Vector.T"/>
				<c path="haxe.ds.Vector.T"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
			<haxe_doc>Sets the value at index `index` to `val`.

		If `index` is negative or exceeds `this.length`, the result is
		unspecified.</haxe_doc>
		</set>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="167" static="1"><f a="this">
	<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
	<x path="Int"/>
</f></get_length>
		<fill public="1" get="inline" set="null" line="185" static="1">
			<f a="this:value">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<c path="haxe.ds.Vector.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets all `length` elements of `this` Vector to `value`.</haxe_doc>
		</fill>
		<blit public="1" params="T" get="inline" set="null" line="194" static="1">
			<f a="src:srcPos:dest:destPos:len">
				<x path="haxe.ds.Vector"><c path="blit.T"/></x>
				<x path="Int"/>
				<x path="haxe.ds.Vector"><c path="blit.T"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies `length` of elements from `src` Vector, beginning at `srcPos` to
		`dest` Vector, beginning at `destPos`

		The results are unspecified if `length` results in out-of-bounds access,
		or if `src` or `dest` are null</haxe_doc>
		</blit>
		<copy public="1" params="T" get="inline" set="null" line="318" static="1">
			<f a="this">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<x path="haxe.ds.Vector"><c path="copy.T"/></x>
			</f>
			<haxe_doc>Returns a shallow copy of `this` Vector.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<join public="1" params="T" get="inline" set="null" line="341" static="1">
			<f a="this:sep">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Vector, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` Vector has length 0, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<map public="1" params="S" get="inline" set="null" line="364" static="1">
			<f a="this:f">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<f a="">
					<c path="haxe.ds.Vector.T"/>
					<c path="map.S"/>
				</f>
				<x path="haxe.ds.Vector"><c path="map.S"/></x>
			</f>
			<haxe_doc>Creates a new Vector by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
		</meta>
	</class>
	<class path="haxe.exceptions.PosException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/exceptions/PosException.hx">
		<extends path="haxe.Exception"/>
		<posInfos final="1" public="1">
			<t path="haxe.PosInfos"/>
			<haxe_doc>Position where this exception was created.</haxe_doc>
		</posInfos>
		<toString public="1" set="method" line="24" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<new public="1" set="method" line="12"><f a="message:?previous:?pos">
	<c path="String"/>
	<c path="haxe.Exception"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception that carry position information of a place where it was created.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.exceptions.NotImplementedException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/exceptions/NotImplementedException.hx">
		<extends path="haxe.exceptions.PosException"/>
		<new public="1" set="method" line="7">
			<f a="?message:?previous:?pos" v="&quot;Not implemented&quot;::">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : "Not implemented" }</e></m></meta>
		</new>
		<haxe_doc>An exception that is thrown when requested function or operation does not have an implementation.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="haxe.extern.Rest" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/extern/Rest.hx">
		<x path="haxe.Rest"><c path="haxe.extern.Rest.T"/></x>
		<haxe_doc><![CDATA[DEPRECATED: use haxe.Rest instead.
	
	A special type that represents "rest" function argument.
	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.
	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="haxe.format.JsonParser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/format/JsonParser.hx">
		<parse public="1" get="inline" set="null" line="44" static="1">
			<f a="str">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[Parses given JSON-encoded `str` and returns the resulting object.

		JSON objects are parsed into anonymous structures and JSON arrays
		are parsed into `Array<Dynamic>`.

		If given `str` is not valid JSON, an exception will be thrown.

		If `str` is null, the result is unspecified.]]></haxe_doc>
		</parse>
		<str><c path="String"/></str>
		<pos><x path="Int"/></pos>
		<doParse set="method" line="56"><f a=""><d/></f></doParse>
		<parseRec set="method" line="70"><f a=""><d/></f></parseRec>
		<parseString set="method" line="152"><f a=""><c path="String"/></f></parseString>
		<parseNumber get="inline" set="null" line="256"><f a="c">
	<x path="Int"/>
	<d/>
</f></parseNumber>
		<nextChar get="inline" set="null" line="312"><f a=""><x path="Int"/></f></nextChar>
		<invalidChar set="method" line="316"><f a=""><x path="Void"/></f></invalidChar>
		<invalidNumber set="method" line="321"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidNumber>
		<new set="method" line="51"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON parser in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-parsing.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.format.JsonPrinter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/format/JsonPrinter.hx">
		<print public="1" set="method" line="44" static="1">
			<f a="o:?replacer:?space">
				<d/>
				<f a="key:value">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `o`'s value and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve
		actual object to be encoded. The `replacer` function takes two parameters,
		the key and the value being encoded. Initial key value is an empty string.

		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.</haxe_doc>
		</print>
		<buf><c path="StringBuf"/></buf>
		<replacer><f a="key:value">
	<d/>
	<d/>
	<d/>
</f></replacer>
		<indent><c path="String"/></indent>
		<pretty><x path="Bool"/></pretty>
		<nind><x path="Int"/></nind>
		<ipad get="inline" set="null" line="71"><f a=""><x path="Void"/></f></ipad>
		<newl get="inline" set="null" line="76"><f a=""><x path="Void"/></f></newl>
		<write set="method" line="81"><f a="k:v">
	<d/>
	<d/>
	<x path="Void"/>
</f></write>
		<addChar get="inline" set="null" line="140"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></addChar>
		<add get="inline" set="null" line="148"><f a="v">
	<c path="String"/>
	<x path="Void"/>
</f></add>
		<classString set="method" line="157"><f a="v">
	<d/>
	<x path="Void"/>
</f></classString>
		<objString get="inline" set="null" line="161"><f a="v">
	<d/>
	<x path="Void"/>
</f></objString>
		<fieldsString set="method" line="165"><f a="v:fields">
	<d/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></fieldsString>
		<quote set="method" line="196"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></quote>
		<new set="method" line="56"><f a="replacer:space">
	<f a="key:value">
		<d/>
		<d/>
		<d/>
	</f>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON printer in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-encoding.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="549" static="1">
			<f a="length">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns a new `Bytes` instance with the given `length`. The values of the
		bytes are not initialized and may not be zero.</haxe_doc>
		</alloc>
		<ofString public="1" set="method" line="580" static="1">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns the `Bytes` representation of the given `String`, using the
		specified encoding (UTF-8 by default).</haxe_doc>
		</ofString>
		<ofData public="1" set="method" line="656" static="1">
			<f a="b">
				<t path="haxe.io.BytesData"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns the `Bytes` representation of the given `BytesData`.</haxe_doc>
		</ofData>
		<ofHex public="1" set="method" line="673" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Converts the given hexadecimal `String` to `Bytes`. `s` must be a string of
		even length consisting only of hexadecimal digits. For example:
		`"0FDA14058916052309"`.</haxe_doc>
		</ofHex>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="45">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the byte at index `pos`.</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="64">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores the given byte `v` at the given position `pos`.</haxe_doc>
		</set>
		<toString public="1" set="method" line="502">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a `String` representation of the bytes interpreted as UTF-8.</haxe_doc>
		</toString>
		<getData public="1" get="inline" set="null" line="541">
			<f a=""><t path="haxe.io.BytesData"/></f>
			<haxe_doc>Returns the bytes of `this` instance as `BytesData`.</haxe_doc>
		</getData>
		<new set="method" line="34"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/BytesBuffer.hx">
		<b><c path="cs.system.io.MemoryStream"/></b>
		<addBytes public="1" get="inline" set="null" line="165"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="202">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer should no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/BytesData.hx">
		<c path="cs.NativeArray"><x path="cs.UInt8"/></c>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<enum path="haxe.io.Encoding" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Encoding.hx">
		<UTF8/>
		<RawNative><haxe_doc>Output the string the way the platform represent it in memory. This is the most efficient but is platform-specific</haxe_doc></RawNative>
		<haxe_doc>String binary encoding supported by Haxe I/O</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.io.Eof" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="32">
			<f a=""><c path="String"/></f>
			<meta><m n=":ifFeature"><e>"haxe.io.Eof.*"</e></m></meta>
		</toString>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<class path="haxe.io.Path" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/io/Path.hx">
		<addTrailingSlash public="1" set="method" line="271" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

		If the last slash in `path` is a backslash, a backslash is appended to
		`path`.

		If the last slash in `path` is a slash, or if no slash is found, a slash
		is appended to `path`. In particular, this applies to the empty String
		`""`.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- `directory1/directory2/filename.extension`
	- `directory1\directory2\filename.extension`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.iterators.ArrayIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0" line="30">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="44">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="36">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.iterators.ArrayKeyValueIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/iterators/ArrayKeyValueIterator.hx">
		<current expr="0" line="27">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<array><c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c></array>
		<hasNext public="1" get="inline" set="null" line="34"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="38"><f a=""><a>
	<value><c path="haxe.iterators.ArrayKeyValueIterator.T"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new public="1" get="inline" set="null" line="30"><f a="array">
	<c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":ifFeature">
				<e>"anon_read.keyValueIterator"</e>
				<e>"dynamic_read.keyValueIterator"</e>
			</m>
		</meta>
	</class>
	<class path="haxe.iterators.DynamicAccessKeyValueIterator" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/iterators/DynamicAccessKeyValueIterator.hx">
		<access final="1"><x path="haxe.DynamicAccess"><c path="haxe.iterators.DynamicAccessKeyValueIterator.T"/></x></access>
		<keys final="1"><c path="Array"><c path="String"/></c></keys>
		<index><x path="Int"/></index>
		<hasNext public="1" get="inline" set="null" line="42">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="49">
			<f a=""><a>
	<value><c path="haxe.iterators.DynamicAccessKeyValueIterator.T"/></value>
	<key><c path="String"/></key>
</a></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="33"><f a="access">
	<x path="haxe.DynamicAccess"><c path="haxe.iterators.DynamicAccessKeyValueIterator.T"/></x>
	<x path="Void"/>
</f></new>
		<haxe_doc>This Key/Value iterator can be used to iterate over `haxe.DynamicAccess`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.iterators.MapKeyValueIterator" params="K:V" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/iterators/MapKeyValueIterator.hx">
		<map><c path="haxe.IMap">
	<c path="haxe.iterators.MapKeyValueIterator.K"/>
	<c path="haxe.iterators.MapKeyValueIterator.V"/>
</c></map>
		<keys><t path="Iterator"><c path="haxe.iterators.MapKeyValueIterator.K"/></t></keys>
		<hasNext public="1" get="inline" set="null" line="43">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="50">
			<f a=""><a>
	<value><c path="haxe.iterators.MapKeyValueIterator.V"/></value>
	<key><c path="haxe.iterators.MapKeyValueIterator.K"/></key>
</a></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35"><f a="map">
	<c path="haxe.IMap">
		<c path="haxe.iterators.MapKeyValueIterator.K"/>
		<c path="haxe.iterators.MapKeyValueIterator.V"/>
	</c>
	<x path="Void"/>
</f></new>
		<haxe_doc>This Key/Value iterator can be used to iterate across maps.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":ifFeature">
				<e>"anon_read.keyValueIterator"</e>
				<e>"dynamic_read.keyValueIterator"</e>
			</m>
		</meta>
	</class>
	<class path="haxe.iterators.StringIteratorUnicode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/iterators/StringIteratorUnicode.hx">
		<offset expr="0" line="34">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offset>
		<s><c path="String"/></s>
		<hasNext public="1" get="inline" set="null" line="47">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="55">
			<f a=""><x path="Int"/></f>
			<meta><m n=":access"><e>StringTools</e></m></meta>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="40">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `StringIteratorUnicode` over String `s`.</haxe_doc>
		</new>
		<haxe_doc>This iterator can be used to iterate across strings in a cross-platform
	way. It handles surrogate pairs on platforms that require it. On each
	iteration, it returns the next character code.

	Note that this has different semantics than a standard for-loop over the
	String's length due to the fact that it deals with surrogate pairs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="haxe.macro.Position" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<min>
				<x path="Int"/>
				<haxe_doc>Position of the first character.</haxe_doc>
			</min>
			<max>
				<x path="Int"/>
				<haxe_doc>Position of the last character.</haxe_doc>
			</max>
			<file>
				<c path="String"/>
				<haxe_doc>Reference to the filename.</haxe_doc>
			</file>
		</a>
		<haxe_doc>Represents a position in a file.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.Expr" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.ExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a node in the AST.
	@see https://haxe.org/manual/macro-reification-expression.html</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<t path="haxe.macro.Expr"/>
		<haxe_doc>Represents a AST node identical to `Expr`, but it allows constraining the
	type of accepted expressions.
	@see https://haxe.org/manual/macro-ExprOf.html</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.Case" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<values>
				<c path="Array"><t path="haxe.macro.Expr"/></c>
				<haxe_doc>The value expressions of the case.</haxe_doc>
			</values>
			<guard>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional guard expressions of the case, if available.</haxe_doc>
			</guard>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the case, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a switch case.
	@see https://haxe.org/manual/expression-switch.html</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.Var" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type-hint of the variable, if available.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Metadata associatied with the variable, if available.</haxe_doc>
			</meta>
			<isStatic>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the variable is static.</haxe_doc>
			</isStatic>
			<isFinal>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the variable can be assigned to.</haxe_doc>
			</isFinal>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the variable, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a variable in the AST.
	@see https://haxe.org/manual/expression-var.html</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.Catch" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type of the catch.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the catch variable.</haxe_doc>
			</name>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The expression of the catch.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a catch in the AST.
	@see https://haxe.org/manual/expression-try-catch.html</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.ObjectField" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<quotes>
				<x path="Null"><e path="haxe.macro.QuoteStatus"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>How the field name is quoted.</haxe_doc>
			</quotes>
			<field>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</field>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The field expression.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents the field of an object declaration.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.TypePath" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<sub>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sub is set on module sub-type access:
		`pack.Module.Type` has `name = "Module"`, `sub = "Type"`, if available.</haxe_doc>
			</sub>
			<params>
				<x path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional parameters of the type path.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Represents the package of the type path.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type path.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a type path in the AST.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the type parameter.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the type parameter.</haxe_doc>
			</meta>
			<defaultType>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional default type of the type parameter.</haxe_doc>
			</defaultType>
			<constraints>
				<x path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional constraints of the type parameter.</haxe_doc>
			</constraints>
		</a>
		<haxe_doc>Represents a type parameter declaration in the AST.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.Function" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<ret>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The return type-hint of the function, if available.</haxe_doc>
			</ret>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of function parameter type declarations.</haxe_doc>
			</params>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the function body, if available.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><t path="haxe.macro.FunctionArg"/></c>
				<haxe_doc>A list of function arguments.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the AST.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<value>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional value of the function argument, if available.</haxe_doc>
			</value>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type-hint of the function argument, if available.</haxe_doc>
			</type>
			<opt>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the function argument is optional.</haxe_doc>
			</opt>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function argument.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the function argument.</haxe_doc>
			</meta>
		</a>
		<haxe_doc>Represents a function argument in the AST.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the metadata entry.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the metadata entry.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the metadata entry.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a metadata entry in the AST.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
		<haxe_doc>Represents metadata in the AST.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.Field" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the field.</haxe_doc>
			</pos>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldType"/>
				<haxe_doc>The kind of the field.</haxe_doc>
			</kind>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the field, if available. If the field has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
			<access>
				<x path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access modifiers of the field. By default fields have private access.
		@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
			</access>
		</a>
		<haxe_doc>Represents a field in the AST.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position to the type definition.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The parameter type declarations of the type definition.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type definition.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type definition.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the type definition.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.TypeDefKind"/>
				<haxe_doc>The kind of the type definition.</haxe_doc>
			</kind>
			<isExtern>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<fields>
				<c path="Array"><t path="haxe.macro.Field"/></c>
				<haxe_doc>The fields of the type definition.</haxe_doc>
			</fields>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the type, if available. If the type has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a type definition.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<path>
				<c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c>
				<haxe_doc>The path to the import expression.</haxe_doc>
			</path>
			<mode>
				<e path="haxe.macro.ImportMode"/>
				<haxe_doc>The mode of the import expression.</haxe_doc>
			</mode>
		</a>
		<haxe_doc>Represents the import expression.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.Ref" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<toString set="method"><f a=""><c path="String"/></f></toString>
			<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
		</a>
		<haxe_doc>Represents a reference to internal compiler structure. It exists to avoid
	expensive encoding if it is not required and to ensure that physical
	equality remains intact.

	A structure is only encoded when user requests it through `ref.get()`.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.AnonType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<status>
				<e path="haxe.macro.AnonStatus"/>
				<haxe_doc>The status/kind of the structure.</haxe_doc>
			</status>
			<fields>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The class fields of the structure.</haxe_doc>
			</fields>
		</a>
		<haxe_doc>Represents information for anonymous structure types.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.TypeParameter" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the type parameter. It is guaranteed to be a `TInst` with a
		`KTypeParameter` kind.</haxe_doc>
			</t>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<defaultType>
				<x path="Null"><e path="haxe.macro.Type"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The default type for this type parameter.</haxe_doc>
			</defaultType>
		</a>
		<haxe_doc>Represents the declaration of type parameters.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.ClassField" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the class field.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the class field.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the class field.</haxe_doc>
			</params>
			<overloads>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The overload fields of the class field.</haxe_doc>
			</overloads>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the class field.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the class field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldKind"/>
				<haxe_doc>The class field kind.</haxe_doc>
			</kind>
			<isPublic>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is public.</haxe_doc>
			</isPublic>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is final.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is extern.</haxe_doc>
			</isExtern>
			<isAbstract>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is abstract.</haxe_doc>
			</isAbstract>
			<expr set="method">
				<f a=""><x path="Null"><t path="haxe.macro.TypedExpr"/></x></f>
				<haxe_doc>Returns the typed expression of the class field.</haxe_doc>
			</expr>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a class field.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.EnumField" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the enum constructor.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the enum constructor.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the enum constructor.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the enum constructor.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the enum constructor.</haxe_doc>
			</meta>
			<index>
				<x path="Int"/>
				<haxe_doc>The index of the enum constructor, i.e. in which position it appears
		in the syntax.</haxe_doc>
			</index>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the enum constructor.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents an enum constructor.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.BaseType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The information that all types (`ClassType`, `EnumType`, `DefType`,
	`AbstractType`) have in common.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.ClassType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<superClass>
				<x path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></x>
				<haxe_doc>The parent class and its type parameters, if available.</haxe_doc>
			</superClass>
			<statics>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The static fields of the class.</haxe_doc>
			</statics>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<overrides>
				<c path="Array"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></c>
				<haxe_doc>The list of fields that have override status.</haxe_doc>
			</overrides>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.ClassKind"/>
				<haxe_doc>The kind of the class.</haxe_doc>
			</kind>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isInterface>
				<x path="Bool"/>
				<haxe_doc>If true the type is an interface, otherwise it is a class.</haxe_doc>
			</isInterface>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>If true the class is final and cannot be extended.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<isAbstract>
				<x path="Bool"/>
				<haxe_doc>If true the class is abstract and cannot be instantiated directly.</haxe_doc>
			</isAbstract>
			<interfaces>
				<c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c>
				<haxe_doc>The implemented interfaces and their type parameters.</haxe_doc>
			</interfaces>
			<init>
				<x path="Null"><t path="haxe.macro.TypedExpr"/></x>
				<haxe_doc>The `__init__` expression of the class, if available.</haxe_doc>
			</init>
			<fields>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The member fields of the class.</haxe_doc>
			</fields>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructor>
				<x path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></x>
				<haxe_doc>The constructor of the class, if available.</haxe_doc>
			</constructor>
		</a>
		<haxe_doc>Represents a class type.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.EnumType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<names>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>An ordered list of enum constructor names.</haxe_doc>
			</names>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructs>
				<t path="Map">
					<c path="String"/>
					<t path="haxe.macro.EnumField"/>
				</t>
				<haxe_doc>The available enum constructors.</haxe_doc>
			</constructs>
		</a>
		<haxe_doc>Represents an enum type.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.DefType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The target type of the typedef.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a typedef.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.AbstractType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<unops>
				<c path="Array"><a>
	<postFix><x path="Bool"/></postFix>
	<op><e path="haxe.macro.Unop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined unary operators of the abstract.</haxe_doc>
			</unops>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The underlying type of the abstract.</haxe_doc>
			</type>
			<to>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><x path="Null"><t path="haxe.macro.ClassField"/></x></field>
</a></c>
				<haxe_doc>The available implicit to-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</to>
			<resolveWrite>
				<x path="Null"><t path="haxe.macro.ClassField"/></x>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolveWrite>
			<resolve>
				<x path="Null"><t path="haxe.macro.ClassField"/></x>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolve>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<impl>
				<x path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></x>
				<haxe_doc>The implementation class of the abstract, if available.</haxe_doc>
			</impl>
			<from>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><x path="Null"><t path="haxe.macro.ClassField"/></x></field>
</a></c>
				<haxe_doc>The available implicit from-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</from>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<binops>
				<c path="Array"><a>
	<op><e path="haxe.macro.Binop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined binary operators of the abstract.</haxe_doc>
			</binops>
			<array>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The defined array-access fields of the abstract.</haxe_doc>
			</array>
		</a>
		<haxe_doc>Represents an abstract type.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<remove set="method">
				<f a="name">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Removes all `name` metadata entries from the origin of `this`
		MetaAccess.

		This method might clear several metadata entries of the same name.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `remove` has no effect on that array.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</remove>
			<has set="method">
				<f a="name">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<haxe_doc>Tells if the origin of `this` MetaAccess has a `name` metadata entry.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</has>
			<get set="method">
				<f a=""><t path="haxe.macro.Metadata"/></f>
				<haxe_doc>Return the wrapped `Metadata` array.

		Modifying this array has no effect on the origin of `this` MetaAccess.
		The `add` and `remove` methods can be used for that.</haxe_doc>
			</get>
			<extract set="method">
				<f a="name">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
				</f>
				<haxe_doc>Extract metadata entries by given `name`.

		If there's no metadata with such name, empty array `[]` is returned.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</extract>
			<add set="method">
				<f a="name:params:pos">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.Expr"/></c>
					<t path="haxe.macro.Position"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Adds the metadata specified by `name`, `params` and `pos` to the origin
		of `this` MetaAccess.

		Metadata names are not unique during compilation, so this method never
		overwrites a previous metadata.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `add` has no effect on that array.

		If any argument is null, compilation fails with an error.</haxe_doc>
			</add>
		</a>
		<haxe_doc>MetaAccess is a wrapper for the `Metadata` array. It can be used to add
	metadata to and remove metadata from its origin.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.TVar" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t set="null">
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the variable.</haxe_doc>
			</t>
			<name set="null">
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta set="null">
				<x path="Null"><t path="haxe.macro.MetaAccess"/></x>
				<haxe_doc>The metadata of the variable.</haxe_doc>
			</meta>
			<id set="null">
				<x path="Int"/>
				<haxe_doc>The unique ID of the variable.</haxe_doc>
			</id>
			<extra set="null">
				<x path="Null"><a>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<expr><x path="Null"><t path="haxe.macro.TypedExpr"/></x></expr>
</a></x>
				<haxe_doc>Special information which is internally used to keep track of closure.
		information</haxe_doc>
			</extra>
			<capture set="null">
				<x path="Bool"/>
				<haxe_doc>Whether or not the variable has been captured by a closure.</haxe_doc>
			</capture>
		</a>
		<haxe_doc>Represents a variable in the typed AST.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.TFunc" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The return type of the function.</haxe_doc>
			</t>
			<expr>
				<t path="haxe.macro.TypedExpr"/>
				<haxe_doc>The expression of the function body.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><a>
	<value><x path="Null"><t path="haxe.macro.TypedExpr"/></x></value>
	<v><t path="haxe.macro.TVar"/></v>
</a></c>
				<haxe_doc>A list of function arguments identified by an argument variable `v` and
		an optional initialization `value`.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the typed AST.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.macro.TypedExpr" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the expression.</haxe_doc>
			</t>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.TypedExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a typed AST node.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.rtti.Path" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<c path="String"/>
		<haxe_doc>The (dot-)path of the runtime type.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.rtti.Platforms" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<c path="Array"><c path="String"/></c>
		<haxe_doc>A list of strings representing the targets where the type is available.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.rtti.FunctionArgument" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<value>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
			</value>
			<t><e path="haxe.rtti.CType"/></t>
			<opt><x path="Bool"/></opt>
			<name><c path="String"/></name>
		</a>
		<haxe_doc>The function argument runtime type information.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<enum path="haxe.rtti.CType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx">
		<CUnknown/>
		<CEnum a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="Array"><e path="haxe.rtti.CType"/></c>
		</CEnum>
		<CClass a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="Array"><e path="haxe.rtti.CType"/></c>
		</CClass>
		<CTypedef a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="Array"><e path="haxe.rtti.CType"/></c>
		</CTypedef>
		<CFunction a="args:ret">
			<c path="Array"><t path="haxe.rtti.FunctionArgument"/></c>
			<e path="haxe.rtti.CType"/>
		</CFunction>
		<CAnonymous a="fields"><c path="Array"><t path="haxe.rtti.ClassField"/></c></CAnonymous>
		<CDynamic a="?t"><e path="haxe.rtti.CType"/></CDynamic>
		<CAbstract a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="Array"><e path="haxe.rtti.CType"/></c>
		</CAbstract>
		<haxe_doc>The runtime member types.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<typedef path="haxe.rtti.PathParams" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<path>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The path of the type.</haxe_doc>
			</path>
			<params>
				<c path="Array"><e path="haxe.rtti.CType"/></c>
				<haxe_doc>The array of parameters types.</haxe_doc>
			</params>
		</a>
		<haxe_doc>The type parameters in the runtime type information.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.rtti.TypeParams" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<c path="Array"><c path="String"/></c>
		<haxe_doc>An array of strings representing the names of the type parameters the type
	has. As of Haxe 3.2.0, this does not include the constraints.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<enum path="haxe.rtti.Rights" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<RNormal/>
		<RNo/>
		<RCall a="m"><c path="String"/></RCall>
		<RMethod/>
		<RDynamic/>
		<RInline/>
		<haxe_doc>Represents the runtime rights of a type.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<typedef path="haxe.rtti.MetaData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<c path="Array"><a>
	<params><c path="Array"><c path="String"/></c></params>
	<name><c path="String"/></name>
</a></c>
		<haxe_doc>The list of runtime metadata.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.rtti.ClassField" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<type>
				<e path="haxe.rtti.CType"/>
				<haxe_doc>The type of the field.</haxe_doc>
			</type>
			<set>
				<e path="haxe.rtti.Rights"/>
				<haxe_doc>The [write access](https://haxe.org/manual/class-field-property.html#define-write-access)
		behavior of the field.</haxe_doc>
			</set>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the field is available.</haxe_doc>
			</platforms>
			<params>
				<t path="haxe.rtti.TypeParams"/>
				<haxe_doc>An array of strings representing the names of the type parameters
		the field has.</haxe_doc>
			</params>
			<overloads>
				<x path="Null"><c path="Array"><t path="haxe.rtti.ClassField"/></c></x>
				<haxe_doc>The list of available overloads for the fields or `null` if no overloads
		exists.</haxe_doc>
			</overloads>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The meta data the field was annotated with.</haxe_doc>
			</meta>
			<line>
				<x path="Null"><x path="Int"/></x>
				<haxe_doc>The line number where the field is defined. This information is only
		available if the field has an expression.
		Otherwise the value is `null`.</haxe_doc>
			</line>
			<isPublic>
				<x path="Bool"/>
				<haxe_doc>Whether or not the field is `public`.</haxe_doc>
			</isPublic>
			<isOverride>
				<x path="Bool"/>
				<haxe_doc>Whether or not the field overrides another field.</haxe_doc>
			</isOverride>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>Whether or not the field is `final`.</haxe_doc>
			</isFinal>
			<get>
				<e path="haxe.rtti.Rights"/>
				<haxe_doc>The [read access](https://haxe.org/manual/class-field-property.html#define-read-access)
		behavior of the field.</haxe_doc>
			</get>
			<expr>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The actual expression of the field or `null` if there is no expression.</haxe_doc>
			</expr>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The documentation of the field. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or
		if the field has no documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc><![CDATA[The runtime class field information.

	@see <https://haxe.org/manual/cr-rtti-structure.html#class-field-information>]]></haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.rtti.TypeInfos" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the type is available.</haxe_doc>
			</platforms>
			<path>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the type.</haxe_doc>
			</path>
			<params>
				<t path="haxe.rtti.TypeParams"/>
				<haxe_doc>An array of strings representing the names of the type parameters the
		type has.</haxe_doc>
			</params>
			<module>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the module containing the type.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The [metadata](https://haxe.org/manual/lf-metadata.html) the type was
		annotated with.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).</haxe_doc>
			</isPrivate>
			<file>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The full slash path of the .hx file containing the type.
		This might be `null` in case there is no such file, e.g. if the
		type is defined through a macro.</haxe_doc>
			</file>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The documentation of the type. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if
		the constructor has no documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The general runtime type information.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.rtti.Classdef" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<tdynamic>
				<x path="Null"><e path="haxe.rtti.CType"/></x>
				<haxe_doc>The type which is dynamically implemented by the class or `null` if no
		such type exists.</haxe_doc>
			</tdynamic>
			<superClass>
				<x path="Null"><t path="haxe.rtti.PathParams"/></x>
				<haxe_doc>The class' parent class defined by its type path and list of type
		parameters.</haxe_doc>
			</superClass>
			<statics>
				<c path="Array"><t path="haxe.rtti.ClassField"/></c>
				<haxe_doc>The list of static class fields.</haxe_doc>
			</statics>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the type is available.</haxe_doc>
			</platforms>
			<path>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the type.</haxe_doc>
			</path>
			<params>
				<t path="haxe.rtti.TypeParams"/>
				<haxe_doc>An array of strings representing the names of the type parameters the
		type has.</haxe_doc>
			</params>
			<module>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the module containing the type.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The [metadata](https://haxe.org/manual/lf-metadata.html) the type was
		annotated with.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).</haxe_doc>
			</isPrivate>
			<isInterface>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class is actually an [interface](https://haxe.org/manual/types-interfaces.html).</haxe_doc>
			</isInterface>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class is `final`.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class is [extern](https://haxe.org/manual/lf-externs.html).</haxe_doc>
			</isExtern>
			<interfaces>
				<c path="Array"><t path="haxe.rtti.PathParams"/></c>
				<haxe_doc>The list of interfaces defined by their type path and list of type
		parameters.</haxe_doc>
			</interfaces>
			<file>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The full slash path of the .hx file containing the type.
		This might be `null` in case there is no such file, e.g. if the
		type is defined through a macro.</haxe_doc>
			</file>
			<fields>
				<c path="Array"><t path="haxe.rtti.ClassField"/></c>
				<haxe_doc>The list of member [class fields](https://haxe.org/manual/class-field.html).</haxe_doc>
			</fields>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The documentation of the type. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if
		the constructor has no documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The runtime class definition information.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.rtti.EnumField" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the constructor is
		available.</haxe_doc>
			</platforms>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the constructor.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The meta data the constructor was annotated with.</haxe_doc>
			</meta>
			<doc>
				<c path="String"/>
				<haxe_doc>The documentation of the constructor. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if
		the constructor has no documentation, the value is `null`.</haxe_doc>
			</doc>
			<args>
				<x path="Null"><c path="Array"><a>
	<t><e path="haxe.rtti.CType"/></t>
	<opt><x path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c></x>
				<haxe_doc>The list of arguments the constructor has or `null` if no arguments are
		available.</haxe_doc>
			</args>
		</a>
		<haxe_doc><![CDATA[The runtime enum constructor information.

	@see <https://haxe.org/manual/cr-rtti-structure.html#enum-constructor-information>]]></haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.rtti.Enumdef" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the type is available.</haxe_doc>
			</platforms>
			<path>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the type.</haxe_doc>
			</path>
			<params>
				<t path="haxe.rtti.TypeParams"/>
				<haxe_doc>An array of strings representing the names of the type parameters the
		type has.</haxe_doc>
			</params>
			<module>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the module containing the type.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The [metadata](https://haxe.org/manual/lf-metadata.html) the type was
		annotated with.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the enum is [extern](https://haxe.org/manual/lf-externs.html).</haxe_doc>
			</isExtern>
			<file>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The full slash path of the .hx file containing the type.
		This might be `null` in case there is no such file, e.g. if the
		type is defined through a macro.</haxe_doc>
			</file>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The documentation of the type. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if
		the constructor has no documentation, the value is `null`.</haxe_doc>
			</doc>
			<constructors>
				<c path="Array"><t path="haxe.rtti.EnumField"/></c>
				<haxe_doc>The list of enum constructors.</haxe_doc>
			</constructors>
		</a>
		<haxe_doc><![CDATA[The enum runtime type information.

	@see <https://haxe.org/manual/cr-rtti-structure.html#enum-type-information>]]></haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.rtti.Typedef" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<types>
				<t path="Map">
					<c path="String"/>
					<e path="haxe.rtti.CType"/>
				</t>
				<haxe_doc>The types of the typedef, by platform.</haxe_doc>
			</types>
			<type>
				<e path="haxe.rtti.CType"/>
				<haxe_doc>The type of the typedef.</haxe_doc>
			</type>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the type is available.</haxe_doc>
			</platforms>
			<path>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the type.</haxe_doc>
			</path>
			<params>
				<t path="haxe.rtti.TypeParams"/>
				<haxe_doc>An array of strings representing the names of the type parameters the
		type has.</haxe_doc>
			</params>
			<module>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the module containing the type.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The [metadata](https://haxe.org/manual/lf-metadata.html) the type was
		annotated with.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).</haxe_doc>
			</isPrivate>
			<file>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The full slash path of the .hx file containing the type.
		This might be `null` in case there is no such file, e.g. if the
		type is defined through a macro.</haxe_doc>
			</file>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The documentation of the type. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if
		the constructor has no documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The typedef runtime information.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.rtti.Abstractdef" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<a>
			<to><c path="Array"><a>
	<t><e path="haxe.rtti.CType"/></t>
	<field><x path="Null"><c path="String"/></x></field>
</a></c></to>
			<platforms>
				<t path="haxe.rtti.Platforms"/>
				<haxe_doc>A list of strings representing the targets where the type is available.</haxe_doc>
			</platforms>
			<path>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the type.</haxe_doc>
			</path>
			<params>
				<t path="haxe.rtti.TypeParams"/>
				<haxe_doc>An array of strings representing the names of the type parameters the
		type has.</haxe_doc>
			</params>
			<module>
				<t path="haxe.rtti.Path"/>
				<haxe_doc>The type path of the module containing the type.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.rtti.MetaData"/>
				<haxe_doc>The [metadata](https://haxe.org/manual/lf-metadata.html) the type was
		annotated with.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).</haxe_doc>
			</isPrivate>
			<impl><t path="haxe.rtti.Classdef"/></impl>
			<from><c path="Array"><a>
	<t><e path="haxe.rtti.CType"/></t>
	<field><x path="Null"><c path="String"/></x></field>
</a></c></from>
			<file>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The full slash path of the .hx file containing the type.
		This might be `null` in case there is no such file, e.g. if the
		type is defined through a macro.</haxe_doc>
			</file>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The documentation of the type. This information is only available
		if the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if
		the constructor has no documentation, the value is `null`.</haxe_doc>
			</doc>
			<athis><e path="haxe.rtti.CType"/></athis>
		</a>
		<haxe_doc><![CDATA[The abstract type runtime information.

	@see <https://haxe.org/manual/cr-rtti-structure.html#abstract-type-information>]]></haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<enum path="haxe.rtti.TypeTree" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<TPackage a="name:full:subs">
			<c path="String"/>
			<c path="String"/>
			<c path="Array"><e path="haxe.rtti.TypeTree"/></c>
		</TPackage>
		<TClassdecl a="c"><t path="haxe.rtti.Classdef"/></TClassdecl>
		<TEnumdecl a="e"><t path="haxe.rtti.Enumdef"/></TEnumdecl>
		<TTypedecl a="t"><t path="haxe.rtti.Typedef"/></TTypedecl>
		<TAbstractdecl a="a"><t path="haxe.rtti.Abstractdef"/></TAbstractdecl>
		<haxe_doc>The tree types of the runtime type.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<typedef path="haxe.rtti.TypeRoot" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<c path="Array"><e path="haxe.rtti.TypeTree"/></c>
		<haxe_doc>Array of `TypeTree`.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="haxe.rtti._Meta.MetaObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/Meta.hx" private="1" module="haxe.rtti.Meta">
		<a>
			<statics>
				<x path="Null"><d><d><x path="Null"><c path="Array"><d/></c></x></d></d></x>
				<meta><m n=":optional"/></meta>
			</statics>
			<obj>
				<x path="Null"><d><x path="Null"><c path="Array"><d/></c></x></d></x>
				<meta><m n=":optional"/></meta>
			</obj>
			<fields>
				<x path="Null"><d><d><x path="Null"><c path="Array"><d/></c></x></d></d></x>
				<meta><m n=":optional"/></meta>
			</fields>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="haxe.rtti.Meta" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/Meta.hx">
		<isInterface set="method" line="46" static="1"><f a="t">
	<d/>
	<x path="Bool"/>
</f></isInterface>
		<getMeta set="method" line="56" static="1"><f a="t">
	<d/>
	<t path="haxe.rtti._Meta.MetaObject"/>
</f></getMeta>
		<getFields public="1" set="method" line="89" static="1">
			<f a="t">
				<d/>
				<d><d><c path="Array"><d/></c></d></d>
			</f>
			<haxe_doc>Returns the metadata that were declared for the given class fields or enum constructors</haxe_doc>
		</getFields>
		<haxe_doc><![CDATA[An API to access classes and enums metadata at runtime.

	@see <https://haxe.org/manual/cr-rtti.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.rtti.Rtti" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/Rtti.hx">
		<getRtti public="1" params="T" set="method" line="41" static="1">
			<f a="c">
				<x path="Class"><c path="getRtti.T"/></x>
				<t path="haxe.rtti.Classdef"/>
			</f>
			<haxe_doc>Returns the `haxe.rtti.CType.Classdef` corresponding to class `c`.

		If `c` has no runtime type information, e.g. because no `@:rtti` was
		added, an exception of type `String` is thrown.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getRtti>
		<haxe_doc><![CDATA[Rtti is a helper class which supplements the `@:rtti` metadata.

	@see <https://haxe.org/manual/cr-rtti.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.rtti.XmlParser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/rtti/XmlParser.hx">
		<root public="1"><t path="haxe.rtti.TypeRoot"/></root>
		<curplatform><c path="String"/></curplatform>
		<mkPath set="method" line="295"><f a="p">
	<c path="String"/>
	<t path="haxe.rtti.Path"/>
</f></mkPath>
		<mkTypeParams set="method" line="299"><f a="p">
	<c path="String"/>
	<t path="haxe.rtti.TypeParams"/>
</f></mkTypeParams>
		<mkRights set="method" line="306"><f a="r">
	<c path="String"/>
	<e path="haxe.rtti.Rights"/>
</f></mkRights>
		<xerror set="method" line="316"><f a="c">
	<x path="haxe.xml.Access"/>
	<d/>
</f></xerror>
		<processElement public="1" set="method" line="325"><f a="x">
	<c path="Xml"/>
	<e path="haxe.rtti.TypeTree"/>
</f></processElement>
		<xmeta set="method" line="336"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.MetaData"/>
</f></xmeta>
		<xoverloads set="method" line="347"><f a="x">
	<x path="haxe.xml.Access"/>
	<c path="Array"><t path="haxe.rtti.ClassField"/></c>
</f></xoverloads>
		<xpath set="method" line="355"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.PathParams"/>
</f></xpath>
		<xclass set="method" line="366"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.Classdef"/>
</f></xclass>
		<xclassfield set="method" line="417">
			<f a="x:?defPublic" v=":false">
				<x path="haxe.xml.Access"/>
				<x path="Bool"/>
				<t path="haxe.rtti.ClassField"/>
			</f>
			<meta><m n=":value"><e>{ defPublic : false }</e></m></meta>
		</xclassfield>
		<xenum set="method" line="446"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.Enumdef"/>
</f></xenum>
		<xenumfield set="method" line="471"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.EnumField"/>
</f></xenumfield>
		<xabstract set="method" line="502"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.Abstractdef"/>
</f></xabstract>
		<xtypedef set="method" line="540"><f a="x">
	<x path="haxe.xml.Access"/>
	<t path="haxe.rtti.Typedef"/>
</f></xtypedef>
		<xtype set="method" line="568"><f a="x">
	<x path="haxe.xml.Access"/>
	<e path="haxe.rtti.CType"/>
</f></xtype>
		<xtypeparams set="method" line="624"><f a="x">
	<x path="haxe.xml.Access"/>
	<c path="Array"><e path="haxe.rtti.CType"/></c>
</f></xtypeparams>
		<defplat set="method" line="631"><f a=""><c path="Array"><c path="String"/></c></f></defplat>
		<new public="1" set="method" line="39"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[XmlParser processes the runtime type information (RTTI) which
	is stored as a XML string in a static field `__rtti`.

	@see <https://haxe.org/manual/cr-rtti.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.NodeAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="haxe.xml._Access.NodeAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="27" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="haxe.xml.Access"/>
		</f>
		<meta><m n=":op"><e>a.b</e></m></meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.NodeAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="27" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="haxe.xml.Access"/>
			</f>
			<meta><m n=":op"><e>a.b</e></m></meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.AttribAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="haxe.xml._Access.AttribAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="39" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":op"><e>a.b</e></m></meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.AttribAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="39" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":op"><e>a.b</e></m></meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.HasAttribAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="haxe.xml._Access.HasAttribAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="59" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>a.b</e></m></meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.HasAttribAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="59" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>a.b</e></m></meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.HasNodeAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="haxe.xml._Access.HasNodeAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="68" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>a.b</e></m></meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.HasNodeAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="68" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>a.b</e></m></meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.NodeListAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="haxe.xml._Access.NodeListAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<resolve public="1" set="method" line="75" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<c path="Array"><x path="haxe.xml.Access"/></c>
		</f>
		<meta><m n=":op"><e>a.b</e></m></meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.NodeListAccess_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<resolve public="1" set="method" line="75" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<c path="Array"><x path="haxe.xml.Access"/></c>
			</f>
			<meta><m n=":op"><e>a.b</e></m></meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="haxe.xml.Access" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx">
		<this><c path="Xml"/></this>
		<haxe_doc>The `haxe.xml.Access` API helps providing a fast dot-syntax access to the
	most common `Xml` methods.</haxe_doc>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="haxe.xml._Access.Access_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
	<x public="1" get="accessor" set="null" static="1"><c path="Xml"/></x>
	<get_x public="1" get="inline" set="null" line="91" static="1"><f a="this">
	<c path="Xml"/>
	<c path="Xml"/>
</f></get_x>
	<name public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<haxe_doc>The name of the current element. This is the same as `Xml.nodeName`.</haxe_doc>
	</name>
	<get_name get="inline" set="null" line="98" static="1"><f a="this">
	<c path="Xml"/>
	<c path="String"/>
</f></get_name>
	<innerData public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<haxe_doc>The inner PCDATA or CDATA of the node.

		An exception is thrown if there is no data or if there not only data
		but also other nodes.</haxe_doc>
	</innerData>
	<innerHTML public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<haxe_doc>The XML string built with all the sub nodes, excluding the current one.</haxe_doc>
	</innerHTML>
	<node public="1" get="accessor" set="null" static="1">
		<x path="haxe.xml._Access.NodeAccess"/>
		<haxe_doc><![CDATA[Access to the first sub element with the given name.

		An exception is thrown if the element doesn't exists.
		Use `hasNode` to check the existence of a node.

		```haxe
		var access = new haxe.xml.Access(Xml.parse("<user><name>John</name></user>"));
		var user = access.node.user;
		var name = user.node.name;
		trace(name.innerData); // John

		// Uncaught Error: Document is missing element password
		var password = user.node.password;
		```]]></haxe_doc>
	</node>
	<get_node get="inline" set="null" line="134" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.NodeAccess"/>
</f></get_node>
	<nodes public="1" get="accessor" set="null" static="1">
		<x path="haxe.xml._Access.NodeListAccess"/>
		<haxe_doc><![CDATA[Access to the List of elements with the given name.
		```haxe
		var fast = new haxe.xml.Access(Xml.parse("
			<users>
				<user name='John'/>
				<user name='Andy'/>
				<user name='Dan'/>
			</users>"
		));

		var users = fast.node.users;
		for (user in users.nodes.user) {
			trace(user.att.name);
		}
		```]]></haxe_doc>
	</nodes>
	<get_nodes get="inline" set="null" line="156" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.NodeListAccess"/>
</f></get_nodes>
	<att public="1" get="accessor" set="null" static="1">
		<x path="haxe.xml._Access.AttribAccess"/>
		<haxe_doc><![CDATA[Access to a given attribute.

		An exception is thrown if the attribute doesn't exists.
		Use `has` to check the existence of an attribute.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user name='Mark'></user>"));
		var user = f.node.user;
		if (user.has.name) {
			trace(user.att.name); // Mark
		}
		```]]></haxe_doc>
	</att>
	<get_att get="inline" set="null" line="175" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.AttribAccess"/>
</f></get_att>
	<has public="1" get="accessor" set="null" static="1">
		<x path="haxe.xml._Access.HasAttribAccess"/>
		<haxe_doc>Check the existence of an attribute with the given name.</haxe_doc>
	</has>
	<get_has get="inline" set="null" line="183" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.HasAttribAccess"/>
</f></get_has>
	<hasNode public="1" get="accessor" set="null" static="1">
		<x path="haxe.xml._Access.HasNodeAccess"/>
		<haxe_doc><![CDATA[Check the existence of a sub node with the given name.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user><age>31</age></user>"));
		var user = f.node.user;
		if (user.hasNode.age) {
			trace(user.node.age.innerData); // 31
		}
		```]]></haxe_doc>
	</hasNode>
	<get_hasNode get="inline" set="null" line="199" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.HasNodeAccess"/>
</f></get_hasNode>
	<elements public="1" get="accessor" set="null" static="1">
		<t path="Iterator"><x path="haxe.xml.Access"/></t>
		<haxe_doc>The list of all sub-elements which are the nodes with type `Xml.Element`.</haxe_doc>
	</elements>
	<get_elements get="inline" set="null" line="207" static="1"><f a="this">
	<c path="Xml"/>
	<t path="Iterator"><x path="haxe.xml.Access"/></t>
</f></get_elements>
	<_new public="1" get="inline" set="null" line="209" static="1">
		<f a="x">
			<c path="Xml"/>
			<x path="haxe.xml.Access"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<get_innerData set="method" line="215" static="1"><f a="this">
	<c path="Xml"/>
	<c path="String"/>
</f></get_innerData>
	<get_innerHTML set="method" line="237" static="1"><f a="this">
	<c path="Xml"/>
	<c path="String"/>
</f></get_innerHTML>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.Access_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1">
		<x public="1" get="accessor" set="null" static="1"><c path="Xml"/></x>
		<get_x public="1" get="inline" set="null" line="91" static="1"><f a="this">
	<c path="Xml"/>
	<c path="Xml"/>
</f></get_x>
		<name public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>The name of the current element. This is the same as `Xml.nodeName`.</haxe_doc>
		</name>
		<get_name get="inline" set="null" line="98" static="1"><f a="this">
	<c path="Xml"/>
	<c path="String"/>
</f></get_name>
		<innerData public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>The inner PCDATA or CDATA of the node.

		An exception is thrown if there is no data or if there not only data
		but also other nodes.</haxe_doc>
		</innerData>
		<innerHTML public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>The XML string built with all the sub nodes, excluding the current one.</haxe_doc>
		</innerHTML>
		<node public="1" get="accessor" set="null" static="1">
			<x path="haxe.xml._Access.NodeAccess"/>
			<haxe_doc><![CDATA[Access to the first sub element with the given name.

		An exception is thrown if the element doesn't exists.
		Use `hasNode` to check the existence of a node.

		```haxe
		var access = new haxe.xml.Access(Xml.parse("<user><name>John</name></user>"));
		var user = access.node.user;
		var name = user.node.name;
		trace(name.innerData); // John

		// Uncaught Error: Document is missing element password
		var password = user.node.password;
		```]]></haxe_doc>
		</node>
		<get_node get="inline" set="null" line="134" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.NodeAccess"/>
</f></get_node>
		<nodes public="1" get="accessor" set="null" static="1">
			<x path="haxe.xml._Access.NodeListAccess"/>
			<haxe_doc><![CDATA[Access to the List of elements with the given name.
		```haxe
		var fast = new haxe.xml.Access(Xml.parse("
			<users>
				<user name='John'/>
				<user name='Andy'/>
				<user name='Dan'/>
			</users>"
		));

		var users = fast.node.users;
		for (user in users.nodes.user) {
			trace(user.att.name);
		}
		```]]></haxe_doc>
		</nodes>
		<get_nodes get="inline" set="null" line="156" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.NodeListAccess"/>
</f></get_nodes>
		<att public="1" get="accessor" set="null" static="1">
			<x path="haxe.xml._Access.AttribAccess"/>
			<haxe_doc><![CDATA[Access to a given attribute.

		An exception is thrown if the attribute doesn't exists.
		Use `has` to check the existence of an attribute.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user name='Mark'></user>"));
		var user = f.node.user;
		if (user.has.name) {
			trace(user.att.name); // Mark
		}
		```]]></haxe_doc>
		</att>
		<get_att get="inline" set="null" line="175" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.AttribAccess"/>
</f></get_att>
		<has public="1" get="accessor" set="null" static="1">
			<x path="haxe.xml._Access.HasAttribAccess"/>
			<haxe_doc>Check the existence of an attribute with the given name.</haxe_doc>
		</has>
		<get_has get="inline" set="null" line="183" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.HasAttribAccess"/>
</f></get_has>
		<hasNode public="1" get="accessor" set="null" static="1">
			<x path="haxe.xml._Access.HasNodeAccess"/>
			<haxe_doc><![CDATA[Check the existence of a sub node with the given name.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user><age>31</age></user>"));
		var user = f.node.user;
		if (user.hasNode.age) {
			trace(user.node.age.innerData); // 31
		}
		```]]></haxe_doc>
		</hasNode>
		<get_hasNode get="inline" set="null" line="199" static="1"><f a="this">
	<c path="Xml"/>
	<x path="haxe.xml._Access.HasNodeAccess"/>
</f></get_hasNode>
		<elements public="1" get="accessor" set="null" static="1">
			<t path="Iterator"><x path="haxe.xml.Access"/></t>
			<haxe_doc>The list of all sub-elements which are the nodes with type `Xml.Element`.</haxe_doc>
		</elements>
		<get_elements get="inline" set="null" line="207" static="1"><f a="this">
	<c path="Xml"/>
	<t path="Iterator"><x path="haxe.xml.Access"/></t>
</f></get_elements>
		<_new public="1" get="inline" set="null" line="209" static="1">
			<f a="x">
				<c path="Xml"/>
				<x path="haxe.xml.Access"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<get_innerData set="method" line="215" static="1"><f a="this">
	<c path="Xml"/>
	<c path="String"/>
</f></get_innerData>
		<get_innerHTML set="method" line="237" static="1"><f a="this">
	<c path="Xml"/>
	<c path="String"/>
</f></get_innerHTML>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Parser.S" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser">
		<this><x path="Int"/></this>
		<meta>
			<m n=":hxGen"/>
			<m n=":enum"/>
		</meta>
		<impl><class path="haxe.xml._Parser.S_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" final="1"><meta>
	<m n=":keep"/>
	<m n=":hxGen"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.xml.XmlParserException" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Parser.hx" module="haxe.xml.Parser">
		<message public="1">
			<c path="String"/>
			<haxe_doc>the XML parsing error message</haxe_doc>
		</message>
		<lineNumber public="1">
			<x path="Int"/>
			<haxe_doc>the line number at which the XML parsing error occurred</haxe_doc>
		</lineNumber>
		<positionAtLine public="1">
			<x path="Int"/>
			<haxe_doc>the character position in the reported line at which the parsing error occurred</haxe_doc>
		</positionAtLine>
		<position public="1">
			<x path="Int"/>
			<haxe_doc>the character position in the XML string at which the parsing error occurred</haxe_doc>
		</position>
		<xml public="1">
			<c path="String"/>
			<haxe_doc>the invalid XML string</haxe_doc>
		</xml>
		<toString public="1" set="method" line="94"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="75"><f a="message:xml:position">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.xml.Parser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Parser.hx">
		<escapes expr="{
	var h = new haxe.ds.StringMap();
	h.set(&quot;lt&quot;, &quot;&lt;&quot;);
	h.set(&quot;gt&quot;, &quot;&gt;&quot;);
	h.set(&quot;amp&quot;, &quot;&amp;&quot;);
	h.set(&quot;quot&quot;, &quot;\&quot;&quot;);
	h.set(&quot;apos&quot;, &quot;&apos;&quot;);
	h;
}" line="100" static="1">
			<c path="haxe.ds.StringMap"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[{
	var h = new haxe.ds.StringMap();
	h.set("lt", "<");
	h.set("gt", ">");
	h.set("amp", "&");
	h.set("quot", "\"");
	h.set("apos", "'");
	h;
}]]></e></m></meta>
		</escapes>
		<parse public="1" set="method" line="115" static="1">
			<f a="str:?strict" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Xml"/>
			</f>
			<meta><m n=":value"><e>{ strict : false }</e></m></meta>
			<haxe_doc>Parses the String into an XML Document. Set strict parsing to true in order to enable a strict check of XML attributes and entities.

		@throws haxe.xml.XmlParserException</haxe_doc>
		</parse>
		<doParse set="method" line="121" static="1">
			<f a="str:strict:?p:?parent" v="::0:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Xml"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ p : 0 }</e></m></meta>
		</doParse>
		<isValidChar get="inline" set="null" line="415" static="1"><f a="c">
	<x path="Int"/>
	<x path="Bool"/>
</f></isValidChar>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="haxe.xml.Printer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/haxe/xml/Printer.hx">
		<print public="1" set="method" line="35" static="1">
			<f a="xml:?pretty" v=":false">
				<c path="Xml"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ pretty : false }</e></m></meta>
			<haxe_doc>Convert `Xml` to string representation.

		Set `pretty` to `true` to prettify the result.</haxe_doc>
		</print>
		<output><c path="StringBuf"/></output>
		<pretty><x path="Bool"/></pretty>
		<writeNode set="method" line="49"><f a="value:tabs">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeNode>
		<write get="inline" set="null" line="104"><f a="input">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<newline get="inline" set="null" line="108"><f a=""><x path="Void"/></f></newline>
		<hasChildren set="method" line="114"><f a="value">
	<c path="Xml"/>
	<x path="Bool"/>
</f></hasChildren>
		<new set="method" line="44"><f a="pretty">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>This class provides utility methods to convert Xml instances to
	String representation.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<enum path="hscript.Const" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<CInt a="v"><x path="Int"/></CInt>
		<CFloat a="f"><x path="Float"/></CFloat>
		<CString a="s"><c path="String"/></CString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<typedef path="hscript.ExprDef" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<e path="hscript.Expr"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<enum path="hscript.Expr" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx">
		<EConst a="c"><e path="hscript.Const"/></EConst>
		<EIdent a="v"><c path="String"/></EIdent>
		<EVar a="n:?t:?e">
			<c path="String"/>
			<e path="hscript.CType"/>
			<e path="hscript.Expr"/>
		</EVar>
		<EParent a="e"><e path="hscript.Expr"/></EParent>
		<EBlock a="e"><c path="Array"><e path="hscript.Expr"/></c></EBlock>
		<EField a="e:f">
			<e path="hscript.Expr"/>
			<c path="String"/>
		</EField>
		<EBinop a="op:e1:e2">
			<c path="String"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EBinop>
		<EUnop a="op:prefix:e">
			<c path="String"/>
			<x path="Bool"/>
			<e path="hscript.Expr"/>
		</EUnop>
		<ECall a="e:params">
			<e path="hscript.Expr"/>
			<c path="Array"><e path="hscript.Expr"/></c>
		</ECall>
		<EIf a="cond:e1:?e2">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EIf>
		<EWhile a="cond:e">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EWhile>
		<EFor a="v:it:e">
			<c path="String"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EFor>
		<EBreak/>
		<EContinue/>
		<EFunction a="args:e:?name:?ret">
			<c path="Array"><t path="hscript.Argument"/></c>
			<e path="hscript.Expr"/>
			<c path="String"/>
			<e path="hscript.CType"/>
		</EFunction>
		<EReturn a="?e"><e path="hscript.Expr"/></EReturn>
		<EArray a="e:index">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EArray>
		<EArrayDecl a="e"><c path="Array"><e path="hscript.Expr"/></c></EArrayDecl>
		<ENew a="cl:params">
			<c path="String"/>
			<c path="Array"><e path="hscript.Expr"/></c>
		</ENew>
		<EThrow a="e"><e path="hscript.Expr"/></EThrow>
		<ETry a="e:v:t:ecatch">
			<e path="hscript.Expr"/>
			<c path="String"/>
			<x path="Null"><e path="hscript.CType"/></x>
			<e path="hscript.Expr"/>
		</ETry>
		<EObject a="fl"><c path="Array"><a>
	<name><c path="String"/></name>
	<e><e path="hscript.Expr"/></e>
</a></c></EObject>
		<ETernary a="cond:e1:e2">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</ETernary>
		<ESwitch a="e:cases:?defaultExpr">
			<e path="hscript.Expr"/>
			<c path="Array"><a>
	<values><c path="Array"><e path="hscript.Expr"/></c></values>
	<expr><e path="hscript.Expr"/></expr>
</a></c>
			<e path="hscript.Expr"/>
		</ESwitch>
		<EDoWhile a="cond:e">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EDoWhile>
		<EMeta a="name:args:e">
			<c path="String"/>
			<c path="Array"><e path="hscript.Expr"/></c>
			<e path="hscript.Expr"/>
		</EMeta>
		<ECheckType a="e:t">
			<e path="hscript.Expr"/>
			<e path="hscript.CType"/>
		</ECheckType>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<typedef path="hscript.Argument" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<a>
			<value>
				<x path="Null"><e path="hscript.Expr"/></x>
				<meta><m n=":optional"/></meta>
			</value>
			<t>
				<x path="Null"><e path="hscript.CType"/></x>
				<meta><m n=":optional"/></meta>
			</t>
			<opt>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</opt>
			<name><c path="String"/></name>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="hscript.Metadata" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<c path="Array"><a>
	<params><c path="Array"><e path="hscript.Expr"/></c></params>
	<name><c path="String"/></name>
</a></c>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<enum path="hscript.CType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<CTPath a="path:?params">
			<c path="Array"><c path="String"/></c>
			<c path="Array"><e path="hscript.CType"/></c>
		</CTPath>
		<CTFun a="args:ret">
			<c path="Array"><e path="hscript.CType"/></c>
			<e path="hscript.CType"/>
		</CTFun>
		<CTAnon a="fields"><c path="Array"><a>
	<t><e path="hscript.CType"/></t>
	<name><c path="String"/></name>
	<meta>
		<x path="Null"><t path="hscript.Metadata"/></x>
		<meta><m n=":optional"/></meta>
	</meta>
</a></c></CTAnon>
		<CTParent a="t"><e path="hscript.CType"/></CTParent>
		<CTOpt a="t"><e path="hscript.CType"/></CTOpt>
		<CTNamed a="n:t">
			<c path="String"/>
			<e path="hscript.CType"/>
		</CTNamed>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<enum path="hscript.Error" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<EInvalidChar a="c"><x path="Int"/></EInvalidChar>
		<EUnexpected a="s"><c path="String"/></EUnexpected>
		<EUnterminatedString/>
		<EUnterminatedComment/>
		<EInvalidPreprocessor a="msg"><c path="String"/></EInvalidPreprocessor>
		<EUnknownVariable a="v"><c path="String"/></EUnknownVariable>
		<EInvalidIterator a="v"><c path="String"/></EInvalidIterator>
		<EInvalidOp a="op"><c path="String"/></EInvalidOp>
		<EInvalidAccess a="f"><c path="String"/></EInvalidAccess>
		<ECustom a="msg"><c path="String"/></ECustom>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<enum path="hscript.ModuleDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<DPackage a="path"><c path="Array"><c path="String"/></c></DPackage>
		<DImport a="path:?everything">
			<c path="Array"><c path="String"/></c>
			<x path="Bool"/>
		</DImport>
		<DClass a="c"><t path="hscript.ClassDecl"/></DClass>
		<DTypedef a="c"><t path="hscript.TypeDecl"/></DTypedef>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<typedef path="hscript.ModuleType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<a>
			<params><a/></params>
			<name><c path="String"/></name>
			<meta><t path="hscript.Metadata"/></meta>
			<isPrivate><x path="Bool"/></isPrivate>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="hscript.ClassDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<a>
			<params><a/></params>
			<name><c path="String"/></name>
			<meta><t path="hscript.Metadata"/></meta>
			<isPrivate><x path="Bool"/></isPrivate>
			<isExtern><x path="Bool"/></isExtern>
			<implement><c path="Array"><e path="hscript.CType"/></c></implement>
			<fields><c path="Array"><t path="hscript.FieldDecl"/></c></fields>
			<extend><x path="Null"><e path="hscript.CType"/></x></extend>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="hscript.TypeDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<a>
			<t><e path="hscript.CType"/></t>
			<params><a/></params>
			<name><c path="String"/></name>
			<meta><t path="hscript.Metadata"/></meta>
			<isPrivate><x path="Bool"/></isPrivate>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="hscript.FieldDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<a>
			<name><c path="String"/></name>
			<meta><t path="hscript.Metadata"/></meta>
			<kind><e path="hscript.FieldKind"/></kind>
			<access><c path="Array"><e path="hscript.FieldAccess"/></c></access>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<enum path="hscript.FieldAccess" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<APublic/>
		<APrivate/>
		<AInline/>
		<AOverride/>
		<AStatic/>
		<AMacro/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hscript.FieldKind" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<KFunction a="f"><t path="hscript.FunctionDecl"/></KFunction>
		<KVar a="v"><t path="hscript.VarDecl"/></KVar>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<typedef path="hscript.FunctionDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<a>
			<ret><x path="Null"><e path="hscript.CType"/></x></ret>
			<expr><e path="hscript.Expr"/></expr>
			<args><c path="Array"><t path="hscript.Argument"/></c></args>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="hscript.VarDecl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Expr.hx" module="hscript.Expr">
		<a>
			<type><x path="Null"><e path="hscript.CType"/></x></type>
			<set><x path="Null"><c path="String"/></x></set>
			<get><x path="Null"><c path="String"/></x></get>
			<expr><x path="Null"><e path="hscript.Expr"/></x></expr>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<enum path="hscript._Interp.Stop" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Interp.hx" private="1" module="hscript.Interp">
		<SBreak/>
		<SContinue/>
		<SReturn/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hscript.Token" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Parser.hx" module="hscript.Parser">
		<TEof/>
		<TConst a="c"><e path="hscript.Const"/></TConst>
		<TId a="s"><c path="String"/></TId>
		<TOp a="s"><c path="String"/></TOp>
		<TPOpen/>
		<TPClose/>
		<TBrOpen/>
		<TBrClose/>
		<TDot/>
		<TComma/>
		<TSemicolon/>
		<TBkOpen/>
		<TBkClose/>
		<TQuestion/>
		<TDoubleDot/>
		<TMeta a="s"><c path="String"/></TMeta>
		<TPrepro a="s"><c path="String"/></TPrepro>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</enum>
	<class path="hscript.Parser" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Parser.hx">
		<p1 get="inline" set="null" expr="0" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</p1>
		<tokenMin get="inline" set="null" expr="0" line="102" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tokenMin>
		<tokenMax get="inline" set="null" expr="0" line="103" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tokenMax>
		<line public="1"><x path="Int"/></line>
		<opChars public="1"><c path="String"/></opChars>
		<identChars public="1"><c path="String"/></identChars>
		<opPriority public="1"><t path="Map">
	<c path="String"/>
	<x path="Int"/>
</t></opPriority>
		<opRightAssoc public="1"><t path="Map">
	<c path="String"/>
	<x path="Bool"/>
</t></opRightAssoc>
		<preprocesorValues public="1" expr="new Map()" line="62">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
			<haxe_doc>allows to check for #if / #else in code</haxe_doc>
		</preprocesorValues>
		<allowJSON public="1">
			<x path="Bool"/>
			<haxe_doc>activate JSON compatiblity</haxe_doc>
		</allowJSON>
		<allowTypes public="1">
			<x path="Bool"/>
			<haxe_doc>allow types declarations</haxe_doc>
		</allowTypes>
		<allowMetadata public="1">
			<x path="Bool"/>
			<haxe_doc>allow haxe metadata declarations</haxe_doc>
		</allowMetadata>
		<resumeErrors public="1">
			<x path="Bool"/>
			<haxe_doc>resume from parsing errors (when parsing incomplete code, during completion for example)</haxe_doc>
		</resumeErrors>
		<input><c path="String"/></input>
		<readPos><x path="Int"/></readPos>
		<char><x path="Int"/></char>
		<ops><c path="Array"><x path="Bool"/></c></ops>
		<idents><c path="Array"><x path="Bool"/></c></idents>
		<uid expr="0" line="91">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</uid>
		<tokens><c path="haxe.ds.GenericStack"><e path="hscript.Token"/></c></tokens>
		<error public="1" get="inline" set="null" line="146"><f a="err:pmin:pmax">
	<e path="hscript.Error"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></error>
		<invalidChar public="1" set="method" line="155"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidChar>
		<initParser set="method" line="159"><f a="origin">
	<x path="Null"><c path="String"/></x>
	<x path="Void"/>
</f></initParser>
		<parseString public="1" set="method" line="183">
			<f a="s:?origin" v=":&quot;hscript&quot;">
				<c path="String"/>
				<c path="String"/>
				<e path="hscript.Expr"/>
			</f>
			<meta><m n=":value"><e>{ origin : "hscript" }</e></m></meta>
		</parseString>
		<unexpected set="method" line="197"><f a="tk">
	<e path="hscript.Token"/>
	<d/>
</f></unexpected>
		<push get="inline" set="null" line="202"><f a="tk">
	<e path="hscript.Token"/>
	<x path="Void"/>
</f></push>
		<ensure get="inline" set="null" line="212"><f a="tk">
	<x path="Null"><e path="hscript.Token"/></x>
	<x path="Void"/>
</f></ensure>
		<ensureToken get="inline" set="null" line="217"><f a="tk">
	<x path="Null"><e path="hscript.Token"/></x>
	<x path="Void"/>
</f></ensureToken>
		<maybe set="method" line="222"><f a="tk">
	<x path="Null"><e path="hscript.Token"/></x>
	<x path="Bool"/>
</f></maybe>
		<getIdent set="method" line="230"><f a=""><c path="String"/></f></getIdent>
		<expr get="inline" set="null" line="240"><f a="e">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></expr>
		<pmin get="inline" set="null" line="248"><f a="e">
	<e path="hscript.Expr"/>
	<x path="Int"/>
</f></pmin>
		<pmax get="inline" set="null" line="256"><f a="e">
	<e path="hscript.Expr"/>
	<x path="Int"/>
</f></pmax>
		<mk get="inline" set="null" line="264"><f a="e:?pmin:?pmax">
	<e path="hscript.Expr"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="hscript.Expr"/>
</f></mk>
		<isBlock set="method" line="275"><f a="e">
	<e path="hscript.Expr"/>
	<x path="Bool"/>
</f></isBlock>
		<parseFullExpr set="method" line="294"><f a="exprs">
	<c path="Array"><e path="hscript.Expr"/></c>
	<x path="Void"/>
</f></parseFullExpr>
		<parseObject set="method" line="314"><f a="p1">
	<x path="Null"><x path="Int"/></x>
	<e path="hscript.Expr"/>
</f></parseObject>
		<parseExpr set="method" line="349"><f a=""><e path="hscript.Expr"/></f></parseExpr>
		<parseLambda set="method" line="488"><f a="args:pmin">
	<c path="Array"><t path="hscript.Argument"/></c>
	<x path="Null"><x path="Int"/></x>
	<e path="hscript.Expr"/>
</f></parseLambda>
		<parseMetaArgs set="method" line="508"><f a=""><c path="Array"><e path="hscript.Expr"/></c></f></parseMetaArgs>
		<mapCompr set="method" line="532"><f a="tmp:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></mapCompr>
		<makeUnop set="method" line="553"><f a="op:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></makeUnop>
		<makeBinop set="method" line="563"><f a="op:e1:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></makeBinop>
		<parseStructure set="method" line="582"><f a="id">
	<c path="String"/>
	<e path="hscript.Expr"/>
</f></parseStructure>
		<parseExprNext set="method" line="774"><f a="e1">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></parseExprNext>
		<parseFunctionArgs set="method" line="821"><f a=""><c path="Array"><t path="hscript.Argument"/></c></f></parseFunctionArgs>
		<parseFunctionDecl set="method" line="863"><f a=""><a>
	<ret><e path="hscript.CType"/></ret>
	<body><e path="hscript.Expr"/></body>
	<args><c path="Array"><t path="hscript.Argument"/></c></args>
</a></f></parseFunctionDecl>
		<parsePath set="method" line="877"><f a=""><c path="Array"><c path="String"/></c></f></parsePath>
		<parseType set="method" line="890"><f a=""><e path="hscript.CType"/></f></parseType>
		<parseTypeNext set="method" line="1012"><f a="t">
	<e path="hscript.CType"/>
	<e path="hscript.CType"/>
</f></parseTypeNext>
		<parseExprList set="method" line="1034"><f a="etk">
	<x path="Null"><e path="hscript.Token"/></x>
	<c path="Array"><e path="hscript.Expr"/></c>
</f></parseExprList>
		<parseModule public="1" set="method" line="1056">
			<f a="content:?origin" v=":&quot;hscript&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><e path="hscript.ModuleDecl"/></c>
			</f>
			<meta><m n=":value"><e>{ origin : "hscript" }</e></m></meta>
		</parseModule>
		<parseMetadata set="method" line="1072"><f a=""><t path="hscript.Metadata"/></f></parseMetadata>
		<parseParams set="method" line="1087"><f a=""><a/></f></parseParams>
		<parseModuleDecl set="method" line="1093"><f a=""><e path="hscript.ModuleDecl"/></f></parseModuleDecl>
		<parseField set="method" line="1186"><f a=""><t path="hscript.FieldDecl"/></f></parseField>
		<readChar get="inline" set="null" line="1260"><f a=""><x path="Int"/></f></readChar>
		<readString set="method" line="1264"><f a="until">
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<token set="method" line="1324"><f a=""><x path="Null"><e path="hscript.Token"/></x></f></token>
		<preprocValue set="method" line="1564"><f a="id">
	<c path="String"/>
	<d/>
</f></preprocValue>
		<preprocStack><c path="Array"><a><r><x path="Bool"/></r></a></c></preprocStack>
		<parsePreproCond set="method" line="1570"><f a=""><e path="hscript.Expr"/></f></parsePreproCond>
		<evalPreproCond set="method" line="1585"><f a="e">
	<e path="hscript.Expr"/>
	<x path="Bool"/>
</f></evalPreproCond>
		<preprocess set="method" line="1603"><f a="id">
	<c path="String"/>
	<e path="hscript.Token"/>
</f></preprocess>
		<skipTokens set="method" line="1636"><f a=""><x path="Void"/></f></skipTokens>
		<tokenComment set="method" line="1651"><f a="op:char">
	<c path="String"/>
	<x path="Int"/>
	<x path="Null"><e path="hscript.Token"/></x>
</f></tokenComment>
		<constString set="method" line="1693"><f a="c">
	<e path="hscript.Const"/>
	<c path="String"/>
</f></constString>
		<tokenString set="method" line="1704"><f a="t">
	<e path="hscript.Token"/>
	<c path="String"/>
</f></tokenString>
		<new public="1" set="method" line="113"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="hscript.Tools" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hscript/hscript/Tools.hx">
		<iter public="1" set="method" line="27" static="1"><f a="e:f">
	<e path="hscript.Expr"/>
	<f a="">
		<e path="hscript.Expr"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></iter>
		<map public="1" set="method" line="63" static="1"><f a="e:f">
	<e path="hscript.Expr"/>
	<f a="">
		<e path="hscript.Expr"/>
		<e path="hscript.Expr"/>
	</f>
	<t path="hscript.ExprDef"/>
</f></map>
		<expr public="1" get="inline" set="null" line="93" static="1"><f a="e">
	<e path="hscript.Expr"/>
	<t path="hscript.ExprDef"/>
</f></expr>
		<mk public="1" get="inline" set="null" line="101" static="1"><f a="e:p">
	<t path="hscript.ExprDef"/>
	<e path="hscript.Expr"/>
	<t path="hscript.ExprDef"/>
</f></mk>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="hsluv.Point" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hsluv/haxe/src/hsluv/Geometry.hx" module="hsluv.Geometry">
		<a>
			<y><x path="Float"/></y>
			<x><x path="Float"/></x>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="hsluv.Line" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hsluv/haxe/src/hsluv/Geometry.hx" module="hsluv.Geometry">
		<a>
			<slope><x path="Float"/></slope>
			<intercept><x path="Float"/></intercept>
		</a>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<typedef path="hsluv.Angle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hsluv/haxe/src/hsluv/Geometry.hx" module="hsluv.Geometry">
		<x path="Float"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="hsluv.Geometry" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hsluv/haxe/src/hsluv/Geometry.hx">
		<intersectLineLine public="1" set="method" line="19" static="1"><f a="a:b">
	<t path="hsluv.Line"/>
	<t path="hsluv.Line"/>
	<t path="hsluv.Point"/>
</f></intersectLineLine>
		<distanceFromOrigin public="1" set="method" line="25" static="1"><f a="point">
	<t path="hsluv.Point"/>
	<x path="Float"/>
</f></distanceFromOrigin>
		<distanceLineFromOrigin public="1" set="method" line="29" static="1"><f a="line">
	<t path="hsluv.Line"/>
	<x path="Float"/>
</f></distanceLineFromOrigin>
		<perpendicularThroughPoint public="1" set="method" line="34" static="1"><f a="line:point">
	<t path="hsluv.Line"/>
	<t path="hsluv.Point"/>
	<t path="hsluv.Line"/>
</f></perpendicularThroughPoint>
		<angleFromOrigin public="1" set="method" line="43" static="1"><f a="point">
	<t path="hsluv.Point"/>
	<t path="hsluv.Angle"/>
</f></angleFromOrigin>
		<normalizeAngle public="1" set="method" line="47" static="1"><f a="angle">
	<t path="hsluv.Angle"/>
	<t path="hsluv.Angle"/>
</f></normalizeAngle>
		<lengthOfRayUntilIntersect public="1" set="method" line="52" static="1"><f a="theta:line">
	<t path="hsluv.Angle"/>
	<t path="hsluv.Line"/>
	<x path="Float"/>
</f></lengthOfRayUntilIntersect>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="hsluv.Hsluv" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/hsluv/haxe/src/hsluv/Hsluv.hx">
		<m expr="[[3.240969941904521, -1.537383177570093, -0.498610760293], [-0.96924363628087, 1.87596750150772, 0.041555057407175], [0.055630079696993, -0.20397695888897, 1.056971514242878]]" line="28" static="1">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>[[3.240969941904521, -1.537383177570093, -0.498610760293], [-0.96924363628087, 1.87596750150772, 0.041555057407175], [0.055630079696993, -0.20397695888897, 1.056971514242878]]</e></m></meta>
		</m>
		<minv expr="[[0.41239079926595, 0.35758433938387, 0.18048078840183], [0.21263900587151, 0.71516867876775, 0.072192315360733], [0.019330818715591, 0.11919477979462, 0.95053215224966]]" line="35" static="1">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>[[0.41239079926595, 0.35758433938387, 0.18048078840183], [0.21263900587151, 0.71516867876775, 0.072192315360733], [0.019330818715591, 0.11919477979462, 0.95053215224966]]</e></m></meta>
		</minv>
		<refY expr="1.0" line="41" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</refY>
		<refU expr="0.19783000664283" line="43" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.19783000664283</e></m></meta>
		</refU>
		<refV expr="0.46831999493879" line="44" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.46831999493879</e></m></meta>
		</refV>
		<kappa expr="903.2962962" line="47" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>903.2962962</e></m></meta>
		</kappa>
		<epsilon expr="0.0088564516" line="48" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0088564516</e></m></meta>
		</epsilon>
		<hexChars expr="&quot;0123456789abcdef&quot;" line="50" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"0123456789abcdef"</e></m></meta>
		</hexChars>
		<getBounds public="1" set="method" line="57" static="1">
			<f a="L">
				<x path="Float"/>
				<c path="Array"><t path="hsluv.Line"/></c>
			</f>
			<haxe_doc>For a given lightness, return a list of 6 lines in slope-intercept
    form that represent the bounds in CIELUV, stepping over which will
    push a value out of the RGB gamut</haxe_doc>
		</getBounds>
		<maxSafeChromaForL public="1" set="method" line="88" static="1">
			<f a="L">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>For given lightness, returns the maximum chroma. Keeping the chroma value
    below this number will ensure that for any hue, the color is within the RGB
    gamut.</haxe_doc>
		</maxSafeChromaForL>
		<maxChromaForLH public="1" set="method" line="100" static="1"><f a="L:H">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></maxChromaForLH>
		<dotProduct set="method" line="115" static="1"><f a="a:b">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
</f></dotProduct>
		<fromLinear set="method" line="126" static="1"><f a="c">
	<x path="Float"/>
	<x path="Float"/>
</f></fromLinear>
		<toLinear set="method" line="134" static="1"><f a="c">
	<x path="Float"/>
	<x path="Float"/>
</f></toLinear>
		<xyzToRgb public="1" set="method" line="148" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* XYZ coordinates are ranging in [0;1] and RGB coordinates in [0;1] range.
    * @param tuple An array containing the color's X,Y and Z values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's red, green and blue.</haxe_doc>
		</xyzToRgb>
		<rgbToXyz public="1" set="method" line="167" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* RGB coordinates are ranging in [0;1] and XYZ coordinates in [0;1].
    * @param tuple An array containing the color's R,G,B values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's XYZ coordinates.</haxe_doc>
		</rgbToXyz>
		<yToL public="1" set="method" line="192" static="1"><f a="Y">
	<x path="Float"/>
	<x path="Float"/>
</f></yToL>
		<lToY public="1" set="method" line="200" static="1"><f a="L">
	<x path="Float"/>
	<x path="Float"/>
</f></lToY>
		<xyzToLuv public="1" set="method" line="214" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* XYZ coordinates are ranging in [0;1].
    * @param tuple An array containing the color's X,Y,Z values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's LUV coordinates.</haxe_doc>
		</xyzToLuv>
		<luvToXyz public="1" set="method" line="260" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* XYZ coordinates are ranging in [0;1].
    * @param tuple An array containing the color's L,U,V values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's XYZ coordinates.</haxe_doc>
		</luvToXyz>
		<luvToLch public="1" set="method" line="294" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* @param tuple An array containing the color's L,U,V values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's LCH coordinates.</haxe_doc>
		</luvToLch>
		<lchToLuv public="1" set="method" line="329" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* @param tuple An array containing the color's L,C,H values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's LUV coordinates.</haxe_doc>
		</lchToLuv>
		<hsluvToLch public="1" set="method" line="354" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100].
    * @param tuple An array containing the color's H,S,L values in HSLuv color space.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's LCH coordinates.</haxe_doc>
		</hsluvToLch>
		<lchToHsluv public="1" set="method" line="393" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100].
    * @param tuple An array containing the color's LCH values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's HSL coordinates in HSLuv color space.</haxe_doc>
		</lchToHsluv>
		<hpluvToLch public="1" set="method" line="431" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* HSLuv values are in [0;360], [0;100] and [0;100].
    * @param tuple An array containing the color's H,S,L values in HPLuv (pastel variant) color space.
    * @return An array containing the resulting color's LCH coordinates.</haxe_doc>
		</hpluvToLch>
		<lchToHpluv public="1" set="method" line="455" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100].
    * @param tuple An array containing the color's LCH values.
    * @return An array containing the resulting color's HSL coordinates in HPLuv (pastel variant) color space.</haxe_doc>
		</lchToHpluv>
		<rgbToHex public="1" set="method" line="480" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* RGB values are ranging in [0;1].
    * @param tuple An array containing the color's RGB values.
    * @return A string containing a `#RRGGBB` representation of given color.</haxe_doc>
		</rgbToHex>
		<hexToRgb public="1" set="method" line="499" static="1">
			<f a="hex">
				<c path="String"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* RGB values are ranging in [0;1].
    * @param hex A `#RRGGBB` representation of a color.
    * @return An array containing the color's RGB values.</haxe_doc>
		</hexToRgb>
		<lchToRgb public="1" set="method" line="517" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* RGB values are ranging in [0;1].
    * @param tuple An array containing the color's LCH values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's RGB coordinates.</haxe_doc>
		</lchToRgb>
		<rgbToLch public="1" set="method" line="533" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* RGB values are ranging in [0;1].
    * @param tuple An array containing the color's RGB values.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's LCH coordinates.</haxe_doc>
		</rgbToLch>
		<hsluvToRgb public="1" set="method" line="552" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param tuple An array containing the color's HSL values in HSLuv color space.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's RGB coordinates.</haxe_doc>
		</hsluvToRgb>
		<rgbToHsluv public="1" set="method" line="568" static="1">
			<f a="tuple:?result">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param tuple An array containing the color's RGB coordinates.
    * @param result A pre-allocated array to store the result into.
    * @return An array containing the resulting color's HSL coordinates in HSLuv color space.</haxe_doc>
		</rgbToHsluv>
		<hpluvToRgb public="1" set="method" line="583" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param tuple An array containing the color's HSL values in HPLuv (pastel variant) color space.
    * @return An array containing the resulting color's RGB coordinates.</haxe_doc>
		</hpluvToRgb>
		<rgbToHpluv public="1" set="method" line="593" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param tuple An array containing the color's RGB coordinates.
    * @return An array containing the resulting color's HSL coordinates in HPLuv (pastel variant) color space.</haxe_doc>
		</rgbToHpluv>
		<hsluvToHex public="1" set="method" line="605" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param tuple An array containing the color's HSL values in HSLuv color space.
    * @return A string containing a `#RRGGBB` representation of given color.</haxe_doc>
		</hsluvToHex>
		<hpluvToHex public="1" set="method" line="610" static="1">
			<f a="tuple">
				<c path="Array"><x path="Float"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
		</hpluvToHex>
		<hexToHsluv public="1" set="method" line="620" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param tuple An array containing the color's HSL values in HPLuv (pastel variant) color space.
    * @return An array containing the color's HSL values in HSLuv color space.</haxe_doc>
		</hexToHsluv>
		<hexToHpluv public="1" set="method" line="630" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* HSLuv values are ranging in [0;360], [0;100] and [0;100] and RGB in [0;1].
    * @param hex A `#RRGGBB` representation of a color.
    * @return An array containing the color's HSL values in HPLuv (pastel variant) color space.</haxe_doc>
		</hexToHpluv>
		<haxe_doc>Human-friendly HSL conversion utility class.

The math for most of this module was taken from:

 * http://www.easyrgb.com
 * http://www.brucelindbloom.com
 * Wikipedia

All numbers below taken from math/bounds.wxm wxMaxima file. We use 17
digits of decimal precision to export the numbers, effectively exporting
them as double precision IEEE 754 floats.

"If an IEEE 754 double precision is converted to a decimal string with at
least 17 significant digits and then converted back to double, then the
final number must match the original"

Source: https://en.wikipedia.org/wiki/Double-precision_floating-point_format
=======</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="microsoft.win32.safehandles.SafeHandleZeroOrMinusOneIsInvalid" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ microsoft.win32.safehandles.SafeHandleZeroOrMinusOneIsInvalid" extern="1" abstract="1">
		<extends path="cs.system.runtime.interopservices.SafeHandle"/>
		<implements path="cs.system.IDisposable"/>
		<IsInvalid public="1" get="accessor" set="null" override="1"><x path="Bool"/></IsInvalid>
		<get_IsInvalid public="1" set="method" override="1"><f a=""><x path="Bool"/></f></get_IsInvalid>
		<new final="1" set="method">
			<f a="ownsHandle">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":abstract"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"</e></m>
		</meta>
	</class>
	<class path="microsoft.win32.safehandles.SafeFileHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ microsoft.win32.safehandles.SafeFileHandle" extern="1" final="1">
		<extends path="microsoft.win32.safehandles.SafeHandleZeroOrMinusOneIsInvalid"/>
		<ReleaseHandle set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</ReleaseHandle>
		<new final="1" public="1" set="method"><f a="preexistingHandle:ownsHandle">
	<c path="cs.system.IntPtr"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"Microsoft.Win32.SafeHandles.SafeFileHandle"</e></m>
		</meta>
	</class>
	<class path="microsoft.win32.safehandles.SafeWaitHandle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/.haxelib/hxcs/4,2,0/netlib/net-20/mscorlib.dll @ microsoft.win32.safehandles.SafeWaitHandle" extern="1" final="1">
		<extends path="microsoft.win32.safehandles.SafeHandleZeroOrMinusOneIsInvalid"/>
		<ReleaseHandle set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":protected"/></meta>
		</ReleaseHandle>
		<new final="1" public="1" set="method"><f a="existingHandle:ownsHandle">
	<c path="cs.system.IntPtr"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":nativeGen"/>
			<m n=":libType"/>
			<m n=":csNative"/>
			<m n=":native"><e>"Microsoft.Win32.SafeHandles.SafeWaitHandle"</e></m>
		</meta>
	</class>
	<class path="poly2tri.AdvancingFront" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/AdvancingFront.hx">
		<head public="1"><c path="poly2tri.Node"/></head>
		<tail public="1"><c path="poly2tri.Node"/></tail>
		<search_node public="1"><c path="poly2tri.Node"/></search_node>
		<reset public="1" get="inline" set="null" line="14"><f a="head:tail">
	<c path="poly2tri.Node"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></reset>
		<locateNode public="1" get="inline" set="null" line="20"><f a="x">
	<x path="Float"/>
	<c path="poly2tri.Node"/>
</f></locateNode>
		<locatePoint public="1" get="inline" set="null" line="53"><f a="point">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Node"/>
</f></locatePoint>
		<new public="1" set="method" line="10"><f a="head:tail">
	<c path="poly2tri.Node"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.Basin" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Basin.hx">
		<left_node public="1"><c path="poly2tri.Node"/></left_node>
		<bottom_node public="1"><c path="poly2tri.Node"/></bottom_node>
		<right_node public="1"><c path="poly2tri.Node"/></right_node>
		<width public="1"><x path="Float"/></width>
		<left_highest public="1"><x path="Bool"/></left_highest>
		<clear public="1" get="inline" set="null" line="18"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.Constants" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Constants.hx">
		<kAlpha public="1" expr="0.3" line="8" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.3</e></m></meta>
		</kAlpha>
		<EPSILON public="1" expr="1e-12" line="9" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1e-12</e></m></meta>
		</EPSILON>
		<PI_2 public="1" expr="Math.PI / 2" line="10" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.PI / 2</e></m></meta>
		</PI_2>
		<PI_3div4 public="1" expr="3 * Math.PI / 4" line="11" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>3 * Math.PI / 4</e></m></meta>
		</PI_3div4>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.Edge" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Edge.hx">
		<p public="1"><c path="poly2tri.Point"/></p>
		<q public="1"><c path="poly2tri.Point"/></q>
		<reset public="1" get="inline" set="null" line="13"><f a="p1:p2">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Void"/>
</f></reset>
		<toString public="1" set="method" line="46"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="9"><f a="p1:p2">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.EdgeEvent" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/EdgeEvent.hx">
		<constrained_edge public="1" expr="null" line="5">
			<c path="poly2tri.Edge"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</constrained_edge>
		<right public="1" expr="false" line="6">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</right>
		<clear public="1" get="inline" set="null" line="13"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.Node" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Node.hx">
		<point public="1"><c path="poly2tri.Point"/></point>
		<triangle public="1"><c path="poly2tri.Triangle"/></triangle>
		<prev public="1"><c path="poly2tri.Node"/></prev>
		<next public="1"><c path="poly2tri.Node"/></next>
		<value public="1"><x path="Float"/></value>
		<reset public="1" get="inline" set="null" line="21">
			<f a="point:?triangle" v=":null">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Triangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ triangle : null }</e></m></meta>
		</reset>
		<getHoleAngle public="1" get="inline" set="null" line="37">
			<f a=""><x path="Float"/></f>
			<haxe_doc>*
     * @param node - middle node
     * @return the angle between 3 front nodes</haxe_doc>
		</getHoleAngle>
		<getBasinAngle public="1" get="inline" set="null" line="57"><f a=""><x path="Float"/></f></getBasinAngle>
		<new public="1" set="method" line="14">
			<f a="point:?triangle" v=":null">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Triangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ triangle : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.Orientation" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Orientation.hx">
		<CW public="1" get="inline" set="null" expr="1" line="5" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CW>
		<CCW public="1" get="inline" set="null" expr="-1" line="6" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</CCW>
		<COLLINEAR public="1" get="inline" set="null" expr="0" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</COLLINEAR>
		<orient2d public="1" get="inline" set="null" line="10" static="1"><f a="pa:pb:pc">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Int"/>
</f></orient2d>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.Point" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Point.hx">
		<sortPoints public="1" get="inline" set="null" line="51" static="1"><f a="points">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Void"/>
</f></sortPoints>
		<cmpPoints public="1" get="inline" set="null" line="56" static="1"><f a="l:r">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Int"/>
</f></cmpPoints>
		<C_ID public="1" expr="0" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</C_ID>
		<id public="1"><x path="Int"/></id>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<edge_list public="1" get="accessor" set="null"><c path="Array"><c path="poly2tri.Edge"/></c></edge_list>
		<reset public="1" get="inline" set="null" line="27"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></reset>
		<get_edge_list get="inline" set="null" line="38"><f a=""><c path="Array"><c path="poly2tri.Edge"/></c></f></get_edge_list>
		<equals public="1" get="inline" set="null" line="46"><f a="that">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="61"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="18"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.Pool" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Pool.hx">
		<enabled public="1" expr="true" line="5" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</enabled>
		<recycleAll public="1" set="method" line="7" static="1"><f a=""><x path="Void"/></f></recycleAll>
		<clearAll public="1" set="method" line="11" static="1"><f a=""><x path="Void"/></f></clearAll>
		<pointArrayIndex expr="0" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pointArrayIndex>
		<pointArrayPool expr="[]" line="17" static="1">
			<c path="Array"><c path="Array"><c path="poly2tri.Point"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pointArrayPool>
		<getPointArray public="1" set="method" line="19" static="1"><f a=""><c path="Array"><c path="poly2tri.Point"/></c></f></getPointArray>
		<triangleArrayIndex expr="0" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</triangleArrayIndex>
		<triangleArrayPool expr="[]" line="44" static="1">
			<c path="Array"><c path="Array"><c path="poly2tri.Triangle"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</triangleArrayPool>
		<getTriangleArray public="1" set="method" line="46" static="1"><f a=""><c path="Array"><c path="poly2tri.Triangle"/></c></f></getTriangleArray>
		<edgeArrayIndex expr="0" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</edgeArrayIndex>
		<edgeArrayPool expr="[]" line="71" static="1">
			<c path="Array"><c path="Array"><c path="poly2tri.Edge"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</edgeArrayPool>
		<getEdgeArray public="1" set="method" line="73" static="1"><f a=""><c path="Array"><c path="poly2tri.Edge"/></c></f></getEdgeArray>
		<edgeIndex expr="0" line="97" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</edgeIndex>
		<edgePool expr="[]" line="98" static="1">
			<c path="Array"><c path="poly2tri.Edge"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</edgePool>
		<getEdge public="1" set="method" line="100" static="1"><f a="p1:p2">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Edge"/>
</f></getEdge>
		<pointIndex expr="0" line="122" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pointIndex>
		<pointPool expr="[]" line="123" static="1">
			<c path="Array"><c path="poly2tri.Point"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pointPool>
		<getPoint public="1" set="method" line="125" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="poly2tri.Point"/>
</f></getPoint>
		<triangleIndex expr="0" line="147" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</triangleIndex>
		<trianglePool expr="[]" line="148" static="1">
			<c path="Array"><c path="poly2tri.Triangle"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</trianglePool>
		<getTriangle public="1" set="method" line="150" static="1">
			<f a="p1:p2:p3:?fixOrientation:?checkOrientation" v=":::false:true">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="poly2tri.Triangle"/>
			</f>
			<meta><m n=":value"><e>{ checkOrientation : true, fixOrientation : false }</e></m></meta>
		</getTriangle>
		<nodeIndex expr="0" line="172" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nodeIndex>
		<nodePool expr="[]" line="173" static="1">
			<c path="Array"><c path="poly2tri.Node"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</nodePool>
		<getNode public="1" set="method" line="175" static="1">
			<f a="point:?triangle" v=":null">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Triangle"/>
				<c path="poly2tri.Node"/>
			</f>
			<meta><m n=":value"><e>{ triangle : null }</e></m></meta>
		</getNode>
		<setArrayLength public="1" params="T" get="inline" set="null" line="197" static="1"><f a="array:length">
	<c path="Array"><c path="setArrayLength.T"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setArrayLength>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.SortPoints" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/SortPoints.hx">
		<cmp get="inline" set="null" line="35" static="1"><f a="l:r">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Int"/>
</f></cmp>
		<sort public="1" get="inline" set="null" line="59" static="1">
			<f a="a">
				<c path="Array"><c path="poly2tri.Point"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
         `cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
         negative Int if `x < y`.
 
         This operation modifies Array `a` in place.
 
         This operation is stable: The order of equal elements is preserved.
 
         If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec set="method" line="63" static="1"><f a="a:from:to">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge set="method" line="84" static="1"><f a="a:from:pivot:to:len1:len2">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate get="inline" set="null" line="110" static="1"><f a="a:from:mid:to">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd get="inline" set="null" line="128" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper get="inline" set="null" line="137" static="1"><f a="a:from:to:val">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower get="inline" set="null" line="152" static="1"><f a="a:from:to:val">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap get="inline" set="null" line="166" static="1"><f a="a:i:j">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<compare get="inline" set="null" line="172" static="1"><f a="a:i:j">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></compare>
		<haxe_doc>SortPoints provides a stable implementation of merge sort through its `sort`
     method. It should be used instead of `Array.sort` in cases where the order
     of equal elements has to be retained on all targets.
     
     This specific implementation has been modified to be exclusively used with array of `poly2tri.Point` instances.
     The compare function (and the rest of the implementation) are inlined to get the best performance out of it.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.Sweep" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Sweep.hx">
		<nextFlipPoint public="1" set="method" line="602" static="1"><f a="ep:eq:ot:op">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
</f></nextFlipPoint>
		<context><c path="poly2tri.SweepContext"/></context>
		<triangulate public="1" set="method" line="13"><f a=""><x path="Void"/></f></triangulate>
		<sweepPoints public="1" get="inline" set="null" line="21"><f a=""><x path="Void"/></f></sweepPoints>
		<finalizationPolygon public="1" get="inline" set="null" line="36"><f a=""><x path="Void"/></f></finalizationPolygon>
		<pointEvent public="1" get="inline" set="null" line="52">
			<f a="point">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Node"/>
			</f>
			<haxe_doc>* Find closes node to the left of the new point and
     * create a new triangle. If needed new holes and basins
     * will be filled to.</haxe_doc>
		</pointEvent>
		<edgeEventByEdge public="1" get="inline" set="null" line="67"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></edgeEventByEdge>
		<edgeEventByPoints public="1" get="inline" set="null" line="82"><f a="ep:eq:triangle:point">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Point"/>
	<x path="Void"/>
</f></edgeEventByPoints>
		<newFrontTriangle public="1" get="inline" set="null" line="114"><f a="point:node">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Node"/>
	<c path="poly2tri.Node"/>
</f></newFrontTriangle>
		<fill public="1" get="inline" set="null" line="140">
			<f a="node">
				<c path="poly2tri.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a triangle to the advancing front to fill a hole.
     * @param tcx
     * @param node - middle node, that is the bottom of the hole</haxe_doc>
		</fill>
		<fillAdvancingFront public="1" get="inline" set="null" line="165">
			<f a="n">
				<c path="poly2tri.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fills holes in the Advancing Front</haxe_doc>
		</fillAdvancingFront>
		<legalize public="1" set="method" line="202">
			<f a="t">
				<c path="poly2tri.Triangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if triangle was legalized</haxe_doc>
		</legalize>
		<fillBasin public="1" get="inline" set="null" line="272">
			<f a="node">
				<c path="poly2tri.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Fills a basin that has formed on the Advancing Front to the right
     * of given node.<br>
     * First we decide a left,bottom and right node that forms the
     * boundaries of the basin. Then we do a reqursive fill.
     *
     * @param tcx
     * @param node - starting node, this or next node will be left node]]></haxe_doc>
		</fillBasin>
		<fillBasinReq public="1" set="method" line="312">
			<f a="node">
				<c path="poly2tri.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Recursive algorithm to fill a Basin with triangles
     *
     * @param tcx
     * @param node - bottom_node</haxe_doc>
		</fillBasinReq>
		<isShallow public="1" get="inline" set="null" line="349"><f a="node">
	<c path="poly2tri.Node"/>
	<x path="Bool"/>
</f></isShallow>
		<fillEdgeEvent public="1" get="inline" set="null" line="360"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillEdgeEvent>
		<fillRightAboveEdgeEvent public="1" set="method" line="372"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillRightAboveEdgeEvent>
		<fillRightBelowEdgeEvent public="1" set="method" line="388"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillRightBelowEdgeEvent>
		<fillRightConcaveEdgeEvent public="1" set="method" line="403"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillRightConcaveEdgeEvent>
		<fillRightConvexEdgeEvent public="1" set="method" line="425"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillRightConvexEdgeEvent>
		<fillLeftAboveEdgeEvent public="1" set="method" line="449"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillLeftAboveEdgeEvent>
		<fillLeftBelowEdgeEvent public="1" set="method" line="465"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillLeftBelowEdgeEvent>
		<fillLeftConvexEdgeEvent public="1" set="method" line="484"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillLeftConvexEdgeEvent>
		<fillLeftConcaveEdgeEvent public="1" set="method" line="508"><f a="edge:node">
	<c path="poly2tri.Edge"/>
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></fillLeftConcaveEdgeEvent>
		<flipEdgeEvent public="1" set="method" line="532"><f a="ep:eq:t:p">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Point"/>
	<x path="Void"/>
</f></flipEdgeEvent>
		<nextFlipTriangle public="1" set="method" line="580"><f a="o:t:ot:p:op">
	<x path="Int"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
</f></nextFlipTriangle>
		<flipScanEdgeEvent public="1" set="method" line="621"><f a="ep:eq:flip_triangle:t:p">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Point"/>
	<x path="Void"/>
</f></flipScanEdgeEvent>
		<new public="1" set="method" line="8"><f a="context">
	<c path="poly2tri.SweepContext"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.SweepContext" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/SweepContext.hx">
		<_tmpArray expr="[]" line="150" static="1">
			<c path="Array"><c path="poly2tri.Triangle"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_tmpArray>
		<triangles public="1"><c path="Array"><c path="poly2tri.Triangle"/></c></triangles>
		<points public="1"><c path="Array"><c path="poly2tri.Point"/></c></points>
		<edge_list public="1"><c path="Array"><c path="poly2tri.Edge"/></c></edge_list>
		<front public="1"><c path="poly2tri.AdvancingFront"/></front>
		<head public="1"><c path="poly2tri.Point"/></head>
		<tail public="1"><c path="poly2tri.Point"/></tail>
		<basin public="1"><c path="poly2tri.Basin"/></basin>
		<edge_event public="1"><c path="poly2tri.EdgeEvent"/></edge_event>
		<reset public="1" set="method" line="29"><f a=""><x path="Void"/></f></reset>
		<addPoints get="inline" set="null" line="44"><f a="points">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Void"/>
</f></addPoints>
		<addPolyline public="1" get="inline" set="null" line="54"><f a="polyline">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Void"/>
</f></addPolyline>
		<initEdges get="inline" set="null" line="63"><f a="polyline">
	<c path="Array"><c path="poly2tri.Point"/></c>
	<x path="Void"/>
</f></initEdges>
		<initTriangulation public="1" get="inline" set="null" line="76"><f a=""><x path="Void"/></f></initTriangulation>
		<locateNode public="1" get="inline" set="null" line="106"><f a="point">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Node"/>
</f></locateNode>
		<createAdvancingFront public="1" get="inline" set="null" line="111"><f a=""><x path="Void"/></f></createAdvancingFront>
		<removeNode public="1" get="inline" set="null" line="134"><f a="node">
	<c path="poly2tri.Node"/>
	<x path="Void"/>
</f></removeNode>
		<mapTriangleToNodes public="1" get="inline" set="null" line="139"><f a="triangle">
	<c path="poly2tri.Triangle"/>
	<x path="Void"/>
</f></mapTriangleToNodes>
		<meshClean public="1" set="method" line="153"><f a="t">
	<c path="poly2tri.Triangle"/>
	<x path="Void"/>
</f></meshClean>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.Triangle" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Triangle.hx">
		<CW_OFFSET get="inline" set="null" expr="1" line="186" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Return the point clockwise to the given point.
     * Return the point counter-clockwise to the given point.
     *
     * Return the neighbor clockwise to given point.
     * Return the neighbor counter-clockwise to given point.</haxe_doc>
		</CW_OFFSET>
		<CCW_OFFSET get="inline" set="null" expr="-1" line="187" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</CCW_OFFSET>
		<rotateTrianglePair public="1" get="inline" set="null" line="372" static="1">
			<f a="t:p:ot:op">
				<c path="poly2tri.Triangle"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Triangle"/>
				<c path="poly2tri.Point"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Rotates a triangle pair one vertex CW
     *<pre>
     *       n2                    n2
     *  P +-----+             P +-----+
     *    | t  /|               |\  t |
     *    |   / |               | \   |
     *  n1|  /  |n3           n1|  \  |n3
     *    | /   |    after CW   |   \ |
     *    |/ oT |               | oT \|
     *    +-----+ oP            +-----+
     *       n4                    n4
     * </pre>]]></haxe_doc>
		</rotateTrianglePair>
		<points public="1"><c path="Array"><c path="poly2tri.Point"/></c></points>
		<neighbors public="1"><c path="Array"><c path="poly2tri.Triangle"/></c></neighbors>
		<interior public="1"><x path="Bool"/></interior>
		<constrained_edge public="1"><c path="Array"><x path="Bool"/></c></constrained_edge>
		<delaunay_edge public="1"><c path="Array"><x path="Bool"/></c></delaunay_edge>
		<reset public="1" get="inline" set="null" line="26">
			<f a="p1:p2:p3:?fixOrientation:?checkOrientation" v=":::false:true">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkOrientation : true, fixOrientation : false }</e></m></meta>
		</reset>
		<containsPoint public="1" get="inline" set="null" line="84">
			<f a="point">
				<c path="poly2tri.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Test if this Triangle contains the Point object given as parameter as its vertices.
     *
     * @return <code>True</code> if the Point objects are of the Triangle's vertices,
     *         <code>false</code> otherwise.]]></haxe_doc>
		</containsPoint>
		<containsEdgePoints public="1" get="inline" set="null" line="89"><f a="p1:p2">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></containsEdgePoints>
		<markNeighbor public="1" get="inline" set="null" line="104">
			<f a="t:p1:p2">
				<c path="poly2tri.Triangle"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Update neighbor pointers.<br>
     * This method takes either 3 parameters (<code>p1</code>, <code>p2</code> and
     * <code>t</code>) or 1 parameter (<code>t</code>).
     * @param   t   Triangle object.
     * @param   p1  Point object.
     * @param   p2  Point object.]]></haxe_doc>
		</markNeighbor>
		<markNeighborTriangle public="1" get="inline" set="null" line="124"><f a="that">
	<c path="poly2tri.Triangle"/>
	<x path="Void"/>
</f></markNeighborTriangle>
		<getPointIndexOffset public="1" get="inline" set="null" line="147">
			<f a="p:?offset" v=":0">
				<c path="poly2tri.Point"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</getPointIndexOffset>
		<pointCW public="1" get="inline" set="null" line="190"><f a="p">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
</f></pointCW>
		<pointCCW public="1" get="inline" set="null" line="195"><f a="p">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
</f></pointCCW>
		<neighborCW public="1" get="inline" set="null" line="200"><f a="p">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
</f></neighborCW>
		<neighborCCW public="1" get="inline" set="null" line="205"><f a="p">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Triangle"/>
</f></neighborCCW>
		<getConstrainedEdgeCW public="1" get="inline" set="null" line="209"><f a="p">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></getConstrainedEdgeCW>
		<setConstrainedEdgeCW public="1" get="inline" set="null" line="210"><f a="p:ce">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setConstrainedEdgeCW>
		<getConstrainedEdgeCCW public="1" get="inline" set="null" line="212"><f a="p">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></getConstrainedEdgeCCW>
		<setConstrainedEdgeCCW public="1" get="inline" set="null" line="213"><f a="p:ce">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setConstrainedEdgeCCW>
		<getDelaunayEdgeCW public="1" get="inline" set="null" line="215"><f a="p">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></getDelaunayEdgeCW>
		<setDelaunayEdgeCW public="1" get="inline" set="null" line="216"><f a="p:e">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setDelaunayEdgeCW>
		<getDelaunayEdgeCCW public="1" get="inline" set="null" line="218"><f a="p">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></getDelaunayEdgeCCW>
		<setDelaunayEdgeCCW public="1" get="inline" set="null" line="219"><f a="p:e">
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></setDelaunayEdgeCCW>
		<neighborAcross public="1" get="inline" set="null" line="225">
			<f a="p">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Triangle"/>
			</f>
			<haxe_doc>* The neighbor across to given point.</haxe_doc>
		</neighborAcross>
		<oppositePoint public="1" get="inline" set="null" line="228"><f a="t:p">
	<c path="poly2tri.Triangle"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
</f></oppositePoint>
		<legalize public="1" set="method" line="239">
			<f a="opoint:?npoint" v=":null">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ npoint : null }</e></m></meta>
			<haxe_doc><![CDATA[* Legalize triangle by rotating clockwise.<br>
     * This method takes either 1 parameter (then the triangle is rotated around
     * points(0)) or 2 parameters (then the triangle is rotated around the first
     * parameter).]]></haxe_doc>
		</legalize>
		<index public="1" get="inline" set="null" line="270">
			<f a="p">
				<c path="poly2tri.Point"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Alias for getPointIndexOffset
     *
     * @param	p</haxe_doc>
		</index>
		<edgeIndex public="1" get="inline" set="null" line="282"><f a="p1:p2">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Int"/>
</f></edgeIndex>
		<markConstrainedEdgeByIndex public="1" get="inline" set="null" line="309">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Mark an edge of this triangle as constrained.<br>
     * This method takes either 1 parameter (an edge index or an Edge instance) or
     * 2 parameters (two Point instances defining the edge of the triangle).]]></haxe_doc>
		</markConstrainedEdgeByIndex>
		<markConstrainedEdgeByEdge public="1" get="inline" set="null" line="314"><f a="edge">
	<c path="poly2tri.Edge"/>
	<x path="Void"/>
</f></markConstrainedEdgeByEdge>
		<markConstrainedEdgeByPoints public="1" get="inline" set="null" line="319"><f a="p:q">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Void"/>
</f></markConstrainedEdgeByPoints>
		<isEdgeSide public="1" get="inline" set="null" line="342">
			<f a="ep:eq">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if a side from this triangle is an edge side.
     * If sides are not marked they will be marked.
     *
     * @param	ep
     * @param	eq
     * @return</haxe_doc>
		</isEdgeSide>
		<clearNeigbors public="1" get="inline" set="null" line="418"><f a=""><x path="Void"/></f></clearNeigbors>
		<clearDelunayEdges public="1" get="inline" set="null" line="425"><f a=""><x path="Void"/></f></clearDelunayEdges>
		<toString public="1" set="method" line="433"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="22">
			<f a="p1:p2:p3:?fixOrientation:?checkOrientation" v=":::false:true">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkOrientation : true, fixOrientation : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="poly2tri.Utils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/poly2tri/src/poly2tri/Utils.hx">
		<insideIncircle public="1" get="inline" set="null" line="30" static="1">
			<f a="pa:pb:pc:pd">
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<c path="poly2tri.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* <b>Requirement</b>:<br>
     * 1. a, b and c form a triangle.<br>
     * 2. a and d is know to be on opposite side of bc<br>
     * <pre>
     *                a
     *                +
     *               / \
     *              /   \
     *            b/     \c
     *            +-------+
     *           /    d    \
     *          /           \
     * </pre>
     * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
     *  a,b and c<br>
     *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
     *  This preknowledge gives us a way to optimize the incircle test
     * @param pa - triangle point, opposite d
     * @param pb - triangle point
     * @param pc - triangle point
     * @param pd - point opposite a
     * @return true if d is inside circle, false if on circle edge]]></haxe_doc>
		</insideIncircle>
		<inScanArea public="1" get="inline" set="null" line="69" static="1"><f a="pa:pb:pc:pd">
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<c path="poly2tri.Point"/>
	<x path="Bool"/>
</f></inScanArea>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="polyline.Extensions" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/polyline/polyline/Extensions.hx">
		<unsafeGet public="1" params="T" get="inline" set="null" line="7" static="1">
			<f a="array:index">
				<c path="Array"><c path="unsafeGet.T"/></c>
				<x path="Int"/>
				<c path="unsafeGet.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</unsafeGet>
		<unsafeSet public="1" params="T" get="inline" set="null" line="24" static="1">
			<f a="array:index:value">
				<c path="Array"><c path="unsafeSet.T"/></c>
				<x path="Int"/>
				<c path="unsafeSet.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</unsafeSet>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<enum path="polyline.StrokeCap" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/polyline/polyline/StrokeCap.hx">
		<BUTT/>
		<SQUARE/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="polyline.StrokeJoin" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/polyline/polyline/StrokeJoin.hx">
		<MITER/>
		<BEVEL/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="sys.FileStat" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<class path="sys.FileSystem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/FileSystem.hx">
		<exists public="1" set="method" line="32" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` exists.</haxe_doc>
		</exists>
		<stat public="1" set="method" line="41" static="1">
			<f a="path">
				<c path="String"/>
				<t path="sys.FileStat"/>
			</f>
			<meta><m n=":access"><e>Date.fromNative</e></m></meta>
			<haxe_doc>Returns `FileStat` information for the file or directory specified by
		`path`.</haxe_doc>
		</stat>
		<fullPath public="1" set="method" line="77" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. Symlinks will be
		followed and the path will be normalized.</haxe_doc>
		</fullPath>
		<isDirectory public="1" set="method" line="87" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` is a directory.

		If `path` is not a valid file system entry or if its destination is not
		accessible, an exception is thrown.</haxe_doc>
		</isDirectory>
		<createDirectory public="1" set="method" line="94" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a directory specified by `path`.

		This method is recursive: The parent directories don't have to exist.

		If the directory cannot be created, an exception is thrown.</haxe_doc>
		</createDirectory>
		<deleteFile public="1" set="method" line="98" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the file specified by `path`.

		If `path` does not denote a valid file, or if that file cannot be
		deleted, an exception is thrown.</haxe_doc>
		</deleteFile>
		<deleteDirectory public="1" set="method" line="104" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the directory specified by `path`. Only empty directories can
		be deleted.

		If `path` does not denote a valid directory, or if that directory cannot
		be deleted, an exception is thrown.</haxe_doc>
		</deleteDirectory>
		<readDirectory public="1" set="method" line="110" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the names of all files and directories in the directory specified
		by `path`. `"."` and `".."` are not included in the output.

		If `path` does not denote a valid directory, an exception is thrown.</haxe_doc>
		</readDirectory>
		<haxe_doc>This class provides information about files and directories.

	If `null` is passed as a file path to any function in this class, the
	result is unspecified, and may differ from target to target.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.File" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/io/File.hx">
		<getContent public="1" set="method" line="27" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Retrieves the content of the file specified by `path` as a String.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getContent>
		<saveContent public="1" set="method" line="34" static="1">
			<f a="path:content">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `content` in the file specified by `path`.

		If the file cannot be written to, an exception is thrown.

		If `path` or `content` are null, the result is unspecified.</haxe_doc>
		</saveContent>
		<getBytes public="1" set="method" line="40" static="1">
			<f a="path">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Retrieves the binary content of the file specified by `path`.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getBytes>
		<saveBytes public="1" set="method" line="47" static="1">
			<f a="path:bytes">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `bytes` in the file specified by `path` in binary mode.

		If the file cannot be written to, an exception is thrown.

		If `path` or `bytes` are null, the result is unspecified.</haxe_doc>
		</saveBytes>
		<read public="1" set="method" line="53" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileInput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Returns an `FileInput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file does not exist or can not be read, an exception is thrown.

		Operations on the returned `FileInput` handle read on the opened file.

		File handles should be closed via `FileInput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</read>
		<write public="1" set="method" line="62" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Returns an `FileOutput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file cannot be written to, an exception is thrown.

		Operations on the returned `FileOutput` handle write to the opened file.
		If the file existed, its previous content is overwritten.

		File handles should be closed via `FileOutput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</write>
		<copy public="1" set="method" line="92" static="1">
			<f a="srcPath:dstPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the contents of the file specified by `srcPath` to the file
		specified by `dstPath`.

		If the `srcPath` does not exist or cannot be read, or if the `dstPath`
		file cannot be written to, an exception is thrown.

		If the file at `dstPath` exists, its contents are overwritten.

		If `srcPath` or `dstPath` are null, the result is unspecified.</haxe_doc>
		</copy>
		<haxe_doc>API for reading and writing files.

	See `sys.FileSystem` for the complementary file system API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileInput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/io/FileInput.hx">
		<extends path="cs.io.NativeInput"/>
		<new set="method" line="26"><f a="stream">
	<c path="cs.system.io.FileStream"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/io/FileOutput.hx">
		<extends path="cs.io.NativeOutput"/>
		<new set="method" line="26"><f a="stream">
	<c path="cs.system.io.FileStream"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="sys.io.Process" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/io/Process.hx">
		<createNativeProcess set="method" line="51" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<t path="cs.system.diagnostics._Process.NativeProcess"/>
			</f>
			<meta><m n=":allow"><e>Sys</e></m></meta>
		</createNativeProcess>
		<buildArgumentsString set="method" line="79" static="1"><f a="args">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
</f></buildArgumentsString>
		<stdout public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>Standard output. The output stream where a process writes its output data.</haxe_doc>
		</stdout>
		<stderr public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>Standard error. The output stream to output error messages or diagnostics.</haxe_doc>
		</stderr>
		<stdin public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>Standard input. The stream data going into a process.</haxe_doc>
		</stdin>
		<native><t path="cs.system.diagnostics._Process.NativeProcess"/></native>
		<exitCode public="1" set="method" line="113">
			<f a="?block" v="true">
				<x path="Bool"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":value"><e>{ block : true }</e></m></meta>
			<haxe_doc>Query the exit code of the process.
		If `block` is true or not specified, it will block until the process terminates.
		If `block` is false, it will return either the process exit code if it's already terminated or null if it's still running.
		If the process has already exited, return the exit code immediately.</haxe_doc>
		</exitCode>
		<close public="1" set="method" line="120">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the process handle and release the associated resources.
		All `Process` fields should not be used after `close()` is called.</haxe_doc>
		</close>
		<new public="1" set="method" line="39">
			<f a="cmd:?args:?detached">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Construct a `Process` object, which run the given command immediately.

		Command arguments can be passed in two ways: 1. using `args`, 2. appending to `cmd` and leaving `args` as `null`.

		 1. When using `args` to pass command arguments, each argument will be automatically quoted, and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		`detached` allows the created process to be standalone. You cannot communicate with it but you can look at its exit code. Not supported on php.

		`close()` should be called when the `Process` is no longer used.</haxe_doc>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.thread.Deque" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/thread/Deque.hx">
		<storage final="1" expr="[]" line="29">
			<c path="Array"><c path="sys.thread.Deque.T"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</storage>
		<lockObj final="1" expr="{ }" line="30">
			<a/>
			<meta><m n=":value"><e>{ }</e></m></meta>
		</lockObj>
		<addEvent final="1" expr="new ManualResetEvent(false)" line="31">
			<c path="cs.system.threading.ManualResetEvent"/>
			<meta><m n=":value"><e>new ManualResetEvent(false)</e></m></meta>
		</addEvent>
		<push public="1" set="method" line="42">
			<f a="i">
				<c path="sys.thread.Deque.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds an element at the front of `this` Deque.

		(Java,Jvm): throws `java.lang.NullPointerException` if `i` is `null`.</haxe_doc>
		</push>
		<pop public="1" set="method" line="49">
			<f a="block">
				<x path="Bool"/>
				<x path="Null"><c path="sys.thread.Deque.T"/></x>
			</f>
			<haxe_doc>Tries to retrieve an element from the front of `this` Deque.

		If an element is available, it is removed from the queue and returned.

		If no element is available and `block` is `false`, `null` is returned.

		Otherwise, execution blocks until an element is available and returns it.</haxe_doc>
		</pop>
		<new public="1" set="method" line="33">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Create a new Deque instance which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>A Deque is a double-ended queue with a `pop` method that can block until
	an element is available. It is commonly used to synchronize threads.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="sys.thread.EventHandler" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/sys/thread/EventLoop.hx" module="sys.thread.EventLoop">
		<from><icast><c path="sys.thread._EventLoop.RegularEvent"/></icast></from>
		<this><c path="sys.thread._EventLoop.RegularEvent"/></this>
		<to><icast><c path="sys.thread._EventLoop.RegularEvent"/></icast></to>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="sys.thread._EventLoop.EventHandler_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/sys/thread/EventLoop.hx" private="1" module="sys.thread.EventLoop" final="1"><meta>
	<m n=":keep"/>
	<m n=":hxGen"/>
</meta></class></impl>
	</abstract>
	<class path="sys.thread._EventLoop.RegularEvent" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/sys/thread/EventLoop.hx" private="1" module="sys.thread.EventLoop">
		<nextRunTime public="1"><x path="Float"/></nextRunTime>
		<interval final="1" public="1"><x path="Float"/></interval>
		<run final="1" public="1"><f a=""><x path="Void"/></f></run>
		<next public="1"><x path="Null"><c path="sys.thread._EventLoop.RegularEvent"/></x></next>
		<cancelled public="1" expr="false" line="284">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</cancelled>
		<new public="1" set="method" line="286"><f a="run:nextRunTime:interval">
	<f a=""><x path="Void"/></f>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="sys.thread.Lock" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/thread/Lock.hx">
		<lockObj final="1" expr="{ }" line="30">
			<a/>
			<meta><m n=":value"><e>{ }</e></m></meta>
		</lockObj>
		<releaseEvent final="1" expr="new ManualResetEvent(false)" line="31">
			<c path="cs.system.threading.ManualResetEvent"/>
			<meta><m n=":value"><e>new ManualResetEvent(false)</e></m></meta>
		</releaseEvent>
		<waitCount expr="1" line="33">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</waitCount>
		<releaseCount expr="0" line="34">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</releaseCount>
		<wait public="1" set="method" line="38"><f a="?timeout">
	<x path="Float"/>
	<x path="Bool"/>
</f></wait>
		<release public="1" set="method" line="73"><f a=""><x path="Void"/></f></release>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<typedef path="sys.thread._Thread.ThreadImpl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread">
		<c path="sys.thread._Thread.HaxeThread"/>
		<meta><m n=":nativeGen"/></meta>
	</typedef>
	<abstract path="sys.thread.Thread" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/thread/Thread.hx">
		<from><icast><t path="sys.thread._Thread.ThreadImpl"/></icast></from>
		<this><t path="sys.thread._Thread.ThreadImpl"/></this>
		<meta><m n=":hxGen"/></meta>
		<impl><class path="sys.thread._Thread.Thread_Impl_" params="" file="/home/runner/work/api-docs/api-docs/ceramic/tools/../git/haxe-binary/linux/haxe/std/cs/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread" final="1">
	<_new get="inline" set="null" line="35" static="1">
		<f a="thread">
			<c path="sys.thread._Thread.HaxeThread"/>
			<x path="sys.thread.Thread"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<create public="1" set="method" line="39" static="1"><f a="job">
	<f a=""><x path="Void"/></f>
	<x path="sys.thread.Thread"/>
</f></create>
	<current public="1" get="inline" set="null" line="70" static="1"><f a=""><x path="sys.thread.Thread"/></f></current>
	<processEvents set="method" line="93" static="1">
		<f a=""><x path="Void"/></f>
		<meta><m n=":keep"/></meta>
	</processEvents>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":hxGen"/>
	</meta>
</class></impl>
	</abstract>
	<class path="tracker.Assert" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Assert.hx">
		<assert public="1" set="method" static="1">
			<f a="expr:?reason">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Assert the expression evaluates to `true`.
        This check is only done in `debug` builds and doesn't affect `release` builds.</haxe_doc>
		</assert>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="tracker.Autorun" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Autorun.hx">
		<extends path="ceramic.Entity"/>
		<prevCurrent expr="[]" line="11" static="1">
			<c path="Array"><c path="tracker.Autorun"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</prevCurrent>
		<current public="1" expr="null" line="13" static="1">
			<c path="tracker.Autorun"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</current>
		<unobserve public="1" get="inline" set="null" line="117" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Ensures current `autorun` won't be affected by the code after this call.
        `reobserve()` should be called to restore previous state.</haxe_doc>
		</unobserve>
		<reobserve public="1" get="inline" set="null" line="127" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Resume observing values and resume affecting current `autorun` scope.
        This should be called after an `unobserve()` call.</haxe_doc>
		</reobserve>
		<unobserved public="1" set="method" line="138" static="1">
			<f a="func">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>Executes the given function synchronously and ensures the
        current `autorun` scope won't be affected</haxe_doc>
		</unobserved>
		<_autorunArrays expr="[]" line="233" static="1">
			<c path="Array"><c path="Array"><c path="tracker.Autorun"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_autorunArrays>
		<_autorunArraysLen expr="0" line="234" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_autorunArraysLen>
		<getAutorunArray public="1" set="method" line="236" static="1"><f a=""><c path="Array"><c path="tracker.Autorun"/></c></f></getAutorunArray>
		<recycleAutorunArray public="1" set="method" line="250" static="1"><f a="array">
	<c path="Array"><c path="tracker.Autorun"/></c>
	<x path="Void"/>
</f></recycleAutorunArray>
		<_arrayOfAutorunArrays expr="[]" line="265" static="1">
			<c path="Array"><c path="Array"><c path="Array"><c path="tracker.Autorun"/></c></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_arrayOfAutorunArrays>
		<_arrayOfAutorunArraysLen expr="0" line="266" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_arrayOfAutorunArraysLen>
		<getArrayOfAutorunArrays public="1" get="inline" set="null" line="268" static="1"><f a=""><c path="Array"><c path="Array"><c path="tracker.Autorun"/></c></c></f></getArrayOfAutorunArrays>
		<recycleArrayOfAutorunArrays public="1" get="inline" set="null" line="282" static="1"><f a="array">
	<c path="Array"><c path="Array"><c path="tracker.Autorun"/></c></c>
	<x path="Void"/>
</f></recycleArrayOfAutorunArrays>
		<_dox_event_reset public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event_reset>
		<emitReset set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>reset event</haxe_doc>
		</emitReset>
		<onReset public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>reset event</haxe_doc>
		</onReset>
		<onceReset public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>reset event</haxe_doc>
		</onceReset>
		<offReset public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>reset event</haxe_doc>
		</offReset>
		<listensReset public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to reset event</haxe_doc>
		</listensReset>
		<onRun public="1" expr="null" line="21">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
		</onRun>
		<afterRun public="1" expr="null" line="23">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
		</afterRun>
		<boundAutorunArrays expr="null" line="25">
			<c path="Array"><c path="Array"><c path="tracker.Autorun"/></c></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</boundAutorunArrays>
		<invalidated public="1" set="null" expr="false" line="27">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</invalidated>
		<destroy public="1" set="method" line="52" override="1"><f a=""><x path="Void"/></f></destroy>
		<willEmitReset get="inline" set="null" line="66"><f a=""><x path="Void"/></f></willEmitReset>
		<run public="1" set="method" line="72"><f a=""><x path="Void"/></f></run>
		<invalidate public="1" get="inline" set="null" line="102"><f a=""><x path="Void"/></f></invalidate>
		<bindToAutorunArray public="1" set="method" line="148"><f a="autorunArray">
	<c path="Array"><c path="tracker.Autorun"/></c>
	<x path="Void"/>
</f></bindToAutorunArray>
		<unbindFromAllAutorunArrays public="1" set="method" line="205"><f a=""><x path="Void"/></f></unbindFromAllAutorunArrays>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="38">
			<f a="onRun:?afterRun">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialize a new autorun.
     * @param onRun The callback that will be executed and used to compute implicit bindings
     * @param afterRun
     *     (optional) A callback run right after `onRun`, not affecting implicit bindings.
     *     Useful when generating side effects without messing up binding dependencies.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="tracker.DynamicEvents" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/DynamicEvents.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<dispatcher><c path="tracker.EventDispatcher"/></dispatcher>
		<mapping><t path="Map">
	<c path="String"/>
	<x path="Int"/>
</t></mapping>
		<nextIndex expr="0" line="15">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextIndex>
		<bindAsComponent set="method" line="26"><f a=""><x path="Void"/></f></bindAsComponent>
		<eventToString set="method" line="32"><f a="event">
	<c path="tracker.DynamicEvents.T"/>
	<c path="String"/>
</f></eventToString>
		<indexForEvent set="method" line="39"><f a="event">
	<c path="tracker.DynamicEvents.T"/>
	<x path="Int"/>
</f></indexForEvent>
		<emit public="1" set="method" line="55"><f a="event:?args">
	<c path="tracker.DynamicEvents.T"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></emit>
		<on public="1" set="method" line="77"><f a="event:owner:cb">
	<c path="tracker.DynamicEvents.T"/>
	<x path="Null"><c path="ceramic.Entity"/></x>
	<d/>
	<x path="Void"/>
</f></on>
		<once public="1" set="method" line="84"><f a="event:owner:cb">
	<c path="tracker.DynamicEvents.T"/>
	<x path="Null"><c path="ceramic.Entity"/></x>
	<d/>
	<x path="Void"/>
</f></once>
		<off public="1" set="method" line="91"><f a="event:?cb">
	<c path="tracker.DynamicEvents.T"/>
	<d/>
	<x path="Void"/>
</f></off>
		<listens public="1" set="method" line="98"><f a="event">
	<c path="tracker.DynamicEvents.T"/>
	<x path="Bool"/>
</f></listens>
		<entity public="1">
			<c path="ceramic.Entity"/>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</entity>
		<setEntity set="method" line="9">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="9">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Fire and listen to dynamic events. Works similarly to static events, but dynamic.
    If you can know the event names at compile time, using static events (`@event function myEvent();`) is preferred.</haxe_doc>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="tracker.EventDispatcher" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/EventDispatcher.hx">
		<items expr="[]" line="14">
			<c path="Array"><c path="tracker._EventDispatcher.EventDispatcherItem"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</items>
		<setWillEmit public="1" set="method" line="20"><f a="index:cb">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></setWillEmit>
		<setDidEmit public="1" set="method" line="32"><f a="index:cb">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></setDidEmit>
		<setWillListen public="1" set="method" line="44"><f a="index:cb">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></setWillListen>
		<wrapEmit public="1" set="method" line="58"><f a="index:numArgs">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></wrapEmit>
		<emit public="1" set="method" line="101"><f a="index:numArgs:?arg1:?arg2:?arg3">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></emit>
		<wrapOn public="1" set="method" line="211"><f a="index">
	<x path="Int"/>
	<d/>
</f></wrapOn>
		<on public="1" set="method" line="239"><f a="index:owner:cb">
	<x path="Int"/>
	<x path="Null"><c path="ceramic.Entity"/></x>
	<d/>
	<x path="Void"/>
</f></on>
		<wrapOnce public="1" set="method" line="296"><f a="index">
	<x path="Int"/>
	<d/>
</f></wrapOnce>
		<once public="1" set="method" line="324"><f a="index:owner:cb">
	<x path="Int"/>
	<x path="Null"><c path="ceramic.Entity"/></x>
	<d/>
	<x path="Void"/>
</f></once>
		<wrapOff public="1" set="method" line="381"><f a="index">
	<x path="Int"/>
	<d/>
</f></wrapOff>
		<off public="1" set="method" line="401"><f a="index:cb">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></off>
		<wrapListens public="1" set="method" line="450"><f a="index">
	<x path="Int"/>
	<d/>
</f></wrapListens>
		<listens public="1" set="method" line="470"><f a="index">
	<x path="Int"/>
	<x path="Bool"/>
</f></listens>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Event dispatcher used by DynamicEvents and Events macro as an alternative implementation
    that doesn't require to add a lot of methods on classes with events.
    This is basically the same code as what is statically generated by Events macro,
    but made dynamic and usable for any type.
    This is not really supposed to be used as is as it is pretty low-level.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="tracker._EventDispatcher.EventDispatcherItem" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/EventDispatcher.hx" private="1" module="tracker.EventDispatcher">
		<willEmit expr="null" line="485">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</willEmit>
		<didEmit expr="null" line="487">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</didEmit>
		<willListen expr="null" line="489">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</willListen>
		<wrappedEmit expr="null" line="491">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</wrappedEmit>
		<wrappedEmitNumArgs expr="-1" line="493">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</wrappedEmitNumArgs>
		<wrappedOn expr="null" line="495">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</wrappedOn>
		<wrappedOnce expr="null" line="497">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</wrappedOnce>
		<wrappedOff expr="null" line="499">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</wrappedOff>
		<wrappedListens expr="null" line="501">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</wrappedListens>
		<cbOnArray expr="[]" line="503">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</cbOnArray>
		<cbOnceArray expr="[]" line="505">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</cbOnceArray>
		<cbOnOwnerUnbindArray expr="[]" line="507">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</cbOnOwnerUnbindArray>
		<cbOnceOwnerUnbindArray expr="[]" line="509">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</cbOnceOwnerUnbindArray>
		<new public="1" set="method" line="511"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>tracker.EventDispatcher</e></m>
		</meta>
	</class>
	<class path="tracker.Extensions" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Extensions.hx">
		<unsafeGet public="1" params="T" get="inline" set="null" line="8" static="1">
			<f a="array:index">
				<c path="Array"><c path="unsafeGet.T"/></c>
				<x path="Int"/>
				<c path="unsafeGet.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</unsafeGet>
		<unsafeSet public="1" params="T" get="inline" set="null" line="25" static="1">
			<f a="array:index:value">
				<c path="Array"><c path="unsafeSet.T"/></c>
				<x path="Int"/>
				<c path="unsafeSet.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</unsafeSet>
		<setArrayLength public="1" params="T" get="inline" set="null" line="42" static="1"><f a="array:length">
	<c path="Array"><c path="setArrayLength.T"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setArrayLength>
		<setProperty public="1" params="T" get="inline" set="null" line="62" static="1">
			<f a="instance:field:value">
				<c path="setProperty.T"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setProperty>
		<getProperty public="1" params="T" get="inline" set="null" line="69" static="1">
			<f a="instance:field">
				<c path="getProperty.T"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</getProperty>
		<haxe_doc>A bunch of static extensions to make life easier.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="tracker.History" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/History.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<_dox_event__undo public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__undo>
		<emitUndo set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>undo event</haxe_doc>
		</emitUndo>
		<onUndo public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>undo event</haxe_doc>
		</onUndo>
		<onceUndo public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>undo event</haxe_doc>
		</onceUndo>
		<offUndo public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>undo event</haxe_doc>
		</offUndo>
		<listensUndo public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to undo event</haxe_doc>
		</listensUndo>
		<_dox_event__redo public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__redo>
		<emitRedo set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>redo event</haxe_doc>
		</emitRedo>
		<onRedo public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>redo event</haxe_doc>
		</onRedo>
		<onceRedo public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>redo event</haxe_doc>
		</onceRedo>
		<offRedo public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>redo event</haxe_doc>
		</offRedo>
		<listensRedo public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to redo event</haxe_doc>
		</listensRedo>
		<entity public="1">
			<c path="tracker.Model"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<stepPending><x path="Bool"/></stepPending>
		<currentData expr="null" line="15">
			<c path="StringBuf"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</currentData>
		<steps expr="[]" line="17">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</steps>
		<currentStep expr="-1" line="19">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</currentStep>
		<scheduledStep expr="null" line="21">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</scheduledStep>
		<ignoreSteps expr="0" line="23">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ignoreSteps>
		<canScheduleImmediateStep expr="true" line="25">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</canScheduleImmediateStep>
		<clearDelayAllowImmediateStep expr="null" line="27">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</clearDelayAllowImmediateStep>
		<maxSteps public="1" expr="-1" line="34">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* If provided, number of available steps will be limited to this value,
     * meaning older steps will be removed and not recoverable if reaching the limit.
     * Default is: store as many steps as possible, no limit (except available memory?)</haxe_doc>
		</maxSteps>
		<clearPreviousStepsOutsideLimit public="1" set="method" line="46">
			<f a="maxSteps">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Manually clear previous steps outside the given limit
     * @param maxSteps</haxe_doc>
		</clearPreviousStepsOutsideLimit>
		<bindAsComponent public="1" set="method" line="57"><f a=""><x path="Void"/></f></bindAsComponent>
		<bindSerializer set="method" line="80"><f a="serializer">
	<c path="tracker.SerializeModel"/>
	<x path="Void"/>
</f></bindSerializer>
		<recordStepIfNeeded set="method" line="105"><f a=""><x path="Void"/></f></recordStepIfNeeded>
		<step public="1" set="method" line="144">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Record a step in the undo stack</haxe_doc>
		</step>
		<disable public="1" set="method" line="158"><f a=""><x path="Void"/></f></disable>
		<enable public="1" set="method" line="164"><f a=""><x path="Void"/></f></enable>
		<undo public="1" set="method" line="173">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Undo last step, if any</haxe_doc>
		</undo>
		<redo public="1" set="method" line="192">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Redo last undone step, if any</haxe_doc>
		</redo>
		<applyCurrentStep set="method" line="208"><f a=""><x path="Void"/></f></applyCurrentStep>
		<setEntity set="method" line="5">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="5">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="tracker.Serializable" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Serializable.hx" interface="1">
		<_serializeId public="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</_serializeId>
		<willSerialize set="method"><f a=""><x path="Void"/></f></willSerialize>
		<didDeserialize set="method"><f a=""><x path="Void"/></f></didDeserialize>
		<serializeShouldDestroy set="method"><f a=""><x path="Bool"/></f></serializeShouldDestroy>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":autoBuild"><e>tracker.macros.SerializableMacro.build()</e></m>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<class path="tracker.Model" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Model.hx">
		<extends path="ceramic.Entity"/>
		<implements path="tracker.Serializable"/>
		<implements path="tracker.Observable"/>
		<_dox_event_observedDirty public="1" set="method" line="637">
			<f a="instance:fromSerializedField">
				<c path="tracker.Model"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</_dox_event_observedDirty>
		<emitObservedDirty set="method" line="1095">
			<f a="instance:fromSerializedField">
				<c path="tracker.Model"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</emitObservedDirty>
		<onObservedDirty public="1" set="method" line="1199">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="tracker.Model"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onObservedDirty>
		<onceObservedDirty public="1" set="method" line="1298">
			<f a="owner:handleInstanceFromSerializedField">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="instance:fromSerializedField">
					<c path="tracker.Model"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</onceObservedDirty>
		<offObservedDirty public="1" set="method" line="1368">
			<f a="?handleInstanceFromSerializedField">
				<f a="instance:fromSerializedField">
					<c path="tracker.Model"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</offObservedDirty>
		<listensObservedDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when any observable value as changed on this instance.</haxe_doc>
		</listensObservedDirty>
		<observedDirty public="1" expr="false" line="131">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Default is `false`, automatically set to `true` when any of this instance's observable variables has changed.</haxe_doc>
		</observedDirty>
		<_dox_event__modelDirty public="1" set="method" line="637">
			<f a="model">
				<c path="tracker.Model"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
		</_dox_event__modelDirty>
		<emitModelDirty set="method" line="1095">
			<f a="model">
				<c path="tracker.Model"/>
				<x path="Void"/>
			</f>
			<haxe_doc>modelDirty event</haxe_doc>
		</emitModelDirty>
		<onModelDirty public="1" set="method" line="1199">
			<f a="owner:handleModel">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="model">
					<c path="tracker.Model"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>modelDirty event</haxe_doc>
		</onModelDirty>
		<onceModelDirty public="1" set="method" line="1298">
			<f a="owner:handleModel">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="model">
					<c path="tracker.Model"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>modelDirty event</haxe_doc>
		</onceModelDirty>
		<offModelDirty public="1" set="method" line="1368">
			<f a="?handleModel">
				<f a="model">
					<c path="tracker.Model"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>modelDirty event</haxe_doc>
		</offModelDirty>
		<listensModelDirty public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Does it listen to modelDirty event</haxe_doc>
		</listensModelDirty>
		<serializer public="1">
			<c path="tracker.SerializeModel"/>
			<meta><m n="component"/></meta>
		</serializer>
		<dirty public="1" set="accessor" expr="false" line="19">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</dirty>
		<set_dirty get="inline" set="null" line="21"><f a="dirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_dirty>
		<willSerialize set="method" line="39">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called right before the object will be serialized.</haxe_doc>
		</willSerialize>
		<didDeserialize set="method" line="45">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called right after the object has been deserialized. Could be useful to override it to check data integrity
        when running a newer model version etc...</haxe_doc>
		</didDeserialize>
		<serializeShouldDestroy set="method" line="53">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Called right before the object is destroyed because it is not used anymore.
     * @return `true` (default) if the destroy should happen or not</haxe_doc>
		</serializeShouldDestroy>
		<hxSerialize set="method" line="62">
			<f a="s">
				<c path="haxe.Serializer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</hxSerialize>
		<hxUnserialize set="method" line="67">
			<f a="u">
				<c path="haxe.Unserializer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</hxUnserialize>
		<_default_dirty set="method" line="19">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc></haxe_doc>
		</_default_dirty>
		<_serializeId public="1" expr="tracker.Utils.uniqueId()" line="273">
			<c path="String"/>
			<meta>
				<m n=":value"><e>tracker.Utils.uniqueId()</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc></haxe_doc>
		</_serializeId>
		<_dox_event_serialize public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when this object gets serialized.</haxe_doc>
		</_dox_event_serialize>
		<emitSerialize set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Event when this object gets serialized.</haxe_doc>
		</emitSerialize>
		<onSerialize public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets serialized.</haxe_doc>
		</onSerialize>
		<onceSerialize public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets serialized.</haxe_doc>
		</onceSerialize>
		<offSerialize public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets serialized.</haxe_doc>
		</offSerialize>
		<listensSerialize public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets serialized.</haxe_doc>
		</listensSerialize>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<_dox_event_deserialize public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Event when this object gets deserialized.</haxe_doc>
		</_dox_event_deserialize>
		<emitDeserialize set="method" line="1095">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Event when this object gets deserialized.</haxe_doc>
		</emitDeserialize>
		<onDeserialize public="1" set="method" line="1199">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets deserialized.</haxe_doc>
		</onDeserialize>
		<onceDeserialize public="1" set="method" line="1298">
			<f a="owner:handle">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets deserialized.</haxe_doc>
		</onceDeserialize>
		<offDeserialize public="1" set="method" line="1368">
			<f a="?handle">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets deserialized.</haxe_doc>
		</offDeserialize>
		<listensDeserialize public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Event when this object gets deserialized.</haxe_doc>
		</listensDeserialize>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>tracker.macros.SerializableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.SerializableMacro.build()</e></m>
			<m n=":build"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.ObservableMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<class path="tracker.SaveModel" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/SaveModel.hx">
		<BACKUP_NUM_STEPS expr="20000" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20000</e></m></meta>
		</BACKUP_NUM_STEPS>
		<NUM_BACKUPS expr="4" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</NUM_BACKUPS>
		<BACKUP_STEPS expr="null" line="12" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</BACKUP_STEPS>
		<busyKeys expr="[]" line="14" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</busyKeys>
		<getSavedOrCreate public="1" params="T" set="method" line="18" static="1"><f a="modelClass:key:?args">
	<x path="Class"><c path="getSavedOrCreate.T"/></x>
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="getSavedOrCreate.T"/>
</f></getSavedOrCreate>
		<isBusyKey public="1" set="method" line="30" static="1"><f a="key">
	<c path="String"/>
	<x path="Bool"/>
</f></isBusyKey>
		<loadFromKey public="1" set="method" line="37" static="1">
			<f a="model:key:?muteWarnings" v="::false">
				<c path="tracker.Model"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ muteWarnings : false }</e></m></meta>
			<haxe_doc>Load data from the given key.</haxe_doc>
		</loadFromKey>
		<autoSaveAsKey public="1" set="method" line="105" static="1">
			<f a="model:key:?appendInterval:?compactInterval" v="::1.0:60.0">
				<c path="tracker.Model"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ compactInterval : 60.0, appendInterval : 1.0 }</e></m></meta>
		</autoSaveAsKey>
		<_autoSaveAsKeyHandleChangeset set="method" line="159" static="1"><f a="changeset:key:saveDataKey1:saveDataKey2:saveIdKey1:saveIdKey2:backupKey1:backupKey2">
	<c path="tracker.SerializeChangeset"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyHandleChangeset>
		<_autoSaveAsKeyAppend set="method" line="189" static="1"><f a="data:key:saveDataKey1:saveDataKey2:saveIdKey1:saveIdKey2">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyAppend>
		<_autoSaveAsKeyAppendInBackground set="method" line="211" static="1"><f a="data:key:saveDataKey1:saveDataKey2:saveIdKey1:saveIdKey2">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyAppendInBackground>
		<_autoSaveAsKeyAppendBackInMain set="method" line="240" static="1"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyAppendBackInMain>
		<_autoSaveAsKeyCompact set="method" line="258" static="1"><f a="data:key:saveDataKey1:saveDataKey2:saveIdKey1:saveIdKey2:backupKey1:backupKey2">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyCompact>
		<_autoSaveAsKeyCompactRunInBackground set="method" line="282" static="1"><f a="data:key:saveDataKey1:saveDataKey2:saveIdKey1:saveIdKey2:backupKey1:backupKey2">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyCompactRunInBackground>
		<_autoSaveAsKeyCompactBackInMain set="method" line="338" static="1"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></_autoSaveAsKeyCompactBackInMain>
		<encodeHashedString public="1" set="method" line="352" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode the given string `str` and return the result.</haxe_doc>
		</encodeHashedString>
		<decodeHashedString public="1" set="method" line="361" static="1">
			<f a="encoded">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode the given `encoded` string and return the result or null if it failed.</haxe_doc>
		</decodeHashedString>
		<meta><m n=":hxGen"/></meta>
	</class>
	<class path="tracker.Serialize" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Serialize.hx">
		<customHxSerialize public="1" expr="null" line="20" static="1">
			<f a="">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</customHxSerialize>
		<customHxDeserialize public="1" expr="null" line="22" static="1">
			<f a="">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</customHxDeserialize>
		<serialize public="1" set="method" line="24" static="1"><f a="serializable">
	<c path="tracker.Serializable"/>
	<c path="String"/>
</f></serialize>
		<deserialize public="1" set="method" line="41" static="1"><f a="?serializable:data">
	<c path="tracker.Serializable"/>
	<c path="String"/>
	<d/>
</f></deserialize>
		<_serializedMap expr="null" line="62" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<a>
					<type><c path="String"/></type>
					<props><d/></props>
					<id><c path="String"/></id>
				</a>
			</x>
			<meta><m n=":value"><e>null</e></m></meta>
		</_serializedMap>
		<_deserializedMap expr="null" line="64" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="tracker.Serializable"/>
			</x>
			<meta><m n=":value"><e>null</e></m></meta>
		</_deserializedMap>
		<_deserializedCacheMap expr="null" line="66" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="tracker.Serializable"/>
			</x>
			<meta><m n=":value"><e>null</e></m></meta>
		</_deserializedCacheMap>
		<_onAddSerializable expr="null" line="68" static="1">
			<f a="">
				<c path="tracker.Serializable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</_onAddSerializable>
		<_onCheckSerializable expr="null" line="70" static="1">
			<f a="">
				<c path="tracker.Serializable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</_onCheckSerializable>
		<_appendSerialize expr="false" line="72" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_appendSerialize>
		<_cachedEnumInfoBySerializableType expr="new Map()" line="74" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Bool"/>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</_cachedEnumInfoBySerializableType>
		<_enumInfo expr="new Map()" line="76" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="haxe.ds.Map">
					<c path="String"/>
					<c path="Array"><c path="String"/></c>
				</x>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</_enumInfo>
		<serializeValue set="method" line="78" static="1"><f a="value">
	<d/>
	<d/>
</f></serializeValue>
		<deserializeValue set="method" line="277" static="1"><f a="value:?serializable">
	<d/>
	<c path="tracker.Serializable"/>
	<d/>
</f></deserializeValue>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":allow"><e>tracker.SerializeModel</e></m>
			<m n=":allow"><e>tracker.SaveModel</e></m>
		</meta>
	</class>
	<class path="tracker.SerializeChangeset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/SerializeChangeset.hx">
		<data public="1"><c path="String"/></data>
		<append public="1" expr="false" line="8">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</append>
		<toString set="method" line="17"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="10">
			<f a="data:?append" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ append : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="tracker.SerializeModel" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/SerializeModel.hx">
		<extends path="ceramic.Entity"/>
		<implements path="ceramic.Component"/>
		<loadFromData public="1" set="method" line="270" static="1">
			<f a="model:data:?hotReload" v="::false">
				<c path="tracker.Model"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ hotReload : false }</e></m></meta>
		</loadFromData>
		<_dox_event_changeset public="1" set="method" line="637">
			<f a="changeset">
				<c path="tracker.SerializeChangeset"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>show</e></m></meta>
			<haxe_doc>Triggered when serialized data is updated.
        If `append` is true, the given string should be appended to the existing one.</haxe_doc>
		</_dox_event_changeset>
		<emitChangeset set="method" line="1095">
			<f a="changeset">
				<c path="tracker.SerializeChangeset"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Triggered when serialized data is updated.
        If `append` is true, the given string should be appended to the existing one.</haxe_doc>
		</emitChangeset>
		<onChangeset public="1" set="method" line="1199">
			<f a="owner:handleChangeset">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="changeset">
					<c path="tracker.SerializeChangeset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Triggered when serialized data is updated.
        If `append` is true, the given string should be appended to the existing one.</haxe_doc>
		</onChangeset>
		<onceChangeset public="1" set="method" line="1298">
			<f a="owner:handleChangeset">
				<x path="Null"><c path="ceramic.Entity"/></x>
				<f a="changeset">
					<c path="tracker.SerializeChangeset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Triggered when serialized data is updated.
        If `append` is true, the given string should be appended to the existing one.</haxe_doc>
		</onceChangeset>
		<offChangeset public="1" set="method" line="1368">
			<f a="?handleChangeset">
				<f a="changeset">
					<c path="tracker.SerializeChangeset"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Triggered when serialized data is updated.
        If `append` is true, the given string should be appended to the existing one.</haxe_doc>
		</offChangeset>
		<listensChangeset public="1" get="inline" set="null" line="1390">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>Triggered when serialized data is updated.
        If `append` is true, the given string should be appended to the existing one.</haxe_doc>
		</listensChangeset>
		<checkInterval public="1" expr="1.0" line="16">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</checkInterval>
		<compactInterval public="1" expr="60.0" line="18">
			<x path="Float"/>
			<meta><m n=":value"><e>60.0</e></m></meta>
		</compactInterval>
		<destroyModelOnUntrack public="1" expr="true" line="20">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</destroyModelOnUntrack>
		<serializedMap public="1" set="null" expr="new Map()" line="24">
			<t path="Map">
				<c path="String"/>
				<a>
					<type><c path="String"/></type>
					<props><d/></props>
					<id><c path="String"/></id>
				</a>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</serializedMap>
		<model public="1" get="accessor" set="null"><c path="tracker.Model"/></model>
		<get_model get="inline" set="null" line="27"><f a=""><c path="tracker.Model"/></f></get_model>
		<entity public="1">
			<c path="tracker.Model"/>
			<meta><m n=":keep"/></meta>
		</entity>
		<bindAsComponent set="method" line="33"><f a=""><x path="Void"/></f></bindAsComponent>
		<compact public="1" set="method" line="53">
			<f a="?done">
				<f a="">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Recompute the whole object tree instead of appending. This will untrack every object not on the model anymore
        and generate a new changeset with the whole serialized object tree.</haxe_doc>
		</compact>
		<trackedModels expr="new Map()" line="92">
			<t path="Map">
				<c path="String"/>
				<c path="tracker.Model"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</trackedModels>
		<willCleanDestroyedTrackedModels expr="false" line="94">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</willCleanDestroyedTrackedModels>
		<dirtyModels expr="new Map()" line="96">
			<t path="Map">
				<c path="String"/>
				<c path="tracker.Model"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</dirtyModels>
		<canCompact expr="false" line="98">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</canCompact>
		<dirty expr="true" line="100">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</dirty>
		<track get="inline" set="null" line="102"><f a="model">
	<c path="tracker.Model"/>
	<x path="Void"/>
</f></track>
		<untrack get="inline" set="null" line="113"><f a="model">
	<c path="tracker.Model"/>
	<x path="Void"/>
</f></untrack>
		<trackedModelDestroyed set="method" line="127"><f a="_">
	<c path="ceramic.Entity"/>
	<x path="Void"/>
</f></trackedModelDestroyed>
		<cleanTrackingFromPrevSerializedMap set="method" line="150"><f a="prevSerializedMap">
	<t path="Map">
		<c path="String"/>
		<a>
			<type><c path="String"/></type>
			<props><d/></props>
			<id><c path="String"/></id>
		</a>
	</t>
	<x path="Void"/>
</f></cleanTrackingFromPrevSerializedMap>
		<modelDirty set="method" line="169"><f a="model:fromSerializedField">
	<c path="tracker.Model"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></modelDirty>
		<explicitModelDirty set="method" line="184"><f a="model">
	<c path="tracker.Model"/>
	<x path="Void"/>
</f></explicitModelDirty>
		<synchronize public="1" set="method" line="192">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Synchronize (expected to be called at regular intervals or when something important needs to be serialized)</haxe_doc>
		</synchronize>
		<compactIfNeeded set="method" line="221"><f a=""><x path="Void"/></f></compactIfNeeded>
		<serializeModel get="inline" set="null" line="230"><f a="model:toAppend">
	<c path="tracker.Model"/>
	<c path="Array"><a>
	<type><c path="String"/></type>
	<props><d/></props>
	<id><c path="String"/></id>
</a></c>
	<x path="Void"/>
</f></serializeModel>
		<setEntity set="method" line="6">
			<f a="entity">
				<c path="ceramic.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</setEntity>
		<getEntity set="method" line="6">
			<f a=""><c path="ceramic.Entity"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc></haxe_doc>
		</getEntity>
		<initializerName public="1" set="null" expr="null" line="249">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc></haxe_doc>
		</initializerName>
		<unbindEvents public="1" set="method" line="1424" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc></haxe_doc>
		</unbindEvents>
		<haxe_doc>Utility to serialize a model object (and its children) continuously and efficiently</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
			<m n=":build"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.ComponentMacro.build()</e></m>
			<m n=":build"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":autoBuild"><e>ceramic.macros.EntityMacro.buildForCompletion()</e></m>
			<m n=":build"><e>tracker.macros.EventsMacro.build()</e></m>
			<m n=":autoBuild"><e>tracker.macros.EventsMacro.build()</e></m>
		</meta>
	</class>
	<class path="tracker.Tracker" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Tracker.hx">
		<backend public="1" static="1"><c path="ceramic.TrackerBackend"/></backend>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="tracker.Utils" params="" file="/home/runner/work/api-docs/api-docs/ceramic/git/tracker/src/tracker/Utils.hx">
		<uniformFrequencyList public="1" set="method" line="10" static="1">
			<f a="values:frequencies:size">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>Generate an uniform list of the requested size,
        containing values uniformly repartited from frequencies.
        @param values the values to put in list
        @param probabilities the corresponding probability for each value
        @param size the size of the final list</haxe_doc>
		</uniformFrequencyList>
		<_nextUniqueIntCursor expr="0" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_nextUniqueIntCursor>
		<_nextUniqueInt0 expr="Std.int(Math.random() * 0x7ffffffe)" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 0x7ffffffe)</e></m></meta>
		</_nextUniqueInt0>
		<_nextUniqueInt1 expr="Std.int(Date.now().getTime() * 0.0001)" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Date.now().getTime() * 0.0001)</e></m></meta>
		</_nextUniqueInt1>
		<_nextUniqueInt2 expr="Std.int(Math.random() * 0x7ffffffe)" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 0x7ffffffe)</e></m></meta>
		</_nextUniqueInt2>
		<_nextUniqueInt3 expr="Std.int(Math.random() * 0x7ffffffe)" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 0x7ffffffe)</e></m></meta>
		</_nextUniqueInt3>
		<_uniqueIdMutex expr="new sys.thread.Mutex()" line="57" static="1">
			<c path="sys.thread.Mutex"/>
			<meta><m n=":value"><e>new sys.thread.Mutex()</e></m></meta>
		</_uniqueIdMutex>
		<uniqueId public="1" set="method" line="62" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Provides an identifier which is garanteed to be unique on the current session.
        It however doesn't garantee that this identifier is not predictable.</haxe_doc>
		</uniqueId>
		<base62Id public="1" get="inline" set="null" line="90" static="1"><f a="?val">
	<x path="Int"/>
	<c path="String"/>
</f></base62Id>
		<encodeChangesetData public="1" set="method" line="114" static="1"><f a="data">
	<c path="String"/>
	<c path="String"/>
</f></encodeChangesetData>
		<decodeChangesetData public="1" set="method" line="120" static="1"><f a="rawData">
	<c path="String"/>
	<a>
		<serializedMap><t path="Map">
	<c path="String"/>
	<a>
		<type><c path="String"/></type>
		<props><d/></props>
		<id><c path="String"/></id>
	</a>
</t></serializedMap>
		<serialized><d/></serialized>
	</a>
</f></decodeChangesetData>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":hxGen"/>
		</meta>
	</class>
	<class path="unityengine.Application" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Application.hx" extern="1">
		<absoluteURL public="1" set="null" static="1"><c path="String"/></absoluteURL>
		<targetFrameRate public="1" static="1"><x path="Int"/></targetFrameRate>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Application"</e></m>
		</meta>
	</class>
	<class path="unityengine.Object" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Object.hx" extern="1">
		<Destroy public="1" set="method" static="1">
			<f a="obj:?t" v=":0.0">
				<c path="unityengine.Object"/>
				<x path="Single"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ t : 0.0 }</e></m></meta>
		</Destroy>
		<DestroyImmediate public="1" set="method" static="1">
			<f a="obj:?allowDestroyingAssets" v=":false">
				<c path="unityengine.Object"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ allowDestroyingAssets : false }</e></m></meta>
		</DestroyImmediate>
		<DontDestroyOnLoad public="1" set="method" static="1"><f a="target">
	<c path="unityengine.Object"/>
	<x path="Void"/>
</f></DontDestroyOnLoad>
		<GetInstanceID public="1" set="method"><f a=""><x path="Int"/></f></GetInstanceID>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Object"</e></m>
		</meta>
	</class>
	<class path="unityengine.AudioClip" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/AudioClip.hx" extern="1">
		<extends path="unityengine.Object"/>
		<ambisonic public="1" set="null"><x path="Bool"/></ambisonic>
		<channels public="1" set="null"><x path="Int"/></channels>
		<frequency public="1" set="null"><x path="Int"/></frequency>
		<length public="1" set="null"><x path="Single"/></length>
		<loadInBackground public="1"><x path="Bool"/></loadInBackground>
		<loadState public="1" set="null"><c path="unityengine.AudioDataLoadState"/></loadState>
		<loadType public="1" set="null"><c path="unityengine.AudioClipLoadType"/></loadType>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.AudioClip"</e></m>
		</meta>
	</class>
	<class path="unityengine.AudioClipLoadType" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/AudioClipLoadType.hx" extern="1">
		<DecompressOnLoad public="1" static="1"><c path="unityengine.AudioClipLoadType"/></DecompressOnLoad>
		<CompressedInMemory public="1" static="1"><c path="unityengine.AudioClipLoadType"/></CompressedInMemory>
		<Streaming public="1" static="1"><c path="unityengine.AudioClipLoadType"/></Streaming>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.AudioClipLoadType"</e></m>
		</meta>
	</class>
	<class path="unityengine.AudioDataLoadState" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/AudioDataLoadState.hx" extern="1">
		<Unloaded public="1" static="1"><c path="unityengine.AudioDataLoadState"/></Unloaded>
		<Loading public="1" static="1"><c path="unityengine.AudioDataLoadState"/></Loading>
		<Loaded public="1" static="1"><c path="unityengine.AudioDataLoadState"/></Loaded>
		<Failed public="1" static="1"><c path="unityengine.AudioDataLoadState"/></Failed>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.AudioDataLoadState"</e></m>
		</meta>
	</class>
	<class path="unityengine.Component" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Component.hx" extern="1">
		<extends path="unityengine.Object"/>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Component"</e></m>
		</meta>
	</class>
	<class path="unityengine.Behaviour" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Behaviour.hx" extern="1">
		<extends path="unityengine.Component"/>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Behaviour"</e></m>
		</meta>
	</class>
	<class path="unityengine.AudioSource" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/AudioSource.hx" extern="1">
		<extends path="unityengine.Behaviour"/>
		<bypassEffects public="1"><x path="Bool"/></bypassEffects>
		<bypassListenerEffects public="1"><x path="Bool"/></bypassListenerEffects>
		<bypassReverbZones public="1"><x path="Bool"/></bypassReverbZones>
		<clip public="1"><c path="unityengine.AudioClip"/></clip>
		<dopplerLevel public="1"><x path="Single"/></dopplerLevel>
		<ignoreListenerPause public="1"><x path="Bool"/></ignoreListenerPause>
		<ignoreListenerVolume public="1"><x path="Bool"/></ignoreListenerVolume>
		<isPlaying public="1" set="null"><x path="Bool"/></isPlaying>
		<isVirtual public="1"><x path="Bool"/></isVirtual>
		<loop public="1"><x path="Bool"/></loop>
		<maxDistance public="1"><x path="Single"/></maxDistance>
		<minDistance public="1"><x path="Single"/></minDistance>
		<mute public="1"><x path="Bool"/></mute>
		<panStereo public="1"><x path="Single"/></panStereo>
		<pitch public="1"><x path="Single"/></pitch>
		<playOnAwake public="1"><x path="Bool"/></playOnAwake>
		<priority public="1"><x path="Int"/></priority>
		<reverbZoneMix public="1"><x path="Single"/></reverbZoneMix>
		<spatialize public="1"><x path="Bool"/></spatialize>
		<time public="1"><x path="Single"/></time>
		<timeSamples public="1"><x path="Int"/></timeSamples>
		<volume public="1"><x path="Single"/></volume>
		<Pause public="1" set="method"><f a=""><x path="Void"/></f></Pause>
		<Play public="1" set="method"><f a=""><x path="Void"/></f></Play>
		<PlayDelayed public="1" set="method"><f a="delay">
	<x path="Single"/>
	<x path="Void"/>
</f></PlayDelayed>
		<Stop public="1" set="method"><f a=""><x path="Void"/></f></Stop>
		<UnPause public="1" set="method"><f a=""><x path="Void"/></f></UnPause>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.AudioSource"</e></m>
		</meta>
	</class>
	<class path="unityengine.Color" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Color.hx" extern="1">
		<new public="1" set="method"><f a="r:g:b:a">
	<x path="Single"/>
	<x path="Single"/>
	<x path="Single"/>
	<x path="Single"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Color"</e></m>
		</meta>
	</class>
	<class path="unityengine.FilterMode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/FilterMode.hx" extern="1">
		<Point public="1" static="1"><c path="unityengine.FilterMode"/></Point>
		<Bilinear public="1" static="1"><c path="unityengine.FilterMode"/></Bilinear>
		<Trilinear public="1" static="1"><c path="unityengine.FilterMode"/></Trilinear>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.FilterMode"</e></m>
		</meta>
	</class>
	<class path="unityengine.GameObject" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/GameObject.hx" extern="1">
		<extends path="unityengine.Object"/>
		<activeInHierarchy public="1"><x path="Bool"/></activeInHierarchy>
		<activeSelf public="1" set="null"><x path="Bool"/></activeSelf>
		<isStatic public="1"><x path="Bool"/></isStatic>
		<layer public="1"><x path="Int"/></layer>
		<tag public="1"><c path="String"/></tag>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.GameObject"</e></m>
		</meta>
	</class>
	<class path="unityengine.ImageConversion" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/ImageConversion.hx" extern="1">
		<EncodeToPNG public="1" set="method" static="1"><f a="tex">
	<c path="unityengine.Texture2D"/>
	<t path="haxe.io.BytesData"/>
</f></EncodeToPNG>
		<EncodeToJPG public="1" set="method" static="1"><f a="tex:quality">
	<c path="unityengine.Texture2D"/>
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
</f></EncodeToJPG>
		<LoadImage public="1" set="method" static="1"><f a="tex:data:markNonReadable">
	<c path="unityengine.Texture2D"/>
	<t path="haxe.io.BytesData"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></LoadImage>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.ImageConversion"</e></m>
		</meta>
	</class>
	<class path="unityengine.Matrix4x4" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Matrix4x4.hx" extern="1"><meta>
	<m n=":nativeGen"/>
	<m n=":native"><e>"UnityEngine.Matrix4x4"</e></m>
</meta></class>
	<class path="unityengine.Mesh" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Mesh.hx" extern="1">
		<extends path="unityengine.Object"/>
		<subMeshCount public="1"><x path="Int"/></subMeshCount>
		<SetVertexBufferParams public="1" set="method"><f a="vertexCount:attributes">
	<x path="Int"/>
	<c path="cs.NativeArray"><c path="unityengine.rendering.VertexAttributeDescriptor"/></c>
	<x path="Void"/>
</f></SetVertexBufferParams>
		<SetVertexBufferData public="1" set="method"><f a="data:dataStart:meshBufferStart:count:stream:flags">
	<c path="cs.NativeArray"><x path="Single"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="unityengine.rendering.MeshUpdateFlags"/>
	<x path="Void"/>
</f></SetVertexBufferData>
		<SetIndexBufferParams public="1" set="method"><f a="indexCount:format">
	<x path="Int"/>
	<c path="unityengine.rendering.IndexFormat"/>
	<x path="Void"/>
</f></SetIndexBufferParams>
		<SetIndexBufferData public="1" set="method"><f a="data:dataStart:meshBufferStart:count:flags">
	<c path="cs.NativeArray"><t path="cs.types.UInt16"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="unityengine.rendering.MeshUpdateFlags"/>
	<x path="Void"/>
</f></SetIndexBufferData>
		<SetSubMesh public="1" set="method"><f a="index:desc:flags">
	<x path="Int"/>
	<c path="unityengine.rendering.SubMeshDescriptor"/>
	<c path="unityengine.rendering.MeshUpdateFlags"/>
	<x path="Void"/>
</f></SetSubMesh>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Mesh"</e></m>
		</meta>
	</class>
	<class path="unityengine.MonoBehaviour" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/MonoBehaviour.hx" extern="1">
		<extends path="unityengine.Behaviour"/>
		<enabled public="1"><x path="Bool"/></enabled>
		<isActiveAndEnabled public="1"><x path="Bool"/></isActiveAndEnabled>
		<gameObject public="1"><c path="unityengine.GameObject"/></gameObject>
		<tag public="1"><c path="String"/></tag>
		<name public="1"><c path="String"/></name>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.MonoBehaviour"</e></m>
		</meta>
	</class>
	<class path="unityengine.Rect" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Rect.hx" extern="1">
		<x public="1"><x path="Single"/></x>
		<y public="1"><x path="Single"/></y>
		<width public="1"><x path="Single"/></width>
		<height public="1"><x path="Single"/></height>
		<new public="1" set="method"><f a="x:y:width:height">
	<x path="Single"/>
	<x path="Single"/>
	<x path="Single"/>
	<x path="Single"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Rect"</e></m>
		</meta>
	</class>
	<class path="unityengine.Texture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Texture.hx" extern="1">
		<extends path="unityengine.Object"/>
		<wrapModeU public="1"><c path="unityengine.TextureWrapMode"/></wrapModeU>
		<wrapModeV public="1"><c path="unityengine.TextureWrapMode"/></wrapModeV>
		<wrapModeW public="1"><c path="unityengine.TextureWrapMode"/></wrapModeW>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Texture"</e></m>
		</meta>
	</class>
	<class path="unityengine.RenderTexture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/RenderTexture.hx" extern="1">
		<extends path="unityengine.Texture"/>
		<active public="1" static="1"><c path="unityengine.RenderTexture"/></active>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<filterMode public="1"><c path="unityengine.FilterMode"/></filterMode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.RenderTexture"</e></m>
		</meta>
	</class>
	<class path="unityengine.ResourceRequest" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/ResourceRequest.hx" extern="1">
		<asset public="1" set="null"><c path="unityengine.Object"/></asset>
		<allowSceneActivation public="1"><x path="Bool"/></allowSceneActivation>
		<isDone public="1" set="null"><x path="Bool"/></isDone>
		<priority public="1"><x path="Int"/></priority>
		<progress public="1" set="null"><x path="Single"/></progress>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.ResourceRequest"</e></m>
		</meta>
	</class>
	<class path="unityengine.ScreenCapture" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/ScreenCapture.hx" extern="1">
		<CaptureScreenshot public="1" set="method" static="1"><f a="filename:superSize">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></CaptureScreenshot>
		<CaptureScreenshotAsTexture public="1" set="method" static="1"><f a="superSize">
	<x path="Int"/>
	<c path="unityengine.Texture2D"/>
</f></CaptureScreenshotAsTexture>
		<CaptureScreenshotIntoRenderTexture public="1" set="method" static="1"><f a="renderTexture">
	<c path="unityengine.RenderTexture"/>
	<x path="Void"/>
</f></CaptureScreenshotIntoRenderTexture>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.ScreenCapture"</e></m>
		</meta>
	</class>
	<class path="unityengine.TextAsset" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/TextAsset.hx" extern="1">
		<extends path="unityengine.Object"/>
		<text public="1" set="null"><c path="String"/></text>
		<bytes public="1" set="null"><c path="cs.NativeArray"><t path="cs.types.UInt8"/></c></bytes>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.TextAsset"</e></m>
		</meta>
	</class>
	<class path="unityengine.Texture2D" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Texture2D.hx" extern="1">
		<extends path="unityengine.Texture"/>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<filterMode public="1"><c path="unityengine.FilterMode"/></filterMode>
		<SetPixelData public="1" set="method"><f a="data:mipLevel:sourceDataStartIndex">
	<c path="cs.NativeArray"><t path="cs.types.UInt8"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></SetPixelData>
		<ReadPixels public="1" set="method"><f a="source:destX:destY:recalculateMipMaps">
	<c path="unityengine.Rect"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></ReadPixels>
		<Apply public="1" set="method"><f a="updateMipmaps:makeNoLongerReadable">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></Apply>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Texture2D"</e></m>
		</meta>
	</class>
	<class path="unityengine.TextureWrapMode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/TextureWrapMode.hx" extern="1">
		<Repeat public="1" static="1"><c path="unityengine.TextureWrapMode"/></Repeat>
		<Clamp public="1" static="1"><c path="unityengine.TextureWrapMode"/></Clamp>
		<Mirror public="1" static="1"><c path="unityengine.TextureWrapMode"/></Mirror>
		<MirrorOnce public="1" static="1"><c path="unityengine.TextureWrapMode"/></MirrorOnce>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.TextureWrapMode"</e></m>
		</meta>
	</class>
	<class path="unityengine.Vector2" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Vector2.hx" extern="1">
		<x public="1" set="null"><x path="Single"/></x>
		<y public="1" set="null"><x path="Single"/></y>
		<new public="1" set="method"><f a="x:y">
	<x path="Single"/>
	<x path="Single"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Vector2"</e></m>
		</meta>
	</class>
	<class path="unityengine.Vector3" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Vector3.hx" extern="1">
		<x public="1" set="null"><x path="Single"/></x>
		<y public="1" set="null"><x path="Single"/></y>
		<z public="1" set="null"><x path="Single"/></z>
		<new public="1" set="method"><f a="x:y:z">
	<x path="Single"/>
	<x path="Single"/>
	<x path="Single"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Vector3"</e></m>
		</meta>
	</class>
	<class path="unityengine.Vector4" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/Vector4.hx" extern="1">
		<x public="1" set="null"><x path="Single"/></x>
		<y public="1" set="null"><x path="Single"/></y>
		<z public="1" set="null"><x path="Single"/></z>
		<w public="1" set="null"><x path="Single"/></w>
		<new public="1" set="method"><f a="x:y:z:w">
	<x path="Single"/>
	<x path="Single"/>
	<x path="Single"/>
	<x path="Single"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Vector4"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.InputControl" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/InputControl.hx" extern="1">
		<displayName public="1" set="null"><c path="String"/></displayName>
		<ReadValue public="1" set="method"><f a=""><c path="unityengine.inputsystem.InputControl.T"/></f></ReadValue>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.InputControl"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.InputDevice" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/InputDevice.hx" extern="1">
		<extends path="unityengine.inputsystem.InputControl"><d/></extends>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.InputDevice"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.Gamepad" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/Gamepad.hx" extern="1">
		<extends path="unityengine.inputsystem.InputDevice"/>
		<current public="1" set="null" static="1"><c path="unityengine.inputsystem.Gamepad"/></current>
		<all public="1" set="null" static="1"><c path="unityengine.inputsystem.utilities.ReadOnlyArray"><c path="unityengine.inputsystem.Gamepad"/></c></all>
		<aButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></aButton>
		<bButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></bButton>
		<xButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></xButton>
		<yButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></yButton>
		<circleButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></circleButton>
		<crossButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></crossButton>
		<triangleButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></triangleButton>
		<squareButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></squareButton>
		<buttonNorth public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></buttonNorth>
		<buttonEast public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></buttonEast>
		<buttonSouth public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></buttonSouth>
		<buttonWest public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></buttonWest>
		<dpad public="1" set="null"><c path="unityengine.inputsystem.controls.DpadControl"/></dpad>
		<leftShoulder public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></leftShoulder>
		<rightShoulder public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></rightShoulder>
		<leftTrigger public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></leftTrigger>
		<rightTrigger public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></rightTrigger>
		<leftStick public="1" set="null"><c path="unityengine.inputsystem.controls.StickControl"/></leftStick>
		<leftStickButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></leftStickButton>
		<rightStick public="1" set="null"><c path="unityengine.inputsystem.controls.StickControl"/></rightStick>
		<rightStickButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></rightStickButton>
		<selectButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></selectButton>
		<startButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></startButton>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Gamepad"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.Keyboard" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/Keyboard.hx" extern="1">
		<extends path="unityengine.inputsystem.InputDevice"/>
		<current public="1" set="null" static="1"><c path="unityengine.inputsystem.Keyboard"/></current>
		<KeyCount public="1" set="null"><x path="Int"/></KeyCount>
		<allKeys public="1" set="null"><c path="unityengine.inputsystem.utilities.ReadOnlyArray"><c path="unityengine.inputsystem.controls.KeyControl"/></c></allKeys>
		<anyKey public="1" set="null"><c path="unityengine.inputsystem.controls.AnyKeyControl"/></anyKey>
		<keyboardLayout public="1" set="null"><c path="String"/></keyboardLayout>
		<onTextInput public="1"><d/></onTextInput>
		<leftArrowKey public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></leftArrowKey>
		<rightArrowKey public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></rightArrowKey>
		<upArrowKey public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></upArrowKey>
		<downArrowKey public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></downArrowKey>
		<enterKey public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></enterKey>
		<escapeKey public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></escapeKey>
		<backspaceKey public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></backspaceKey>
		<spaceKey public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></spaceKey>
		<leftShiftKey public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></leftShiftKey>
		<rightShiftKey public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></rightShiftKey>
		<f1Key public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></f1Key>
		<f2Key public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></f2Key>
		<f3Key public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></f3Key>
		<f4Key public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></f4Key>
		<f5Key public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></f5Key>
		<f6Key public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></f6Key>
		<f7Key public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></f7Key>
		<f8Key public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></f8Key>
		<f9Key public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></f9Key>
		<f10Key public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></f10Key>
		<f11Key public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></f11Key>
		<f12Key public="1" set="null"><c path="unityengine.inputsystem.controls.KeyControl"/></f12Key>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Keyboard"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.Pointer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/Pointer.hx" extern="1">
		<extends path="unityengine.inputsystem.InputDevice"/>
		<position public="1" set="null"><c path="unityengine.inputsystem.controls.Vector2Control"/></position>
		<delta public="1" set="null"><c path="unityengine.inputsystem.controls.Vector2Control"/></delta>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Pointer"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.Mouse" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/Mouse.hx" extern="1">
		<extends path="unityengine.inputsystem.Pointer"/>
		<current public="1" set="null" static="1"><c path="unityengine.inputsystem.Mouse"/></current>
		<leftButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></leftButton>
		<middleButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></middleButton>
		<rightButton public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></rightButton>
		<scroll public="1" set="null"><c path="unityengine.inputsystem.controls.Vector2Control"/></scroll>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Mouse"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.TouchPhase" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/TouchPhase.hx" extern="1">
		<None public="1" static="1"><c path="unityengine.inputsystem.TouchPhase"/></None>
		<Began public="1" static="1"><c path="unityengine.inputsystem.TouchPhase"/></Began>
		<Moved public="1" static="1"><c path="unityengine.inputsystem.TouchPhase"/></Moved>
		<Ended public="1" static="1"><c path="unityengine.inputsystem.TouchPhase"/></Ended>
		<Canceled public="1" static="1"><c path="unityengine.inputsystem.TouchPhase"/></Canceled>
		<Stationary public="1" static="1"><c path="unityengine.inputsystem.TouchPhase"/></Stationary>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.TouchPhase"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.Touchscreen" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/Touchscreen.hx" extern="1">
		<extends path="unityengine.inputsystem.Pointer"/>
		<current public="1" set="null" static="1"><c path="unityengine.inputsystem.Touchscreen"/></current>
		<primaryTouch public="1" set="null"><c path="unityengine.inputsystem.controls.TouchControl"/></primaryTouch>
		<touches public="1" set="null"><c path="unityengine.inputsystem.utilities.ReadOnlyArray"><c path="unityengine.inputsystem.controls.TouchControl"/></c></touches>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Touchscreen"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.controls.AxisControl" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/controls/AxisControl.hx" extern="1">
		<extends path="unityengine.inputsystem.InputControl"><c path="unityengine.inputsystem.controls.AxisControl.T"/></extends>
		<ReadValue public="1" set="method" override="1"><f a=""><c path="unityengine.inputsystem.controls.AxisControl.T"/></f></ReadValue>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Controls.AxisControl"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.controls.ButtonControl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/controls/ButtonControl.hx" extern="1">
		<extends path="unityengine.inputsystem.controls.AxisControl"><d/></extends>
		<isPressed public="1" set="null"><x path="Bool"/></isPressed>
		<wasPressedThisFrame public="1" set="null"><x path="Bool"/></wasPressedThisFrame>
		<wasReleasedThisFrame public="1" set="null"><x path="Bool"/></wasReleasedThisFrame>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Controls.ButtonControl"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.controls.AnyKeyControl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/controls/AnyKeyControl.hx" extern="1">
		<extends path="unityengine.inputsystem.controls.ButtonControl"/>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Controls.AnyKeyControl"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.controls.DoubleControl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/controls/DoubleControl.hx" extern="1">
		<extends path="unityengine.inputsystem.InputControl"><x path="Float"/></extends>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Controls.DoubleControl"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.controls.Vector2Control" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/controls/Vector2Control.hx" extern="1">
		<extends path="unityengine.inputsystem.InputControl"><d/></extends>
		<x public="1" set="null"><c path="unityengine.inputsystem.controls.AxisControl"><x path="Single"/></c></x>
		<y public="1" set="null"><c path="unityengine.inputsystem.controls.AxisControl"><x path="Single"/></c></y>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Controls.Vector2Control"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.controls.DpadControl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/controls/DpadControl.hx" extern="1">
		<extends path="unityengine.inputsystem.controls.Vector2Control"/>
		<up public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></up>
		<right public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></right>
		<down public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></down>
		<left public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></left>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Controls.DpadControl"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.controls.IntegerControl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/controls/IntegerControl.hx" extern="1">
		<extends path="unityengine.inputsystem.InputControl"><x path="Int"/></extends>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Controls.IntegerControl"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.controls.KeyControl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/controls/KeyControl.hx" extern="1">
		<extends path="unityengine.inputsystem.controls.ButtonControl"/>
		<scanCode public="1" set="null"><x path="Int"/></scanCode>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Controls.KeyControl"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.controls.StickControl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/controls/StickControl.hx" extern="1">
		<extends path="unityengine.inputsystem.controls.Vector2Control"/>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Controls.StickControl"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.controls.TouchControl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/controls/TouchControl.hx" extern="1">
		<extends path="unityengine.inputsystem.InputControl"><c path="unityengine.inputsystem.lowlevel.TouchState"/></extends>
		<indirectTouch public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></indirectTouch>
		<isInProgress public="1" set="null"><x path="Bool"/></isInProgress>
		<phase public="1" set="null"><c path="unityengine.inputsystem.controls.TouchPhaseControl"/></phase>
		<position public="1" set="null"><c path="unityengine.inputsystem.controls.Vector2Control"/></position>
		<delta public="1" set="null"><c path="unityengine.inputsystem.controls.Vector2Control"/></delta>
		<press public="1" set="null"><c path="unityengine.inputsystem.controls.TouchPressControl"/></press>
		<pressure public="1" set="null"><c path="unityengine.inputsystem.controls.AxisControl"><d/></c></pressure>
		<radius public="1" set="null"><c path="unityengine.inputsystem.controls.Vector2Control"/></radius>
		<startPosition public="1" set="null"><c path="unityengine.inputsystem.controls.Vector2Control"/></startPosition>
		<startTime public="1" set="null"><c path="unityengine.inputsystem.controls.DoubleControl"/></startTime>
		<tap public="1" set="null"><c path="unityengine.inputsystem.controls.ButtonControl"/></tap>
		<tapCount public="1" set="null"><c path="unityengine.inputsystem.controls.IntegerControl"/></tapCount>
		<touchId public="1" set="null"><c path="unityengine.inputsystem.controls.IntegerControl"/></touchId>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Controls.TouchControl"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.controls.TouchPhaseControl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/controls/TouchPhaseControl.hx" extern="1">
		<extends path="unityengine.inputsystem.InputControl"><c path="unityengine.inputsystem.TouchPhase"/></extends>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Controls.TouchPhaseControl"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.controls.TouchPressControl" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/controls/TouchPressControl.hx" extern="1">
		<extends path="unityengine.inputsystem.controls.ButtonControl"/>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Controls.TouchPressControl"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.lowlevel.TouchState" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/lowlevel/TouchState.hx" extern="1">
		<position public="1" set="null"><c path="unityengine.Vector2"/></position>
		<delta public="1" set="null"><c path="unityengine.Vector2"/></delta>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.LowLevel"</e></m>
		</meta>
	</class>
	<class path="unityengine.inputsystem.utilities.ReadOnlyArray" params="T" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/inputsystem/utilities/ReadOnlyArray.hx" extern="1">
		<Count public="1" set="null"><x path="Int"/></Count>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.InputSystem.Utilities.ReadOnlyArray"</e></m>
		</meta>
	</class>
	<class path="unityengine.rendering.BlendMode" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/BlendMode.hx" extern="1">
		<Zero public="1" set="null" static="1"><c path="unityengine.rendering.BlendMode"/></Zero>
		<One public="1" set="null" static="1"><c path="unityengine.rendering.BlendMode"/></One>
		<DstColor public="1" set="null" static="1"><c path="unityengine.rendering.BlendMode"/></DstColor>
		<SrcColor public="1" set="null" static="1"><c path="unityengine.rendering.BlendMode"/></SrcColor>
		<OneMinusDstColor public="1" set="null" static="1"><c path="unityengine.rendering.BlendMode"/></OneMinusDstColor>
		<SrcAlpha public="1" set="null" static="1"><c path="unityengine.rendering.BlendMode"/></SrcAlpha>
		<OneMinusSrcColor public="1" set="null" static="1"><c path="unityengine.rendering.BlendMode"/></OneMinusSrcColor>
		<DstAlpha public="1" set="null" static="1"><c path="unityengine.rendering.BlendMode"/></DstAlpha>
		<OneMinusDstAlpha public="1" set="null" static="1"><c path="unityengine.rendering.BlendMode"/></OneMinusDstAlpha>
		<SrcAlphaSaturate public="1" set="null" static="1"><c path="unityengine.rendering.BlendMode"/></SrcAlphaSaturate>
		<OneMinusSrcAlpha public="1" set="null" static="1"><c path="unityengine.rendering.BlendMode"/></OneMinusSrcAlpha>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Rendering.BlendMode"</e></m>
		</meta>
	</class>
	<class path="unityengine.rendering.CommandBuffer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/CommandBuffer.hx" extern="1">
		<Clear public="1" set="method"><f a=""><x path="Void"/></f></Clear>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Rendering.CommandBuffer"</e></m>
		</meta>
	</class>
	<class path="unityengine.rendering.CommandBufferPool" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/CommandBufferPool.hx" extern="1">
		<Get public="1" set="method" static="1"><f a=""><c path="unityengine.rendering.CommandBuffer"/></f></Get>
		<Release public="1" set="method" static="1"><f a="cmd">
	<c path="unityengine.rendering.CommandBuffer"/>
	<x path="Void"/>
</f></Release>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Rendering.CommandBufferPool"</e></m>
		</meta>
	</class>
	<class path="unityengine.rendering.CompareFunction" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/CompareFunction.hx" extern="1">
		<Disabled public="1" static="1"><c path="unityengine.rendering.CompareFunction"/></Disabled>
		<Never public="1" static="1"><c path="unityengine.rendering.CompareFunction"/></Never>
		<Less public="1" static="1"><c path="unityengine.rendering.CompareFunction"/></Less>
		<Equal public="1" static="1"><c path="unityengine.rendering.CompareFunction"/></Equal>
		<LessEqual public="1" static="1"><c path="unityengine.rendering.CompareFunction"/></LessEqual>
		<Greater public="1" static="1"><c path="unityengine.rendering.CompareFunction"/></Greater>
		<NotEqual public="1" static="1"><c path="unityengine.rendering.CompareFunction"/></NotEqual>
		<GreaterEqual public="1" static="1"><c path="unityengine.rendering.CompareFunction"/></GreaterEqual>
		<Always public="1" static="1"><c path="unityengine.rendering.CompareFunction"/></Always>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Rendering.CompareFunction"</e></m>
		</meta>
	</class>
	<class path="unityengine.rendering.IndexFormat" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/IndexFormat.hx" extern="1">
		<UInt16 public="1" set="null" static="1"><c path="unityengine.rendering.IndexFormat"/></UInt16>
		<UInt32 public="1" set="null" static="1"><c path="unityengine.rendering.IndexFormat"/></UInt32>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Rendering.IndexFormat"</e></m>
		</meta>
	</class>
	<class path="unityengine.rendering.MeshUpdateFlags" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/MeshUpdateFlags.hx" extern="1"><meta>
	<m n=":nativeGen"/>
	<m n=":native"><e>"UnityEngine.Rendering.MeshUpdateFlags"</e></m>
</meta></class>
	<class path="unityengine.rendering.StencilOp" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/StencilOp.hx" extern="1">
		<Keep public="1" static="1"><c path="unityengine.rendering.StencilOp"/></Keep>
		<Zero public="1" static="1"><c path="unityengine.rendering.StencilOp"/></Zero>
		<Replace public="1" static="1"><c path="unityengine.rendering.StencilOp"/></Replace>
		<IncrementSaturate public="1" static="1"><c path="unityengine.rendering.StencilOp"/></IncrementSaturate>
		<DecrementSaturate public="1" static="1"><c path="unityengine.rendering.StencilOp"/></DecrementSaturate>
		<Invert public="1" static="1"><c path="unityengine.rendering.StencilOp"/></Invert>
		<IncrementWrap public="1" static="1"><c path="unityengine.rendering.StencilOp"/></IncrementWrap>
		<DecrementWrap public="1" static="1"><c path="unityengine.rendering.StencilOp"/></DecrementWrap>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Rendering.StencilOp"</e></m>
		</meta>
	</class>
	<class path="unityengine.rendering.SubMeshDescriptor" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/SubMeshDescriptor.hx" extern="1">
		<new public="1" set="method"><f a="indexStart:indexCount:topology">
	<x path="Int"/>
	<x path="Int"/>
	<c path="unityengine.MeshTopology"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Rendering.SubMeshDescriptor"</e></m>
		</meta>
	</class>
	<class path="unityengine.rendering.VertexAttribute" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/VertexAttribute.hx" extern="1">
		<Position public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></Position>
		<Normal public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></Normal>
		<Tangent public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></Tangent>
		<Color public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></Color>
		<TexCoord0 public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></TexCoord0>
		<TexCoord1 public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></TexCoord1>
		<TexCoord2 public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></TexCoord2>
		<TexCoord3 public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></TexCoord3>
		<TexCoord4 public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></TexCoord4>
		<TexCoord5 public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></TexCoord5>
		<TexCoord6 public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></TexCoord6>
		<TexCoord7 public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></TexCoord7>
		<BlendWeight public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></BlendWeight>
		<BlendIndices public="1" static="1"><c path="unityengine.rendering.VertexAttribute"/></BlendIndices>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Rendering.VertexAttribute"</e></m>
		</meta>
	</class>
	<class path="unityengine.rendering.VertexAttributeDescriptor" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/VertexAttributeDescriptor.hx" extern="1">
		<new public="1" set="method"><f a="attribute:format:dimension:stream">
	<c path="unityengine.rendering.VertexAttribute"/>
	<c path="unityengine.rendering.VertexAttributeFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Rendering.VertexAttributeDescriptor"</e></m>
		</meta>
	</class>
	<class path="unityengine.rendering.VertexAttributeFormat" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/VertexAttributeFormat.hx" extern="1">
		<Float32 public="1" set="null" static="1"><c path="unityengine.rendering.VertexAttributeFormat"/></Float32>
		<Float16 public="1" set="null" static="1"><c path="unityengine.rendering.VertexAttributeFormat"/></Float16>
		<UNorm8 public="1" set="null" static="1"><c path="unityengine.rendering.VertexAttributeFormat"/></UNorm8>
		<SNorm8 public="1" set="null" static="1"><c path="unityengine.rendering.VertexAttributeFormat"/></SNorm8>
		<UNorm16 public="1" set="null" static="1"><c path="unityengine.rendering.VertexAttributeFormat"/></UNorm16>
		<SNorm16 public="1" set="null" static="1"><c path="unityengine.rendering.VertexAttributeFormat"/></SNorm16>
		<UInt8 public="1" set="null" static="1"><c path="unityengine.rendering.VertexAttributeFormat"/></UInt8>
		<SInt8 public="1" set="null" static="1"><c path="unityengine.rendering.VertexAttributeFormat"/></SInt8>
		<UInt16 public="1" set="null" static="1"><c path="unityengine.rendering.VertexAttributeFormat"/></UInt16>
		<SInt16 public="1" set="null" static="1"><c path="unityengine.rendering.VertexAttributeFormat"/></SInt16>
		<UInt32 public="1" set="null" static="1"><c path="unityengine.rendering.VertexAttributeFormat"/></UInt32>
		<SInt32 public="1" set="null" static="1"><c path="unityengine.rendering.VertexAttributeFormat"/></SInt32>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Rendering.VertexAttributeFormat"</e></m>
		</meta>
	</class>
	<class path="unityengine.rendering.universal.RenderingData" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/universal/RenderingData.hx" extern="1"><meta>
	<m n=":nativeGen"/>
	<m n=":native"><e>"UnityEngine.Rendering.Universal.RenderingData"</e></m>
</meta></class>
	<class path="unityengine.rendering.universal.ScriptableRenderer" params="" file="/home/runner/work/api-docs/api-docs/ceramic/plugins/unity/runtime/src/unityengine/rendering/universal/ScriptableRenderer.hx" extern="1">
		<EnqueuePass public="1" set="method"><f a="renderPass">
	<c path="unityengine.rendering.universal.ScriptableRenderPass"/>
	<x path="Void"/>
</f></EnqueuePass>
		<meta>
			<m n=":nativeGen"/>
			<m n=":native"><e>"UnityEngine.Rendering.Universal.ScriptableRenderer"</e></m>
		</meta>
	</class>
</haxe>